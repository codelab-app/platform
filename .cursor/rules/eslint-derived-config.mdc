---
description: Eslint derived config block
globs:
alwaysApply: false
---
Below are the two idiomatic ways to tweak reactPlugin.configs.recommended in ESLint Flat-config while keeping all plugin registration centralized in eslint.config.mjs.
Both patterns respect the rule-merge order (later objects win) and keep your file-scoped overrides nice and explicit.

⸻

1. Override with a follow-up config block

(simplest, what you’re already doing)

// React rules configuration – NO plugin registration here
import reactPlugin from 'eslint-plugin-react'
import tailwindConfig from './recommended/tailwind.config.mjs'

// GENERATED BY CURSOR
export default [
  // --- base ---
  reactPlugin.configs.recommended,

  // --- global tweaks for every *.jsx / *.tsx file ---
  {
    files: ['**/*.{tsx,jsx}'],
    settings: {
      react: { version: 'detect' },
    },
    rules: {
      // ◀︎ overrides/adds *after* the recommended rules
      'react/jsx-no-useless-fragment': ['error', { allowExpressions: true }],
      'react/prop-types': 'off',
      'react/jsx-sort-props': 'error',
      // …any other tweaks
    },
  },

  // Tailwind blocks
  ...tailwindConfig,

  // --- Storybook-only overrides ---
  {
    files: ['**/*.stories.{jsx,tsx}'],
    rules: {
      'react/jsx-props-no-spreading': 'off',
    },
  },
]

Why it works
	•	The first object (reactPlugin.configs.recommended) seeds the default rules.
	•	The second object targets the same file globs and wins on any overlapping keys, because ESLint merges arrays left→right.
	•	Storybook-specific relaxations come last so they trump the earlier blocks only for *.stories.*.

Use this when you only need a handful of overrides—clean, explicit, and zero deep-copying.

⸻

2. Build a derived config object once, then spread it

(useful when you want many tweaks or need to share the derivation)

// GENERATED BY CURSOR
import reactPlugin from 'eslint-plugin-react'
import tailwindConfig from './recommended/tailwind.config.mjs'

// clone + patch the recommended config in one go
const reactBase = {
  // keep everything from the original
  ...reactPlugin.configs.recommended,
  // but replace/extend what we care about
  rules: {
    ...reactPlugin.configs.recommended.rules,
    'react/jsx-no-useless-fragment': ['error', { allowExpressions: true }],
    'react/prop-types': 'off',
    'react/jsx-sort-props': 'error',
    // …
  },
  settings: {
    ...reactPlugin.configs.recommended.settings,
    react: { version: 'detect' },
  },
}

export default [
  reactBase,
  ...tailwindConfig,
  {
    files: ['**/*.stories.{jsx,tsx}'],
    rules: { 'react/jsx-props-no-spreading': 'off' },
  },
]

Why you might pick this
	•	You avoid scattering React tweaks across multiple blocks.
	•	You can export reactBase for reuse in other package configs.
	•	Everything React-related lives in one immutable object, which some teams prefer for auditability.

⸻

Which pattern should you use?
	•	Small rule adjustments → Pattern #1 (add a later block).
Easier to read; keeps the rule list near the files it affects.
	•	Larger, shared, or many overrides → Pattern #2 (derive once).
Reduces duplication when several sub-projects share the same React baseline.

Both keep plugin registration untouched and comply with your flat-config, arrow-function, and comment-preservation conventions. Pick whichever lines up best with your repo’s organisation style.
