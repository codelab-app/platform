directive @auth(
  password: AuthRule
  query: AuthRule
  add: AuthRule
  update: AuthRule
  delete: AuthRule
) on OBJECT | INTERFACE

directive @cacheControl(maxAge: Int!) on QUERY

directive @cascade(fields: [String]) on FIELD

directive @custom(http: CustomHTTP, dql: String) on FIELD_DEFINITION

directive @dgraph(
  type: String
  pred: String
) on OBJECT | INTERFACE | FIELD_DEFINITION

directive @generate(
  query: GenerateQueryParams
  mutation: GenerateMutationParams
  subscription: Boolean
) on OBJECT | INTERFACE

directive @hasInverse(field: String!) on FIELD_DEFINITION

directive @id on FIELD_DEFINITION

directive @lambda on FIELD_DEFINITION

directive @lambdaOnMutate(
  add: Boolean
  update: Boolean
  delete: Boolean
) on OBJECT | INTERFACE

directive @remote on OBJECT | INTERFACE | UNION | INPUT_OBJECT | ENUM

directive @remoteResponse(name: String) on FIELD_DEFINITION

directive @search(by: [DgraphIndex!]) on FIELD_DEFINITION

directive @secret(field: String!, pred: String) on OBJECT | INTERFACE

directive @withSubscription on OBJECT | INTERFACE | FIELD_DEFINITION

input AddAppInput {
  ownerId: String!
  pages: [PageRef]
  name: String!
}

type AddAppPayload {
  app(filter: AppFilter, order: AppOrder, first: Int, offset: Int): [App]
  numUids: Int
}

input AddArrayTypeInput {
  name: String!
  type: TypeRef!
}

type AddArrayTypePayload {
  arrayType(
    filter: ArrayTypeFilter
    order: ArrayTypeOrder
    first: Int
    offset: Int
  ): [ArrayType]
  numUids: Int
}

input AddArrayValueInput {
  values: [PropValueRef!]!
}

type AddArrayValuePayload {
  arrayValue(filter: ArrayValueFilter, first: Int, offset: Int): [ArrayValue]
  numUids: Int
}

input AddAtomInput {
  type: AtomType!
  label: String!
  library: LibraryRef
  propTypes: InterfaceRef!
}

type AddAtomPayload {
  atom(filter: AtomFilter, order: AtomOrder, first: Int, offset: Int): [Atom]
  numUids: Int
}

input AddBooleanValueInput {
  booleanValue: Boolean!
}

type AddBooleanValuePayload {
  booleanValue(
    filter: BooleanValueFilter
    first: Int
    offset: Int
  ): [BooleanValue]
  numUids: Int
}

input AddComponentInput {
  library: LibraryRef!
  atom: AtomRef!
  label: String!
  children: [ComponentRef]
  tags: [TagRef]
}

type AddComponentPayload {
  component(
    filter: ComponentFilter
    order: ComponentOrder
    first: Int
    offset: Int
  ): [Component]
  numUids: Int
}

input AddElementInput {
  name: String!
  children: [ElementRef]
  parent: ElementRef
  atom: AtomRef
  ownedBy: ElementOwnerRef
  component: ComponentRef
  props: [PropRef!]!
  css: String
}

type AddElementPayload {
  element(
    filter: ElementFilter
    order: ElementOrder
    first: Int
    offset: Int
  ): [Element]
  numUids: Int
}

input AddEnumTypeInput {
  name: String!
  allowedValues: [EnumTypeValueRef!]!
}

type AddEnumTypePayload {
  enumType(
    filter: EnumTypeFilter
    order: EnumTypeOrder
    first: Int
    offset: Int
  ): [EnumType]
  numUids: Int
}

input AddEnumTypeValueInput {
  name: String
  value: String!
}

type AddEnumTypeValuePayload {
  enumTypeValue(
    filter: EnumTypeValueFilter
    order: EnumTypeValueOrder
    first: Int
    offset: Int
  ): [EnumTypeValue]
  numUids: Int
}

input AddFieldInput {
  type: TypeRef!
  key: String!
  name: String!
  description: String
  interface: InterfaceRef!
}

type AddFieldPayload {
  field(
    filter: FieldFilter
    order: FieldOrder
    first: Int
    offset: Int
  ): [Field]
  numUids: Int
}

input AddFloatValueInput {
  floatValue: Float!
}

type AddFloatValuePayload {
  floatValue(
    filter: FloatValueFilter
    order: FloatValueOrder
    first: Int
    offset: Int
  ): [FloatValue]
  numUids: Int
}

input AddIntValueInput {
  intValue: Int!
}

type AddIntValuePayload {
  intValue(
    filter: IntValueFilter
    order: IntValueOrder
    first: Int
    offset: Int
  ): [IntValue]
  numUids: Int
}

input AddInterfaceInput {
  name: String!
  atom: AtomRef
  fields: [FieldRef]
}

type AddInterfacePayload {
  interface(
    filter: InterfaceFilter
    order: InterfaceOrder
    first: Int
    offset: Int
  ): [Interface]
  numUids: Int
}

input AddInterfaceValueInput {
  props: [PropRef!]!
}

type AddInterfaceValuePayload {
  interfaceValue(
    filter: InterfaceValueFilter
    first: Int
    offset: Int
  ): [InterfaceValue]
  numUids: Int
}

input AddLambdaInput {
  ownerId: String!
  name: String!
  body: String!
}

type AddLambdaPayload {
  lambda(
    filter: LambdaFilter
    order: LambdaOrder
    first: Int
    offset: Int
  ): [Lambda]
  numUids: Int
}

input AddLibraryInput {
  ownerId: String!
  name: String!
  atoms: [AtomRef]
  components: [ComponentRef]
}

type AddLibraryPayload {
  library(
    filter: LibraryFilter
    order: LibraryOrder
    first: Int
    offset: Int
  ): [Library]
  numUids: Int
}

input AddPageInput {
  name: String!
  app: AppRef!
  rootElement: ElementRef!
}

type AddPagePayload {
  page(filter: PageFilter, order: PageOrder, first: Int, offset: Int): [Page]
  numUids: Int
}

input AddPrimitiveTypeInput {
  name: String!
  primitiveKind: PrimitiveKind!
}

type AddPrimitiveTypePayload {
  primitiveType(
    filter: PrimitiveTypeFilter
    order: PrimitiveTypeOrder
    first: Int
    offset: Int
  ): [PrimitiveType]
  numUids: Int
}

input AddPropInput {
  field: FieldRef!
  value: PropValueRef
  element: ElementRef
}

type AddPropPayload {
  prop(filter: PropFilter, first: Int, offset: Int): [Prop]
  numUids: Int
}

input AddStringValueInput {
  stringValue: String!
}

type AddStringValuePayload {
  stringValue(
    filter: StringValueFilter
    order: StringValueOrder
    first: Int
    offset: Int
  ): [StringValue]
  numUids: Int
}

input AddTagInput {
  label: String!
}

type AddTagPayload {
  tag(filter: TagFilter, order: TagOrder, first: Int, offset: Int): [Tag]
  numUids: Int
}

type App {
  id: ID!
  ownerId: String!
  pages(filter: PageFilter, order: PageOrder, first: Int, offset: Int): [Page]
  name: String!
  pagesAggregate(filter: PageFilter): PageAggregateResult
}

type AppAggregateResult {
  count: Int
  ownerIdMin: String
  ownerIdMax: String
  nameMin: String
  nameMax: String
}

input AppFilter {
  id: [ID!]
  ownerId: StringHashFilter
  has: [AppHasFilter]
  and: [AppFilter]
  or: [AppFilter]
  not: AppFilter
}

enum AppHasFilter {
  ownerId
  pages
  name
}

input AppOrder {
  asc: AppOrderable
  desc: AppOrderable
  then: AppOrder
}

enum AppOrderable {
  ownerId
  name
}

input AppPatch {
  ownerId: String
  pages: [PageRef]
  name: String
}

input AppRef {
  id: ID
  ownerId: String
  pages: [PageRef]
  name: String
}

type ArrayType implements Type {
  id: ID!
  name: String!
  type(filter: TypeFilter): Type!
}

type ArrayTypeAggregateResult {
  count: Int
  nameMin: String
  nameMax: String
}

input ArrayTypeFilter {
  id: [ID!]
  has: [ArrayTypeHasFilter]
  and: [ArrayTypeFilter]
  or: [ArrayTypeFilter]
  not: ArrayTypeFilter
}

enum ArrayTypeHasFilter {
  name
  type
}

input ArrayTypeOrder {
  asc: ArrayTypeOrderable
  desc: ArrayTypeOrderable
  then: ArrayTypeOrder
}

enum ArrayTypeOrderable {
  name
}

input ArrayTypePatch {
  name: String
  type: TypeRef
}

input ArrayTypeRef {
  id: ID
  name: String
  type: TypeRef
}

type ArrayValue {
  id: ID!
  values(filter: PropValueFilter, first: Int, offset: Int): [PropValue!]!
}

type ArrayValueAggregateResult {
  count: Int
}

input ArrayValueFilter {
  id: [ID!]
  has: [ArrayValueHasFilter]
  and: [ArrayValueFilter]
  or: [ArrayValueFilter]
  not: ArrayValueFilter
}

enum ArrayValueHasFilter {
  values
}

input ArrayValuePatch {
  values: [PropValueRef!]
}

input ArrayValueRef {
  id: ID
  values: [PropValueRef!]
}

type Atom {
  id: ID!
  type: AtomType!
  label: String!
  library(filter: LibraryFilter): Library
  propTypes(filter: InterfaceFilter): Interface!
}

type AtomAggregateResult {
  count: Int
  labelMin: String
  labelMax: String
}

input AtomFilter {
  id: [ID!]
  has: [AtomHasFilter]
  and: [AtomFilter]
  or: [AtomFilter]
  not: AtomFilter
}

enum AtomHasFilter {
  type
  label
  library
  propTypes
}

input AtomOrder {
  asc: AtomOrderable
  desc: AtomOrderable
  then: AtomOrder
}

enum AtomOrderable {
  label
}

input AtomPatch {
  type: AtomType
  label: String
  library: LibraryRef
  propTypes: InterfaceRef
}

input AtomRef {
  id: ID
  type: AtomType
  label: String
  library: LibraryRef
  propTypes: InterfaceRef
}

enum AtomType {
  AntDesignAffix
  AntDesignAlert
  AntDesignAnchor
  AntDesignAnchorLink
  AntDesignAutoComplete
  AntDesignAvatar
  AntDesignBackTop
  AntDesignBadge
  AntDesignBreadcrumb
  AntDesignBreadcrumbItem
  AntDesignButton
  AntDesignCalendar
  AntDesignCard
  AntDesignCardGrid
  AntDesignCardMeta
  AntDesignCarousel
  AntDesignCascader
  AntDesignCheckbox
  AntDesignCollapse
  AntDesignCollapsePanel
  AntDesignComment
  AntDesignConfigProvider
  AntDesignDatePicker
  AntDesignDescriptions
  AntDesignDescriptionsItem
  AntDesignDivider
  AntDesignDrawer
  AntDesignDropdown
  AntDesignEmpty
  AntDesignForm
  AntDesignFormItem
  AntDesignFormItemHook
  AntDesignFormList
  AntDesignGridCol
  AntDesignGridRow
  AntDesignIcon
  AntDesignInput
  AntDesignInputNumber
  AntDesignLayout
  AntDesignLayoutContent
  AntDesignLayoutFooter
  AntDesignLayoutHeader
  AntDesignLayoutSider
  AntDesignList
  AntDesignListItem
  AntDesignListItemMeta
  AntDesignMapper
  AntDesignMentions
  AntDesignMentionsOption
  AntDesignMenu
  AntDesignMenuItem
  AntDesignMenuItemGroup
  AntDesignMenuSubMenu
  AntDesignModal
  AntDesignPageHeader
  AntDesignPageContainer
  AntDesignPagination
  AntDesignPopconfirm
  AntDesignPopover
  AntDesignProgress
  AntDesignProvider
  AntDesignRglContainer
  AntDesignRglItem
  AntDesignRglResponsiveContainer
  AntDesignRadio
  AntDesignRadioGroup
  AntDesignRate
  AntDesignRenderComponent
  AntDesignRenderContainer
  AntDesignResult
  AntDesignSelect
  AntDesignSelectOption
  AntDesignSkeleton
  AntDesignSlider
  AntDesignSpace
  AntDesignSpin
  AntDesignStatistic
  AntDesignSteps
  AntDesignStepsStep
  AntDesignSwitch
  AntDesignTable
  AntDesignTabs
  AntDesignTabsTabPane
  AntDesignTag
  AntDesignTimePicker
  AntDesignTimeline
  AntDesignTimelineItem
  AntDesignTooltip
  AntDesignTransfer
  AntDesignTree
  AntDesignTreeNode
  AntDesignTreeSelect
  AntDesignTypography
  AntDesignTypographyParagraph
  AntDesignTypographyText
  AntDesignTypographyTitle
  AntDesignUpload
  ReactFragment
  HtmlA
  HtmlP
  HtmlVideo
  HtmlUList
  HtmlTrack
  HtmlTitle
  HtmlTime
  HtmlTextarea
  HtmlTemplate
  HtmlTableRow
  HtmlTable
  HtmlTableCol
  HtmlTableCell
  HtmlTableCaption
  HtmlStyle
  HtmlSpan
  HtmlSource
  HtmlSelect
  HtmlQuote
  HtmlProgress
  HtmlPre
  HtmlPicture
  HtmlParam
  HtmlOutput
  HtmlOption
  HtmlOptgroup
  HtmlObject
  HtmlOList
  HtmlMeter
  HtmlMeta
  HtmlMap
  HtmlLink
  HtmlLegend
  HtmlLabel
  HtmlLi
  HtmlInput
  HtmlImage
  HtmlIframe
  HtmlH1
  HtmlH2
  HtmlH3
  HtmlH4
  HtmlH5
  HtmlH6
  HtmlHead
  HtmlHr
  HtmlFrameset
  HtmlFrame
  HtmlForm
  HtmlFont
  HtmlFieldset
  HtmlEmbed
  HtmlDiv
  HtmlDialog
  HtmlDetails
  HtmlDatalist
  HtmlData
  HtmlDList
  HtmlCanvas
  HtmlButton
  HtmlBase
  HtmlBr
  HtmlAudio
  HtmlArea
  HtmlFooter
  HtmlAside
  HtmlHeader
  HtmlMain
  HtmlNav
  HtmlSection
  HtmlCode
  HtmlEm
  HtmlI
  HtmlS
  HtmlSmall
  HtmlStrong
  HtmlSub
  HtmlSup
}

input AuthRule {
  and: [AuthRule]
  or: [AuthRule]
  not: AuthRule
  rule: String
}

type BooleanValue {
  id: ID!
  booleanValue: Boolean!
}

type BooleanValueAggregateResult {
  count: Int
}

input BooleanValueFilter {
  id: [ID!]
  has: [BooleanValueHasFilter]
  and: [BooleanValueFilter]
  or: [BooleanValueFilter]
  not: BooleanValueFilter
}

enum BooleanValueHasFilter {
  booleanValue
}

input BooleanValuePatch {
  booleanValue: Boolean
}

input BooleanValueRef {
  id: ID
  booleanValue: Boolean
}

type Component {
  id: ID!
  library(filter: LibraryFilter): Library!
  atom(filter: AtomFilter): Atom!
  label: String!
  children(
    filter: ComponentFilter
    order: ComponentOrder
    first: Int
    offset: Int
  ): [Component]
  tags(filter: TagFilter, order: TagOrder, first: Int, offset: Int): [Tag]
  childrenAggregate(filter: ComponentFilter): ComponentAggregateResult
  tagsAggregate(filter: TagFilter): TagAggregateResult
}

type ComponentAggregateResult {
  count: Int
  labelMin: String
  labelMax: String
}

input ComponentFilter {
  id: [ID!]
  has: [ComponentHasFilter]
  and: [ComponentFilter]
  or: [ComponentFilter]
  not: ComponentFilter
}

enum ComponentHasFilter {
  library
  atom
  label
  children
  tags
}

input ComponentOrder {
  asc: ComponentOrderable
  desc: ComponentOrderable
  then: ComponentOrder
}

enum ComponentOrderable {
  label
}

input ComponentPatch {
  library: LibraryRef
  atom: AtomRef
  label: String
  children: [ComponentRef]
  tags: [TagRef]
}

input ComponentRef {
  id: ID
  library: LibraryRef
  atom: AtomRef
  label: String
  children: [ComponentRef]
  tags: [TagRef]
}

input ContainsFilter {
  point: PointRef
  polygon: PolygonRef
}

input CustomHTTP {
  url: String!
  method: HTTPMethod!
  body: String
  graphql: String
  mode: Mode
  forwardHeaders: [String!]
  secretHeaders: [String!]
  introspectionHeaders: [String!]
  skipIntrospection: Boolean
}

"""
The DateTime scalar type represents date and time as a string in RFC3339 format.
For example: "1985-04-12T23:20:50.52Z" represents 20 minutes and 50.52 seconds after the 23rd hour of April 12th, 1985 in UTC.
"""
scalar DateTime

input DateTimeFilter {
  eq: DateTime
  in: [DateTime]
  le: DateTime
  lt: DateTime
  ge: DateTime
  gt: DateTime
  between: DateTimeRange
}

input DateTimeRange {
  min: DateTime!
  max: DateTime!
}

type DeleteAppPayload {
  app(filter: AppFilter, order: AppOrder, first: Int, offset: Int): [App]
  msg: String
  numUids: Int
}

type DeleteArrayTypePayload {
  arrayType(
    filter: ArrayTypeFilter
    order: ArrayTypeOrder
    first: Int
    offset: Int
  ): [ArrayType]
  msg: String
  numUids: Int
}

type DeleteArrayValuePayload {
  arrayValue(filter: ArrayValueFilter, first: Int, offset: Int): [ArrayValue]
  msg: String
  numUids: Int
}

type DeleteAtomPayload {
  atom(filter: AtomFilter, order: AtomOrder, first: Int, offset: Int): [Atom]
  msg: String
  numUids: Int
}

type DeleteBooleanValuePayload {
  booleanValue(
    filter: BooleanValueFilter
    first: Int
    offset: Int
  ): [BooleanValue]
  msg: String
  numUids: Int
}

type DeleteComponentPayload {
  component(
    filter: ComponentFilter
    order: ComponentOrder
    first: Int
    offset: Int
  ): [Component]
  msg: String
  numUids: Int
}

type DeleteElementPayload {
  element(
    filter: ElementFilter
    order: ElementOrder
    first: Int
    offset: Int
  ): [Element]
  msg: String
  numUids: Int
}

type DeleteEnumTypePayload {
  enumType(
    filter: EnumTypeFilter
    order: EnumTypeOrder
    first: Int
    offset: Int
  ): [EnumType]
  msg: String
  numUids: Int
}

type DeleteEnumTypeValuePayload {
  enumTypeValue(
    filter: EnumTypeValueFilter
    order: EnumTypeValueOrder
    first: Int
    offset: Int
  ): [EnumTypeValue]
  msg: String
  numUids: Int
}

type DeleteFieldPayload {
  field(
    filter: FieldFilter
    order: FieldOrder
    first: Int
    offset: Int
  ): [Field]
  msg: String
  numUids: Int
}

type DeleteFloatValuePayload {
  floatValue(
    filter: FloatValueFilter
    order: FloatValueOrder
    first: Int
    offset: Int
  ): [FloatValue]
  msg: String
  numUids: Int
}

type DeleteIntValuePayload {
  intValue(
    filter: IntValueFilter
    order: IntValueOrder
    first: Int
    offset: Int
  ): [IntValue]
  msg: String
  numUids: Int
}

type DeleteInterfacePayload {
  interface(
    filter: InterfaceFilter
    order: InterfaceOrder
    first: Int
    offset: Int
  ): [Interface]
  msg: String
  numUids: Int
}

type DeleteInterfaceValuePayload {
  interfaceValue(
    filter: InterfaceValueFilter
    first: Int
    offset: Int
  ): [InterfaceValue]
  msg: String
  numUids: Int
}

type DeleteLambdaPayload {
  lambda(
    filter: LambdaFilter
    order: LambdaOrder
    first: Int
    offset: Int
  ): [Lambda]
  msg: String
  numUids: Int
}

type DeleteLibraryPayload {
  library(
    filter: LibraryFilter
    order: LibraryOrder
    first: Int
    offset: Int
  ): [Library]
  msg: String
  numUids: Int
}

type DeletePagePayload {
  page(filter: PageFilter, order: PageOrder, first: Int, offset: Int): [Page]
  msg: String
  numUids: Int
}

type DeletePrimitiveTypePayload {
  primitiveType(
    filter: PrimitiveTypeFilter
    order: PrimitiveTypeOrder
    first: Int
    offset: Int
  ): [PrimitiveType]
  msg: String
  numUids: Int
}

type DeletePropPayload {
  prop(filter: PropFilter, first: Int, offset: Int): [Prop]
  msg: String
  numUids: Int
}

type DeleteStringValuePayload {
  stringValue(
    filter: StringValueFilter
    order: StringValueOrder
    first: Int
    offset: Int
  ): [StringValue]
  msg: String
  numUids: Int
}

type DeleteTagPayload {
  tag(filter: TagFilter, order: TagOrder, first: Int, offset: Int): [Tag]
  msg: String
  numUids: Int
}

type DeleteTypePayload {
  type(filter: TypeFilter, order: TypeOrder, first: Int, offset: Int): [Type]
  msg: String
  numUids: Int
}

enum DgraphIndex {
  int
  int64
  float
  bool
  hash
  exact
  term
  fulltext
  trigram
  regexp
  year
  month
  day
  hour
  geo
}

type Element {
  id: ID!
  name: String!
  children(
    filter: ElementFilter
    order: ElementOrder
    first: Int
    offset: Int
  ): [Element]
  parent(filter: ElementFilter): Element
  atom(filter: AtomFilter): Atom
  ownedBy(filter: ElementOwnerFilter): ElementOwner
  component(filter: ComponentFilter): Component
  props(filter: PropFilter, first: Int, offset: Int): [Prop!]!
  css: String
  childrenAggregate(filter: ElementFilter): ElementAggregateResult
  propsAggregate(filter: PropFilter): PropAggregateResult
}

type ElementAggregateResult {
  count: Int
  nameMin: String
  nameMax: String
  cssMin: String
  cssMax: String
}

input ElementFilter {
  id: [ID!]
  name: StringFullTextFilter_StringTermFilter
  has: [ElementHasFilter]
  and: [ElementFilter]
  or: [ElementFilter]
  not: ElementFilter
}

enum ElementHasFilter {
  name
  children
  parent
  atom
  ownedBy
  component
  props
  css
}

input ElementOrder {
  asc: ElementOrderable
  desc: ElementOrderable
  then: ElementOrder
}

enum ElementOrderable {
  name
  css
}

union ElementOwner = Page

input ElementOwnerFilter {
  memberTypes: [ElementOwnerType!]
  pageFilter: PageFilter
}

input ElementOwnerRef {
  pageRef: PageRef
}

enum ElementOwnerType {
  Page
}

input ElementPatch {
  name: String
  children: [ElementRef]
  parent: ElementRef
  atom: AtomRef
  ownedBy: ElementOwnerRef
  component: ComponentRef
  props: [PropRef!]
  css: String
}

input ElementRef {
  id: ID
  name: String
  children: [ElementRef]
  parent: ElementRef
  atom: AtomRef
  ownedBy: ElementOwnerRef
  component: ComponentRef
  props: [PropRef!]
  css: String
}

type EnumType implements Type {
  id: ID!
  name: String!
  allowedValues(
    filter: EnumTypeValueFilter
    order: EnumTypeValueOrder
    first: Int
    offset: Int
  ): [EnumTypeValue!]!
  allowedValuesAggregate(
    filter: EnumTypeValueFilter
  ): EnumTypeValueAggregateResult
}

type EnumTypeAggregateResult {
  count: Int
  nameMin: String
  nameMax: String
}

input EnumTypeFilter {
  id: [ID!]
  has: [EnumTypeHasFilter]
  and: [EnumTypeFilter]
  or: [EnumTypeFilter]
  not: EnumTypeFilter
}

enum EnumTypeHasFilter {
  name
  allowedValues
}

input EnumTypeOrder {
  asc: EnumTypeOrderable
  desc: EnumTypeOrderable
  then: EnumTypeOrder
}

enum EnumTypeOrderable {
  name
}

input EnumTypePatch {
  name: String
  allowedValues: [EnumTypeValueRef!]
}

input EnumTypeRef {
  id: ID
  name: String
  allowedValues: [EnumTypeValueRef!]
}

type EnumTypeValue {
  id: ID!
  name: String
  value: String!
}

type EnumTypeValueAggregateResult {
  count: Int
  nameMin: String
  nameMax: String
  valueMin: String
  valueMax: String
}

input EnumTypeValueFilter {
  id: [ID!]
  has: [EnumTypeValueHasFilter]
  and: [EnumTypeValueFilter]
  or: [EnumTypeValueFilter]
  not: EnumTypeValueFilter
}

enum EnumTypeValueHasFilter {
  name
  value
}

input EnumTypeValueOrder {
  asc: EnumTypeValueOrderable
  desc: EnumTypeValueOrderable
  then: EnumTypeValueOrder
}

enum EnumTypeValueOrderable {
  name
  value
}

input EnumTypeValuePatch {
  name: String
  value: String
}

input EnumTypeValueRef {
  id: ID
  name: String
  value: String
}

type Field {
  id: ID!
  type(filter: TypeFilter): Type!
  key: String!
  name: String!
  description: String
  interface(filter: InterfaceFilter): Interface!
}

type FieldAggregateResult {
  count: Int
  keyMin: String
  keyMax: String
  nameMin: String
  nameMax: String
  descriptionMin: String
  descriptionMax: String
}

input FieldFilter {
  id: [ID!]
  key: StringFullTextFilter_StringHashFilter
  has: [FieldHasFilter]
  and: [FieldFilter]
  or: [FieldFilter]
  not: FieldFilter
}

enum FieldHasFilter {
  type
  key
  name
  description
  interface
}

input FieldOrder {
  asc: FieldOrderable
  desc: FieldOrderable
  then: FieldOrder
}

enum FieldOrderable {
  key
  name
  description
}

input FieldPatch {
  type: TypeRef
  key: String
  name: String
  description: String
  interface: InterfaceRef
}

input FieldRef {
  id: ID
  type: TypeRef
  key: String
  name: String
  description: String
  interface: InterfaceRef
}

input FloatFilter {
  eq: Float
  in: [Float]
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: FloatRange
}

input FloatRange {
  min: Float!
  max: Float!
}

type FloatValue {
  id: ID!
  floatValue: Float!
}

type FloatValueAggregateResult {
  count: Int
  floatValueMin: Float
  floatValueMax: Float
  floatValueSum: Float
  floatValueAvg: Float
}

input FloatValueFilter {
  id: [ID!]
  has: [FloatValueHasFilter]
  and: [FloatValueFilter]
  or: [FloatValueFilter]
  not: FloatValueFilter
}

enum FloatValueHasFilter {
  floatValue
}

input FloatValueOrder {
  asc: FloatValueOrderable
  desc: FloatValueOrderable
  then: FloatValueOrder
}

enum FloatValueOrderable {
  floatValue
}

input FloatValuePatch {
  floatValue: Float
}

input FloatValueRef {
  id: ID
  floatValue: Float
}

input GenerateMutationParams {
  add: Boolean
  update: Boolean
  delete: Boolean
}

input GenerateQueryParams {
  get: Boolean
  query: Boolean
  password: Boolean
  aggregate: Boolean
}

enum HTTPMethod {
  GET
  POST
  PUT
  PATCH
  DELETE
}

"""
The Int64 scalar type represents a signed 64‐bit numeric non‐fractional value.
Int64 can represent values in range [-(2^63),(2^63 - 1)].
"""
scalar Int64

input Int64Filter {
  eq: Int64
  in: [Int64]
  le: Int64
  lt: Int64
  ge: Int64
  gt: Int64
  between: Int64Range
}

input Int64Range {
  min: Int64!
  max: Int64!
}

input IntFilter {
  eq: Int
  in: [Int]
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: IntRange
}

input IntRange {
  min: Int!
  max: Int!
}

type IntValue {
  id: ID!
  intValue: Int!
}

type IntValueAggregateResult {
  count: Int
  intValueMin: Int
  intValueMax: Int
  intValueSum: Int
  intValueAvg: Float
}

input IntValueFilter {
  id: [ID!]
  has: [IntValueHasFilter]
  and: [IntValueFilter]
  or: [IntValueFilter]
  not: IntValueFilter
}

enum IntValueHasFilter {
  intValue
}

input IntValueOrder {
  asc: IntValueOrderable
  desc: IntValueOrderable
  then: IntValueOrder
}

enum IntValueOrderable {
  intValue
}

input IntValuePatch {
  intValue: Int
}

input IntValueRef {
  id: ID
  intValue: Int
}

type Interface implements Type {
  id: ID!
  name: String!
  atom(filter: AtomFilter): Atom
  fields(
    filter: FieldFilter
    order: FieldOrder
    first: Int
    offset: Int
  ): [Field]
  fieldsAggregate(filter: FieldFilter): FieldAggregateResult
}

type InterfaceAggregateResult {
  count: Int
  nameMin: String
  nameMax: String
}

input InterfaceFilter {
  id: [ID!]
  has: [InterfaceHasFilter]
  and: [InterfaceFilter]
  or: [InterfaceFilter]
  not: InterfaceFilter
}

enum InterfaceHasFilter {
  name
  atom
  fields
}

input InterfaceOrder {
  asc: InterfaceOrderable
  desc: InterfaceOrderable
  then: InterfaceOrder
}

enum InterfaceOrderable {
  name
}

input InterfacePatch {
  name: String
  atom: AtomRef
  fields: [FieldRef]
}

input InterfaceRef {
  id: ID
  name: String
  atom: AtomRef
  fields: [FieldRef]
}

type InterfaceValue {
  id: ID!
  props(filter: PropFilter, first: Int, offset: Int): [Prop!]!
  propsAggregate(filter: PropFilter): PropAggregateResult
}

type InterfaceValueAggregateResult {
  count: Int
}

input InterfaceValueFilter {
  id: [ID!]
  has: [InterfaceValueHasFilter]
  and: [InterfaceValueFilter]
  or: [InterfaceValueFilter]
  not: InterfaceValueFilter
}

enum InterfaceValueHasFilter {
  props
}

input InterfaceValuePatch {
  props: [PropRef!]
}

input InterfaceValueRef {
  id: ID
  props: [PropRef!]
}

input IntersectsFilter {
  polygon: PolygonRef
  multiPolygon: MultiPolygonRef
}

type Lambda {
  id: ID!
  ownerId: String!
  name: String!
  body: String!
}

type LambdaAggregateResult {
  count: Int
  ownerIdMin: String
  ownerIdMax: String
  nameMin: String
  nameMax: String
  bodyMin: String
  bodyMax: String
}

input LambdaFilter {
  id: [ID!]
  ownerId: StringHashFilter
  has: [LambdaHasFilter]
  and: [LambdaFilter]
  or: [LambdaFilter]
  not: LambdaFilter
}

enum LambdaHasFilter {
  ownerId
  name
  body
}

input LambdaOrder {
  asc: LambdaOrderable
  desc: LambdaOrderable
  then: LambdaOrder
}

enum LambdaOrderable {
  ownerId
  name
  body
}

input LambdaPatch {
  ownerId: String
  name: String
  body: String
}

input LambdaRef {
  id: ID
  ownerId: String
  name: String
  body: String
}

type Library {
  id: ID!
  ownerId: String!
  name: String!
  atoms(filter: AtomFilter, order: AtomOrder, first: Int, offset: Int): [Atom]
  components(
    filter: ComponentFilter
    order: ComponentOrder
    first: Int
    offset: Int
  ): [Component]
  atomsAggregate(filter: AtomFilter): AtomAggregateResult
  componentsAggregate(filter: ComponentFilter): ComponentAggregateResult
}

type LibraryAggregateResult {
  count: Int
  ownerIdMin: String
  ownerIdMax: String
  nameMin: String
  nameMax: String
}

input LibraryFilter {
  id: [ID!]
  has: [LibraryHasFilter]
  and: [LibraryFilter]
  or: [LibraryFilter]
  not: LibraryFilter
}

enum LibraryHasFilter {
  ownerId
  name
  atoms
  components
}

input LibraryOrder {
  asc: LibraryOrderable
  desc: LibraryOrderable
  then: LibraryOrder
}

enum LibraryOrderable {
  ownerId
  name
}

input LibraryPatch {
  ownerId: String
  name: String
  atoms: [AtomRef]
  components: [ComponentRef]
}

input LibraryRef {
  id: ID
  ownerId: String
  name: String
  atoms: [AtomRef]
  components: [ComponentRef]
}

enum Mode {
  BATCH
  SINGLE
}

type MultiPolygon {
  polygons: [Polygon!]!
}

input MultiPolygonRef {
  polygons: [PolygonRef!]!
}

type Mutation {
  addApp(input: [AddAppInput!]!): AddAppPayload
  updateApp(input: UpdateAppInput!): UpdateAppPayload
  deleteApp(filter: AppFilter!): DeleteAppPayload
  addLambda(input: [AddLambdaInput!]!): AddLambdaPayload
  updateLambda(input: UpdateLambdaInput!): UpdateLambdaPayload
  deleteLambda(filter: LambdaFilter!): DeleteLambdaPayload
  addPage(input: [AddPageInput!]!): AddPagePayload
  updatePage(input: UpdatePageInput!): UpdatePagePayload
  deletePage(filter: PageFilter!): DeletePagePayload
  addElement(input: [AddElementInput!]!): AddElementPayload
  updateElement(input: UpdateElementInput!): UpdateElementPayload
  deleteElement(filter: ElementFilter!): DeleteElementPayload
  addLibrary(input: [AddLibraryInput!]!): AddLibraryPayload
  updateLibrary(input: UpdateLibraryInput!): UpdateLibraryPayload
  deleteLibrary(filter: LibraryFilter!): DeleteLibraryPayload
  addComponent(input: [AddComponentInput!]!): AddComponentPayload
  updateComponent(input: UpdateComponentInput!): UpdateComponentPayload
  deleteComponent(filter: ComponentFilter!): DeleteComponentPayload
  addAtom(input: [AddAtomInput!]!): AddAtomPayload
  updateAtom(input: UpdateAtomInput!): UpdateAtomPayload
  deleteAtom(filter: AtomFilter!): DeleteAtomPayload
  addTag(input: [AddTagInput!]!): AddTagPayload
  updateTag(input: UpdateTagInput!): UpdateTagPayload
  deleteTag(filter: TagFilter!): DeleteTagPayload
  addPrimitiveType(input: [AddPrimitiveTypeInput!]!): AddPrimitiveTypePayload
  updatePrimitiveType(
    input: UpdatePrimitiveTypeInput!
  ): UpdatePrimitiveTypePayload
  deletePrimitiveType(filter: PrimitiveTypeFilter!): DeletePrimitiveTypePayload
  addArrayType(input: [AddArrayTypeInput!]!): AddArrayTypePayload
  updateArrayType(input: UpdateArrayTypeInput!): UpdateArrayTypePayload
  deleteArrayType(filter: ArrayTypeFilter!): DeleteArrayTypePayload
  addEnumTypeValue(input: [AddEnumTypeValueInput!]!): AddEnumTypeValuePayload
  updateEnumTypeValue(
    input: UpdateEnumTypeValueInput!
  ): UpdateEnumTypeValuePayload
  deleteEnumTypeValue(filter: EnumTypeValueFilter!): DeleteEnumTypeValuePayload
  addEnumType(input: [AddEnumTypeInput!]!): AddEnumTypePayload
  updateEnumType(input: UpdateEnumTypeInput!): UpdateEnumTypePayload
  deleteEnumType(filter: EnumTypeFilter!): DeleteEnumTypePayload
  addInterface(input: [AddInterfaceInput!]!): AddInterfacePayload
  updateInterface(input: UpdateInterfaceInput!): UpdateInterfacePayload
  deleteInterface(filter: InterfaceFilter!): DeleteInterfacePayload
  updateType(input: UpdateTypeInput!): UpdateTypePayload
  deleteType(filter: TypeFilter!): DeleteTypePayload
  addField(input: [AddFieldInput!]!): AddFieldPayload
  updateField(input: UpdateFieldInput!): UpdateFieldPayload
  deleteField(filter: FieldFilter!): DeleteFieldPayload
  addStringValue(input: [AddStringValueInput!]!): AddStringValuePayload
  updateStringValue(input: UpdateStringValueInput!): UpdateStringValuePayload
  deleteStringValue(filter: StringValueFilter!): DeleteStringValuePayload
  addIntValue(input: [AddIntValueInput!]!): AddIntValuePayload
  updateIntValue(input: UpdateIntValueInput!): UpdateIntValuePayload
  deleteIntValue(filter: IntValueFilter!): DeleteIntValuePayload
  addFloatValue(input: [AddFloatValueInput!]!): AddFloatValuePayload
  updateFloatValue(input: UpdateFloatValueInput!): UpdateFloatValuePayload
  deleteFloatValue(filter: FloatValueFilter!): DeleteFloatValuePayload
  addBooleanValue(input: [AddBooleanValueInput!]!): AddBooleanValuePayload
  updateBooleanValue(input: UpdateBooleanValueInput!): UpdateBooleanValuePayload
  deleteBooleanValue(filter: BooleanValueFilter!): DeleteBooleanValuePayload
  addArrayValue(input: [AddArrayValueInput!]!): AddArrayValuePayload
  updateArrayValue(input: UpdateArrayValueInput!): UpdateArrayValuePayload
  deleteArrayValue(filter: ArrayValueFilter!): DeleteArrayValuePayload
  addInterfaceValue(input: [AddInterfaceValueInput!]!): AddInterfaceValuePayload
  updateInterfaceValue(
    input: UpdateInterfaceValueInput!
  ): UpdateInterfaceValuePayload
  deleteInterfaceValue(
    filter: InterfaceValueFilter!
  ): DeleteInterfaceValuePayload
  addProp(input: [AddPropInput!]!): AddPropPayload
  updateProp(input: UpdatePropInput!): UpdatePropPayload
  deleteProp(filter: PropFilter!): DeletePropPayload
}

input NearFilter {
  distance: Float!
  coordinate: PointRef!
}

type Page {
  id: ID!
  name: String!
  app(filter: AppFilter): App!
  rootElement(filter: ElementFilter): Element!
}

type PageAggregateResult {
  count: Int
  nameMin: String
  nameMax: String
}

input PageFilter {
  id: [ID!]
  name: StringFullTextFilter_StringTermFilter
  has: [PageHasFilter]
  and: [PageFilter]
  or: [PageFilter]
  not: PageFilter
}

enum PageHasFilter {
  name
  app
  rootElement
}

input PageOrder {
  asc: PageOrderable
  desc: PageOrderable
  then: PageOrder
}

enum PageOrderable {
  name
}

input PagePatch {
  name: String
  app: AppRef
  rootElement: ElementRef
}

input PageRef {
  id: ID
  name: String
  app: AppRef
  rootElement: ElementRef
}

type Point {
  longitude: Float!
  latitude: Float!
}

input PointGeoFilter {
  near: NearFilter
  within: WithinFilter
}

type PointList {
  points: [Point!]!
}

input PointListRef {
  points: [PointRef!]!
}

input PointRef {
  longitude: Float!
  latitude: Float!
}

type Polygon {
  coordinates: [PointList!]!
}

input PolygonGeoFilter {
  near: NearFilter
  within: WithinFilter
  contains: ContainsFilter
  intersects: IntersectsFilter
}

input PolygonRef {
  coordinates: [PointListRef!]!
}

enum PrimitiveKind {
  String
  Integer
  Float
  Boolean
}

type PrimitiveType implements Type {
  id: ID!
  name: String!
  primitiveKind: PrimitiveKind!
}

type PrimitiveTypeAggregateResult {
  count: Int
  nameMin: String
  nameMax: String
}

input PrimitiveTypeFilter {
  id: [ID!]
  has: [PrimitiveTypeHasFilter]
  and: [PrimitiveTypeFilter]
  or: [PrimitiveTypeFilter]
  not: PrimitiveTypeFilter
}

enum PrimitiveTypeHasFilter {
  name
  primitiveKind
}

input PrimitiveTypeOrder {
  asc: PrimitiveTypeOrderable
  desc: PrimitiveTypeOrderable
  then: PrimitiveTypeOrder
}

enum PrimitiveTypeOrderable {
  name
}

input PrimitiveTypePatch {
  name: String
  primitiveKind: PrimitiveKind
}

input PrimitiveTypeRef {
  id: ID
  name: String
  primitiveKind: PrimitiveKind
}

type Prop {
  id: ID!
  field(filter: FieldFilter): Field!
  value(filter: PropValueFilter): PropValue
  element(filter: ElementFilter): Element
}

type PropAggregateResult {
  count: Int
}

input PropFilter {
  id: [ID!]
  has: [PropHasFilter]
  and: [PropFilter]
  or: [PropFilter]
  not: PropFilter
}

enum PropHasFilter {
  field
  value
  element
}

input PropPatch {
  field: FieldRef
  value: PropValueRef
  element: ElementRef
}

input PropRef {
  id: ID
  field: FieldRef
  value: PropValueRef
  element: ElementRef
}

union PropValue =
    StringValue
  | IntValue
  | FloatValue
  | BooleanValue
  | ArrayValue
  | InterfaceValue
  | EnumTypeValue

input PropValueFilter {
  memberTypes: [PropValueType!]
  stringValueFilter: StringValueFilter
  intValueFilter: IntValueFilter
  floatValueFilter: FloatValueFilter
  booleanValueFilter: BooleanValueFilter
  arrayValueFilter: ArrayValueFilter
  interfaceValueFilter: InterfaceValueFilter
  enumTypeValueFilter: EnumTypeValueFilter
}

input PropValueRef {
  stringValueRef: StringValueRef
  intValueRef: IntValueRef
  floatValueRef: FloatValueRef
  booleanValueRef: BooleanValueRef
  arrayValueRef: ArrayValueRef
  interfaceValueRef: InterfaceValueRef
  enumTypeValueRef: EnumTypeValueRef
}

enum PropValueType {
  StringValue
  IntValue
  FloatValue
  BooleanValue
  ArrayValue
  InterfaceValue
  EnumTypeValue
}

type Query {
  getApp(id: ID!): App
  queryApp(filter: AppFilter, order: AppOrder, first: Int, offset: Int): [App]
  aggregateApp(filter: AppFilter): AppAggregateResult
  getLambda(id: ID!): Lambda
  queryLambda(
    filter: LambdaFilter
    order: LambdaOrder
    first: Int
    offset: Int
  ): [Lambda]
  aggregateLambda(filter: LambdaFilter): LambdaAggregateResult
  getPage(id: ID!): Page
  queryPage(
    filter: PageFilter
    order: PageOrder
    first: Int
    offset: Int
  ): [Page]
  aggregatePage(filter: PageFilter): PageAggregateResult
  getElement(id: ID!): Element
  queryElement(
    filter: ElementFilter
    order: ElementOrder
    first: Int
    offset: Int
  ): [Element]
  aggregateElement(filter: ElementFilter): ElementAggregateResult
  getLibrary(id: ID!): Library
  queryLibrary(
    filter: LibraryFilter
    order: LibraryOrder
    first: Int
    offset: Int
  ): [Library]
  aggregateLibrary(filter: LibraryFilter): LibraryAggregateResult
  getComponent(id: ID!): Component
  queryComponent(
    filter: ComponentFilter
    order: ComponentOrder
    first: Int
    offset: Int
  ): [Component]
  aggregateComponent(filter: ComponentFilter): ComponentAggregateResult
  getAtom(id: ID!): Atom
  queryAtom(
    filter: AtomFilter
    order: AtomOrder
    first: Int
    offset: Int
  ): [Atom]
  aggregateAtom(filter: AtomFilter): AtomAggregateResult
  queryTag(filter: TagFilter, order: TagOrder, first: Int, offset: Int): [Tag]
  aggregateTag(filter: TagFilter): TagAggregateResult
  getPrimitiveType(id: ID!): PrimitiveType
  queryPrimitiveType(
    filter: PrimitiveTypeFilter
    order: PrimitiveTypeOrder
    first: Int
    offset: Int
  ): [PrimitiveType]
  aggregatePrimitiveType(
    filter: PrimitiveTypeFilter
  ): PrimitiveTypeAggregateResult
  getArrayType(id: ID!): ArrayType
  queryArrayType(
    filter: ArrayTypeFilter
    order: ArrayTypeOrder
    first: Int
    offset: Int
  ): [ArrayType]
  aggregateArrayType(filter: ArrayTypeFilter): ArrayTypeAggregateResult
  getEnumTypeValue(id: ID!): EnumTypeValue
  queryEnumTypeValue(
    filter: EnumTypeValueFilter
    order: EnumTypeValueOrder
    first: Int
    offset: Int
  ): [EnumTypeValue]
  aggregateEnumTypeValue(
    filter: EnumTypeValueFilter
  ): EnumTypeValueAggregateResult
  getEnumType(id: ID!): EnumType
  queryEnumType(
    filter: EnumTypeFilter
    order: EnumTypeOrder
    first: Int
    offset: Int
  ): [EnumType]
  aggregateEnumType(filter: EnumTypeFilter): EnumTypeAggregateResult
  getInterface(id: ID!): Interface
  queryInterface(
    filter: InterfaceFilter
    order: InterfaceOrder
    first: Int
    offset: Int
  ): [Interface]
  aggregateInterface(filter: InterfaceFilter): InterfaceAggregateResult
  getType(id: ID!): Type
  queryType(
    filter: TypeFilter
    order: TypeOrder
    first: Int
    offset: Int
  ): [Type]
  aggregateType(filter: TypeFilter): TypeAggregateResult
  getField(id: ID!): Field
  queryField(
    filter: FieldFilter
    order: FieldOrder
    first: Int
    offset: Int
  ): [Field]
  aggregateField(filter: FieldFilter): FieldAggregateResult
  getStringValue(id: ID!): StringValue
  queryStringValue(
    filter: StringValueFilter
    order: StringValueOrder
    first: Int
    offset: Int
  ): [StringValue]
  aggregateStringValue(filter: StringValueFilter): StringValueAggregateResult
  getIntValue(id: ID!): IntValue
  queryIntValue(
    filter: IntValueFilter
    order: IntValueOrder
    first: Int
    offset: Int
  ): [IntValue]
  aggregateIntValue(filter: IntValueFilter): IntValueAggregateResult
  getFloatValue(id: ID!): FloatValue
  queryFloatValue(
    filter: FloatValueFilter
    order: FloatValueOrder
    first: Int
    offset: Int
  ): [FloatValue]
  aggregateFloatValue(filter: FloatValueFilter): FloatValueAggregateResult
  getBooleanValue(id: ID!): BooleanValue
  queryBooleanValue(
    filter: BooleanValueFilter
    first: Int
    offset: Int
  ): [BooleanValue]
  aggregateBooleanValue(filter: BooleanValueFilter): BooleanValueAggregateResult
  getArrayValue(id: ID!): ArrayValue
  queryArrayValue(
    filter: ArrayValueFilter
    first: Int
    offset: Int
  ): [ArrayValue]
  aggregateArrayValue(filter: ArrayValueFilter): ArrayValueAggregateResult
  getInterfaceValue(id: ID!): InterfaceValue
  queryInterfaceValue(
    filter: InterfaceValueFilter
    first: Int
    offset: Int
  ): [InterfaceValue]
  aggregateInterfaceValue(
    filter: InterfaceValueFilter
  ): InterfaceValueAggregateResult
  getProp(id: ID!): Prop
  queryProp(filter: PropFilter, first: Int, offset: Int): [Prop]
  aggregateProp(filter: PropFilter): PropAggregateResult
}

input StringExactFilter {
  eq: String
  in: [String]
  le: String
  lt: String
  ge: String
  gt: String
  between: StringRange
}

input StringFullTextFilter {
  alloftext: String
  anyoftext: String
}

input StringFullTextFilter_StringHashFilter {
  alloftext: String
  anyoftext: String
  eq: String
  in: [String]
}

input StringFullTextFilter_StringTermFilter {
  alloftext: String
  anyoftext: String
  allofterms: String
  anyofterms: String
}

input StringHashFilter {
  eq: String
  in: [String]
}

input StringRange {
  min: String!
  max: String!
}

input StringRegExpFilter {
  regexp: String
}

input StringTermFilter {
  allofterms: String
  anyofterms: String
}

type StringValue {
  id: ID!
  stringValue: String!
}

type StringValueAggregateResult {
  count: Int
  stringValueMin: String
  stringValueMax: String
}

input StringValueFilter {
  id: [ID!]
  has: [StringValueHasFilter]
  and: [StringValueFilter]
  or: [StringValueFilter]
  not: StringValueFilter
}

enum StringValueHasFilter {
  stringValue
}

input StringValueOrder {
  asc: StringValueOrderable
  desc: StringValueOrderable
  then: StringValueOrder
}

enum StringValueOrderable {
  stringValue
}

input StringValuePatch {
  stringValue: String
}

input StringValueRef {
  id: ID
  stringValue: String
}

type Tag {
  label: String!
}

type TagAggregateResult {
  count: Int
  labelMin: String
  labelMax: String
}

input TagFilter {
  has: [TagHasFilter]
  and: [TagFilter]
  or: [TagFilter]
  not: TagFilter
}

enum TagHasFilter {
  label
}

input TagOrder {
  asc: TagOrderable
  desc: TagOrderable
  then: TagOrder
}

enum TagOrderable {
  label
}

input TagPatch {
  label: String
}

input TagRef {
  label: String
}

interface Type {
  id: ID!
  name: String!
}

type TypeAggregateResult {
  count: Int
  nameMin: String
  nameMax: String
}

input TypeFilter {
  id: [ID!]
  has: [TypeHasFilter]
  and: [TypeFilter]
  or: [TypeFilter]
  not: TypeFilter
}

enum TypeHasFilter {
  name
}

input TypeOrder {
  asc: TypeOrderable
  desc: TypeOrderable
  then: TypeOrder
}

enum TypeOrderable {
  name
}

input TypePatch {
  name: String
}

input TypeRef {
  id: ID!
}

union TypeUnion = Interface | EnumType | ArrayType | PrimitiveType

input TypeUnionFilter {
  memberTypes: [TypeUnionType!]
  interfaceFilter: InterfaceFilter
  enumTypeFilter: EnumTypeFilter
  arrayTypeFilter: ArrayTypeFilter
  primitiveTypeFilter: PrimitiveTypeFilter
}

input TypeUnionRef {
  interfaceRef: InterfaceRef
  enumTypeRef: EnumTypeRef
  arrayTypeRef: ArrayTypeRef
  primitiveTypeRef: PrimitiveTypeRef
}

enum TypeUnionType {
  Interface
  EnumType
  ArrayType
  PrimitiveType
}

input UpdateAppInput {
  filter: AppFilter!
  set: AppPatch
  remove: AppPatch
}

type UpdateAppPayload {
  app(filter: AppFilter, order: AppOrder, first: Int, offset: Int): [App]
  numUids: Int
}

input UpdateArrayTypeInput {
  filter: ArrayTypeFilter!
  set: ArrayTypePatch
  remove: ArrayTypePatch
}

type UpdateArrayTypePayload {
  arrayType(
    filter: ArrayTypeFilter
    order: ArrayTypeOrder
    first: Int
    offset: Int
  ): [ArrayType]
  numUids: Int
}

input UpdateArrayValueInput {
  filter: ArrayValueFilter!
  set: ArrayValuePatch
  remove: ArrayValuePatch
}

type UpdateArrayValuePayload {
  arrayValue(filter: ArrayValueFilter, first: Int, offset: Int): [ArrayValue]
  numUids: Int
}

input UpdateAtomInput {
  filter: AtomFilter!
  set: AtomPatch
  remove: AtomPatch
}

type UpdateAtomPayload {
  atom(filter: AtomFilter, order: AtomOrder, first: Int, offset: Int): [Atom]
  numUids: Int
}

input UpdateBooleanValueInput {
  filter: BooleanValueFilter!
  set: BooleanValuePatch
  remove: BooleanValuePatch
}

type UpdateBooleanValuePayload {
  booleanValue(
    filter: BooleanValueFilter
    first: Int
    offset: Int
  ): [BooleanValue]
  numUids: Int
}

input UpdateComponentInput {
  filter: ComponentFilter!
  set: ComponentPatch
  remove: ComponentPatch
}

type UpdateComponentPayload {
  component(
    filter: ComponentFilter
    order: ComponentOrder
    first: Int
    offset: Int
  ): [Component]
  numUids: Int
}

input UpdateElementInput {
  filter: ElementFilter!
  set: ElementPatch
  remove: ElementPatch
}

type UpdateElementPayload {
  element(
    filter: ElementFilter
    order: ElementOrder
    first: Int
    offset: Int
  ): [Element]
  numUids: Int
}

input UpdateEnumTypeInput {
  filter: EnumTypeFilter!
  set: EnumTypePatch
  remove: EnumTypePatch
}

type UpdateEnumTypePayload {
  enumType(
    filter: EnumTypeFilter
    order: EnumTypeOrder
    first: Int
    offset: Int
  ): [EnumType]
  numUids: Int
}

input UpdateEnumTypeValueInput {
  filter: EnumTypeValueFilter!
  set: EnumTypeValuePatch
  remove: EnumTypeValuePatch
}

type UpdateEnumTypeValuePayload {
  enumTypeValue(
    filter: EnumTypeValueFilter
    order: EnumTypeValueOrder
    first: Int
    offset: Int
  ): [EnumTypeValue]
  numUids: Int
}

input UpdateFieldInput {
  filter: FieldFilter!
  set: FieldPatch
  remove: FieldPatch
}

type UpdateFieldPayload {
  field(
    filter: FieldFilter
    order: FieldOrder
    first: Int
    offset: Int
  ): [Field]
  numUids: Int
}

input UpdateFloatValueInput {
  filter: FloatValueFilter!
  set: FloatValuePatch
  remove: FloatValuePatch
}

type UpdateFloatValuePayload {
  floatValue(
    filter: FloatValueFilter
    order: FloatValueOrder
    first: Int
    offset: Int
  ): [FloatValue]
  numUids: Int
}

input UpdateIntValueInput {
  filter: IntValueFilter!
  set: IntValuePatch
  remove: IntValuePatch
}

type UpdateIntValuePayload {
  intValue(
    filter: IntValueFilter
    order: IntValueOrder
    first: Int
    offset: Int
  ): [IntValue]
  numUids: Int
}

input UpdateInterfaceInput {
  filter: InterfaceFilter!
  set: InterfacePatch
  remove: InterfacePatch
}

type UpdateInterfacePayload {
  interface(
    filter: InterfaceFilter
    order: InterfaceOrder
    first: Int
    offset: Int
  ): [Interface]
  numUids: Int
}

input UpdateInterfaceValueInput {
  filter: InterfaceValueFilter!
  set: InterfaceValuePatch
  remove: InterfaceValuePatch
}

type UpdateInterfaceValuePayload {
  interfaceValue(
    filter: InterfaceValueFilter
    first: Int
    offset: Int
  ): [InterfaceValue]
  numUids: Int
}

input UpdateLambdaInput {
  filter: LambdaFilter!
  set: LambdaPatch
  remove: LambdaPatch
}

type UpdateLambdaPayload {
  lambda(
    filter: LambdaFilter
    order: LambdaOrder
    first: Int
    offset: Int
  ): [Lambda]
  numUids: Int
}

input UpdateLibraryInput {
  filter: LibraryFilter!
  set: LibraryPatch
  remove: LibraryPatch
}

type UpdateLibraryPayload {
  library(
    filter: LibraryFilter
    order: LibraryOrder
    first: Int
    offset: Int
  ): [Library]
  numUids: Int
}

input UpdatePageInput {
  filter: PageFilter!
  set: PagePatch
  remove: PagePatch
}

type UpdatePagePayload {
  page(filter: PageFilter, order: PageOrder, first: Int, offset: Int): [Page]
  numUids: Int
}

input UpdatePrimitiveTypeInput {
  filter: PrimitiveTypeFilter!
  set: PrimitiveTypePatch
  remove: PrimitiveTypePatch
}

type UpdatePrimitiveTypePayload {
  primitiveType(
    filter: PrimitiveTypeFilter
    order: PrimitiveTypeOrder
    first: Int
    offset: Int
  ): [PrimitiveType]
  numUids: Int
}

input UpdatePropInput {
  filter: PropFilter!
  set: PropPatch
  remove: PropPatch
}

type UpdatePropPayload {
  prop(filter: PropFilter, first: Int, offset: Int): [Prop]
  numUids: Int
}

input UpdateStringValueInput {
  filter: StringValueFilter!
  set: StringValuePatch
  remove: StringValuePatch
}

type UpdateStringValuePayload {
  stringValue(
    filter: StringValueFilter
    order: StringValueOrder
    first: Int
    offset: Int
  ): [StringValue]
  numUids: Int
}

input UpdateTagInput {
  filter: TagFilter!
  set: TagPatch
  remove: TagPatch
}

type UpdateTagPayload {
  tag(filter: TagFilter, order: TagOrder, first: Int, offset: Int): [Tag]
  numUids: Int
}

input UpdateTypeInput {
  filter: TypeFilter!
  set: TypePatch
  remove: TypePatch
}

type UpdateTypePayload {
  type(filter: TypeFilter, order: TypeOrder, first: Int, offset: Int): [Type]
  numUids: Int
}

input WithinFilter {
  polygon: PolygonRef!
}
