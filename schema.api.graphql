# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type CreateResponse {
  id: String!
}

type App {
  id: ID!
  ownerId: String!
  name: String!
  pages: App!
}

type User {
  id: String!
  auth0Id: String!
  roles: [Role!]!
}

enum Role {
  Admin
  User
  Guest
}

type Field {
  id: ID!
  key: String!
  name: String
  description: String
}

"""
A edge between types. Depending on the kind can mean a couple of things:
  TypeEdgeKind.Field - it represents a Field object, the field property will contain the metadata;
  TypeEdgeKind.ArrayItem - it represents the generic array item type of an array type. The field property will be empty
"""
type TypeEdge {
  source: String!
  target: String!
  kind: TypeEdgeKind!

  """Empty if kind is not TypeEdgeKind.Field"""
  field: Field
}

enum TypeEdgeKind {
  Field
  ArrayItem
}

type ArrayType implements Type {
  typeKind: TypeKind!
  id: ID!
  name: String!
  typeGraph: TypeGraph!
}

interface Type {
  typeKind: TypeKind!
  id: ID!
  name: String!
  typeGraph: TypeGraph!
}

enum TypeKind {
  PrimitiveType
  ArrayType
  InterfaceType
  EnumType
  LambdaType
  ElementType
  ComponentType
}

"""
The ComponentType allows selecting a Component in the props form. The value is stored as the componentId 
"""
type ComponentType implements Type {
  typeKind: TypeKind!
  id: ID!
  name: String!
  typeGraph: TypeGraph!
}

"""
The ElementType allows selecting an Element in the props form. The value is stored as the elementId 
"""
type ElementType implements Type {
  typeKind: TypeKind!
  id: ID!
  name: String!
  typeGraph: TypeGraph!
  kind: ElementTypeKind!
}

enum ElementTypeKind {
  AllElements
  DescendantsOnly
  ChildrenOnly
}

type EnumTypeValue {
  id: ID!
  name: String
  value: String!
}

type EnumType implements Type {
  typeKind: TypeKind!
  id: ID!
  name: String!
  typeGraph: TypeGraph!
  allowedValues: [EnumTypeValue!]!
}

type InterfaceType implements Type {
  typeKind: TypeKind!
  id: ID!
  name: String!
  typeGraph: TypeGraph!
  fields: [Field!]!
}

"""
The LambdaType allows selecting a Lambda in the props form. The value is stored as the lambdaId 
"""
type LambdaType implements Type {
  typeKind: TypeKind!
  id: ID!
  name: String!
  typeGraph: TypeGraph!
}

type PrimitiveType implements Type {
  typeKind: TypeKind!
  id: ID!
  name: String!
  typeGraph: TypeGraph!
  primitiveKind: PrimitiveKind!
}

enum PrimitiveKind {
  String
  Integer
  Float
  Boolean
}

type TypeGraph {
  vertices: [TypeVertex!]!
  edges: [TypeEdge!]!
}

union TypeVertex = EnumType | PrimitiveType | ArrayType | ComponentType | ElementType | InterfaceType | LambdaType

type Atom {
  id: ID!
  type: AtomType!

  """
  This is a unique ID suitable for seeders to lookup, will rename to value
  """
  name: String!
  api: InterfaceType!
}

enum AtomType {
  AntDesignAffix
  AntDesignAlert
  AntDesignAnchor
  AntDesignAnchorLink
  AntDesignAutoComplete
  AntDesignAvatar
  AntDesignBackTop
  AntDesignBadge
  AntDesignBreadcrumb
  AntDesignBreadcrumbItem
  AntDesignButton
  AntDesignCalendar
  AntDesignCard
  AntDesignCardGrid
  AntDesignCardMeta
  AntDesignCarousel
  AntDesignCascader
  AntDesignCheckbox
  AntDesignCollapse
  AntDesignCollapsePanel
  AntDesignComment
  AntDesignConfigProvider
  AntDesignDatePicker
  AntDesignDescriptions
  AntDesignDescriptionsItem
  AntDesignDivider
  AntDesignDrawer
  AntDesignDropdown
  AntDesignEmpty
  AntDesignForm
  AntDesignFormItem
  AntDesignFormItemHook
  AntDesignFormList
  AntDesignGridCol
  AntDesignGridRow
  AntDesignIcon
  AntDesignInput
  AntDesignInputNumber
  AntDesignLayout
  AntDesignLayoutContent
  AntDesignLayoutFooter
  AntDesignLayoutHeader
  AntDesignLayoutSider
  AntDesignList
  AntDesignListItem
  AntDesignListItemMeta
  AntDesignMapper
  AntDesignMentions
  AntDesignMentionsOption
  AntDesignMenu
  AntDesignMenuItem
  AntDesignMenuItemGroup
  AntDesignMenuSubMenu
  AntDesignModal
  AntDesignPageHeader
  AntDesignPageContainer
  AntDesignPagination
  AntDesignPopconfirm
  AntDesignPopover
  AntDesignProgress
  AntDesignProvider
  AntDesignRglContainer
  AntDesignRglItem
  AntDesignRglResponsiveContainer
  AntDesignRadio
  AntDesignRadioGroup
  AntDesignRate
  AntDesignRenderComponent
  AntDesignRenderContainer
  AntDesignResult
  AntDesignSelect
  AntDesignSelectOption
  AntDesignSkeleton
  AntDesignSlider
  AntDesignSpace
  AntDesignSpin
  AntDesignStatistic
  AntDesignSteps
  AntDesignStepsStep
  AntDesignSwitch
  AntDesignTable
  AntDesignTabs
  AntDesignTabsTabPane
  AntDesignTag
  AntDesignTimePicker
  AntDesignTimeline
  AntDesignTimelineItem
  AntDesignTooltip
  AntDesignTransfer
  AntDesignTree
  AntDesignTreeNode
  AntDesignTreeSelect
  AntDesignTypography
  AntDesignTypographyParagraph
  AntDesignTypographyText
  AntDesignTypographyTitle
  AntDesignUpload
  AntDesignImage
  Query
  TextList
  Text
  State
  ReactFragment
  HtmlA
  HtmlP
  HtmlVideo
  HtmlUList
  HtmlTrack
  HtmlTitle
  HtmlTime
  HtmlTextarea
  HtmlTemplate
  HtmlTableRow
  HtmlTable
  HtmlTableCol
  HtmlTableCell
  HtmlTableCaption
  HtmlStyle
  HtmlSpan
  HtmlSource
  HtmlSelect
  HtmlQuote
  HtmlProgress
  HtmlPre
  HtmlPicture
  HtmlParam
  HtmlOutput
  HtmlOption
  HtmlOptgroup
  HtmlObject
  HtmlOList
  HtmlMeter
  HtmlMeta
  HtmlMap
  HtmlLink
  HtmlLegend
  HtmlLabel
  HtmlLi
  HtmlInput
  HtmlImage
  HtmlIframe
  HtmlH1
  HtmlH2
  HtmlH3
  HtmlH4
  HtmlH5
  HtmlH6
  HtmlHead
  HtmlHr
  HtmlFrameset
  HtmlFrame
  HtmlForm
  HtmlFont
  HtmlFieldset
  HtmlEmbed
  HtmlDiv
  HtmlDialog
  HtmlDetails
  HtmlDatalist
  HtmlData
  HtmlDList
  HtmlCanvas
  HtmlButton
  HtmlBase
  HtmlBr
  HtmlAudio
  HtmlArea
  HtmlFooter
  HtmlAside
  HtmlHeader
  HtmlMain
  HtmlNav
  HtmlSection
  HtmlCode
  HtmlEm
  HtmlI
  HtmlS
  HtmlSmall
  HtmlStrong
  HtmlSub
  HtmlSup
}

type Hook {
  id: ID!
  type: HookType!
  config: HookConfig!
}

enum HookType {
  Query
  GraphqlQuery
  RecoilState
}

union HookConfig = QueryHookConfig | GraphqlQueryHookConfig | RecoilStateHookConfig

type QueryHookConfig {
  queryKey: String!
  url: String
  body: String
  method: QueryMethod
  lambdaId: String
}

enum QueryMethod {
  GET
  DELETE
  HEAD
  OPTIONS
  POST
  PUT
  PATCH
  PURGE
  LINK
  UNLINK
}

type GraphqlQueryHookConfig {
  body: String!
  url: String!
  dataKey: String
}

type RecoilStateHookConfig {
  stateKey: String!
  defaultValue: String
}

type PropMapBinding {
  id: ID!

  """
  The ID of the target element, if omitted, the current element will be the target
  """
  targetElementId: String

  """The key of the prop, as received in the source element"""
  sourceKey: String!

  """The key of the prop, that the target Element will receive"""
  targetKey: String!
}

type Element {
  id: ID!

  """
  Due to union nullability issue, we have to make this non-nullable. Defaults to atom type
  """
  name: String!
  css: String

  """Props in a json format"""
  props: String!
  hooks: [Hook!]!

  """
  If set, the element will get rendered for each item in the array found in its props by the given key, if it exists
  """
  renderForEachPropKey: String

  """
  If set, the element will get rendered only if the prop with the given key exists and is evaluated as truthy (exception - the string "false" will evaluate to falsy)
  """
  renderIfPropKey: String
  propMapBindings: [PropMapBinding!]!
  propTransformationJs: String
  atom: Atom
}

type Component {
  id: ID!
  name: String!
}

"""An edge between two element nodes"""
type ElementEdge {
  """The id of the source Element/Component"""
  source: String!

  """The id of the target Element/Component"""
  target: String!
  order: Int
}

type ElementGraph {
  """All descendant Elements or Components, at any level"""
  vertices: [ElementVertex!]!

  """All the links connecting the descendant elements/components"""
  edges: [ElementEdge!]!
}

union ElementVertex = Element | Component

type Lambda {
  id: ID!
  ownerId: String!
  name: String!
  body: String!
}

type LambdaPayload {
  payload: String!
}

type Page {
  id: ID!
  name: String!
  elements: ElementGraph
}

type Tag {
  id: String!
  name: String!
  isRoot: Boolean!
}

"""An edge between two element nodes"""
type TagEdge {
  """The id of the source Tag"""
  source: String!

  """The id of the target Tag"""
  target: String!
  order: Int
}

type TagGraph {
  """All descendant Elements or Components, at any level"""
  vertices: [TagVertex!]!

  """All the links connecting the descendant elements/components"""
  edges: [TagEdge!]!
}

union TagVertex = Tag

type Query {
  getMe: User
  getUser(input: GetUserInput!): User
  getUsers(input: GetUsersInput): [User!]!
  getApp(input: GetAppInput!): App
  getApps: [App!]!
  getPages(input: GetPagesInput!): [Page!]!
  getPage(input: GetPageInput!): Page

  """
  Aggregates the requested element and all of its descendant elements (infinitely deep) in the form of a flat array of Element and array of ElementEdge
  """
  getElementGraph(input: GetElementGraphInput!): ElementGraph

  """Get a single element."""
  getElement(input: GetElementInput!): Element
  getComponent(input: GetComponentInput!): Component
  getComponentElements(input: GetComponentInput!): ElementGraph
  getComponents(input: GetComponentsInput): [Component!]!
  getAtoms(input: GetAtomsInput): [Atom!]
  getAtom(input: GetAtomInput!): Atom
  getType(input: GetTypeInput!): Type
  getTypeGraph(input: GetTypeInput!): TypeGraph
  getTypes(input: GetTypesInput): [Type!]!
  getField(input: GetFieldInput!): Field
  getLambda(input: GetLambdaInput!): Lambda
  getLambdas: [Lambda!]!
  getTag(input: GetTagInput!): Tag

  """Get all Tag graphs"""
  getTags: [Tag!]!

  """
  Aggregates the requested tags and all of its descendant tags (infinitely deep) in the form of a flat array of TagVertex (alias of Tag) and array of TagEdge
  """
  getTagGraph: TagGraph
}

input GetUserInput {
  id: String
  auth0Id: String
}

input GetUsersInput {
  page: Int!
  perPage: Int!
  query: String!
  sort: String!
}

input GetAppInput {
  byId: AppByIdFilter
  byPage: AppByPageFilter
}

input AppByIdFilter {
  appId: String!
}

input AppByPageFilter {
  pageId: String!
}

input GetPagesInput {
  byApp: PageByAppFilter!
}

input PageByAppFilter {
  appId: String!
}

input GetPageInput {
  pageId: String!
}

input GetElementGraphInput {
  elementId: String!
}

input GetElementInput {
  elementId: String!
}

input GetComponentInput {
  componentId: String!
}

input GetComponentsInput {
  componentIds: [String!]
}

input GetAtomsInput {
  where: AtomsWhereInput
}

input AtomsWhereInput {
  ids: [String!]
}

input GetAtomInput {
  where: AtomWhereUniqueInput!
}

input AtomWhereUniqueInput {
  id: String
  type: AtomType
  element: String
}

input GetTypeInput {
  where: WhereUniqueType!
}

input WhereUniqueType {
  id: String
  name: String
  atomId: String
}

"""Filters are optional and you can provide all three of them together"""
input GetTypesInput {
  byIds: TypesByIdsFilter
  byKind: TypesByKindFilter
  byName: TypesByNameFilter
}

input TypesByIdsFilter {
  typeIds: [String!]!
}

input TypesByKindFilter {
  kind: TypeKind!
}

input TypesByNameFilter {
  name: String!
}

input GetFieldInput {
  byInterface: FieldByInterfaceFilter
  byId: FieldByIdFilter
}

input FieldByInterfaceFilter {
  interfaceId: String!
  fieldKey: String!
}

input FieldByIdFilter {
  fieldId: String!
}

input GetLambdaInput {
  lambdaId: String!
}

input GetTagInput {
  where: WhereUniqueTag!
}

input WhereUniqueTag {
  name: String
  id: String
}

type Mutation {
  upsertUser(input: UpsertUserInput!): CreateResponse!
  deleteUser(input: DeleteUserInput!): Boolean!
  createApp(input: CreateAppInput!): CreateResponse!
  updateApp(input: UpdateAppInput!): Void
  deleteApp(input: DeleteAppInput!): Void
  resetData: Void
  createPage(input: CreatePageInput!): CreateResponse!
  deletePage(input: DeletePageInput!): Void
  updatePage(input: UpdatePageInput!): Void
  createPropMapBinding(input: CreatePropMapBindingInput!): CreateResponse!
  updatePropMapBinding(input: UpdatePropMapBindingInput!): Void
  deletePropMapBinding(input: DeletePropMapBindingInput!): Void
  addHookToElement(input: AddHookToElementInput!): CreateResponse!
  removeHookFromElement(input: RemoveHookFromElementInput!): Void
  createElement(input: CreateElementInput!): CreateResponse!
  updateElement(input: UpdateElementInput!): Void
  moveElement(input: MoveElementInput!): Void
  updateElementProps(input: UpdateElementPropsInput!): Void

  """Deletes an element and all the descending elements"""
  deleteElement(input: DeleteElementInput!): Void
  createComponent(input: CreateComponentInput!): CreateResponse!
  updateComponent(input: UpdateComponentInput!): Void
  deleteComponent(input: DeleteComponentInput!): Void
  createAtom(input: CreateAtomInput!): CreateResponse!
  deleteAtom(input: DeleteAtomInput!): Void
  importAtoms(input: ImportAtomsInput!): Void
  updateAtom(input: UpdateAtomInput!): Void
  seedBaseTypes: Void
  createType(input: CreateTypeInput!): CreateResponse!
  updateEnumType(input: UpdateEnumTypeInput!): Void
  updatePrimitiveType(input: UpdatePrimitiveTypeInput!): Void
  updateType(input: UpdateTypeInput!): Void
  deleteType(input: DeleteTypeInput!): Void
  createField(input: CreateFieldInput!): CreateResponse!
  updateField(input: UpdateFieldInput!): Void
  deleteField(input: DeleteFieldInput!): Void
  createLambda(input: CreateLambdaInput!): CreateResponse!
  deleteLambda(input: DeleteLambdaInput!): Void
  updateLambda(input: UpdateLambdaInput!): Void
  executeLambda(input: ExecuteLambdaInput!): LambdaPayload
  createTag(input: CreateTagInput!): CreateResponse!
  updateTag(input: UpdateTagInput!): Void
  deleteTags(input: DeleteTagsInput!): Void
}

input UpsertUserInput {
  data: UpsertUserDataInput!
  where: UserWhereUniqueInput
}

input UpsertUserDataInput {
  auth0Id: String!
  roles: [Role!]!
}

input UserWhereUniqueInput {
  id: String
  auth0Id: String
}

input DeleteUserInput {
  id: String!
}

input CreateAppInput {
  name: String!
}

"""Date custom scalar type"""
scalar Void

input UpdateAppInput {
  id: String!
  data: UpdateAppData!
}

input UpdateAppData {
  name: String!
}

input DeleteAppInput {
  appId: String!
}

input CreatePageInput {
  name: String!
  appId: String!
}

input DeletePageInput {
  pageId: String!
}

input UpdatePageInput {
  pageId: String!
  updateData: UpdatePageData!
}

input UpdatePageData {
  name: String!
  appId: String!
}

input CreatePropMapBindingInput {
  elementId: String!

  """
  The ID of the target element, if omitted, the current element will be the target
  """
  targetElementId: String

  """The key of the prop, as received in the source element"""
  sourceKey: String!

  """The key of the prop, that the target Element will receive"""
  targetKey: String!
}

input UpdatePropMapBindingInput {
  propMapBindingId: String!
  data: UpdatePropMapBindingData!
}

input UpdatePropMapBindingData {
  """
  The ID of the target element, if omitted, the current element will be the target
  """
  targetElementId: String

  """The key of the prop, as received in the source element"""
  sourceKey: String!

  """The key of the prop, that the target Element will receive"""
  targetKey: String!
}

input DeletePropMapBindingInput {
  propMapBindingIds: [String!]!
}

"""Provide exactly one of the config fields"""
input AddHookToElementInput {
  elementId: String!
  queryHook: QueryHookConfigInput
  graphqlQueryHook: GraphqlQueryHookConfigInput
  recoilStateHook: RecoilStateHookConfigInput
}

"""Provide either a lambdaId, or body/method/url"""
input QueryHookConfigInput {
  queryKey: String!
  url: String
  body: String
  method: QueryMethod
  lambdaId: String
}

input GraphqlQueryHookConfigInput {
  url: String!
  body: String!
  dataKey: String
}

input RecoilStateHookConfigInput {
  stateKey: String!
  defaultValue: String
}

input RemoveHookFromElementInput {
  elementId: String!
  hookId: String!
}

input CreateElementInput {
  name: String
  atomId: String
  componentId: String
  parentElementId: String

  """
  Leave it out to automatically set it as the last order of all the children
  """
  order: Int
}

input UpdateElementInput {
  data: UpdateElementData!
  id: String!
}

input UpdateElementData {
  name: String
  atomId: String
  componentId: String
  css: String

  """
  If set, the element will get rendered for each item in the array found in its props by the given key, if it exists
  """
  renderForEachPropKey: String

  """
  If set, the element will get rendered only if the prop with the given key exists and is evaluated as truthy (exception - the string "false" will evaluate to falsy)
  """
  renderIfPropKey: String
  propTransformationJs: String
}

input MoveElementInput {
  elementId: String!
  moveData: MoveData!
}

input MoveData {
  order: Int!
  parentElementId: String!
}

input UpdateElementPropsInput {
  props: String!
  elementId: String!
}

input DeleteElementInput {
  elementId: String!
}

input CreateComponentInput {
  name: String!
}

input UpdateComponentInput {
  componentId: String!
  updateData: UpdateComponentData!
}

input UpdateComponentData {
  name: String!
}

input DeleteComponentInput {
  componentId: String!
}

input CreateAtomInput {
  name: String!
  type: AtomType!

  """Pass in an existing interface ID to assign it to the atom"""
  api: String
}

input DeleteAtomInput {
  atomId: String!
}

input ImportAtomsInput {
  payload: String!
}

input UpdateAtomInput {
  id: String!
  data: CreateAtomInput!
}

"""Provide one of the properties"""
input CreateTypeInput {
  name: String!
  typeKind: TypeKind!
  primitiveType: CreatePrimitiveTypeInput
  arrayType: CreateArrayTypeInput
  enumType: CreateEnumTypeInput
  interfaceType: Boolean = false
  lambdaType: Boolean = false
  componentType: Boolean = false
  elementType: CreateElementTypeInput
}

input CreatePrimitiveTypeInput {
  primitiveKind: PrimitiveKind!
}

input CreateArrayTypeInput {
  itemTypeId: String!
}

input CreateEnumTypeInput {
  allowedValues: [CreateEnumTypeValueInput!]!
}

input CreateEnumTypeValueInput {
  name: String
  value: String!
}

input CreateElementTypeInput {
  kind: ElementTypeKind!
}

input UpdateEnumTypeInput {
  typeId: String!
  updateData: UpdateEnumTypeData!
}

input UpdateEnumTypeData {
  allowedValues: [UpdateEnumTypeValueData!]!
  name: String!
}

input UpdateEnumTypeValueData {
  id: String
  name: String
  value: String!
}

input UpdatePrimitiveTypeInput {
  typeId: String!
  updateData: UpdatePrimitiveKindData!
}

input UpdatePrimitiveKindData {
  primitiveKind: PrimitiveKind!
  name: String!
}

input UpdateTypeInput {
  updateData: UpdateTypeData!
  typeId: String!
}

input UpdateTypeData {
  name: String!
}

input DeleteTypeInput {
  typeId: String!
}

input CreateFieldInput {
  key: String!
  name: String
  description: String

  """The interface to add fields to"""
  interfaceId: String!
  type: TypeRef!
}

input TypeRef {
  existingTypeId: String
  newType: CreateTypeInput
}

input UpdateFieldInput {
  fieldId: String!
  updateData: UpdateFieldData!
}

input UpdateFieldData {
  key: String!
  name: String
  description: String
  type: TypeRef!
}

input DeleteFieldInput {
  fieldId: String!
}

input CreateLambdaInput {
  """Name of the Lambda function to be executed"""
  name: String!

  """Content of the Lambda function"""
  body: String!
}

input DeleteLambdaInput {
  lambdaId: String!
}

input UpdateLambdaInput {
  """Name of the Lambda function to be executed"""
  name: String!

  """Content of the Lambda function"""
  body: String!
  id: String!
}

input ExecuteLambdaInput {
  lambdaId: String!
  payload: String
}

input CreateTagInput {
  name: String!
  parentTagId: String

  """
  We can create multiple tag trees, the root tells us whether this is a separate tree
  """
  isRoot: Boolean = false
}

input UpdateTagInput {
  id: String!
  data: UpdateTagData!
}

input UpdateTagData {
  name: String!
}

input DeleteTagsInput {
  ids: [String!]!
}
