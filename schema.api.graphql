# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

interface TypeEdge {
  source: String!
  target: String!
}

type ObjectRef {
  id: ID!
}

type CreateResponse {
  id: String!
}

type PayloadResponse {
  payload: String!
}

type User {
  id: ID!
  auth0Id: String!
  roles: [Role!]!
}

enum Role {
  Admin
  User
  Guest
}

type Field {
  id: ID!
  key: String!
  name: String
  description: String
  target: String!
  source: String!
}

type BaseTypeEdge implements TypeEdge {
  source: String!
  target: String!
}

type FieldTypeEdge implements TypeEdge {
  source: String!
  target: String!
  id: ID!
  key: String!
  name: String
  description: String
}

type ArrayType implements Type {
  typeKind: TypeKind!
  id: ID!
  name: String!
  owner: ObjectRef
  typeGraph: TypeGraph!
  itemType: ObjectRef!
}

interface Type {
  typeKind: TypeKind!
  id: ID!
  name: String!
  owner: ObjectRef
  typeGraph: TypeGraph!
}

enum TypeKind {
  PrimitiveType
  ArrayType
  InterfaceType
  EnumType
  LambdaType
  ElementType
  RenderPropsType
  ReactNodeType
  UnionType
  MonacoType
  PageType
  AppType
}

"""
The ElementType allows selecting an Element in the props form. The value is stored as the elementId 
"""
type ElementType implements Type {
  typeKind: TypeKind!
  id: ID!
  name: String!
  owner: ObjectRef
  typeGraph: TypeGraph!
  elementKind: ElementTypeKind!
}

enum ElementTypeKind {
  AllElements
  DescendantsOnly
  ChildrenOnly
}

type EnumTypeValue {
  id: ID!
  name: String
  value: String!
}

type EnumType implements Type {
  typeKind: TypeKind!
  id: ID!
  name: String!
  owner: ObjectRef
  typeGraph: TypeGraph!
  allowedValues: [EnumTypeValue!]!
}

type InterfaceType implements Type {
  typeKind: TypeKind!
  id: ID!
  name: String!
  owner: ObjectRef
  typeGraph: TypeGraph!
  fields: [Field!]!
}

"""
The LambdaType allows selecting a Lambda in the props form. The value is stored as the lambdaId 
"""
type LambdaType implements Type {
  typeKind: TypeKind!
  id: ID!
  name: String!
  owner: ObjectRef
  typeGraph: TypeGraph!
}

type PrimitiveType implements Type {
  typeKind: TypeKind!
  id: ID!
  name: String!
  owner: ObjectRef
  typeGraph: TypeGraph!
  primitiveKind: PrimitiveTypeKind!
}

enum PrimitiveTypeKind {
  String
  Integer
  Float
  Boolean
}

type ReactNodeType implements Type {
  typeKind: TypeKind!
  id: ID!
  name: String!
  owner: ObjectRef
  typeGraph: TypeGraph!
}

type RenderPropsType implements Type {
  typeKind: TypeKind!
  id: ID!
  name: String!
  owner: ObjectRef
  typeGraph: TypeGraph!
}

"""
The AppType allows selecting a App in the props form. The value is stored as the appId 
"""
type AppType implements Type {
  typeKind: TypeKind!
  id: ID!
  name: String!
  owner: ObjectRef
  typeGraph: TypeGraph!
}

"""
The MonacoType allows inserting code using Monaco Editor in the props form.
"""
type MonacoType implements Type {
  typeKind: TypeKind!
  id: ID!
  name: String!
  owner: ObjectRef
  typeGraph: TypeGraph!
  language: MonacoLanguage!
}

enum MonacoLanguage {
  TypeScript
  JavaScript
  CSS
  JSON
  Graphql
  CSSINJS
}

"""
The PageType allows selecting a Page in the props form. The value is stored as the pageId 
"""
type PageType implements Type {
  typeKind: TypeKind!
  id: ID!
  name: String!
  owner: ObjectRef
  typeGraph: TypeGraph!
}

type UnionType implements Type {
  typeKind: TypeKind!
  id: ID!
  name: String!
  owner: ObjectRef
  typeGraph: TypeGraph!
  typesOfUnionType: [ObjectRef!]!
}

type TypeGraph {
  vertices: [TypeVertex!]!
  edges: [TypeEdge!]!
}

union TypeVertex = EnumType | PrimitiveType | ArrayType | ElementType | InterfaceType | LambdaType | PageType | AppType | RenderPropsType | ReactNodeType | UnionType | MonacoType

type Atom {
  id: ID!

  """
  An Atom could be of HTML type <button> or <a>, or a component type of <Button> or <Link>
  """
  type: AtomType!

  """This acts as unique ID suitable for seeder lookup"""
  name: String!
  tags: [String!]!
  apiGraph: TypeGraph!
  api: InterfaceType!
}

enum AtomType {
  HookQueryLambda
  HookQueryConfig
  HookGraphqlQuery
  HookGraphqlMutation
  HookRecoilState
  HookQueryPage
  HookQueryPages
  HookRouter
  AntDesignAffix
  AntDesignAlert
  AntDesignAnchor
  AntDesignAnchorLink
  AntDesignAutoComplete
  AntDesignAvatar
  AntDesignBackTop
  AntDesignBadge
  AntDesignBreadcrumb
  AntDesignBreadcrumbItem
  AntDesignButton
  AntDesignCalendar
  AntDesignCard
  AntDesignCardGrid
  AntDesignCardMeta
  AntDesignCarousel
  AntDesignCascader
  AntDesignCheckbox
  AntDesignCollapse
  AntDesignCollapsePanel
  AntDesignComment
  AntDesignConfigProvider
  AntDesignDatePicker
  AntDesignDescriptions
  AntDesignDescriptionsItem
  AntDesignDivider
  AntDesignDrawer
  AntDesignDropdown
  AntDesignEmpty
  AntDesignForm
  AntDesignFormItem
  AntDesignFormItemHook
  AntDesignFormList
  AntDesignGridCol
  AntDesignGridRow
  AntDesignIcon
  AntDesignInput
  AntDesignInputNumber
  AntDesignLayout
  AntDesignLayoutContent
  AntDesignLayoutFooter
  AntDesignLayoutHeader
  AntDesignLayoutSider
  AntDesignList
  AntDesignListItem
  AntDesignListItemMeta
  AntDesignMapper
  AntDesignMentions
  AntDesignMentionsOption
  AntDesignMenu
  AntDesignMenuItem
  AntDesignMenuItemGroup
  AntDesignMenuSubMenu
  AntDesignModal
  AntDesignPageHeader
  AntDesignPageContainer
  AntDesignPagination
  AntDesignPopconfirm
  AntDesignPopover
  AntDesignProgress
  AntDesignProvider
  AntDesignRglContainer
  AntDesignRglItem
  AntDesignRglResponsiveContainer
  AntDesignRadio
  AntDesignRadioGroup
  AntDesignRate
  AntDesignRenderComponent
  AntDesignRenderContainer
  AntDesignResult
  AntDesignSelect
  AntDesignSelectOption
  AntDesignSkeleton
  AntDesignSlider
  AntDesignSpace
  AntDesignSpin
  AntDesignStatistic
  AntDesignSteps
  AntDesignStepsStep
  AntDesignSwitch
  AntDesignTable
  AntDesignTabs
  AntDesignTabsTabPane
  AntDesignTag
  AntDesignTimePicker
  AntDesignTimeline
  AntDesignTimelineItem
  AntDesignTooltip
  AntDesignTransfer
  AntDesignTree
  AntDesignTreeNode
  AntDesignTreeSelect
  AntDesignTypography
  AntDesignTypographyParagraph
  AntDesignTypographyText
  AntDesignTypographyTitle
  AntDesignUpload
  AntDesignImage
  MuiAccordion
  MuiAccordionActions
  MuiAccordionDetails
  MuiAccordionSummary
  MuiAlert
  MuiAlertTitle
  MuiAppBar
  MuiAutocomplete
  MuiAvatar
  MuiAvatarGroup
  MuiBackdrop
  MuiBackdropUnstyled
  MuiBadge
  MuiBadgeUnstyled
  MuiBottomNavigation
  MuiBottomNavigationAction
  MuiBox
  MuiBreadcrumbs
  MuiButton
  MuiButtonBase
  MuiButtonGroup
  MuiButtonUnstyled
  MuiCalendarPicker
  MuiCalendarPickerSkeleton
  MuiCard
  MuiCardActionArea
  MuiCardActions
  MuiCardContent
  MuiCardHeader
  MuiCardMedia
  MuiCheckbox
  MuiChip
  MuiCircularProgress
  MuiClickAwayListener
  MuiClockPicker
  MuiCollapse
  MuiContainer
  MuiCssBaseline
  MuiDataGrid
  MuiGridColDef
  MuiDatePicker
  MuiDateRangePicker
  MuiDateRangePickerDay
  MuiDateTimePicker
  MuiDesktopDatePicker
  MuiDesktopDateRangePicker
  MuiDesktopDateTimePicker
  MuiDesktopTimePicker
  MuiDialog
  MuiDialogActions
  MuiDialogContent
  MuiDialogContentText
  MuiDialogTitle
  MuiDivider
  MuiDrawer
  MuiFab
  MuiFade
  MuiFilledInput
  MuiFormControl
  MuiFormControlLabel
  MuiFormControlUnstyled
  MuiFormGroup
  MuiFormHelperText
  MuiFormLabel
  MuiGlobalStyles
  MuiGrid
  MuiGrow
  MuiHidden
  MuiIcon
  MuiIconButton
  MuiImageList
  MuiImageListItem
  MuiImageListItemBar
  MuiInput
  MuiInputAdornment
  MuiInputBase
  MuiInputLabel
  MuiLinearProgress
  MuiLink
  MuiList
  MuiListItem
  MuiListItemAvatar
  MuiListItemButton
  MuiListItemIcon
  MuiListItemSecondaryAction
  MuiListItemText
  MuiListSubheader
  MuiLoadingButton
  MuiMasonry
  MuiMasonryItem
  MuiMenu
  MuiMenuItem
  MuiMenuList
  MuiMobileDatePicker
  MuiMobileDateRangePicker
  MuiMobileDateTimePicker
  MuiMobileStepper
  MuiMobileTimePicker
  MuiModal
  MuiModalUnstyled
  MuiMonthPicker
  MuiNativeSelect
  MuiNoSsr
  MuiOutlinedInput
  MuiPagination
  MuiPaginationItem
  MuiPaper
  MuiPickersDay
  MuiPopover
  MuiPopper
  MuiPortal
  MuiRadio
  MuiRadioGroup
  MuiRating
  MuiScopedCssBaseline
  MuiSelect
  MuiSkeleton
  MuiSlide
  MuiSlider
  MuiSliderUnstyled
  MuiSnackbar
  MuiSnackbarContent
  MuiSpeedDial
  MuiSpeedDialAction
  MuiSpeedDialIcon
  MuiStack
  MuiStaticDatePicker
  MuiStaticDateRangePicker
  MuiStaticDateTimePicker
  MuiStaticTimePicker
  MuiStep
  MuiStepButton
  MuiStepConnector
  MuiStepContent
  MuiStepIcon
  MuiStepLabel
  MuiStepper
  MuiSvgIcon
  MuiSwipeableDrawer
  MuiSwitch
  MuiSwitchUnstyled
  MuiTab
  MuiTabContext
  MuiTabList
  MuiTabPanel
  MuiTabScrollButton
  MuiTable
  MuiTableBody
  MuiTableCell
  MuiTableContainer
  MuiTableFooter
  MuiTableHead
  MuiTablePagination
  MuiTableRow
  MuiTableSortLabel
  MuiTabs
  MuiTextField
  MuiTextareaAutosize
  MuiTimePicker
  MuiTimeline
  MuiTimelineConnector
  MuiTimelineContent
  MuiTimelineDot
  MuiTimelineItem
  MuiTimelineOppositeContent
  MuiTimelineSeparator
  MuiToggleButton
  MuiToggleButtonGroup
  MuiToolbar
  MuiTooltip
  MuiTreeItem
  MuiTreeView
  MuiTypography
  MuiUnstableTrapFocus
  MuiYearPicker
  MuiZoom
  Query
  TextList
  Text
  State
  ReactFragment
  HtmlA
  HtmlP
  HtmlVideo
  HtmlUList
  HtmlTrack
  HtmlTitle
  HtmlTime
  HtmlTextarea
  HtmlTemplate
  HtmlTableRow
  HtmlTable
  HtmlTableCol
  HtmlTableCell
  HtmlTableCaption
  HtmlStyle
  HtmlSpan
  HtmlSource
  HtmlSelect
  HtmlQuote
  HtmlProgress
  HtmlPre
  HtmlPicture
  HtmlParam
  HtmlOutput
  HtmlOption
  HtmlOptgroup
  HtmlObject
  HtmlOList
  HtmlMeter
  HtmlMeta
  HtmlMap
  HtmlLink
  HtmlLegend
  HtmlLabel
  HtmlLi
  HtmlInput
  HtmlImage
  HtmlIframe
  HtmlH1
  HtmlH2
  HtmlH3
  HtmlH4
  HtmlH5
  HtmlH6
  HtmlHead
  HtmlHr
  HtmlFrameset
  HtmlFrame
  HtmlForm
  HtmlFont
  HtmlFieldset
  HtmlEmbed
  HtmlDiv
  HtmlDialog
  HtmlDetails
  HtmlDatalist
  HtmlData
  HtmlDList
  HtmlCanvas
  HtmlButton
  HtmlBase
  HtmlBr
  HtmlAudio
  HtmlArea
  HtmlFooter
  HtmlAside
  HtmlHeader
  HtmlMain
  HtmlNav
  HtmlSection
  HtmlCode
  HtmlEm
  HtmlI
  HtmlS
  HtmlSmall
  HtmlStrong
  HtmlSub
  HtmlSup
}

type Prop {
  id: ID!
  data: String!
}

type Hook {
  id: ID!
  type: AtomType!
  config: Prop!
}

type Tag {
  id: ID!
  name: String!
  owner: ObjectRef
  parent: String
  children: [String!]!
  isRoot: Boolean!
}

"""An edge between two element nodes"""
type TagEdge {
  """The id of the source Tag"""
  source: String!

  """The id of the target Tag"""
  target: String!
  order: Int
}

type TagGraph {
  """All descendant Elements or Components, at any level"""
  vertices: [TagVertex!]!

  """All the links connecting the descendant elements/components"""
  edges: [TagEdge!]!
}

union TagVertex = Tag

type PropMapBinding {
  id: ID!

  """
  The ID of the target element, if omitted, the current element will be the target
  """
  targetElementId: String

  """The key of the prop, as received in the source element"""
  sourceKey: String!

  """The key of the prop, that the target Element will receive"""
  targetKey: String!
}

type Element {
  id: ID!

  """We default the Element name to the Atom type"""
  name: String

  """
  A tag for components, we can't help but put it on the same model as element
  """
  componentTag: Tag
  fixedId: String

  """The CSS string that gets passed down to emotion"""
  css: String
  atom: Atom

  """These are the prop data that we bind with"""
  props: Prop!
  hooks: [Hook!]!

  """
  If set, the element will get rendered for each item in the array found in its props by the given key, if it exists
  """
  renderForEachPropKey: String

  """
  If set, the element will get rendered only if the prop with the given key exists and is evaluated as truthy (exception - the string "false" will evaluate to falsy)
  """
  renderIfPropKey: String

  """Maps external object data to their property keys in the Element"""
  propMapBindings: [PropMapBinding!]!

  """Allows transformation of external props data"""
  propTransformationJs: String

  """Tells what type of Component this Element is using"""
  instanceOfComponent: ObjectRef
  parentElement: ObjectRef
  owner: ObjectRef

  """
  Aggregates the requested element and all of its descendant elements (infinitely deep) in the form of a flat array of Element and array of ElementEdge
  """
  graph: ElementGraph!
}

"""An edge between two element nodes"""
type ElementEdge {
  """The id of the source Element"""
  source: String!

  """The id of the target Element"""
  target: String!
  order: Int
}

type ElementGraph {
  vertices: [Element!]!

  """All the links connecting the descendant elements"""
  edges: [ElementEdge!]!
}

type Page {
  id: ID!
  name: String!
  elements: ElementGraph
  rootElementId: String!
}

type App {
  id: ID!
  ownerId: String!
  name: String!
  pages: [Page!]!
}

type Lambda {
  id: ID!
  ownerId: String!
  name: String!
  body: String!
}

type LambdaPayload {
  payload: String!
}

type Query {
  getApp(input: GetAppInput!): App
  getApps: [App!]!
  exportApp(input: ExportAppInput!): PayloadResponse!

  """
  Aggregates the requested element and all of its descendant elements (infinitely deep) in the form of a flat array of Element and array of ElementEdge
  """
  getElementGraph(input: GetElementGraphInput!): ElementGraph!

  """Get a single element."""
  getElement(input: GetElementInput!): Element
  getComponents(input: GetComponentsInput): [Element!]!
  getAtomsTypeHook: [Atom!]
  getAtoms(input: GetAtomsInput): [Atom!]
  getAtom(input: GetAtomInput!): Atom
  getType(input: GetTypeInput!): Type
  getTypeGraph(input: GetTypeGraphInput!): TypeGraph
  getTypes(input: GetTypesInput): [Type!]!
  getField(input: GetFieldInput!): Field
  getProp: Prop!
  getPages(input: GetPagesInput!): [Page!]!
  getPage(input: GetPageInput!): Page
  getMe: User
  getUser(input: GetUserInput!): User
  getUsers(input: GetUsersInput): [User!]!
  getLambda(input: GetLambdaInput!): Lambda
  getLambdas: [Lambda!]!
  getTag(input: GetTagInput!): Tag

  """Get all Tag graphs"""
  getTags(input: GetTagsInput): [Tag!]!

  """
  Aggregates the requested tags and all of its descendant tags (infinitely deep) in the form of a flat array of TagVertex (alias of Tag) and array of TagEdge
  """
  getTagGraph: TagGraph

  """
  Aggregates the requested tags and all of its descendant tags (infinitely deep) in the form of a flat array of TagVertex (alias of Tag) and array of TagEdge
  """
  getTagGraphs(input: GetTagGraphsInput): TagGraph!
}

input GetAppInput {
  byId: AppByIdFilter
  byPage: AppByPageFilter
}

input AppByIdFilter {
  appId: String!
}

input AppByPageFilter {
  pageId: String!
}

input ExportAppInput {
  appId: String!
}

input GetElementGraphInput {
  where: WhereUniqueElement!
}

input WhereUniqueElement {
  id: String
  fixedId: String
}

input GetElementInput {
  where: WhereUniqueElement!
}

input GetComponentsInput {
  searchQuery: String
  componentIds: [String!]
}

input GetAtomsInput {
  where: AtomsWhereInput
}

"""Provide no more than 1 filter"""
input AtomsWhereInput {
  ids: [String!]
  types: [AtomType!]
  searchQuery: String
}

input GetAtomInput {
  where: AtomWhereUniqueInput!
}

input AtomWhereUniqueInput {
  id: String
  type: AtomType
  element: String
}

input GetTypeInput {
  where: WhereUniqueType!
}

"""Provide exactly 1 field"""
input WhereUniqueType {
  id: String
  name: String
  atomId: String
  enumTypeValueId: String
}

input GetTypeGraphInput {
  where: WhereUniqueTypeGraph!
}

"""Provide exactly 1 field"""
input WhereUniqueTypeGraph {
  id: String
  name: String
  atomId: String
}

input GetTypesInput {
  where: TypesWhereInput
}

"""Provide exactly no more than 1 filter"""
input TypesWhereInput {
  ids: [String!]
  kind: TypeKind
  name: String
}

input GetFieldInput {
  byInterface: FieldByInterfaceFilter
  byId: FieldByIdFilter
}

input FieldByInterfaceFilter {
  interfaceId: String!
  fieldKey: String!
}

input FieldByIdFilter {
  fieldId: String!
}

input GetPagesInput {
  byApp: PageByAppFilter!
}

input PageByAppFilter {
  appId: String!
}

input GetPageInput {
  pageId: String!
}

input GetUserInput {
  id: String
  auth0Id: String
}

input GetUsersInput {
  page: Int!
  perPage: Int!
  query: String!
  sort: String!
}

input GetLambdaInput {
  lambdaId: String!
}

input GetTagInput {
  where: WhereUniqueTag!
}

input WhereUniqueTag {
  name: String
  id: String
}

input GetTagsInput {
  ids: [String!]
}

input GetTagGraphsInput {
  where: TagsWhereInput
}

input TagsWhereInput {
  ids: [String!]
}

type Mutation {
  createApp(input: CreateAppInput!): App!
  updateApp(input: UpdateAppInput!): App
  deleteApp(input: DeleteAppInput!): App
  importApp(input: ImportAppInput!): App!
  createPropMapBinding(input: CreatePropMapBindingInput!): PropMapBinding!
  updatePropMapBinding(input: UpdatePropMapBindingInput!): PropMapBinding
  deletePropMapBinding(input: DeletePropMapBindingInput!): [PropMapBinding!]
  addHookToElement(input: AddHookToElementInput!): Hook!
  removeHookFromElement(input: RemoveHookFromElementInput!): Hook
  createElement(input: CreateElementInput!): Element!
  updateElement(input: UpdateElementInput!): Element!
  moveElement(input: MoveElementInput!): Element!
  duplicateElement(input: DuplicateElementInput!): Element!
  updateElementProps(input: UpdateElementPropsInput!): Element!

  """Deletes an element and all the descending elements"""
  deleteElement(input: DeleteElementInput!): Element!
  convertElementToComponent(input: ConvertElementToComponentInput!): Element!

  """Facade for creating a element with component tag"""
  createComponent(input: CreateComponentInput!): Element!
  createAtom(input: CreateAtomInput!): Atom!
  deleteAtom(input: DeleteAtomInput!): Atom!
  importAtoms(input: ImportAtomsInput!): Void
  updateAtom(input: UpdateAtomInput!): Atom
  upsertAtoms(input: UpsertAtomsInput!): [Atom!]!
  importTypes(input: ImportTypesInput!): [CreateResponse!]
  seedBaseTypes: Void
  createType(input: CreateTypeInput!): Type!
  updateEnumType(input: UpdateEnumTypeInput!): EnumType
  updatePrimitiveType(input: UpdatePrimitiveTypeInput!): PrimitiveType
  updateUnionType(input: UpdateUnionTypeInput!): UnionType
  updateType(input: UpdateTypeInput!): Type
  deleteType(input: DeleteTypeInput!): Type
  createField(input: CreateFieldInput!): Field!
  updateField(input: UpdateFieldInput!): Field
  deleteField(input: DeleteFieldInput!): Field
  createPage(input: CreatePageInput!): Page!
  deletePage(input: DeletePageInput!): Page!
  updatePage(input: UpdatePageInput!): Page!
  upsertUser(input: UpsertUserInput!): User!
  deleteUser(input: DeleteUserInput!): Boolean!
  resetData: Void
  executeCommand(input: ExecuteCommandInput!): PayloadResponse!
  createLambda(input: CreateLambdaInput!): Lambda!
  deleteLambda(input: DeleteLambdaInput!): Lambda!
  updateLambda(input: UpdateLambdaInput!): Lambda
  executeLambda(input: ExecuteLambdaInput!): LambdaPayload
  createTag(input: CreateTagInput!): Tag!
  updateTag(input: UpdateTagInput!): Tag
  deleteTags(input: DeleteTagsInput!): [Tag!]
  upsertTag(input: UpsertTagInput!): Tag!
  importTags(input: ImportTagsInput!): Void
}

input CreateAppInput {
  name: String!
}

input UpdateAppInput {
  id: String!
  data: UpdateAppData!
}

input UpdateAppData {
  name: String!
}

input DeleteAppInput {
  appId: String!
}

input ImportAppInput {
  payload: String!
}

input CreatePropMapBindingInput {
  elementId: String!

  """
  The ID of the target element, if omitted, the current element will be the target
  """
  targetElementId: String

  """The key of the prop, as received in the source element"""
  sourceKey: String!

  """The key of the prop, that the target Element will receive"""
  targetKey: String!
}

input UpdatePropMapBindingInput {
  propMapBindingId: String!
  elementId: String!
  data: UpdatePropMapBindingData!
}

input UpdatePropMapBindingData {
  """
  The ID of the target element, if omitted, the current element will be the target
  """
  targetElementId: String

  """The key of the prop, as received in the source element"""
  sourceKey: String!

  """The key of the prop, that the target Element will receive"""
  targetKey: String!
}

input DeletePropMapBindingInput {
  elementId: String!
  propMapBindingIds: [String!]!
}

input AddHookToElementInput {
  elementId: String!

  """JSON string"""
  config: String!
  type: AtomType!
}

input RemoveHookFromElementInput {
  elementId: String!
  hookId: String!
}

input CreateElementInput {
  """Attaches the newly created element as child of an existing element"""
  parentElementId: String
  name: String
  css: String
  atomId: String

  """
  The order in parent. Leave it out to automatically set it as the last order of all the children
  """
  order: Int
  props: String

  """
  Set to a elementId with component tag, which will be used as a component template for this element. isComponent and instanceOfComponentId are mutually exclusive
  """
  instanceOfComponentId: String
}

input UpdateElementInput {
  data: UpdateElementData!
  id: String!
}

input UpdateElementData {
  name: String
  atomId: String
  instanceOfComponentId: String
  css: String

  """
  If set, the element will get rendered for each item in the array found in its props by the given key, if it exists
  """
  renderForEachPropKey: String

  """
  If set, the element will get rendered only if the prop with the given key exists and is evaluated as truthy (exception - the string "false" will evaluate to falsy)
  """
  renderIfPropKey: String
  propTransformationJs: String
}

input MoveElementInput {
  elementId: String!
  moveData: MoveData!
}

input MoveData {
  order: Int!
  parentElementId: String
}

input DuplicateElementInput {
  elementId: String!
}

input UpdateElementPropsInput {
  data: String!
  elementId: String!
}

input DeleteElementInput {
  elementId: String!
}

input ConvertElementToComponentInput {
  elementId: String!

  """Leave out to infer it automatically"""
  componentName: String
}

input CreateComponentInput {
  name: String!
  props: String
  atomId: String
}

input CreateAtomInput {
  name: String!
  type: AtomType!

  """Pass in an existing interface ID to assign it to the atom"""
  api: String
}

input DeleteAtomInput {
  atomId: String!
}

"""Date custom scalar type"""
scalar Void

input ImportAtomsInput {
  payload: String!
}

input UpdateAtomInput {
  id: String!
  data: CreateAtomInput!
}

input UpsertAtomsInput {
  atoms: [UpsertAtomInput!]!
}

input UpsertAtomInput {
  name: String!
  type: AtomType!

  """Pass in an existing interface ID to assign it to the atom"""
  api: String
  id: String
}

input ImportTypesInput {
  payload: String!
}

"""Provide one of the properties"""
input CreateTypeInput {
  name: String!
  typeKind: TypeKind!
  primitiveType: CreatePrimitiveTypeInput
  arrayType: CreateArrayTypeInput
  enumType: CreateEnumTypeInput
  unionType: CreateUnionType
  elementType: CreateElementTypeInput
  monacoType: CreateMonacoTypeInput
}

input CreatePrimitiveTypeInput {
  primitiveKind: PrimitiveTypeKind!
}

input CreateArrayTypeInput {
  itemTypeId: String!
}

input CreateEnumTypeInput {
  allowedValues: [CreateEnumTypeValueInput!]!
}

input CreateEnumTypeValueInput {
  name: String
  value: String!
}

input CreateUnionType {
  typeIdsOfUnionType: [String!]!
}

input CreateElementTypeInput {
  kind: ElementTypeKind!
}

input CreateMonacoTypeInput {
  language: MonacoLanguage!
}

input UpdateEnumTypeInput {
  typeId: String!
  updateData: UpdateEnumTypeData!
}

input UpdateEnumTypeData {
  allowedValues: [UpdateEnumTypeValueData!]!
  name: String!
}

input UpdateEnumTypeValueData {
  id: String
  name: String
  value: String!
}

input UpdatePrimitiveTypeInput {
  typeId: String!
  updateData: UpdatePrimitiveKindData!
}

input UpdatePrimitiveKindData {
  primitiveKind: PrimitiveTypeKind!
  name: String!
}

input UpdateUnionTypeInput {
  updateData: UpdateUnionTypeData!
  typeId: String!
}

input UpdateUnionTypeData {
  name: String!
  typeIdsOfUnionType: [String!]!
}

input UpdateTypeInput {
  updateData: UpdateTypeData!
  typeId: String!
}

input UpdateTypeData {
  name: String!
}

input DeleteTypeInput {
  typeId: String!
}

input CreateFieldInput {
  key: String!
  name: String
  description: String

  """The interface to add fields to"""
  interfaceId: String!

  """The type of the field we're adding"""
  type: TypeRef!
}

input TypeRef {
  existingTypeId: String
  newType: CreateTypeInput
}

input UpdateFieldInput {
  interfaceId: String!
  fieldId: String!
  updateData: UpdateFieldData!
}

input UpdateFieldData {
  key: String!
  name: String
  description: String

  """The type of the field we're adding"""
  type: TypeRef!
}

input DeleteFieldInput {
  fieldId: String!
  interfaceId: String!
}

input CreatePageInput {
  name: String!
  appId: String!
}

input DeletePageInput {
  pageId: String!
}

input UpdatePageInput {
  pageId: String!
  updateData: UpdatePageData!
}

input UpdatePageData {
  name: String!
}

input UpsertUserInput {
  data: UpsertUserDataInput!
  where: UserWhereUniqueInput
}

input UpsertUserDataInput {
  auth0Id: String!
  roles: [Role!]!
}

input UserWhereUniqueInput {
  id: String
  auth0Id: String
}

input DeleteUserInput {
  id: String!
}

input ExecuteCommandInput {
  command: String!
}

input CreateLambdaInput {
  """Name of the Lambda function to be executed"""
  name: String!

  """Content of the Lambda function"""
  body: String!
}

input DeleteLambdaInput {
  lambdaId: String!
}

input UpdateLambdaInput {
  """Name of the Lambda function to be executed"""
  name: String!

  """Content of the Lambda function"""
  body: String!
  id: String!
}

input ExecuteLambdaInput {
  lambdaId: String!
  payload: String
}

input CreateTagInput {
  name: String!

  """Parent tag id, empty parent means it's root"""
  parentTagId: String = null
}

input UpdateTagInput {
  id: String!
  data: UpdateTagData!
}

input UpdateTagData {
  name: String!
}

input DeleteTagsInput {
  ids: [String!]!
}

input UpsertTagInput {
  data: CreateTagInput!
  where: TagWhereUniqueInput
}

input TagWhereUniqueInput {
  id: String
  name: String
}

input ImportTagsInput {
  payload: String!
}
