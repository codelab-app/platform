/* eslint-disable */
import { DocumentTypeDecoration } from '@graphql-typed-document-node/core'
export type Maybe<T> = T | null
export type InputMaybe<T> = Maybe<T>
export type Exact<T extends { [key: string]: unknown }> = {
  [K in keyof T]: T[K]
}
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]?: Maybe<T[SubKey]>
}
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]: Maybe<T[SubKey]>
}
export type MakeEmpty<
  T extends { [key: string]: unknown },
  K extends keyof T,
> = { [_ in K]?: never }
export type Incremental<T> =
  | T
  | {
      [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never
    }
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string }
  String: { input: string; output: string }
  Boolean: { input: boolean; output: boolean }
  Int: { input: number; output: number }
  Float: { input: number; output: number }
}

export enum ActionKind {
  /** Action responsible for fetching data from a resource */
  ApiAction = 'ApiAction',
  /** Action with custom code */
  CodeAction = 'CodeAction',
}

/** Allows picking a action from the list of actions */
export type ActionType = IBaseType & {
  fieldRefs: Array<Field>
  fieldRefsAggregate?: Maybe<ActionTypeFieldFieldRefsAggregationSelection>
  fieldRefsConnection: IBaseTypeFieldRefsConnection
  id: Scalars['ID']['output']
  kind: TypeKind
  name: Scalars['String']['output']
  owner: User
  ownerAggregate?: Maybe<ActionTypeUserOwnerAggregationSelection>
  ownerConnection: IBaseTypeOwnerConnection
}

/** Allows picking a action from the list of actions */
export type ActionTypeFieldRefsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<FieldOptions>
  sort?: InputMaybe<Array<FieldSort>>
  where?: InputMaybe<FieldWhere>
}

/** Allows picking a action from the list of actions */
export type ActionTypeFieldRefsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<FieldWhere>
}

/** Allows picking a action from the list of actions */
export type ActionTypeFieldRefsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<IBaseTypeFieldRefsConnectionSort>>
  where?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
}

/** Allows picking a action from the list of actions */
export type ActionTypeOwnerArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<UserOptions>
  sort?: InputMaybe<Array<UserSort>>
  where?: InputMaybe<UserWhere>
}

/** Allows picking a action from the list of actions */
export type ActionTypeOwnerAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<UserWhere>
}

/** Allows picking a action from the list of actions */
export type ActionTypeOwnerConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<IBaseTypeOwnerConnectionSort>>
  where?: InputMaybe<IBaseTypeOwnerConnectionWhere>
}

export type ActionTypeAggregateSelection = {
  count: Scalars['Int']['output']
  id: IdAggregateSelection
  name: StringAggregateSelection
}

export type ActionTypeConnectInput = {
  fieldRefs?: InputMaybe<Array<ActionTypeFieldRefsConnectFieldInput>>
  owner?: InputMaybe<ActionTypeOwnerConnectFieldInput>
}

export type ActionTypeConnectOrCreateWhere = {
  node: ActionTypeUniqueWhere
}

export type ActionTypeConnectWhere = {
  node: ActionTypeWhere
}

export type ActionTypeCreateInput = {
  fieldRefs?: InputMaybe<ActionTypeFieldRefsFieldInput>
  id: Scalars['ID']['input']
  kind?: TypeKind
  name: Scalars['String']['input']
  owner?: InputMaybe<ActionTypeOwnerFieldInput>
}

export type ActionTypeCreatedEvent = {
  createdActionType: ActionTypeEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type ActionTypeDeleteInput = {
  fieldRefs?: InputMaybe<Array<IBaseTypeFieldRefsDeleteFieldInput>>
  owner?: InputMaybe<IBaseTypeOwnerDeleteFieldInput>
}

export type ActionTypeDeletedEvent = {
  deletedActionType: ActionTypeEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type ActionTypeDisconnectInput = {
  fieldRefs?: InputMaybe<Array<IBaseTypeFieldRefsDisconnectFieldInput>>
  owner?: InputMaybe<IBaseTypeOwnerDisconnectFieldInput>
}

export type ActionTypeEdge = {
  cursor: Scalars['String']['output']
  node: ActionType
}

export type ActionTypeEventPayload = {
  id: Scalars['ID']['output']
  kind: TypeKind
  name: Scalars['String']['output']
}

export type ActionTypeFieldFieldRefsAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<ActionTypeFieldFieldRefsNodeAggregateSelection>
}

export type ActionTypeFieldFieldRefsNodeAggregateSelection = {
  defaultValues: StringAggregateSelection
  description: StringAggregateSelection
  id: IdAggregateSelection
  key: StringAggregateSelection
  name: StringAggregateSelection
  validationRules: StringAggregateSelection
}

export type ActionTypeFieldRefsAggregateInput = {
  AND?: InputMaybe<Array<ActionTypeFieldRefsAggregateInput>>
  NOT?: InputMaybe<ActionTypeFieldRefsAggregateInput>
  OR?: InputMaybe<Array<ActionTypeFieldRefsAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<ActionTypeFieldRefsNodeAggregationWhereInput>
}

export type ActionTypeFieldRefsConnectFieldInput = {
  connect?: InputMaybe<Array<FieldConnectInput>>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<FieldConnectWhere>
}

export type ActionTypeFieldRefsConnectOrCreateFieldInput = {
  onCreate: ActionTypeFieldRefsConnectOrCreateFieldInputOnCreate
  where: FieldConnectOrCreateWhere
}

export type ActionTypeFieldRefsConnectOrCreateFieldInputOnCreate = {
  node: FieldOnCreateInput
}

export type ActionTypeFieldRefsCreateFieldInput = {
  node: FieldCreateInput
}

export type ActionTypeFieldRefsFieldInput = {
  connect?: InputMaybe<Array<ActionTypeFieldRefsConnectFieldInput>>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<
    Array<ActionTypeFieldRefsConnectOrCreateFieldInput>
  >
  create?: InputMaybe<Array<ActionTypeFieldRefsCreateFieldInput>>
}

export type ActionTypeFieldRefsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<ActionTypeFieldRefsNodeAggregationWhereInput>>
  NOT?: InputMaybe<ActionTypeFieldRefsNodeAggregationWhereInput>
  OR?: InputMaybe<Array<ActionTypeFieldRefsNodeAggregationWhereInput>>
  defaultValues_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  defaultValues_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  description_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  description_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  key_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  key_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  validationRules_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type ActionTypeFieldRefsUpdateConnectionInput = {
  node?: InputMaybe<FieldUpdateInput>
}

export type ActionTypeFieldRefsUpdateFieldInput = {
  connect?: InputMaybe<Array<ActionTypeFieldRefsConnectFieldInput>>
  connectOrCreate?: InputMaybe<
    Array<ActionTypeFieldRefsConnectOrCreateFieldInput>
  >
  create?: InputMaybe<Array<ActionTypeFieldRefsCreateFieldInput>>
  delete?: InputMaybe<Array<IBaseTypeFieldRefsDeleteFieldInput>>
  disconnect?: InputMaybe<Array<IBaseTypeFieldRefsDisconnectFieldInput>>
  update?: InputMaybe<ActionTypeFieldRefsUpdateConnectionInput>
  where?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
}

export type ActionTypeOnCreateInput = {
  id: Scalars['ID']['input']
  kind?: TypeKind
  name: Scalars['String']['input']
}

export type ActionTypeOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  /** Specify one or more ActionTypeSort objects to sort ActionTypes by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<ActionTypeSort>>
}

export type ActionTypeOwnerAggregateInput = {
  AND?: InputMaybe<Array<ActionTypeOwnerAggregateInput>>
  NOT?: InputMaybe<ActionTypeOwnerAggregateInput>
  OR?: InputMaybe<Array<ActionTypeOwnerAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<ActionTypeOwnerNodeAggregationWhereInput>
}

export type ActionTypeOwnerConnectFieldInput = {
  connect?: InputMaybe<UserConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<UserConnectWhere>
}

export type ActionTypeOwnerConnectOrCreateFieldInput = {
  onCreate: ActionTypeOwnerConnectOrCreateFieldInputOnCreate
  where: UserConnectOrCreateWhere
}

export type ActionTypeOwnerConnectOrCreateFieldInputOnCreate = {
  node: UserOnCreateInput
}

export type ActionTypeOwnerCreateFieldInput = {
  node: UserCreateInput
}

export type ActionTypeOwnerFieldInput = {
  connect?: InputMaybe<ActionTypeOwnerConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<ActionTypeOwnerConnectOrCreateFieldInput>
  create?: InputMaybe<ActionTypeOwnerCreateFieldInput>
}

export type ActionTypeOwnerNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<ActionTypeOwnerNodeAggregationWhereInput>>
  NOT?: InputMaybe<ActionTypeOwnerNodeAggregationWhereInput>
  OR?: InputMaybe<Array<ActionTypeOwnerNodeAggregationWhereInput>>
  auth0Id_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  auth0Id_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  email_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  email_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  username_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  username_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type ActionTypeOwnerUpdateConnectionInput = {
  node?: InputMaybe<UserUpdateInput>
}

export type ActionTypeOwnerUpdateFieldInput = {
  connect?: InputMaybe<ActionTypeOwnerConnectFieldInput>
  connectOrCreate?: InputMaybe<ActionTypeOwnerConnectOrCreateFieldInput>
  create?: InputMaybe<ActionTypeOwnerCreateFieldInput>
  delete?: InputMaybe<IBaseTypeOwnerDeleteFieldInput>
  disconnect?: InputMaybe<IBaseTypeOwnerDisconnectFieldInput>
  update?: InputMaybe<ActionTypeOwnerUpdateConnectionInput>
  where?: InputMaybe<IBaseTypeOwnerConnectionWhere>
}

/** Fields to sort ActionTypes by. The order in which sorts are applied is not guaranteed when specifying many fields in one ActionTypeSort object. */
export type ActionTypeSort = {
  id?: InputMaybe<SortDirection>
  kind?: InputMaybe<SortDirection>
  name?: InputMaybe<SortDirection>
}

export type ActionTypeSubscriptionWhere = {
  AND?: InputMaybe<Array<ActionTypeSubscriptionWhere>>
  NOT?: InputMaybe<ActionTypeSubscriptionWhere>
  OR?: InputMaybe<Array<ActionTypeSubscriptionWhere>>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  kind?: InputMaybe<TypeKind>
  kind_EQ?: InputMaybe<TypeKind>
  kind_IN?: InputMaybe<Array<TypeKind>>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>
  name_MATCHES?: InputMaybe<Scalars['String']['input']>
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
}

export type ActionTypeUniqueWhere = {
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
}

export type ActionTypeUpdateInput = {
  fieldRefs?: InputMaybe<Array<ActionTypeFieldRefsUpdateFieldInput>>
  /** @deprecated Please use the explicit _SET field */
  id?: InputMaybe<Scalars['ID']['input']>
  id_SET?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _SET field */
  kind?: InputMaybe<TypeKind>
  kind_SET?: InputMaybe<TypeKind>
  /** @deprecated Please use the explicit _SET field */
  name?: InputMaybe<Scalars['String']['input']>
  name_SET?: InputMaybe<Scalars['String']['input']>
  owner?: InputMaybe<ActionTypeOwnerUpdateFieldInput>
}

export type ActionTypeUpdatedEvent = {
  event: EventType
  previousState: ActionTypeEventPayload
  timestamp: Scalars['Float']['output']
  updatedActionType: ActionTypeEventPayload
}

export type ActionTypeUserOwnerAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<ActionTypeUserOwnerNodeAggregateSelection>
}

export type ActionTypeUserOwnerNodeAggregateSelection = {
  auth0Id: StringAggregateSelection
  email: StringAggregateSelection
  id: IdAggregateSelection
  username: StringAggregateSelection
}

export type ActionTypeWhere = {
  AND?: InputMaybe<Array<ActionTypeWhere>>
  NOT?: InputMaybe<ActionTypeWhere>
  OR?: InputMaybe<Array<ActionTypeWhere>>
  fieldRefsAggregate?: InputMaybe<ActionTypeFieldRefsAggregateInput>
  /** Return ActionTypes where all of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_ALL?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return ActionTypes where none of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_NONE?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return ActionTypes where one of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_SINGLE?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return ActionTypes where some of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_SOME?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return ActionTypes where all of the related Fields match this filter */
  fieldRefs_ALL?: InputMaybe<FieldWhere>
  /** Return ActionTypes where none of the related Fields match this filter */
  fieldRefs_NONE?: InputMaybe<FieldWhere>
  /** Return ActionTypes where one of the related Fields match this filter */
  fieldRefs_SINGLE?: InputMaybe<FieldWhere>
  /** Return ActionTypes where some of the related Fields match this filter */
  fieldRefs_SOME?: InputMaybe<FieldWhere>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  kind?: InputMaybe<TypeKind>
  kind_EQ?: InputMaybe<TypeKind>
  kind_IN?: InputMaybe<Array<TypeKind>>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>
  name_MATCHES?: InputMaybe<Scalars['String']['input']>
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  owner?: InputMaybe<UserWhere>
  ownerAggregate?: InputMaybe<ActionTypeOwnerAggregateInput>
  ownerConnection?: InputMaybe<IBaseTypeOwnerConnectionWhere>
}

export type ActionTypesConnection = {
  edges: Array<ActionTypeEdge>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type AnyAction = ApiAction | CodeAction

export type AnyActionWhere = {
  ApiAction?: InputMaybe<ApiActionWhere>
  CodeAction?: InputMaybe<CodeActionWhere>
}

export type AnyType =
  | ActionType
  | AppType
  | ArrayType
  | CodeMirrorType
  | ElementType
  | EnumType
  | InterfaceType
  | LambdaType
  | PageType
  | PrimitiveType
  | ReactNodeType
  | RenderPropType
  | RichTextType
  | UnionType

export type AnyTypeWhere = {
  ActionType?: InputMaybe<ActionTypeWhere>
  AppType?: InputMaybe<AppTypeWhere>
  ArrayType?: InputMaybe<ArrayTypeWhere>
  CodeMirrorType?: InputMaybe<CodeMirrorTypeWhere>
  ElementType?: InputMaybe<ElementTypeWhere>
  EnumType?: InputMaybe<EnumTypeWhere>
  InterfaceType?: InputMaybe<InterfaceTypeWhere>
  LambdaType?: InputMaybe<LambdaTypeWhere>
  PageType?: InputMaybe<PageTypeWhere>
  PrimitiveType?: InputMaybe<PrimitiveTypeWhere>
  ReactNodeType?: InputMaybe<ReactNodeTypeWhere>
  RenderPropType?: InputMaybe<RenderPropTypeWhere>
  RichTextType?: InputMaybe<RichTextTypeWhere>
  UnionType?: InputMaybe<UnionTypeWhere>
}

export type ApiAction = BaseAction & {
  config: Prop
  configAggregate?: Maybe<ApiActionPropConfigAggregationSelection>
  configConnection: ApiActionConfigConnection
  errorAction?: Maybe<AnyAction>
  errorActionConnection: ApiActionErrorActionConnection
  id: Scalars['ID']['output']
  name: Scalars['String']['output']
  postRenderElement?: Maybe<Element>
  postRenderElementAggregate?: Maybe<ApiActionElementPostRenderElementAggregationSelection>
  postRenderElementConnection: BaseActionPostRenderElementConnection
  preRenderElement?: Maybe<Element>
  preRenderElementAggregate?: Maybe<ApiActionElementPreRenderElementAggregationSelection>
  preRenderElementConnection: BaseActionPreRenderElementConnection
  /** Resource to fetch data from */
  resource: Resource
  resourceAggregate?: Maybe<ApiActionResourceResourceAggregationSelection>
  resourceConnection: ApiActionResourceConnection
  store: Store
  storeAggregate?: Maybe<ApiActionStoreStoreAggregationSelection>
  storeConnection: BaseActionStoreConnection
  /** Response handlers */
  successAction?: Maybe<AnyAction>
  successActionConnection: ApiActionSuccessActionConnection
  type: ActionKind
}

export type ApiActionConfigArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<PropOptions>
  sort?: InputMaybe<Array<PropSort>>
  where?: InputMaybe<PropWhere>
}

export type ApiActionConfigAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<PropWhere>
}

export type ApiActionConfigConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<ApiActionConfigConnectionSort>>
  where?: InputMaybe<ApiActionConfigConnectionWhere>
}

export type ApiActionErrorActionArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<QueryOptions>
  where?: InputMaybe<AnyActionWhere>
}

export type ApiActionErrorActionConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  where?: InputMaybe<ApiActionErrorActionConnectionWhere>
}

export type ApiActionPostRenderElementArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<ElementOptions>
  sort?: InputMaybe<Array<ElementSort>>
  where?: InputMaybe<ElementWhere>
}

export type ApiActionPostRenderElementAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<ElementWhere>
}

export type ApiActionPostRenderElementConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<BaseActionPostRenderElementConnectionSort>>
  where?: InputMaybe<BaseActionPostRenderElementConnectionWhere>
}

export type ApiActionPreRenderElementArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<ElementOptions>
  sort?: InputMaybe<Array<ElementSort>>
  where?: InputMaybe<ElementWhere>
}

export type ApiActionPreRenderElementAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<ElementWhere>
}

export type ApiActionPreRenderElementConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<BaseActionPreRenderElementConnectionSort>>
  where?: InputMaybe<BaseActionPreRenderElementConnectionWhere>
}

export type ApiActionResourceArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<ResourceOptions>
  sort?: InputMaybe<Array<ResourceSort>>
  where?: InputMaybe<ResourceWhere>
}

export type ApiActionResourceAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<ResourceWhere>
}

export type ApiActionResourceConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<ApiActionResourceConnectionSort>>
  where?: InputMaybe<ApiActionResourceConnectionWhere>
}

export type ApiActionStoreArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<StoreOptions>
  sort?: InputMaybe<Array<StoreSort>>
  where?: InputMaybe<StoreWhere>
}

export type ApiActionStoreAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<StoreWhere>
}

export type ApiActionStoreConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<BaseActionStoreConnectionSort>>
  where?: InputMaybe<BaseActionStoreConnectionWhere>
}

export type ApiActionSuccessActionArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<QueryOptions>
  where?: InputMaybe<AnyActionWhere>
}

export type ApiActionSuccessActionConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  where?: InputMaybe<ApiActionSuccessActionConnectionWhere>
}

export type ApiActionAggregateSelection = {
  count: Scalars['Int']['output']
  id: IdAggregateSelection
  name: StringAggregateSelection
}

export type ApiActionConfigAggregateInput = {
  AND?: InputMaybe<Array<ApiActionConfigAggregateInput>>
  NOT?: InputMaybe<ApiActionConfigAggregateInput>
  OR?: InputMaybe<Array<ApiActionConfigAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<ApiActionConfigNodeAggregationWhereInput>
}

export type ApiActionConfigConnectFieldInput = {
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<PropConnectWhere>
}

export type ApiActionConfigConnectOrCreateFieldInput = {
  onCreate: ApiActionConfigConnectOrCreateFieldInputOnCreate
  where: PropConnectOrCreateWhere
}

export type ApiActionConfigConnectOrCreateFieldInputOnCreate = {
  node: PropOnCreateInput
}

export type ApiActionConfigConnection = {
  edges: Array<ApiActionConfigRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type ApiActionConfigConnectionSort = {
  node?: InputMaybe<PropSort>
}

export type ApiActionConfigConnectionWhere = {
  AND?: InputMaybe<Array<ApiActionConfigConnectionWhere>>
  NOT?: InputMaybe<ApiActionConfigConnectionWhere>
  OR?: InputMaybe<Array<ApiActionConfigConnectionWhere>>
  node?: InputMaybe<PropWhere>
}

export type ApiActionConfigCreateFieldInput = {
  node: PropCreateInput
}

export type ApiActionConfigDeleteFieldInput = {
  where?: InputMaybe<ApiActionConfigConnectionWhere>
}

export type ApiActionConfigDisconnectFieldInput = {
  where?: InputMaybe<ApiActionConfigConnectionWhere>
}

export type ApiActionConfigFieldInput = {
  connect?: InputMaybe<ApiActionConfigConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<ApiActionConfigConnectOrCreateFieldInput>
  create?: InputMaybe<ApiActionConfigCreateFieldInput>
}

export type ApiActionConfigNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<ApiActionConfigNodeAggregationWhereInput>>
  NOT?: InputMaybe<ApiActionConfigNodeAggregationWhereInput>
  OR?: InputMaybe<Array<ApiActionConfigNodeAggregationWhereInput>>
  data_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  data_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  data_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  data_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  data_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  data_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  data_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  data_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  data_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  data_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  data_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  data_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  data_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  data_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  data_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
}

export type ApiActionConfigRelationship = {
  cursor: Scalars['String']['output']
  node: Prop
}

export type ApiActionConfigUpdateConnectionInput = {
  node?: InputMaybe<PropUpdateInput>
}

export type ApiActionConfigUpdateFieldInput = {
  connect?: InputMaybe<ApiActionConfigConnectFieldInput>
  connectOrCreate?: InputMaybe<ApiActionConfigConnectOrCreateFieldInput>
  create?: InputMaybe<ApiActionConfigCreateFieldInput>
  delete?: InputMaybe<ApiActionConfigDeleteFieldInput>
  disconnect?: InputMaybe<ApiActionConfigDisconnectFieldInput>
  update?: InputMaybe<ApiActionConfigUpdateConnectionInput>
  where?: InputMaybe<ApiActionConfigConnectionWhere>
}

export type ApiActionConnectInput = {
  config?: InputMaybe<ApiActionConfigConnectFieldInput>
  errorAction?: InputMaybe<ApiActionErrorActionConnectInput>
  postRenderElement?: InputMaybe<ApiActionPostRenderElementConnectFieldInput>
  preRenderElement?: InputMaybe<ApiActionPreRenderElementConnectFieldInput>
  resource?: InputMaybe<ApiActionResourceConnectFieldInput>
  store?: InputMaybe<ApiActionStoreConnectFieldInput>
  successAction?: InputMaybe<ApiActionSuccessActionConnectInput>
}

export type ApiActionConnectWhere = {
  node: ApiActionWhere
}

export type ApiActionCreateInput = {
  config?: InputMaybe<ApiActionConfigFieldInput>
  errorAction?: InputMaybe<ApiActionErrorActionCreateInput>
  id: Scalars['ID']['input']
  name: Scalars['String']['input']
  postRenderElement?: InputMaybe<ApiActionPostRenderElementFieldInput>
  preRenderElement?: InputMaybe<ApiActionPreRenderElementFieldInput>
  resource?: InputMaybe<ApiActionResourceFieldInput>
  store?: InputMaybe<ApiActionStoreFieldInput>
  successAction?: InputMaybe<ApiActionSuccessActionCreateInput>
  type?: ActionKind
}

export type ApiActionCreatedEvent = {
  createdApiAction: ApiActionEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type ApiActionDeleteInput = {
  config?: InputMaybe<ApiActionConfigDeleteFieldInput>
  errorAction?: InputMaybe<ApiActionErrorActionDeleteInput>
  postRenderElement?: InputMaybe<BaseActionPostRenderElementDeleteFieldInput>
  preRenderElement?: InputMaybe<BaseActionPreRenderElementDeleteFieldInput>
  resource?: InputMaybe<ApiActionResourceDeleteFieldInput>
  store?: InputMaybe<BaseActionStoreDeleteFieldInput>
  successAction?: InputMaybe<ApiActionSuccessActionDeleteInput>
}

export type ApiActionDeletedEvent = {
  deletedApiAction: ApiActionEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type ApiActionDisconnectInput = {
  config?: InputMaybe<ApiActionConfigDisconnectFieldInput>
  errorAction?: InputMaybe<ApiActionErrorActionDisconnectInput>
  postRenderElement?: InputMaybe<BaseActionPostRenderElementDisconnectFieldInput>
  preRenderElement?: InputMaybe<BaseActionPreRenderElementDisconnectFieldInput>
  resource?: InputMaybe<ApiActionResourceDisconnectFieldInput>
  store?: InputMaybe<BaseActionStoreDisconnectFieldInput>
  successAction?: InputMaybe<ApiActionSuccessActionDisconnectInput>
}

export type ApiActionEdge = {
  cursor: Scalars['String']['output']
  node: ApiAction
}

export type ApiActionElementPostRenderElementAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<ApiActionElementPostRenderElementNodeAggregateSelection>
}

export type ApiActionElementPostRenderElementNodeAggregateSelection = {
  childMapperPropKey: StringAggregateSelection
  compositeKey: StringAggregateSelection
  id: IdAggregateSelection
  renderForEachPropKey: StringAggregateSelection
  renderIfExpression: StringAggregateSelection
  style: StringAggregateSelection
}

export type ApiActionElementPreRenderElementAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<ApiActionElementPreRenderElementNodeAggregateSelection>
}

export type ApiActionElementPreRenderElementNodeAggregateSelection = {
  childMapperPropKey: StringAggregateSelection
  compositeKey: StringAggregateSelection
  id: IdAggregateSelection
  renderForEachPropKey: StringAggregateSelection
  renderIfExpression: StringAggregateSelection
  style: StringAggregateSelection
}

export type ApiActionErrorActionApiActionConnectFieldInput = {
  connect?: InputMaybe<ApiActionConnectInput>
  where?: InputMaybe<ApiActionConnectWhere>
}

export type ApiActionErrorActionApiActionConnectionWhere = {
  AND?: InputMaybe<Array<ApiActionErrorActionApiActionConnectionWhere>>
  NOT?: InputMaybe<ApiActionErrorActionApiActionConnectionWhere>
  OR?: InputMaybe<Array<ApiActionErrorActionApiActionConnectionWhere>>
  node?: InputMaybe<ApiActionWhere>
}

export type ApiActionErrorActionApiActionCreateFieldInput = {
  node: ApiActionCreateInput
}

export type ApiActionErrorActionApiActionDeleteFieldInput = {
  delete?: InputMaybe<ApiActionDeleteInput>
  where?: InputMaybe<ApiActionErrorActionApiActionConnectionWhere>
}

export type ApiActionErrorActionApiActionDisconnectFieldInput = {
  disconnect?: InputMaybe<ApiActionDisconnectInput>
  where?: InputMaybe<ApiActionErrorActionApiActionConnectionWhere>
}

export type ApiActionErrorActionApiActionFieldInput = {
  connect?: InputMaybe<ApiActionErrorActionApiActionConnectFieldInput>
  create?: InputMaybe<ApiActionErrorActionApiActionCreateFieldInput>
}

export type ApiActionErrorActionApiActionUpdateConnectionInput = {
  node?: InputMaybe<ApiActionUpdateInput>
}

export type ApiActionErrorActionApiActionUpdateFieldInput = {
  connect?: InputMaybe<ApiActionErrorActionApiActionConnectFieldInput>
  create?: InputMaybe<ApiActionErrorActionApiActionCreateFieldInput>
  delete?: InputMaybe<ApiActionErrorActionApiActionDeleteFieldInput>
  disconnect?: InputMaybe<ApiActionErrorActionApiActionDisconnectFieldInput>
  update?: InputMaybe<ApiActionErrorActionApiActionUpdateConnectionInput>
  where?: InputMaybe<ApiActionErrorActionApiActionConnectionWhere>
}

export type ApiActionErrorActionCodeActionConnectFieldInput = {
  connect?: InputMaybe<CodeActionConnectInput>
  where?: InputMaybe<CodeActionConnectWhere>
}

export type ApiActionErrorActionCodeActionConnectionWhere = {
  AND?: InputMaybe<Array<ApiActionErrorActionCodeActionConnectionWhere>>
  NOT?: InputMaybe<ApiActionErrorActionCodeActionConnectionWhere>
  OR?: InputMaybe<Array<ApiActionErrorActionCodeActionConnectionWhere>>
  node?: InputMaybe<CodeActionWhere>
}

export type ApiActionErrorActionCodeActionCreateFieldInput = {
  node: CodeActionCreateInput
}

export type ApiActionErrorActionCodeActionDeleteFieldInput = {
  delete?: InputMaybe<CodeActionDeleteInput>
  where?: InputMaybe<ApiActionErrorActionCodeActionConnectionWhere>
}

export type ApiActionErrorActionCodeActionDisconnectFieldInput = {
  disconnect?: InputMaybe<CodeActionDisconnectInput>
  where?: InputMaybe<ApiActionErrorActionCodeActionConnectionWhere>
}

export type ApiActionErrorActionCodeActionFieldInput = {
  connect?: InputMaybe<ApiActionErrorActionCodeActionConnectFieldInput>
  create?: InputMaybe<ApiActionErrorActionCodeActionCreateFieldInput>
}

export type ApiActionErrorActionCodeActionUpdateConnectionInput = {
  node?: InputMaybe<CodeActionUpdateInput>
}

export type ApiActionErrorActionCodeActionUpdateFieldInput = {
  connect?: InputMaybe<ApiActionErrorActionCodeActionConnectFieldInput>
  create?: InputMaybe<ApiActionErrorActionCodeActionCreateFieldInput>
  delete?: InputMaybe<ApiActionErrorActionCodeActionDeleteFieldInput>
  disconnect?: InputMaybe<ApiActionErrorActionCodeActionDisconnectFieldInput>
  update?: InputMaybe<ApiActionErrorActionCodeActionUpdateConnectionInput>
  where?: InputMaybe<ApiActionErrorActionCodeActionConnectionWhere>
}

export type ApiActionErrorActionConnectInput = {
  ApiAction?: InputMaybe<ApiActionErrorActionApiActionConnectFieldInput>
  CodeAction?: InputMaybe<ApiActionErrorActionCodeActionConnectFieldInput>
}

export type ApiActionErrorActionConnection = {
  edges: Array<ApiActionErrorActionRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type ApiActionErrorActionConnectionWhere = {
  ApiAction?: InputMaybe<ApiActionErrorActionApiActionConnectionWhere>
  CodeAction?: InputMaybe<ApiActionErrorActionCodeActionConnectionWhere>
}

export type ApiActionErrorActionCreateInput = {
  ApiAction?: InputMaybe<ApiActionErrorActionApiActionFieldInput>
  CodeAction?: InputMaybe<ApiActionErrorActionCodeActionFieldInput>
}

export type ApiActionErrorActionDeleteInput = {
  ApiAction?: InputMaybe<ApiActionErrorActionApiActionDeleteFieldInput>
  CodeAction?: InputMaybe<ApiActionErrorActionCodeActionDeleteFieldInput>
}

export type ApiActionErrorActionDisconnectInput = {
  ApiAction?: InputMaybe<ApiActionErrorActionApiActionDisconnectFieldInput>
  CodeAction?: InputMaybe<ApiActionErrorActionCodeActionDisconnectFieldInput>
}

export type ApiActionErrorActionRelationship = {
  cursor: Scalars['String']['output']
  node: AnyAction
}

export type ApiActionErrorActionUpdateInput = {
  ApiAction?: InputMaybe<ApiActionErrorActionApiActionUpdateFieldInput>
  CodeAction?: InputMaybe<ApiActionErrorActionCodeActionUpdateFieldInput>
}

export type ApiActionEventPayload = {
  id: Scalars['ID']['output']
  name: Scalars['String']['output']
  type: ActionKind
}

export type ApiActionOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  /** Specify one or more ApiActionSort objects to sort ApiActions by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<ApiActionSort>>
}

export type ApiActionPostRenderElementAggregateInput = {
  AND?: InputMaybe<Array<ApiActionPostRenderElementAggregateInput>>
  NOT?: InputMaybe<ApiActionPostRenderElementAggregateInput>
  OR?: InputMaybe<Array<ApiActionPostRenderElementAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<ApiActionPostRenderElementNodeAggregationWhereInput>
}

export type ApiActionPostRenderElementConnectFieldInput = {
  connect?: InputMaybe<ElementConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<ElementConnectWhere>
}

export type ApiActionPostRenderElementConnectOrCreateFieldInput = {
  onCreate: ApiActionPostRenderElementConnectOrCreateFieldInputOnCreate
  where: ElementConnectOrCreateWhere
}

export type ApiActionPostRenderElementConnectOrCreateFieldInputOnCreate = {
  node: ElementOnCreateInput
}

export type ApiActionPostRenderElementCreateFieldInput = {
  node: ElementCreateInput
}

export type ApiActionPostRenderElementFieldInput = {
  connect?: InputMaybe<ApiActionPostRenderElementConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<ApiActionPostRenderElementConnectOrCreateFieldInput>
  create?: InputMaybe<ApiActionPostRenderElementCreateFieldInput>
}

export type ApiActionPostRenderElementNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<ApiActionPostRenderElementNodeAggregationWhereInput>>
  NOT?: InputMaybe<ApiActionPostRenderElementNodeAggregationWhereInput>
  OR?: InputMaybe<Array<ApiActionPostRenderElementNodeAggregationWhereInput>>
  childMapperPropKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  childMapperPropKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_GTE?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_LTE?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_LONGEST_LENGTH_EQUAL?: InputMaybe<
    Scalars['Int']['input']
  >
  renderForEachPropKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<
    Scalars['Int']['input']
  >
  renderForEachPropKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  renderIfExpression_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  style_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  style_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type ApiActionPostRenderElementUpdateConnectionInput = {
  node?: InputMaybe<ElementUpdateInput>
}

export type ApiActionPostRenderElementUpdateFieldInput = {
  connect?: InputMaybe<ApiActionPostRenderElementConnectFieldInput>
  connectOrCreate?: InputMaybe<ApiActionPostRenderElementConnectOrCreateFieldInput>
  create?: InputMaybe<ApiActionPostRenderElementCreateFieldInput>
  delete?: InputMaybe<BaseActionPostRenderElementDeleteFieldInput>
  disconnect?: InputMaybe<BaseActionPostRenderElementDisconnectFieldInput>
  update?: InputMaybe<ApiActionPostRenderElementUpdateConnectionInput>
  where?: InputMaybe<BaseActionPostRenderElementConnectionWhere>
}

export type ApiActionPreRenderElementAggregateInput = {
  AND?: InputMaybe<Array<ApiActionPreRenderElementAggregateInput>>
  NOT?: InputMaybe<ApiActionPreRenderElementAggregateInput>
  OR?: InputMaybe<Array<ApiActionPreRenderElementAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<ApiActionPreRenderElementNodeAggregationWhereInput>
}

export type ApiActionPreRenderElementConnectFieldInput = {
  connect?: InputMaybe<ElementConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<ElementConnectWhere>
}

export type ApiActionPreRenderElementConnectOrCreateFieldInput = {
  onCreate: ApiActionPreRenderElementConnectOrCreateFieldInputOnCreate
  where: ElementConnectOrCreateWhere
}

export type ApiActionPreRenderElementConnectOrCreateFieldInputOnCreate = {
  node: ElementOnCreateInput
}

export type ApiActionPreRenderElementCreateFieldInput = {
  node: ElementCreateInput
}

export type ApiActionPreRenderElementFieldInput = {
  connect?: InputMaybe<ApiActionPreRenderElementConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<ApiActionPreRenderElementConnectOrCreateFieldInput>
  create?: InputMaybe<ApiActionPreRenderElementCreateFieldInput>
}

export type ApiActionPreRenderElementNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<ApiActionPreRenderElementNodeAggregationWhereInput>>
  NOT?: InputMaybe<ApiActionPreRenderElementNodeAggregationWhereInput>
  OR?: InputMaybe<Array<ApiActionPreRenderElementNodeAggregationWhereInput>>
  childMapperPropKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  childMapperPropKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_GTE?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_LTE?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_LONGEST_LENGTH_EQUAL?: InputMaybe<
    Scalars['Int']['input']
  >
  renderForEachPropKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<
    Scalars['Int']['input']
  >
  renderForEachPropKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  renderIfExpression_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  style_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  style_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type ApiActionPreRenderElementUpdateConnectionInput = {
  node?: InputMaybe<ElementUpdateInput>
}

export type ApiActionPreRenderElementUpdateFieldInput = {
  connect?: InputMaybe<ApiActionPreRenderElementConnectFieldInput>
  connectOrCreate?: InputMaybe<ApiActionPreRenderElementConnectOrCreateFieldInput>
  create?: InputMaybe<ApiActionPreRenderElementCreateFieldInput>
  delete?: InputMaybe<BaseActionPreRenderElementDeleteFieldInput>
  disconnect?: InputMaybe<BaseActionPreRenderElementDisconnectFieldInput>
  update?: InputMaybe<ApiActionPreRenderElementUpdateConnectionInput>
  where?: InputMaybe<BaseActionPreRenderElementConnectionWhere>
}

export type ApiActionPropConfigAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<ApiActionPropConfigNodeAggregateSelection>
}

export type ApiActionPropConfigNodeAggregateSelection = {
  data: StringAggregateSelection
  id: IdAggregateSelection
}

export type ApiActionResourceAggregateInput = {
  AND?: InputMaybe<Array<ApiActionResourceAggregateInput>>
  NOT?: InputMaybe<ApiActionResourceAggregateInput>
  OR?: InputMaybe<Array<ApiActionResourceAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<ApiActionResourceNodeAggregationWhereInput>
}

export type ApiActionResourceConnectFieldInput = {
  connect?: InputMaybe<ResourceConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<ResourceConnectWhere>
}

export type ApiActionResourceConnectOrCreateFieldInput = {
  onCreate: ApiActionResourceConnectOrCreateFieldInputOnCreate
  where: ResourceConnectOrCreateWhere
}

export type ApiActionResourceConnectOrCreateFieldInputOnCreate = {
  node: ResourceOnCreateInput
}

export type ApiActionResourceConnection = {
  edges: Array<ApiActionResourceRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type ApiActionResourceConnectionSort = {
  node?: InputMaybe<ResourceSort>
}

export type ApiActionResourceConnectionWhere = {
  AND?: InputMaybe<Array<ApiActionResourceConnectionWhere>>
  NOT?: InputMaybe<ApiActionResourceConnectionWhere>
  OR?: InputMaybe<Array<ApiActionResourceConnectionWhere>>
  node?: InputMaybe<ResourceWhere>
}

export type ApiActionResourceCreateFieldInput = {
  node: ResourceCreateInput
}

export type ApiActionResourceDeleteFieldInput = {
  delete?: InputMaybe<ResourceDeleteInput>
  where?: InputMaybe<ApiActionResourceConnectionWhere>
}

export type ApiActionResourceDisconnectFieldInput = {
  disconnect?: InputMaybe<ResourceDisconnectInput>
  where?: InputMaybe<ApiActionResourceConnectionWhere>
}

export type ApiActionResourceFieldInput = {
  connect?: InputMaybe<ApiActionResourceConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<ApiActionResourceConnectOrCreateFieldInput>
  create?: InputMaybe<ApiActionResourceCreateFieldInput>
}

export type ApiActionResourceNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<ApiActionResourceNodeAggregationWhereInput>>
  NOT?: InputMaybe<ApiActionResourceNodeAggregationWhereInput>
  OR?: InputMaybe<Array<ApiActionResourceNodeAggregationWhereInput>>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type ApiActionResourceRelationship = {
  cursor: Scalars['String']['output']
  node: Resource
}

export type ApiActionResourceResourceAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<ApiActionResourceResourceNodeAggregateSelection>
}

export type ApiActionResourceResourceNodeAggregateSelection = {
  id: IdAggregateSelection
  name: StringAggregateSelection
}

export type ApiActionResourceUpdateConnectionInput = {
  node?: InputMaybe<ResourceUpdateInput>
}

export type ApiActionResourceUpdateFieldInput = {
  connect?: InputMaybe<ApiActionResourceConnectFieldInput>
  connectOrCreate?: InputMaybe<ApiActionResourceConnectOrCreateFieldInput>
  create?: InputMaybe<ApiActionResourceCreateFieldInput>
  delete?: InputMaybe<ApiActionResourceDeleteFieldInput>
  disconnect?: InputMaybe<ApiActionResourceDisconnectFieldInput>
  update?: InputMaybe<ApiActionResourceUpdateConnectionInput>
  where?: InputMaybe<ApiActionResourceConnectionWhere>
}

/** Fields to sort ApiActions by. The order in which sorts are applied is not guaranteed when specifying many fields in one ApiActionSort object. */
export type ApiActionSort = {
  id?: InputMaybe<SortDirection>
  name?: InputMaybe<SortDirection>
  type?: InputMaybe<SortDirection>
}

export type ApiActionStoreAggregateInput = {
  AND?: InputMaybe<Array<ApiActionStoreAggregateInput>>
  NOT?: InputMaybe<ApiActionStoreAggregateInput>
  OR?: InputMaybe<Array<ApiActionStoreAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<ApiActionStoreNodeAggregationWhereInput>
}

export type ApiActionStoreConnectFieldInput = {
  connect?: InputMaybe<StoreConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<StoreConnectWhere>
}

export type ApiActionStoreConnectOrCreateFieldInput = {
  onCreate: ApiActionStoreConnectOrCreateFieldInputOnCreate
  where: StoreConnectOrCreateWhere
}

export type ApiActionStoreConnectOrCreateFieldInputOnCreate = {
  node: StoreOnCreateInput
}

export type ApiActionStoreCreateFieldInput = {
  node: StoreCreateInput
}

export type ApiActionStoreFieldInput = {
  connect?: InputMaybe<ApiActionStoreConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<ApiActionStoreConnectOrCreateFieldInput>
  create?: InputMaybe<ApiActionStoreCreateFieldInput>
}

export type ApiActionStoreNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<ApiActionStoreNodeAggregationWhereInput>>
  NOT?: InputMaybe<ApiActionStoreNodeAggregationWhereInput>
  OR?: InputMaybe<Array<ApiActionStoreNodeAggregationWhereInput>>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type ApiActionStoreStoreAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<ApiActionStoreStoreNodeAggregateSelection>
}

export type ApiActionStoreStoreNodeAggregateSelection = {
  id: IdAggregateSelection
  name: StringAggregateSelection
}

export type ApiActionStoreUpdateConnectionInput = {
  node?: InputMaybe<StoreUpdateInput>
}

export type ApiActionStoreUpdateFieldInput = {
  connect?: InputMaybe<ApiActionStoreConnectFieldInput>
  connectOrCreate?: InputMaybe<ApiActionStoreConnectOrCreateFieldInput>
  create?: InputMaybe<ApiActionStoreCreateFieldInput>
  delete?: InputMaybe<BaseActionStoreDeleteFieldInput>
  disconnect?: InputMaybe<BaseActionStoreDisconnectFieldInput>
  update?: InputMaybe<ApiActionStoreUpdateConnectionInput>
  where?: InputMaybe<BaseActionStoreConnectionWhere>
}

export type ApiActionSubscriptionWhere = {
  AND?: InputMaybe<Array<ApiActionSubscriptionWhere>>
  NOT?: InputMaybe<ApiActionSubscriptionWhere>
  OR?: InputMaybe<Array<ApiActionSubscriptionWhere>>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>
  name_MATCHES?: InputMaybe<Scalars['String']['input']>
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  type?: InputMaybe<ActionKind>
  type_EQ?: InputMaybe<ActionKind>
  type_IN?: InputMaybe<Array<ActionKind>>
}

export type ApiActionSuccessActionApiActionConnectFieldInput = {
  connect?: InputMaybe<ApiActionConnectInput>
  where?: InputMaybe<ApiActionConnectWhere>
}

export type ApiActionSuccessActionApiActionConnectionWhere = {
  AND?: InputMaybe<Array<ApiActionSuccessActionApiActionConnectionWhere>>
  NOT?: InputMaybe<ApiActionSuccessActionApiActionConnectionWhere>
  OR?: InputMaybe<Array<ApiActionSuccessActionApiActionConnectionWhere>>
  node?: InputMaybe<ApiActionWhere>
}

export type ApiActionSuccessActionApiActionCreateFieldInput = {
  node: ApiActionCreateInput
}

export type ApiActionSuccessActionApiActionDeleteFieldInput = {
  delete?: InputMaybe<ApiActionDeleteInput>
  where?: InputMaybe<ApiActionSuccessActionApiActionConnectionWhere>
}

export type ApiActionSuccessActionApiActionDisconnectFieldInput = {
  disconnect?: InputMaybe<ApiActionDisconnectInput>
  where?: InputMaybe<ApiActionSuccessActionApiActionConnectionWhere>
}

export type ApiActionSuccessActionApiActionFieldInput = {
  connect?: InputMaybe<ApiActionSuccessActionApiActionConnectFieldInput>
  create?: InputMaybe<ApiActionSuccessActionApiActionCreateFieldInput>
}

export type ApiActionSuccessActionApiActionUpdateConnectionInput = {
  node?: InputMaybe<ApiActionUpdateInput>
}

export type ApiActionSuccessActionApiActionUpdateFieldInput = {
  connect?: InputMaybe<ApiActionSuccessActionApiActionConnectFieldInput>
  create?: InputMaybe<ApiActionSuccessActionApiActionCreateFieldInput>
  delete?: InputMaybe<ApiActionSuccessActionApiActionDeleteFieldInput>
  disconnect?: InputMaybe<ApiActionSuccessActionApiActionDisconnectFieldInput>
  update?: InputMaybe<ApiActionSuccessActionApiActionUpdateConnectionInput>
  where?: InputMaybe<ApiActionSuccessActionApiActionConnectionWhere>
}

export type ApiActionSuccessActionCodeActionConnectFieldInput = {
  connect?: InputMaybe<CodeActionConnectInput>
  where?: InputMaybe<CodeActionConnectWhere>
}

export type ApiActionSuccessActionCodeActionConnectionWhere = {
  AND?: InputMaybe<Array<ApiActionSuccessActionCodeActionConnectionWhere>>
  NOT?: InputMaybe<ApiActionSuccessActionCodeActionConnectionWhere>
  OR?: InputMaybe<Array<ApiActionSuccessActionCodeActionConnectionWhere>>
  node?: InputMaybe<CodeActionWhere>
}

export type ApiActionSuccessActionCodeActionCreateFieldInput = {
  node: CodeActionCreateInput
}

export type ApiActionSuccessActionCodeActionDeleteFieldInput = {
  delete?: InputMaybe<CodeActionDeleteInput>
  where?: InputMaybe<ApiActionSuccessActionCodeActionConnectionWhere>
}

export type ApiActionSuccessActionCodeActionDisconnectFieldInput = {
  disconnect?: InputMaybe<CodeActionDisconnectInput>
  where?: InputMaybe<ApiActionSuccessActionCodeActionConnectionWhere>
}

export type ApiActionSuccessActionCodeActionFieldInput = {
  connect?: InputMaybe<ApiActionSuccessActionCodeActionConnectFieldInput>
  create?: InputMaybe<ApiActionSuccessActionCodeActionCreateFieldInput>
}

export type ApiActionSuccessActionCodeActionUpdateConnectionInput = {
  node?: InputMaybe<CodeActionUpdateInput>
}

export type ApiActionSuccessActionCodeActionUpdateFieldInput = {
  connect?: InputMaybe<ApiActionSuccessActionCodeActionConnectFieldInput>
  create?: InputMaybe<ApiActionSuccessActionCodeActionCreateFieldInput>
  delete?: InputMaybe<ApiActionSuccessActionCodeActionDeleteFieldInput>
  disconnect?: InputMaybe<ApiActionSuccessActionCodeActionDisconnectFieldInput>
  update?: InputMaybe<ApiActionSuccessActionCodeActionUpdateConnectionInput>
  where?: InputMaybe<ApiActionSuccessActionCodeActionConnectionWhere>
}

export type ApiActionSuccessActionConnectInput = {
  ApiAction?: InputMaybe<ApiActionSuccessActionApiActionConnectFieldInput>
  CodeAction?: InputMaybe<ApiActionSuccessActionCodeActionConnectFieldInput>
}

export type ApiActionSuccessActionConnection = {
  edges: Array<ApiActionSuccessActionRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type ApiActionSuccessActionConnectionWhere = {
  ApiAction?: InputMaybe<ApiActionSuccessActionApiActionConnectionWhere>
  CodeAction?: InputMaybe<ApiActionSuccessActionCodeActionConnectionWhere>
}

export type ApiActionSuccessActionCreateInput = {
  ApiAction?: InputMaybe<ApiActionSuccessActionApiActionFieldInput>
  CodeAction?: InputMaybe<ApiActionSuccessActionCodeActionFieldInput>
}

export type ApiActionSuccessActionDeleteInput = {
  ApiAction?: InputMaybe<ApiActionSuccessActionApiActionDeleteFieldInput>
  CodeAction?: InputMaybe<ApiActionSuccessActionCodeActionDeleteFieldInput>
}

export type ApiActionSuccessActionDisconnectInput = {
  ApiAction?: InputMaybe<ApiActionSuccessActionApiActionDisconnectFieldInput>
  CodeAction?: InputMaybe<ApiActionSuccessActionCodeActionDisconnectFieldInput>
}

export type ApiActionSuccessActionRelationship = {
  cursor: Scalars['String']['output']
  node: AnyAction
}

export type ApiActionSuccessActionUpdateInput = {
  ApiAction?: InputMaybe<ApiActionSuccessActionApiActionUpdateFieldInput>
  CodeAction?: InputMaybe<ApiActionSuccessActionCodeActionUpdateFieldInput>
}

export type ApiActionUpdateInput = {
  config?: InputMaybe<ApiActionConfigUpdateFieldInput>
  errorAction?: InputMaybe<ApiActionErrorActionUpdateInput>
  /** @deprecated Please use the explicit _SET field */
  id?: InputMaybe<Scalars['ID']['input']>
  id_SET?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _SET field */
  name?: InputMaybe<Scalars['String']['input']>
  name_SET?: InputMaybe<Scalars['String']['input']>
  postRenderElement?: InputMaybe<ApiActionPostRenderElementUpdateFieldInput>
  preRenderElement?: InputMaybe<ApiActionPreRenderElementUpdateFieldInput>
  resource?: InputMaybe<ApiActionResourceUpdateFieldInput>
  store?: InputMaybe<ApiActionStoreUpdateFieldInput>
  successAction?: InputMaybe<ApiActionSuccessActionUpdateInput>
  /** @deprecated Please use the explicit _SET field */
  type?: InputMaybe<ActionKind>
  type_SET?: InputMaybe<ActionKind>
}

export type ApiActionUpdatedEvent = {
  event: EventType
  previousState: ApiActionEventPayload
  timestamp: Scalars['Float']['output']
  updatedApiAction: ApiActionEventPayload
}

export type ApiActionWhere = {
  AND?: InputMaybe<Array<ApiActionWhere>>
  NOT?: InputMaybe<ApiActionWhere>
  OR?: InputMaybe<Array<ApiActionWhere>>
  config?: InputMaybe<PropWhere>
  configAggregate?: InputMaybe<ApiActionConfigAggregateInput>
  configConnection?: InputMaybe<ApiActionConfigConnectionWhere>
  errorAction?: InputMaybe<AnyActionWhere>
  errorActionConnection?: InputMaybe<ApiActionErrorActionConnectionWhere>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>
  name_MATCHES?: InputMaybe<Scalars['String']['input']>
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  postRenderElement?: InputMaybe<ElementWhere>
  postRenderElementAggregate?: InputMaybe<ApiActionPostRenderElementAggregateInput>
  postRenderElementConnection?: InputMaybe<BaseActionPostRenderElementConnectionWhere>
  preRenderElement?: InputMaybe<ElementWhere>
  preRenderElementAggregate?: InputMaybe<ApiActionPreRenderElementAggregateInput>
  preRenderElementConnection?: InputMaybe<BaseActionPreRenderElementConnectionWhere>
  resource?: InputMaybe<ResourceWhere>
  resourceAggregate?: InputMaybe<ApiActionResourceAggregateInput>
  resourceConnection?: InputMaybe<ApiActionResourceConnectionWhere>
  store?: InputMaybe<StoreWhere>
  storeAggregate?: InputMaybe<ApiActionStoreAggregateInput>
  storeConnection?: InputMaybe<BaseActionStoreConnectionWhere>
  successAction?: InputMaybe<AnyActionWhere>
  successActionConnection?: InputMaybe<ApiActionSuccessActionConnectionWhere>
  /** @deprecated Please use the explicit _EQ version */
  type?: InputMaybe<ActionKind>
  type_EQ?: InputMaybe<ActionKind>
  type_IN?: InputMaybe<Array<ActionKind>>
}

export type ApiActionsConnection = {
  edges: Array<ApiActionEdge>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type App = WithOwner & {
  compositeKey: Scalars['String']['output']
  domains: Array<Domain>
  domainsAggregate?: Maybe<AppDomainDomainsAggregationSelection>
  domainsConnection: AppDomainsConnection
  id: Scalars['ID']['output']
  name: Scalars['String']['output']
  owner: User
  ownerAggregate?: Maybe<AppUserOwnerAggregationSelection>
  ownerConnection: WithOwnerOwnerConnection
  pages: Array<Page>
  pagesAggregate?: Maybe<AppPagePagesAggregationSelection>
  pagesConnection: AppPagesConnection
  slug: Scalars['String']['output']
}

export type AppDomainsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<DomainOptions>
  sort?: InputMaybe<Array<DomainSort>>
  where?: InputMaybe<DomainWhere>
}

export type AppDomainsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<DomainWhere>
}

export type AppDomainsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<AppDomainsConnectionSort>>
  where?: InputMaybe<AppDomainsConnectionWhere>
}

export type AppOwnerArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<UserOptions>
  sort?: InputMaybe<Array<UserSort>>
  where?: InputMaybe<UserWhere>
}

export type AppOwnerAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<UserWhere>
}

export type AppOwnerConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<WithOwnerOwnerConnectionSort>>
  where?: InputMaybe<WithOwnerOwnerConnectionWhere>
}

export type AppPagesArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<PageOptions>
  sort?: InputMaybe<Array<PageSort>>
  where?: InputMaybe<PageWhere>
}

export type AppPagesAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<PageWhere>
}

export type AppPagesConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<AppPagesConnectionSort>>
  where?: InputMaybe<AppPagesConnectionWhere>
}

export type AppAggregateSelection = {
  compositeKey: StringAggregateSelection
  count: Scalars['Int']['output']
  id: IdAggregateSelection
}

export type AppConnectInput = {
  domains?: InputMaybe<Array<AppDomainsConnectFieldInput>>
  owner?: InputMaybe<AppOwnerConnectFieldInput>
  pages?: InputMaybe<Array<AppPagesConnectFieldInput>>
}

export type AppConnectOrCreateWhere = {
  node: AppUniqueWhere
}

export type AppConnectWhere = {
  node: AppWhere
}

export type AppCreateInput = {
  compositeKey: Scalars['String']['input']
  domains?: InputMaybe<AppDomainsFieldInput>
  id: Scalars['ID']['input']
  owner?: InputMaybe<AppOwnerFieldInput>
  pages?: InputMaybe<AppPagesFieldInput>
}

export type AppCreatedEvent = {
  createdApp: AppEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type AppDeleteInput = {
  domains?: InputMaybe<Array<AppDomainsDeleteFieldInput>>
  owner?: InputMaybe<WithOwnerOwnerDeleteFieldInput>
  pages?: InputMaybe<Array<AppPagesDeleteFieldInput>>
}

export type AppDeletedEvent = {
  deletedApp: AppEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type AppDisconnectInput = {
  domains?: InputMaybe<Array<AppDomainsDisconnectFieldInput>>
  owner?: InputMaybe<WithOwnerOwnerDisconnectFieldInput>
  pages?: InputMaybe<Array<AppPagesDisconnectFieldInput>>
}

export type AppDomainDomainsAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<AppDomainDomainsNodeAggregateSelection>
}

export type AppDomainDomainsNodeAggregateSelection = {
  id: IdAggregateSelection
  name: StringAggregateSelection
}

export type AppDomainsAggregateInput = {
  AND?: InputMaybe<Array<AppDomainsAggregateInput>>
  NOT?: InputMaybe<AppDomainsAggregateInput>
  OR?: InputMaybe<Array<AppDomainsAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<AppDomainsNodeAggregationWhereInput>
}

export type AppDomainsConnectFieldInput = {
  connect?: InputMaybe<Array<DomainConnectInput>>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<DomainConnectWhere>
}

export type AppDomainsConnectOrCreateFieldInput = {
  onCreate: AppDomainsConnectOrCreateFieldInputOnCreate
  where: DomainConnectOrCreateWhere
}

export type AppDomainsConnectOrCreateFieldInputOnCreate = {
  node: DomainOnCreateInput
}

export type AppDomainsConnection = {
  edges: Array<AppDomainsRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type AppDomainsConnectionSort = {
  node?: InputMaybe<DomainSort>
}

export type AppDomainsConnectionWhere = {
  AND?: InputMaybe<Array<AppDomainsConnectionWhere>>
  NOT?: InputMaybe<AppDomainsConnectionWhere>
  OR?: InputMaybe<Array<AppDomainsConnectionWhere>>
  node?: InputMaybe<DomainWhere>
}

export type AppDomainsCreateFieldInput = {
  node: DomainCreateInput
}

export type AppDomainsDeleteFieldInput = {
  delete?: InputMaybe<DomainDeleteInput>
  where?: InputMaybe<AppDomainsConnectionWhere>
}

export type AppDomainsDisconnectFieldInput = {
  disconnect?: InputMaybe<DomainDisconnectInput>
  where?: InputMaybe<AppDomainsConnectionWhere>
}

export type AppDomainsFieldInput = {
  connect?: InputMaybe<Array<AppDomainsConnectFieldInput>>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<Array<AppDomainsConnectOrCreateFieldInput>>
  create?: InputMaybe<Array<AppDomainsCreateFieldInput>>
}

export type AppDomainsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<AppDomainsNodeAggregationWhereInput>>
  NOT?: InputMaybe<AppDomainsNodeAggregationWhereInput>
  OR?: InputMaybe<Array<AppDomainsNodeAggregationWhereInput>>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type AppDomainsRelationship = {
  cursor: Scalars['String']['output']
  node: Domain
}

export type AppDomainsUpdateConnectionInput = {
  node?: InputMaybe<DomainUpdateInput>
}

export type AppDomainsUpdateFieldInput = {
  connect?: InputMaybe<Array<AppDomainsConnectFieldInput>>
  connectOrCreate?: InputMaybe<Array<AppDomainsConnectOrCreateFieldInput>>
  create?: InputMaybe<Array<AppDomainsCreateFieldInput>>
  delete?: InputMaybe<Array<AppDomainsDeleteFieldInput>>
  disconnect?: InputMaybe<Array<AppDomainsDisconnectFieldInput>>
  update?: InputMaybe<AppDomainsUpdateConnectionInput>
  where?: InputMaybe<AppDomainsConnectionWhere>
}

export type AppEdge = {
  cursor: Scalars['String']['output']
  node: App
}

export type AppEventPayload = {
  compositeKey: Scalars['String']['output']
  id: Scalars['ID']['output']
}

export type AppOnCreateInput = {
  compositeKey: Scalars['String']['input']
  id: Scalars['ID']['input']
}

export type AppOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  /** Specify one or more AppSort objects to sort Apps by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<AppSort>>
}

export type AppOwnerAggregateInput = {
  AND?: InputMaybe<Array<AppOwnerAggregateInput>>
  NOT?: InputMaybe<AppOwnerAggregateInput>
  OR?: InputMaybe<Array<AppOwnerAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<AppOwnerNodeAggregationWhereInput>
}

export type AppOwnerConnectFieldInput = {
  connect?: InputMaybe<UserConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<UserConnectWhere>
}

export type AppOwnerConnectOrCreateFieldInput = {
  onCreate: AppOwnerConnectOrCreateFieldInputOnCreate
  where: UserConnectOrCreateWhere
}

export type AppOwnerConnectOrCreateFieldInputOnCreate = {
  node: UserOnCreateInput
}

export type AppOwnerCreateFieldInput = {
  node: UserCreateInput
}

export type AppOwnerFieldInput = {
  connect?: InputMaybe<AppOwnerConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<AppOwnerConnectOrCreateFieldInput>
  create?: InputMaybe<AppOwnerCreateFieldInput>
}

export type AppOwnerNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<AppOwnerNodeAggregationWhereInput>>
  NOT?: InputMaybe<AppOwnerNodeAggregationWhereInput>
  OR?: InputMaybe<Array<AppOwnerNodeAggregationWhereInput>>
  auth0Id_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  auth0Id_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  email_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  email_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  username_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  username_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type AppOwnerUpdateConnectionInput = {
  node?: InputMaybe<UserUpdateInput>
}

export type AppOwnerUpdateFieldInput = {
  connect?: InputMaybe<AppOwnerConnectFieldInput>
  connectOrCreate?: InputMaybe<AppOwnerConnectOrCreateFieldInput>
  create?: InputMaybe<AppOwnerCreateFieldInput>
  delete?: InputMaybe<WithOwnerOwnerDeleteFieldInput>
  disconnect?: InputMaybe<WithOwnerOwnerDisconnectFieldInput>
  update?: InputMaybe<AppOwnerUpdateConnectionInput>
  where?: InputMaybe<WithOwnerOwnerConnectionWhere>
}

export type AppPagePagesAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<AppPagePagesNodeAggregateSelection>
}

export type AppPagePagesNodeAggregateSelection = {
  compositeKey: StringAggregateSelection
  id: IdAggregateSelection
  urlPattern: StringAggregateSelection
}

export type AppPagesAggregateInput = {
  AND?: InputMaybe<Array<AppPagesAggregateInput>>
  NOT?: InputMaybe<AppPagesAggregateInput>
  OR?: InputMaybe<Array<AppPagesAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<AppPagesNodeAggregationWhereInput>
}

export type AppPagesConnectFieldInput = {
  connect?: InputMaybe<Array<PageConnectInput>>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<PageConnectWhere>
}

export type AppPagesConnectOrCreateFieldInput = {
  onCreate: AppPagesConnectOrCreateFieldInputOnCreate
  where: PageConnectOrCreateWhere
}

export type AppPagesConnectOrCreateFieldInputOnCreate = {
  node: PageOnCreateInput
}

export type AppPagesConnection = {
  edges: Array<AppPagesRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type AppPagesConnectionSort = {
  node?: InputMaybe<PageSort>
}

export type AppPagesConnectionWhere = {
  AND?: InputMaybe<Array<AppPagesConnectionWhere>>
  NOT?: InputMaybe<AppPagesConnectionWhere>
  OR?: InputMaybe<Array<AppPagesConnectionWhere>>
  node?: InputMaybe<PageWhere>
}

export type AppPagesCreateFieldInput = {
  node: PageCreateInput
}

export type AppPagesDeleteFieldInput = {
  delete?: InputMaybe<PageDeleteInput>
  where?: InputMaybe<AppPagesConnectionWhere>
}

export type AppPagesDisconnectFieldInput = {
  disconnect?: InputMaybe<PageDisconnectInput>
  where?: InputMaybe<AppPagesConnectionWhere>
}

export type AppPagesFieldInput = {
  connect?: InputMaybe<Array<AppPagesConnectFieldInput>>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<Array<AppPagesConnectOrCreateFieldInput>>
  create?: InputMaybe<Array<AppPagesCreateFieldInput>>
}

export type AppPagesNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<AppPagesNodeAggregationWhereInput>>
  NOT?: InputMaybe<AppPagesNodeAggregationWhereInput>
  OR?: InputMaybe<Array<AppPagesNodeAggregationWhereInput>>
  compositeKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  urlPattern_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  urlPattern_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  urlPattern_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  urlPattern_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  urlPattern_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  urlPattern_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  urlPattern_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  urlPattern_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  urlPattern_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  urlPattern_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  urlPattern_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  urlPattern_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  urlPattern_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  urlPattern_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  urlPattern_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type AppPagesRelationship = {
  cursor: Scalars['String']['output']
  node: Page
}

export type AppPagesUpdateConnectionInput = {
  node?: InputMaybe<PageUpdateInput>
}

export type AppPagesUpdateFieldInput = {
  connect?: InputMaybe<Array<AppPagesConnectFieldInput>>
  connectOrCreate?: InputMaybe<Array<AppPagesConnectOrCreateFieldInput>>
  create?: InputMaybe<Array<AppPagesCreateFieldInput>>
  delete?: InputMaybe<Array<AppPagesDeleteFieldInput>>
  disconnect?: InputMaybe<Array<AppPagesDisconnectFieldInput>>
  update?: InputMaybe<AppPagesUpdateConnectionInput>
  where?: InputMaybe<AppPagesConnectionWhere>
}

/** Fields to sort Apps by. The order in which sorts are applied is not guaranteed when specifying many fields in one AppSort object. */
export type AppSort = {
  compositeKey?: InputMaybe<SortDirection>
  id?: InputMaybe<SortDirection>
}

export type AppSubscriptionWhere = {
  AND?: InputMaybe<Array<AppSubscriptionWhere>>
  NOT?: InputMaybe<AppSubscriptionWhere>
  OR?: InputMaybe<Array<AppSubscriptionWhere>>
  /** @deprecated Please use the explicit _EQ version */
  compositeKey?: InputMaybe<Scalars['String']['input']>
  compositeKey_CONTAINS?: InputMaybe<Scalars['String']['input']>
  compositeKey_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  compositeKey_EQ?: InputMaybe<Scalars['String']['input']>
  compositeKey_IN?: InputMaybe<Array<Scalars['String']['input']>>
  compositeKey_MATCHES?: InputMaybe<Scalars['String']['input']>
  compositeKey_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
}

/** Allows picking a app from the list of apps */
export type AppType = IBaseType & {
  fieldRefs: Array<Field>
  fieldRefsAggregate?: Maybe<AppTypeFieldFieldRefsAggregationSelection>
  fieldRefsConnection: IBaseTypeFieldRefsConnection
  id: Scalars['ID']['output']
  kind: TypeKind
  name: Scalars['String']['output']
  owner: User
  ownerAggregate?: Maybe<AppTypeUserOwnerAggregationSelection>
  ownerConnection: IBaseTypeOwnerConnection
}

/** Allows picking a app from the list of apps */
export type AppTypeFieldRefsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<FieldOptions>
  sort?: InputMaybe<Array<FieldSort>>
  where?: InputMaybe<FieldWhere>
}

/** Allows picking a app from the list of apps */
export type AppTypeFieldRefsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<FieldWhere>
}

/** Allows picking a app from the list of apps */
export type AppTypeFieldRefsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<IBaseTypeFieldRefsConnectionSort>>
  where?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
}

/** Allows picking a app from the list of apps */
export type AppTypeOwnerArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<UserOptions>
  sort?: InputMaybe<Array<UserSort>>
  where?: InputMaybe<UserWhere>
}

/** Allows picking a app from the list of apps */
export type AppTypeOwnerAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<UserWhere>
}

/** Allows picking a app from the list of apps */
export type AppTypeOwnerConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<IBaseTypeOwnerConnectionSort>>
  where?: InputMaybe<IBaseTypeOwnerConnectionWhere>
}

export type AppTypeAggregateSelection = {
  count: Scalars['Int']['output']
  id: IdAggregateSelection
  name: StringAggregateSelection
}

export type AppTypeConnectInput = {
  fieldRefs?: InputMaybe<Array<AppTypeFieldRefsConnectFieldInput>>
  owner?: InputMaybe<AppTypeOwnerConnectFieldInput>
}

export type AppTypeConnectWhere = {
  node: AppTypeWhere
}

export type AppTypeCreateInput = {
  fieldRefs?: InputMaybe<AppTypeFieldRefsFieldInput>
  id: Scalars['ID']['input']
  kind?: TypeKind
  name: Scalars['String']['input']
  owner?: InputMaybe<AppTypeOwnerFieldInput>
}

export type AppTypeCreatedEvent = {
  createdAppType: AppTypeEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type AppTypeDeleteInput = {
  fieldRefs?: InputMaybe<Array<IBaseTypeFieldRefsDeleteFieldInput>>
  owner?: InputMaybe<IBaseTypeOwnerDeleteFieldInput>
}

export type AppTypeDeletedEvent = {
  deletedAppType: AppTypeEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type AppTypeDisconnectInput = {
  fieldRefs?: InputMaybe<Array<IBaseTypeFieldRefsDisconnectFieldInput>>
  owner?: InputMaybe<IBaseTypeOwnerDisconnectFieldInput>
}

export type AppTypeEdge = {
  cursor: Scalars['String']['output']
  node: AppType
}

export type AppTypeEventPayload = {
  id: Scalars['ID']['output']
  kind: TypeKind
  name: Scalars['String']['output']
}

export type AppTypeFieldFieldRefsAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<AppTypeFieldFieldRefsNodeAggregateSelection>
}

export type AppTypeFieldFieldRefsNodeAggregateSelection = {
  defaultValues: StringAggregateSelection
  description: StringAggregateSelection
  id: IdAggregateSelection
  key: StringAggregateSelection
  name: StringAggregateSelection
  validationRules: StringAggregateSelection
}

export type AppTypeFieldRefsAggregateInput = {
  AND?: InputMaybe<Array<AppTypeFieldRefsAggregateInput>>
  NOT?: InputMaybe<AppTypeFieldRefsAggregateInput>
  OR?: InputMaybe<Array<AppTypeFieldRefsAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<AppTypeFieldRefsNodeAggregationWhereInput>
}

export type AppTypeFieldRefsConnectFieldInput = {
  connect?: InputMaybe<Array<FieldConnectInput>>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<FieldConnectWhere>
}

export type AppTypeFieldRefsConnectOrCreateFieldInput = {
  onCreate: AppTypeFieldRefsConnectOrCreateFieldInputOnCreate
  where: FieldConnectOrCreateWhere
}

export type AppTypeFieldRefsConnectOrCreateFieldInputOnCreate = {
  node: FieldOnCreateInput
}

export type AppTypeFieldRefsCreateFieldInput = {
  node: FieldCreateInput
}

export type AppTypeFieldRefsFieldInput = {
  connect?: InputMaybe<Array<AppTypeFieldRefsConnectFieldInput>>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<Array<AppTypeFieldRefsConnectOrCreateFieldInput>>
  create?: InputMaybe<Array<AppTypeFieldRefsCreateFieldInput>>
}

export type AppTypeFieldRefsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<AppTypeFieldRefsNodeAggregationWhereInput>>
  NOT?: InputMaybe<AppTypeFieldRefsNodeAggregationWhereInput>
  OR?: InputMaybe<Array<AppTypeFieldRefsNodeAggregationWhereInput>>
  defaultValues_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  defaultValues_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  description_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  description_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  key_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  key_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  validationRules_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type AppTypeFieldRefsUpdateConnectionInput = {
  node?: InputMaybe<FieldUpdateInput>
}

export type AppTypeFieldRefsUpdateFieldInput = {
  connect?: InputMaybe<Array<AppTypeFieldRefsConnectFieldInput>>
  connectOrCreate?: InputMaybe<Array<AppTypeFieldRefsConnectOrCreateFieldInput>>
  create?: InputMaybe<Array<AppTypeFieldRefsCreateFieldInput>>
  delete?: InputMaybe<Array<IBaseTypeFieldRefsDeleteFieldInput>>
  disconnect?: InputMaybe<Array<IBaseTypeFieldRefsDisconnectFieldInput>>
  update?: InputMaybe<AppTypeFieldRefsUpdateConnectionInput>
  where?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
}

export type AppTypeOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  /** Specify one or more AppTypeSort objects to sort AppTypes by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<AppTypeSort>>
}

export type AppTypeOwnerAggregateInput = {
  AND?: InputMaybe<Array<AppTypeOwnerAggregateInput>>
  NOT?: InputMaybe<AppTypeOwnerAggregateInput>
  OR?: InputMaybe<Array<AppTypeOwnerAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<AppTypeOwnerNodeAggregationWhereInput>
}

export type AppTypeOwnerConnectFieldInput = {
  connect?: InputMaybe<UserConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<UserConnectWhere>
}

export type AppTypeOwnerConnectOrCreateFieldInput = {
  onCreate: AppTypeOwnerConnectOrCreateFieldInputOnCreate
  where: UserConnectOrCreateWhere
}

export type AppTypeOwnerConnectOrCreateFieldInputOnCreate = {
  node: UserOnCreateInput
}

export type AppTypeOwnerCreateFieldInput = {
  node: UserCreateInput
}

export type AppTypeOwnerFieldInput = {
  connect?: InputMaybe<AppTypeOwnerConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<AppTypeOwnerConnectOrCreateFieldInput>
  create?: InputMaybe<AppTypeOwnerCreateFieldInput>
}

export type AppTypeOwnerNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<AppTypeOwnerNodeAggregationWhereInput>>
  NOT?: InputMaybe<AppTypeOwnerNodeAggregationWhereInput>
  OR?: InputMaybe<Array<AppTypeOwnerNodeAggregationWhereInput>>
  auth0Id_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  auth0Id_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  email_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  email_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  username_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  username_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type AppTypeOwnerUpdateConnectionInput = {
  node?: InputMaybe<UserUpdateInput>
}

export type AppTypeOwnerUpdateFieldInput = {
  connect?: InputMaybe<AppTypeOwnerConnectFieldInput>
  connectOrCreate?: InputMaybe<AppTypeOwnerConnectOrCreateFieldInput>
  create?: InputMaybe<AppTypeOwnerCreateFieldInput>
  delete?: InputMaybe<IBaseTypeOwnerDeleteFieldInput>
  disconnect?: InputMaybe<IBaseTypeOwnerDisconnectFieldInput>
  update?: InputMaybe<AppTypeOwnerUpdateConnectionInput>
  where?: InputMaybe<IBaseTypeOwnerConnectionWhere>
}

/** Fields to sort AppTypes by. The order in which sorts are applied is not guaranteed when specifying many fields in one AppTypeSort object. */
export type AppTypeSort = {
  id?: InputMaybe<SortDirection>
  kind?: InputMaybe<SortDirection>
  name?: InputMaybe<SortDirection>
}

export type AppTypeSubscriptionWhere = {
  AND?: InputMaybe<Array<AppTypeSubscriptionWhere>>
  NOT?: InputMaybe<AppTypeSubscriptionWhere>
  OR?: InputMaybe<Array<AppTypeSubscriptionWhere>>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  kind?: InputMaybe<TypeKind>
  kind_EQ?: InputMaybe<TypeKind>
  kind_IN?: InputMaybe<Array<TypeKind>>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>
  name_MATCHES?: InputMaybe<Scalars['String']['input']>
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
}

export type AppTypeUpdateInput = {
  fieldRefs?: InputMaybe<Array<AppTypeFieldRefsUpdateFieldInput>>
  /** @deprecated Please use the explicit _SET field */
  id?: InputMaybe<Scalars['ID']['input']>
  id_SET?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _SET field */
  kind?: InputMaybe<TypeKind>
  kind_SET?: InputMaybe<TypeKind>
  /** @deprecated Please use the explicit _SET field */
  name?: InputMaybe<Scalars['String']['input']>
  name_SET?: InputMaybe<Scalars['String']['input']>
  owner?: InputMaybe<AppTypeOwnerUpdateFieldInput>
}

export type AppTypeUpdatedEvent = {
  event: EventType
  previousState: AppTypeEventPayload
  timestamp: Scalars['Float']['output']
  updatedAppType: AppTypeEventPayload
}

export type AppTypeUserOwnerAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<AppTypeUserOwnerNodeAggregateSelection>
}

export type AppTypeUserOwnerNodeAggregateSelection = {
  auth0Id: StringAggregateSelection
  email: StringAggregateSelection
  id: IdAggregateSelection
  username: StringAggregateSelection
}

export type AppTypeWhere = {
  AND?: InputMaybe<Array<AppTypeWhere>>
  NOT?: InputMaybe<AppTypeWhere>
  OR?: InputMaybe<Array<AppTypeWhere>>
  fieldRefsAggregate?: InputMaybe<AppTypeFieldRefsAggregateInput>
  /** Return AppTypes where all of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_ALL?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return AppTypes where none of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_NONE?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return AppTypes where one of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_SINGLE?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return AppTypes where some of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_SOME?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return AppTypes where all of the related Fields match this filter */
  fieldRefs_ALL?: InputMaybe<FieldWhere>
  /** Return AppTypes where none of the related Fields match this filter */
  fieldRefs_NONE?: InputMaybe<FieldWhere>
  /** Return AppTypes where one of the related Fields match this filter */
  fieldRefs_SINGLE?: InputMaybe<FieldWhere>
  /** Return AppTypes where some of the related Fields match this filter */
  fieldRefs_SOME?: InputMaybe<FieldWhere>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  kind?: InputMaybe<TypeKind>
  kind_EQ?: InputMaybe<TypeKind>
  kind_IN?: InputMaybe<Array<TypeKind>>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>
  name_MATCHES?: InputMaybe<Scalars['String']['input']>
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  owner?: InputMaybe<UserWhere>
  ownerAggregate?: InputMaybe<AppTypeOwnerAggregateInput>
  ownerConnection?: InputMaybe<IBaseTypeOwnerConnectionWhere>
}

export type AppTypesConnection = {
  edges: Array<AppTypeEdge>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type AppUniqueWhere = {
  /** @deprecated Please use the explicit _EQ version */
  compositeKey?: InputMaybe<Scalars['String']['input']>
  compositeKey_EQ?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
}

export type AppUpdateInput = {
  /** @deprecated Please use the explicit _SET field */
  compositeKey?: InputMaybe<Scalars['String']['input']>
  compositeKey_SET?: InputMaybe<Scalars['String']['input']>
  domains?: InputMaybe<Array<AppDomainsUpdateFieldInput>>
  owner?: InputMaybe<AppOwnerUpdateFieldInput>
  pages?: InputMaybe<Array<AppPagesUpdateFieldInput>>
}

export type AppUpdatedEvent = {
  event: EventType
  previousState: AppEventPayload
  timestamp: Scalars['Float']['output']
  updatedApp: AppEventPayload
}

export type AppUserOwnerAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<AppUserOwnerNodeAggregateSelection>
}

export type AppUserOwnerNodeAggregateSelection = {
  auth0Id: StringAggregateSelection
  email: StringAggregateSelection
  id: IdAggregateSelection
  username: StringAggregateSelection
}

export type AppWhere = {
  AND?: InputMaybe<Array<AppWhere>>
  NOT?: InputMaybe<AppWhere>
  OR?: InputMaybe<Array<AppWhere>>
  /** @deprecated Please use the explicit _EQ version */
  compositeKey?: InputMaybe<Scalars['String']['input']>
  compositeKey_CONTAINS?: InputMaybe<Scalars['String']['input']>
  compositeKey_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  compositeKey_EQ?: InputMaybe<Scalars['String']['input']>
  compositeKey_IN?: InputMaybe<Array<Scalars['String']['input']>>
  compositeKey_MATCHES?: InputMaybe<Scalars['String']['input']>
  compositeKey_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  domainsAggregate?: InputMaybe<AppDomainsAggregateInput>
  /** Return Apps where all of the related AppDomainsConnections match this filter */
  domainsConnection_ALL?: InputMaybe<AppDomainsConnectionWhere>
  /** Return Apps where none of the related AppDomainsConnections match this filter */
  domainsConnection_NONE?: InputMaybe<AppDomainsConnectionWhere>
  /** Return Apps where one of the related AppDomainsConnections match this filter */
  domainsConnection_SINGLE?: InputMaybe<AppDomainsConnectionWhere>
  /** Return Apps where some of the related AppDomainsConnections match this filter */
  domainsConnection_SOME?: InputMaybe<AppDomainsConnectionWhere>
  /** Return Apps where all of the related Domains match this filter */
  domains_ALL?: InputMaybe<DomainWhere>
  /** Return Apps where none of the related Domains match this filter */
  domains_NONE?: InputMaybe<DomainWhere>
  /** Return Apps where one of the related Domains match this filter */
  domains_SINGLE?: InputMaybe<DomainWhere>
  /** Return Apps where some of the related Domains match this filter */
  domains_SOME?: InputMaybe<DomainWhere>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  owner?: InputMaybe<UserWhere>
  ownerAggregate?: InputMaybe<AppOwnerAggregateInput>
  ownerConnection?: InputMaybe<WithOwnerOwnerConnectionWhere>
  pagesAggregate?: InputMaybe<AppPagesAggregateInput>
  /** Return Apps where all of the related AppPagesConnections match this filter */
  pagesConnection_ALL?: InputMaybe<AppPagesConnectionWhere>
  /** Return Apps where none of the related AppPagesConnections match this filter */
  pagesConnection_NONE?: InputMaybe<AppPagesConnectionWhere>
  /** Return Apps where one of the related AppPagesConnections match this filter */
  pagesConnection_SINGLE?: InputMaybe<AppPagesConnectionWhere>
  /** Return Apps where some of the related AppPagesConnections match this filter */
  pagesConnection_SOME?: InputMaybe<AppPagesConnectionWhere>
  /** Return Apps where all of the related Pages match this filter */
  pages_ALL?: InputMaybe<PageWhere>
  /** Return Apps where none of the related Pages match this filter */
  pages_NONE?: InputMaybe<PageWhere>
  /** Return Apps where one of the related Pages match this filter */
  pages_SINGLE?: InputMaybe<PageWhere>
  /** Return Apps where some of the related Pages match this filter */
  pages_SOME?: InputMaybe<PageWhere>
}

export type AppsConnection = {
  edges: Array<AppEdge>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

/**
 * ArrayType Allows defining a variable number of items of a given type.
 * Contains a reference to another type which is the array item type.
 */
export type ArrayType = IBaseType &
  WithDescendants & {
    descendantTypesIds: Array<Scalars['ID']['output']>
    fieldRefs: Array<Field>
    fieldRefsAggregate?: Maybe<ArrayTypeFieldFieldRefsAggregationSelection>
    fieldRefsConnection: IBaseTypeFieldRefsConnection
    id: Scalars['ID']['output']
    itemType: IBaseType
    itemTypeAggregate?: Maybe<ArrayTypeIBaseTypeItemTypeAggregationSelection>
    itemTypeConnection: ArrayTypeItemTypeConnection
    kind: TypeKind
    name: Scalars['String']['output']
    owner: User
    ownerAggregate?: Maybe<ArrayTypeUserOwnerAggregationSelection>
    ownerConnection: IBaseTypeOwnerConnection
  }

/**
 * ArrayType Allows defining a variable number of items of a given type.
 * Contains a reference to another type which is the array item type.
 */
export type ArrayTypeFieldRefsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<FieldOptions>
  sort?: InputMaybe<Array<FieldSort>>
  where?: InputMaybe<FieldWhere>
}

/**
 * ArrayType Allows defining a variable number of items of a given type.
 * Contains a reference to another type which is the array item type.
 */
export type ArrayTypeFieldRefsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<FieldWhere>
}

/**
 * ArrayType Allows defining a variable number of items of a given type.
 * Contains a reference to another type which is the array item type.
 */
export type ArrayTypeFieldRefsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<IBaseTypeFieldRefsConnectionSort>>
  where?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
}

/**
 * ArrayType Allows defining a variable number of items of a given type.
 * Contains a reference to another type which is the array item type.
 */
export type ArrayTypeItemTypeArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<IBaseTypeOptions>
  sort?: InputMaybe<Array<IBaseTypeSort>>
  where?: InputMaybe<IBaseTypeWhere>
}

/**
 * ArrayType Allows defining a variable number of items of a given type.
 * Contains a reference to another type which is the array item type.
 */
export type ArrayTypeItemTypeAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<IBaseTypeWhere>
}

/**
 * ArrayType Allows defining a variable number of items of a given type.
 * Contains a reference to another type which is the array item type.
 */
export type ArrayTypeItemTypeConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<ArrayTypeItemTypeConnectionSort>>
  where?: InputMaybe<ArrayTypeItemTypeConnectionWhere>
}

/**
 * ArrayType Allows defining a variable number of items of a given type.
 * Contains a reference to another type which is the array item type.
 */
export type ArrayTypeOwnerArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<UserOptions>
  sort?: InputMaybe<Array<UserSort>>
  where?: InputMaybe<UserWhere>
}

/**
 * ArrayType Allows defining a variable number of items of a given type.
 * Contains a reference to another type which is the array item type.
 */
export type ArrayTypeOwnerAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<UserWhere>
}

/**
 * ArrayType Allows defining a variable number of items of a given type.
 * Contains a reference to another type which is the array item type.
 */
export type ArrayTypeOwnerConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<IBaseTypeOwnerConnectionSort>>
  where?: InputMaybe<IBaseTypeOwnerConnectionWhere>
}

export type ArrayTypeAggregateSelection = {
  count: Scalars['Int']['output']
  id: IdAggregateSelection
  name: StringAggregateSelection
}

export type ArrayTypeConnectInput = {
  fieldRefs?: InputMaybe<Array<ArrayTypeFieldRefsConnectFieldInput>>
  itemType?: InputMaybe<ArrayTypeItemTypeConnectFieldInput>
  owner?: InputMaybe<ArrayTypeOwnerConnectFieldInput>
}

export type ArrayTypeConnectWhere = {
  node: ArrayTypeWhere
}

export type ArrayTypeCreateInput = {
  fieldRefs?: InputMaybe<ArrayTypeFieldRefsFieldInput>
  id: Scalars['ID']['input']
  itemType?: InputMaybe<ArrayTypeItemTypeFieldInput>
  kind?: TypeKind
  name: Scalars['String']['input']
  owner?: InputMaybe<ArrayTypeOwnerFieldInput>
}

export type ArrayTypeCreatedEvent = {
  createdArrayType: ArrayTypeEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type ArrayTypeDeleteInput = {
  fieldRefs?: InputMaybe<Array<IBaseTypeFieldRefsDeleteFieldInput>>
  itemType?: InputMaybe<ArrayTypeItemTypeDeleteFieldInput>
  owner?: InputMaybe<IBaseTypeOwnerDeleteFieldInput>
}

export type ArrayTypeDeletedEvent = {
  deletedArrayType: ArrayTypeEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type ArrayTypeDisconnectInput = {
  fieldRefs?: InputMaybe<Array<IBaseTypeFieldRefsDisconnectFieldInput>>
  itemType?: InputMaybe<ArrayTypeItemTypeDisconnectFieldInput>
  owner?: InputMaybe<IBaseTypeOwnerDisconnectFieldInput>
}

export type ArrayTypeEdge = {
  cursor: Scalars['String']['output']
  node: ArrayType
}

export type ArrayTypeEventPayload = {
  id: Scalars['ID']['output']
  kind: TypeKind
  name: Scalars['String']['output']
}

export type ArrayTypeFieldFieldRefsAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<ArrayTypeFieldFieldRefsNodeAggregateSelection>
}

export type ArrayTypeFieldFieldRefsNodeAggregateSelection = {
  defaultValues: StringAggregateSelection
  description: StringAggregateSelection
  id: IdAggregateSelection
  key: StringAggregateSelection
  name: StringAggregateSelection
  validationRules: StringAggregateSelection
}

export type ArrayTypeFieldRefsAggregateInput = {
  AND?: InputMaybe<Array<ArrayTypeFieldRefsAggregateInput>>
  NOT?: InputMaybe<ArrayTypeFieldRefsAggregateInput>
  OR?: InputMaybe<Array<ArrayTypeFieldRefsAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<ArrayTypeFieldRefsNodeAggregationWhereInput>
}

export type ArrayTypeFieldRefsConnectFieldInput = {
  connect?: InputMaybe<Array<FieldConnectInput>>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<FieldConnectWhere>
}

export type ArrayTypeFieldRefsConnectOrCreateFieldInput = {
  onCreate: ArrayTypeFieldRefsConnectOrCreateFieldInputOnCreate
  where: FieldConnectOrCreateWhere
}

export type ArrayTypeFieldRefsConnectOrCreateFieldInputOnCreate = {
  node: FieldOnCreateInput
}

export type ArrayTypeFieldRefsCreateFieldInput = {
  node: FieldCreateInput
}

export type ArrayTypeFieldRefsFieldInput = {
  connect?: InputMaybe<Array<ArrayTypeFieldRefsConnectFieldInput>>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<
    Array<ArrayTypeFieldRefsConnectOrCreateFieldInput>
  >
  create?: InputMaybe<Array<ArrayTypeFieldRefsCreateFieldInput>>
}

export type ArrayTypeFieldRefsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<ArrayTypeFieldRefsNodeAggregationWhereInput>>
  NOT?: InputMaybe<ArrayTypeFieldRefsNodeAggregationWhereInput>
  OR?: InputMaybe<Array<ArrayTypeFieldRefsNodeAggregationWhereInput>>
  defaultValues_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  defaultValues_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  description_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  description_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  key_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  key_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  validationRules_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type ArrayTypeFieldRefsUpdateConnectionInput = {
  node?: InputMaybe<FieldUpdateInput>
}

export type ArrayTypeFieldRefsUpdateFieldInput = {
  connect?: InputMaybe<Array<ArrayTypeFieldRefsConnectFieldInput>>
  connectOrCreate?: InputMaybe<
    Array<ArrayTypeFieldRefsConnectOrCreateFieldInput>
  >
  create?: InputMaybe<Array<ArrayTypeFieldRefsCreateFieldInput>>
  delete?: InputMaybe<Array<IBaseTypeFieldRefsDeleteFieldInput>>
  disconnect?: InputMaybe<Array<IBaseTypeFieldRefsDisconnectFieldInput>>
  update?: InputMaybe<ArrayTypeFieldRefsUpdateConnectionInput>
  where?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
}

export type ArrayTypeIBaseTypeItemTypeAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<ArrayTypeIBaseTypeItemTypeNodeAggregateSelection>
}

export type ArrayTypeIBaseTypeItemTypeNodeAggregateSelection = {
  id: IdAggregateSelection
  name: StringAggregateSelection
}

export type ArrayTypeItemTypeAggregateInput = {
  AND?: InputMaybe<Array<ArrayTypeItemTypeAggregateInput>>
  NOT?: InputMaybe<ArrayTypeItemTypeAggregateInput>
  OR?: InputMaybe<Array<ArrayTypeItemTypeAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<ArrayTypeItemTypeNodeAggregationWhereInput>
}

export type ArrayTypeItemTypeConnectFieldInput = {
  connect?: InputMaybe<IBaseTypeConnectInput>
  where?: InputMaybe<IBaseTypeConnectWhere>
}

export type ArrayTypeItemTypeConnection = {
  edges: Array<ArrayTypeItemTypeRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type ArrayTypeItemTypeConnectionSort = {
  node?: InputMaybe<IBaseTypeSort>
}

export type ArrayTypeItemTypeConnectionWhere = {
  AND?: InputMaybe<Array<ArrayTypeItemTypeConnectionWhere>>
  NOT?: InputMaybe<ArrayTypeItemTypeConnectionWhere>
  OR?: InputMaybe<Array<ArrayTypeItemTypeConnectionWhere>>
  node?: InputMaybe<IBaseTypeWhere>
}

export type ArrayTypeItemTypeCreateFieldInput = {
  node: IBaseTypeCreateInput
}

export type ArrayTypeItemTypeDeleteFieldInput = {
  delete?: InputMaybe<IBaseTypeDeleteInput>
  where?: InputMaybe<ArrayTypeItemTypeConnectionWhere>
}

export type ArrayTypeItemTypeDisconnectFieldInput = {
  disconnect?: InputMaybe<IBaseTypeDisconnectInput>
  where?: InputMaybe<ArrayTypeItemTypeConnectionWhere>
}

export type ArrayTypeItemTypeFieldInput = {
  connect?: InputMaybe<ArrayTypeItemTypeConnectFieldInput>
  create?: InputMaybe<ArrayTypeItemTypeCreateFieldInput>
}

export type ArrayTypeItemTypeNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<ArrayTypeItemTypeNodeAggregationWhereInput>>
  NOT?: InputMaybe<ArrayTypeItemTypeNodeAggregationWhereInput>
  OR?: InputMaybe<Array<ArrayTypeItemTypeNodeAggregationWhereInput>>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type ArrayTypeItemTypeRelationship = {
  cursor: Scalars['String']['output']
  node: IBaseType
}

export type ArrayTypeItemTypeUpdateConnectionInput = {
  node?: InputMaybe<IBaseTypeUpdateInput>
}

export type ArrayTypeItemTypeUpdateFieldInput = {
  connect?: InputMaybe<ArrayTypeItemTypeConnectFieldInput>
  create?: InputMaybe<ArrayTypeItemTypeCreateFieldInput>
  delete?: InputMaybe<ArrayTypeItemTypeDeleteFieldInput>
  disconnect?: InputMaybe<ArrayTypeItemTypeDisconnectFieldInput>
  update?: InputMaybe<ArrayTypeItemTypeUpdateConnectionInput>
  where?: InputMaybe<ArrayTypeItemTypeConnectionWhere>
}

export type ArrayTypeOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  /** Specify one or more ArrayTypeSort objects to sort ArrayTypes by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<ArrayTypeSort>>
}

export type ArrayTypeOwnerAggregateInput = {
  AND?: InputMaybe<Array<ArrayTypeOwnerAggregateInput>>
  NOT?: InputMaybe<ArrayTypeOwnerAggregateInput>
  OR?: InputMaybe<Array<ArrayTypeOwnerAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<ArrayTypeOwnerNodeAggregationWhereInput>
}

export type ArrayTypeOwnerConnectFieldInput = {
  connect?: InputMaybe<UserConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<UserConnectWhere>
}

export type ArrayTypeOwnerConnectOrCreateFieldInput = {
  onCreate: ArrayTypeOwnerConnectOrCreateFieldInputOnCreate
  where: UserConnectOrCreateWhere
}

export type ArrayTypeOwnerConnectOrCreateFieldInputOnCreate = {
  node: UserOnCreateInput
}

export type ArrayTypeOwnerCreateFieldInput = {
  node: UserCreateInput
}

export type ArrayTypeOwnerFieldInput = {
  connect?: InputMaybe<ArrayTypeOwnerConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<ArrayTypeOwnerConnectOrCreateFieldInput>
  create?: InputMaybe<ArrayTypeOwnerCreateFieldInput>
}

export type ArrayTypeOwnerNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<ArrayTypeOwnerNodeAggregationWhereInput>>
  NOT?: InputMaybe<ArrayTypeOwnerNodeAggregationWhereInput>
  OR?: InputMaybe<Array<ArrayTypeOwnerNodeAggregationWhereInput>>
  auth0Id_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  auth0Id_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  email_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  email_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  username_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  username_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type ArrayTypeOwnerUpdateConnectionInput = {
  node?: InputMaybe<UserUpdateInput>
}

export type ArrayTypeOwnerUpdateFieldInput = {
  connect?: InputMaybe<ArrayTypeOwnerConnectFieldInput>
  connectOrCreate?: InputMaybe<ArrayTypeOwnerConnectOrCreateFieldInput>
  create?: InputMaybe<ArrayTypeOwnerCreateFieldInput>
  delete?: InputMaybe<IBaseTypeOwnerDeleteFieldInput>
  disconnect?: InputMaybe<IBaseTypeOwnerDisconnectFieldInput>
  update?: InputMaybe<ArrayTypeOwnerUpdateConnectionInput>
  where?: InputMaybe<IBaseTypeOwnerConnectionWhere>
}

/** Fields to sort ArrayTypes by. The order in which sorts are applied is not guaranteed when specifying many fields in one ArrayTypeSort object. */
export type ArrayTypeSort = {
  id?: InputMaybe<SortDirection>
  kind?: InputMaybe<SortDirection>
  name?: InputMaybe<SortDirection>
}

export type ArrayTypeSubscriptionWhere = {
  AND?: InputMaybe<Array<ArrayTypeSubscriptionWhere>>
  NOT?: InputMaybe<ArrayTypeSubscriptionWhere>
  OR?: InputMaybe<Array<ArrayTypeSubscriptionWhere>>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  kind?: InputMaybe<TypeKind>
  kind_EQ?: InputMaybe<TypeKind>
  kind_IN?: InputMaybe<Array<TypeKind>>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>
  name_MATCHES?: InputMaybe<Scalars['String']['input']>
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
}

export type ArrayTypeUpdateInput = {
  fieldRefs?: InputMaybe<Array<ArrayTypeFieldRefsUpdateFieldInput>>
  /** @deprecated Please use the explicit _SET field */
  id?: InputMaybe<Scalars['ID']['input']>
  id_SET?: InputMaybe<Scalars['ID']['input']>
  itemType?: InputMaybe<ArrayTypeItemTypeUpdateFieldInput>
  /** @deprecated Please use the explicit _SET field */
  kind?: InputMaybe<TypeKind>
  kind_SET?: InputMaybe<TypeKind>
  /** @deprecated Please use the explicit _SET field */
  name?: InputMaybe<Scalars['String']['input']>
  name_SET?: InputMaybe<Scalars['String']['input']>
  owner?: InputMaybe<ArrayTypeOwnerUpdateFieldInput>
}

export type ArrayTypeUpdatedEvent = {
  event: EventType
  previousState: ArrayTypeEventPayload
  timestamp: Scalars['Float']['output']
  updatedArrayType: ArrayTypeEventPayload
}

export type ArrayTypeUserOwnerAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<ArrayTypeUserOwnerNodeAggregateSelection>
}

export type ArrayTypeUserOwnerNodeAggregateSelection = {
  auth0Id: StringAggregateSelection
  email: StringAggregateSelection
  id: IdAggregateSelection
  username: StringAggregateSelection
}

export type ArrayTypeWhere = {
  AND?: InputMaybe<Array<ArrayTypeWhere>>
  NOT?: InputMaybe<ArrayTypeWhere>
  OR?: InputMaybe<Array<ArrayTypeWhere>>
  fieldRefsAggregate?: InputMaybe<ArrayTypeFieldRefsAggregateInput>
  /** Return ArrayTypes where all of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_ALL?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return ArrayTypes where none of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_NONE?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return ArrayTypes where one of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_SINGLE?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return ArrayTypes where some of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_SOME?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return ArrayTypes where all of the related Fields match this filter */
  fieldRefs_ALL?: InputMaybe<FieldWhere>
  /** Return ArrayTypes where none of the related Fields match this filter */
  fieldRefs_NONE?: InputMaybe<FieldWhere>
  /** Return ArrayTypes where one of the related Fields match this filter */
  fieldRefs_SINGLE?: InputMaybe<FieldWhere>
  /** Return ArrayTypes where some of the related Fields match this filter */
  fieldRefs_SOME?: InputMaybe<FieldWhere>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  itemType?: InputMaybe<IBaseTypeWhere>
  itemTypeAggregate?: InputMaybe<ArrayTypeItemTypeAggregateInput>
  itemTypeConnection?: InputMaybe<ArrayTypeItemTypeConnectionWhere>
  /** @deprecated Please use the explicit _EQ version */
  kind?: InputMaybe<TypeKind>
  kind_EQ?: InputMaybe<TypeKind>
  kind_IN?: InputMaybe<Array<TypeKind>>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>
  name_MATCHES?: InputMaybe<Scalars['String']['input']>
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  owner?: InputMaybe<UserWhere>
  ownerAggregate?: InputMaybe<ArrayTypeOwnerAggregateInput>
  ownerConnection?: InputMaybe<IBaseTypeOwnerConnectionWhere>
}

export type ArrayTypesConnection = {
  edges: Array<ArrayTypeEdge>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type Atom = WithOwner & {
  api: InterfaceType
  apiAggregate?: Maybe<AtomInterfaceTypeApiAggregationSelection>
  apiConnection: AtomApiConnection
  elements: Array<Element>
  elementsAggregate?: Maybe<AtomElementElementsAggregationSelection>
  elementsConnection: AtomElementsConnection
  externalCssSource?: Maybe<Scalars['String']['output']>
  externalJsSource?: Maybe<Scalars['String']['output']>
  externalSourceType?: Maybe<Scalars['String']['output']>
  icon?: Maybe<Scalars['String']['output']>
  id: Scalars['ID']['output']
  name: Scalars['String']['output']
  owner: User
  ownerAggregate?: Maybe<AtomUserOwnerAggregationSelection>
  ownerConnection: WithOwnerOwnerConnection
  requiredParents: Array<Atom>
  requiredParentsAggregate?: Maybe<AtomAtomRequiredParentsAggregationSelection>
  requiredParentsConnection: AtomRequiredParentsConnection
  suggestedChildren: Array<Atom>
  suggestedChildrenAggregate?: Maybe<AtomAtomSuggestedChildrenAggregationSelection>
  suggestedChildrenConnection: AtomSuggestedChildrenConnection
  tags: Array<Tag>
  tagsAggregate?: Maybe<AtomTagTagsAggregationSelection>
  tagsConnection: AtomTagsConnection
  type: AtomType
}

export type AtomApiArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<InterfaceTypeOptions>
  sort?: InputMaybe<Array<InterfaceTypeSort>>
  where?: InputMaybe<InterfaceTypeWhere>
}

export type AtomApiAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<InterfaceTypeWhere>
}

export type AtomApiConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<AtomApiConnectionSort>>
  where?: InputMaybe<AtomApiConnectionWhere>
}

export type AtomElementsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<ElementOptions>
  sort?: InputMaybe<Array<ElementSort>>
  where?: InputMaybe<ElementWhere>
}

export type AtomElementsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<ElementWhere>
}

export type AtomElementsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<AtomElementsConnectionSort>>
  where?: InputMaybe<AtomElementsConnectionWhere>
}

export type AtomOwnerArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<UserOptions>
  sort?: InputMaybe<Array<UserSort>>
  where?: InputMaybe<UserWhere>
}

export type AtomOwnerAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<UserWhere>
}

export type AtomOwnerConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<WithOwnerOwnerConnectionSort>>
  where?: InputMaybe<WithOwnerOwnerConnectionWhere>
}

export type AtomRequiredParentsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<AtomOptions>
  sort?: InputMaybe<Array<AtomSort>>
  where?: InputMaybe<AtomWhere>
}

export type AtomRequiredParentsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<AtomWhere>
}

export type AtomRequiredParentsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<AtomRequiredParentsConnectionSort>>
  where?: InputMaybe<AtomRequiredParentsConnectionWhere>
}

export type AtomSuggestedChildrenArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<AtomOptions>
  sort?: InputMaybe<Array<AtomSort>>
  where?: InputMaybe<AtomWhere>
}

export type AtomSuggestedChildrenAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<AtomWhere>
}

export type AtomSuggestedChildrenConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<AtomSuggestedChildrenConnectionSort>>
  where?: InputMaybe<AtomSuggestedChildrenConnectionWhere>
}

export type AtomTagsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<TagOptions>
  sort?: InputMaybe<Array<TagSort>>
  where?: InputMaybe<TagWhere>
}

export type AtomTagsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<TagWhere>
}

export type AtomTagsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<AtomTagsConnectionSort>>
  where?: InputMaybe<AtomTagsConnectionWhere>
}

export type AtomAggregateSelection = {
  count: Scalars['Int']['output']
  externalCssSource: StringAggregateSelection
  externalJsSource: StringAggregateSelection
  externalSourceType: StringAggregateSelection
  icon: StringAggregateSelection
  id: IdAggregateSelection
  name: StringAggregateSelection
}

export type AtomApiAggregateInput = {
  AND?: InputMaybe<Array<AtomApiAggregateInput>>
  NOT?: InputMaybe<AtomApiAggregateInput>
  OR?: InputMaybe<Array<AtomApiAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<AtomApiNodeAggregationWhereInput>
}

export type AtomApiConnectFieldInput = {
  connect?: InputMaybe<InterfaceTypeConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<InterfaceTypeConnectWhere>
}

export type AtomApiConnection = {
  edges: Array<AtomApiRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type AtomApiConnectionSort = {
  node?: InputMaybe<InterfaceTypeSort>
}

export type AtomApiConnectionWhere = {
  AND?: InputMaybe<Array<AtomApiConnectionWhere>>
  NOT?: InputMaybe<AtomApiConnectionWhere>
  OR?: InputMaybe<Array<AtomApiConnectionWhere>>
  node?: InputMaybe<InterfaceTypeWhere>
}

export type AtomApiCreateFieldInput = {
  node: InterfaceTypeCreateInput
}

export type AtomApiDeleteFieldInput = {
  delete?: InputMaybe<InterfaceTypeDeleteInput>
  where?: InputMaybe<AtomApiConnectionWhere>
}

export type AtomApiDisconnectFieldInput = {
  disconnect?: InputMaybe<InterfaceTypeDisconnectInput>
  where?: InputMaybe<AtomApiConnectionWhere>
}

export type AtomApiFieldInput = {
  connect?: InputMaybe<AtomApiConnectFieldInput>
  create?: InputMaybe<AtomApiCreateFieldInput>
}

export type AtomApiNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<AtomApiNodeAggregationWhereInput>>
  NOT?: InputMaybe<AtomApiNodeAggregationWhereInput>
  OR?: InputMaybe<Array<AtomApiNodeAggregationWhereInput>>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type AtomApiRelationship = {
  cursor: Scalars['String']['output']
  node: InterfaceType
}

export type AtomApiUpdateConnectionInput = {
  node?: InputMaybe<InterfaceTypeUpdateInput>
}

export type AtomApiUpdateFieldInput = {
  connect?: InputMaybe<AtomApiConnectFieldInput>
  create?: InputMaybe<AtomApiCreateFieldInput>
  delete?: InputMaybe<AtomApiDeleteFieldInput>
  disconnect?: InputMaybe<AtomApiDisconnectFieldInput>
  update?: InputMaybe<AtomApiUpdateConnectionInput>
  where?: InputMaybe<AtomApiConnectionWhere>
}

export type AtomAtomRequiredParentsAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<AtomAtomRequiredParentsNodeAggregateSelection>
}

export type AtomAtomRequiredParentsNodeAggregateSelection = {
  externalCssSource: StringAggregateSelection
  externalJsSource: StringAggregateSelection
  externalSourceType: StringAggregateSelection
  icon: StringAggregateSelection
  id: IdAggregateSelection
  name: StringAggregateSelection
}

export type AtomAtomSuggestedChildrenAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<AtomAtomSuggestedChildrenNodeAggregateSelection>
}

export type AtomAtomSuggestedChildrenNodeAggregateSelection = {
  externalCssSource: StringAggregateSelection
  externalJsSource: StringAggregateSelection
  externalSourceType: StringAggregateSelection
  icon: StringAggregateSelection
  id: IdAggregateSelection
  name: StringAggregateSelection
}

export type AtomConnectInput = {
  api?: InputMaybe<AtomApiConnectFieldInput>
  elements?: InputMaybe<Array<AtomElementsConnectFieldInput>>
  owner?: InputMaybe<AtomOwnerConnectFieldInput>
  requiredParents?: InputMaybe<Array<AtomRequiredParentsConnectFieldInput>>
  suggestedChildren?: InputMaybe<Array<AtomSuggestedChildrenConnectFieldInput>>
  tags?: InputMaybe<Array<AtomTagsConnectFieldInput>>
}

export type AtomConnectOrCreateWhere = {
  node: AtomUniqueWhere
}

export type AtomConnectWhere = {
  node: AtomWhere
}

export type AtomCreateInput = {
  api?: InputMaybe<AtomApiFieldInput>
  elements?: InputMaybe<AtomElementsFieldInput>
  externalCssSource?: InputMaybe<Scalars['String']['input']>
  externalJsSource?: InputMaybe<Scalars['String']['input']>
  externalSourceType?: InputMaybe<Scalars['String']['input']>
  icon?: InputMaybe<Scalars['String']['input']>
  id: Scalars['ID']['input']
  name: Scalars['String']['input']
  owner?: InputMaybe<AtomOwnerFieldInput>
  requiredParents?: InputMaybe<AtomRequiredParentsFieldInput>
  suggestedChildren?: InputMaybe<AtomSuggestedChildrenFieldInput>
  tags?: InputMaybe<AtomTagsFieldInput>
  type: AtomType
}

export type AtomCreatedEvent = {
  createdAtom: AtomEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type AtomDeleteInput = {
  api?: InputMaybe<AtomApiDeleteFieldInput>
  elements?: InputMaybe<Array<AtomElementsDeleteFieldInput>>
  owner?: InputMaybe<WithOwnerOwnerDeleteFieldInput>
  requiredParents?: InputMaybe<Array<AtomRequiredParentsDeleteFieldInput>>
  suggestedChildren?: InputMaybe<Array<AtomSuggestedChildrenDeleteFieldInput>>
  tags?: InputMaybe<Array<AtomTagsDeleteFieldInput>>
}

export type AtomDeletedEvent = {
  deletedAtom: AtomEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type AtomDisconnectInput = {
  api?: InputMaybe<AtomApiDisconnectFieldInput>
  elements?: InputMaybe<Array<AtomElementsDisconnectFieldInput>>
  owner?: InputMaybe<WithOwnerOwnerDisconnectFieldInput>
  requiredParents?: InputMaybe<Array<AtomRequiredParentsDisconnectFieldInput>>
  suggestedChildren?: InputMaybe<
    Array<AtomSuggestedChildrenDisconnectFieldInput>
  >
  tags?: InputMaybe<Array<AtomTagsDisconnectFieldInput>>
}

export type AtomEdge = {
  cursor: Scalars['String']['output']
  node: Atom
}

export type AtomElementElementsAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<AtomElementElementsNodeAggregateSelection>
}

export type AtomElementElementsNodeAggregateSelection = {
  childMapperPropKey: StringAggregateSelection
  compositeKey: StringAggregateSelection
  id: IdAggregateSelection
  renderForEachPropKey: StringAggregateSelection
  renderIfExpression: StringAggregateSelection
  style: StringAggregateSelection
}

export type AtomElementsAggregateInput = {
  AND?: InputMaybe<Array<AtomElementsAggregateInput>>
  NOT?: InputMaybe<AtomElementsAggregateInput>
  OR?: InputMaybe<Array<AtomElementsAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<AtomElementsNodeAggregationWhereInput>
}

export type AtomElementsConnectFieldInput = {
  connect?: InputMaybe<Array<ElementConnectInput>>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<ElementConnectWhere>
}

export type AtomElementsConnectOrCreateFieldInput = {
  onCreate: AtomElementsConnectOrCreateFieldInputOnCreate
  where: ElementConnectOrCreateWhere
}

export type AtomElementsConnectOrCreateFieldInputOnCreate = {
  node: ElementOnCreateInput
}

export type AtomElementsConnection = {
  edges: Array<AtomElementsRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type AtomElementsConnectionSort = {
  node?: InputMaybe<ElementSort>
}

export type AtomElementsConnectionWhere = {
  AND?: InputMaybe<Array<AtomElementsConnectionWhere>>
  NOT?: InputMaybe<AtomElementsConnectionWhere>
  OR?: InputMaybe<Array<AtomElementsConnectionWhere>>
  node?: InputMaybe<ElementWhere>
}

export type AtomElementsCreateFieldInput = {
  node: ElementCreateInput
}

export type AtomElementsDeleteFieldInput = {
  delete?: InputMaybe<ElementDeleteInput>
  where?: InputMaybe<AtomElementsConnectionWhere>
}

export type AtomElementsDisconnectFieldInput = {
  disconnect?: InputMaybe<ElementDisconnectInput>
  where?: InputMaybe<AtomElementsConnectionWhere>
}

export type AtomElementsFieldInput = {
  connect?: InputMaybe<Array<AtomElementsConnectFieldInput>>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<Array<AtomElementsConnectOrCreateFieldInput>>
  create?: InputMaybe<Array<AtomElementsCreateFieldInput>>
}

export type AtomElementsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<AtomElementsNodeAggregationWhereInput>>
  NOT?: InputMaybe<AtomElementsNodeAggregationWhereInput>
  OR?: InputMaybe<Array<AtomElementsNodeAggregationWhereInput>>
  childMapperPropKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  childMapperPropKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_GTE?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_LTE?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_LONGEST_LENGTH_EQUAL?: InputMaybe<
    Scalars['Int']['input']
  >
  renderForEachPropKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<
    Scalars['Int']['input']
  >
  renderForEachPropKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  renderIfExpression_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  style_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  style_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type AtomElementsRelationship = {
  cursor: Scalars['String']['output']
  node: Element
}

export type AtomElementsUpdateConnectionInput = {
  node?: InputMaybe<ElementUpdateInput>
}

export type AtomElementsUpdateFieldInput = {
  connect?: InputMaybe<Array<AtomElementsConnectFieldInput>>
  connectOrCreate?: InputMaybe<Array<AtomElementsConnectOrCreateFieldInput>>
  create?: InputMaybe<Array<AtomElementsCreateFieldInput>>
  delete?: InputMaybe<Array<AtomElementsDeleteFieldInput>>
  disconnect?: InputMaybe<Array<AtomElementsDisconnectFieldInput>>
  update?: InputMaybe<AtomElementsUpdateConnectionInput>
  where?: InputMaybe<AtomElementsConnectionWhere>
}

export type AtomEventPayload = {
  externalCssSource?: Maybe<Scalars['String']['output']>
  externalJsSource?: Maybe<Scalars['String']['output']>
  externalSourceType?: Maybe<Scalars['String']['output']>
  icon?: Maybe<Scalars['String']['output']>
  id: Scalars['ID']['output']
  name: Scalars['String']['output']
  type: AtomType
}

export type AtomInterfaceTypeApiAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<AtomInterfaceTypeApiNodeAggregateSelection>
}

export type AtomInterfaceTypeApiNodeAggregateSelection = {
  id: IdAggregateSelection
  name: StringAggregateSelection
}

export type AtomOnCreateInput = {
  externalCssSource?: InputMaybe<Scalars['String']['input']>
  externalJsSource?: InputMaybe<Scalars['String']['input']>
  externalSourceType?: InputMaybe<Scalars['String']['input']>
  icon?: InputMaybe<Scalars['String']['input']>
  id: Scalars['ID']['input']
  name: Scalars['String']['input']
  type: AtomType
}

export type AtomOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  /** Specify one or more AtomSort objects to sort Atoms by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<AtomSort>>
}

export type AtomOwnerAggregateInput = {
  AND?: InputMaybe<Array<AtomOwnerAggregateInput>>
  NOT?: InputMaybe<AtomOwnerAggregateInput>
  OR?: InputMaybe<Array<AtomOwnerAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<AtomOwnerNodeAggregationWhereInput>
}

export type AtomOwnerConnectFieldInput = {
  connect?: InputMaybe<UserConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<UserConnectWhere>
}

export type AtomOwnerConnectOrCreateFieldInput = {
  onCreate: AtomOwnerConnectOrCreateFieldInputOnCreate
  where: UserConnectOrCreateWhere
}

export type AtomOwnerConnectOrCreateFieldInputOnCreate = {
  node: UserOnCreateInput
}

export type AtomOwnerCreateFieldInput = {
  node: UserCreateInput
}

export type AtomOwnerFieldInput = {
  connect?: InputMaybe<AtomOwnerConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<AtomOwnerConnectOrCreateFieldInput>
  create?: InputMaybe<AtomOwnerCreateFieldInput>
}

export type AtomOwnerNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<AtomOwnerNodeAggregationWhereInput>>
  NOT?: InputMaybe<AtomOwnerNodeAggregationWhereInput>
  OR?: InputMaybe<Array<AtomOwnerNodeAggregationWhereInput>>
  auth0Id_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  auth0Id_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  email_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  email_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  username_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  username_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type AtomOwnerUpdateConnectionInput = {
  node?: InputMaybe<UserUpdateInput>
}

export type AtomOwnerUpdateFieldInput = {
  connect?: InputMaybe<AtomOwnerConnectFieldInput>
  connectOrCreate?: InputMaybe<AtomOwnerConnectOrCreateFieldInput>
  create?: InputMaybe<AtomOwnerCreateFieldInput>
  delete?: InputMaybe<WithOwnerOwnerDeleteFieldInput>
  disconnect?: InputMaybe<WithOwnerOwnerDisconnectFieldInput>
  update?: InputMaybe<AtomOwnerUpdateConnectionInput>
  where?: InputMaybe<WithOwnerOwnerConnectionWhere>
}

export type AtomRequiredParentsAggregateInput = {
  AND?: InputMaybe<Array<AtomRequiredParentsAggregateInput>>
  NOT?: InputMaybe<AtomRequiredParentsAggregateInput>
  OR?: InputMaybe<Array<AtomRequiredParentsAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<AtomRequiredParentsNodeAggregationWhereInput>
}

export type AtomRequiredParentsConnectFieldInput = {
  connect?: InputMaybe<Array<AtomConnectInput>>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<AtomConnectWhere>
}

export type AtomRequiredParentsConnectOrCreateFieldInput = {
  onCreate: AtomRequiredParentsConnectOrCreateFieldInputOnCreate
  where: AtomConnectOrCreateWhere
}

export type AtomRequiredParentsConnectOrCreateFieldInputOnCreate = {
  node: AtomOnCreateInput
}

export type AtomRequiredParentsConnection = {
  edges: Array<AtomRequiredParentsRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type AtomRequiredParentsConnectionSort = {
  node?: InputMaybe<AtomSort>
}

export type AtomRequiredParentsConnectionWhere = {
  AND?: InputMaybe<Array<AtomRequiredParentsConnectionWhere>>
  NOT?: InputMaybe<AtomRequiredParentsConnectionWhere>
  OR?: InputMaybe<Array<AtomRequiredParentsConnectionWhere>>
  node?: InputMaybe<AtomWhere>
}

export type AtomRequiredParentsCreateFieldInput = {
  node: AtomCreateInput
}

export type AtomRequiredParentsDeleteFieldInput = {
  delete?: InputMaybe<AtomDeleteInput>
  where?: InputMaybe<AtomRequiredParentsConnectionWhere>
}

export type AtomRequiredParentsDisconnectFieldInput = {
  disconnect?: InputMaybe<AtomDisconnectInput>
  where?: InputMaybe<AtomRequiredParentsConnectionWhere>
}

export type AtomRequiredParentsFieldInput = {
  connect?: InputMaybe<Array<AtomRequiredParentsConnectFieldInput>>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<
    Array<AtomRequiredParentsConnectOrCreateFieldInput>
  >
  create?: InputMaybe<Array<AtomRequiredParentsCreateFieldInput>>
}

export type AtomRequiredParentsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<AtomRequiredParentsNodeAggregationWhereInput>>
  NOT?: InputMaybe<AtomRequiredParentsNodeAggregationWhereInput>
  OR?: InputMaybe<Array<AtomRequiredParentsNodeAggregationWhereInput>>
  externalCssSource_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  externalCssSource_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  externalCssSource_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  externalCssSource_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  externalCssSource_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  externalCssSource_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  externalCssSource_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  externalCssSource_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  externalCssSource_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  externalCssSource_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  externalCssSource_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  externalCssSource_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  externalCssSource_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  externalCssSource_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  externalCssSource_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  externalJsSource_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  externalJsSource_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  externalJsSource_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  externalJsSource_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  externalJsSource_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  externalJsSource_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  externalJsSource_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  externalJsSource_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  externalJsSource_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  externalJsSource_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  externalJsSource_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  externalJsSource_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  externalJsSource_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  externalJsSource_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  externalJsSource_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  externalSourceType_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  externalSourceType_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  externalSourceType_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  externalSourceType_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  externalSourceType_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  externalSourceType_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  externalSourceType_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  externalSourceType_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  externalSourceType_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  externalSourceType_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  externalSourceType_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  externalSourceType_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  externalSourceType_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  externalSourceType_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  externalSourceType_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  icon_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  icon_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  icon_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  icon_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  icon_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  icon_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  icon_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  icon_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  icon_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  icon_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  icon_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  icon_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  icon_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  icon_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  icon_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type AtomRequiredParentsRelationship = {
  cursor: Scalars['String']['output']
  node: Atom
}

export type AtomRequiredParentsUpdateConnectionInput = {
  node?: InputMaybe<AtomUpdateInput>
}

export type AtomRequiredParentsUpdateFieldInput = {
  connect?: InputMaybe<Array<AtomRequiredParentsConnectFieldInput>>
  connectOrCreate?: InputMaybe<
    Array<AtomRequiredParentsConnectOrCreateFieldInput>
  >
  create?: InputMaybe<Array<AtomRequiredParentsCreateFieldInput>>
  delete?: InputMaybe<Array<AtomRequiredParentsDeleteFieldInput>>
  disconnect?: InputMaybe<Array<AtomRequiredParentsDisconnectFieldInput>>
  update?: InputMaybe<AtomRequiredParentsUpdateConnectionInput>
  where?: InputMaybe<AtomRequiredParentsConnectionWhere>
}

/** Fields to sort Atoms by. The order in which sorts are applied is not guaranteed when specifying many fields in one AtomSort object. */
export type AtomSort = {
  externalCssSource?: InputMaybe<SortDirection>
  externalJsSource?: InputMaybe<SortDirection>
  externalSourceType?: InputMaybe<SortDirection>
  icon?: InputMaybe<SortDirection>
  id?: InputMaybe<SortDirection>
  name?: InputMaybe<SortDirection>
  type?: InputMaybe<SortDirection>
}

export type AtomSubscriptionWhere = {
  AND?: InputMaybe<Array<AtomSubscriptionWhere>>
  NOT?: InputMaybe<AtomSubscriptionWhere>
  OR?: InputMaybe<Array<AtomSubscriptionWhere>>
  /** @deprecated Please use the explicit _EQ version */
  externalCssSource?: InputMaybe<Scalars['String']['input']>
  externalCssSource_CONTAINS?: InputMaybe<Scalars['String']['input']>
  externalCssSource_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  externalCssSource_EQ?: InputMaybe<Scalars['String']['input']>
  externalCssSource_IN?: InputMaybe<
    Array<InputMaybe<Scalars['String']['input']>>
  >
  externalCssSource_MATCHES?: InputMaybe<Scalars['String']['input']>
  externalCssSource_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  externalJsSource?: InputMaybe<Scalars['String']['input']>
  externalJsSource_CONTAINS?: InputMaybe<Scalars['String']['input']>
  externalJsSource_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  externalJsSource_EQ?: InputMaybe<Scalars['String']['input']>
  externalJsSource_IN?: InputMaybe<
    Array<InputMaybe<Scalars['String']['input']>>
  >
  externalJsSource_MATCHES?: InputMaybe<Scalars['String']['input']>
  externalJsSource_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  externalSourceType?: InputMaybe<Scalars['String']['input']>
  externalSourceType_CONTAINS?: InputMaybe<Scalars['String']['input']>
  externalSourceType_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  externalSourceType_EQ?: InputMaybe<Scalars['String']['input']>
  externalSourceType_IN?: InputMaybe<
    Array<InputMaybe<Scalars['String']['input']>>
  >
  externalSourceType_MATCHES?: InputMaybe<Scalars['String']['input']>
  externalSourceType_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  icon?: InputMaybe<Scalars['String']['input']>
  icon_CONTAINS?: InputMaybe<Scalars['String']['input']>
  icon_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  icon_EQ?: InputMaybe<Scalars['String']['input']>
  icon_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>
  icon_MATCHES?: InputMaybe<Scalars['String']['input']>
  icon_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>
  name_MATCHES?: InputMaybe<Scalars['String']['input']>
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  type?: InputMaybe<AtomType>
  type_EQ?: InputMaybe<AtomType>
  type_IN?: InputMaybe<Array<AtomType>>
}

export type AtomSuggestedChildrenAggregateInput = {
  AND?: InputMaybe<Array<AtomSuggestedChildrenAggregateInput>>
  NOT?: InputMaybe<AtomSuggestedChildrenAggregateInput>
  OR?: InputMaybe<Array<AtomSuggestedChildrenAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<AtomSuggestedChildrenNodeAggregationWhereInput>
}

export type AtomSuggestedChildrenConnectFieldInput = {
  connect?: InputMaybe<Array<AtomConnectInput>>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<AtomConnectWhere>
}

export type AtomSuggestedChildrenConnectOrCreateFieldInput = {
  onCreate: AtomSuggestedChildrenConnectOrCreateFieldInputOnCreate
  where: AtomConnectOrCreateWhere
}

export type AtomSuggestedChildrenConnectOrCreateFieldInputOnCreate = {
  node: AtomOnCreateInput
}

export type AtomSuggestedChildrenConnection = {
  edges: Array<AtomSuggestedChildrenRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type AtomSuggestedChildrenConnectionSort = {
  node?: InputMaybe<AtomSort>
}

export type AtomSuggestedChildrenConnectionWhere = {
  AND?: InputMaybe<Array<AtomSuggestedChildrenConnectionWhere>>
  NOT?: InputMaybe<AtomSuggestedChildrenConnectionWhere>
  OR?: InputMaybe<Array<AtomSuggestedChildrenConnectionWhere>>
  node?: InputMaybe<AtomWhere>
}

export type AtomSuggestedChildrenCreateFieldInput = {
  node: AtomCreateInput
}

export type AtomSuggestedChildrenDeleteFieldInput = {
  delete?: InputMaybe<AtomDeleteInput>
  where?: InputMaybe<AtomSuggestedChildrenConnectionWhere>
}

export type AtomSuggestedChildrenDisconnectFieldInput = {
  disconnect?: InputMaybe<AtomDisconnectInput>
  where?: InputMaybe<AtomSuggestedChildrenConnectionWhere>
}

export type AtomSuggestedChildrenFieldInput = {
  connect?: InputMaybe<Array<AtomSuggestedChildrenConnectFieldInput>>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<
    Array<AtomSuggestedChildrenConnectOrCreateFieldInput>
  >
  create?: InputMaybe<Array<AtomSuggestedChildrenCreateFieldInput>>
}

export type AtomSuggestedChildrenNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<AtomSuggestedChildrenNodeAggregationWhereInput>>
  NOT?: InputMaybe<AtomSuggestedChildrenNodeAggregationWhereInput>
  OR?: InputMaybe<Array<AtomSuggestedChildrenNodeAggregationWhereInput>>
  externalCssSource_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  externalCssSource_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  externalCssSource_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  externalCssSource_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  externalCssSource_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  externalCssSource_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  externalCssSource_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  externalCssSource_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  externalCssSource_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  externalCssSource_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  externalCssSource_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  externalCssSource_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  externalCssSource_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  externalCssSource_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  externalCssSource_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  externalJsSource_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  externalJsSource_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  externalJsSource_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  externalJsSource_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  externalJsSource_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  externalJsSource_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  externalJsSource_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  externalJsSource_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  externalJsSource_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  externalJsSource_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  externalJsSource_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  externalJsSource_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  externalJsSource_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  externalJsSource_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  externalJsSource_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  externalSourceType_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  externalSourceType_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  externalSourceType_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  externalSourceType_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  externalSourceType_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  externalSourceType_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  externalSourceType_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  externalSourceType_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  externalSourceType_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  externalSourceType_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  externalSourceType_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  externalSourceType_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  externalSourceType_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  externalSourceType_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  externalSourceType_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  icon_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  icon_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  icon_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  icon_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  icon_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  icon_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  icon_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  icon_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  icon_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  icon_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  icon_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  icon_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  icon_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  icon_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  icon_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type AtomSuggestedChildrenRelationship = {
  cursor: Scalars['String']['output']
  node: Atom
}

export type AtomSuggestedChildrenUpdateConnectionInput = {
  node?: InputMaybe<AtomUpdateInput>
}

export type AtomSuggestedChildrenUpdateFieldInput = {
  connect?: InputMaybe<Array<AtomSuggestedChildrenConnectFieldInput>>
  connectOrCreate?: InputMaybe<
    Array<AtomSuggestedChildrenConnectOrCreateFieldInput>
  >
  create?: InputMaybe<Array<AtomSuggestedChildrenCreateFieldInput>>
  delete?: InputMaybe<Array<AtomSuggestedChildrenDeleteFieldInput>>
  disconnect?: InputMaybe<Array<AtomSuggestedChildrenDisconnectFieldInput>>
  update?: InputMaybe<AtomSuggestedChildrenUpdateConnectionInput>
  where?: InputMaybe<AtomSuggestedChildrenConnectionWhere>
}

export type AtomTagTagsAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<AtomTagTagsNodeAggregateSelection>
}

export type AtomTagTagsNodeAggregateSelection = {
  id: IdAggregateSelection
  name: StringAggregateSelection
}

export type AtomTagsAggregateInput = {
  AND?: InputMaybe<Array<AtomTagsAggregateInput>>
  NOT?: InputMaybe<AtomTagsAggregateInput>
  OR?: InputMaybe<Array<AtomTagsAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<AtomTagsNodeAggregationWhereInput>
}

export type AtomTagsConnectFieldInput = {
  connect?: InputMaybe<Array<TagConnectInput>>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<TagConnectWhere>
}

export type AtomTagsConnectOrCreateFieldInput = {
  onCreate: AtomTagsConnectOrCreateFieldInputOnCreate
  where: TagConnectOrCreateWhere
}

export type AtomTagsConnectOrCreateFieldInputOnCreate = {
  node: TagOnCreateInput
}

export type AtomTagsConnection = {
  edges: Array<AtomTagsRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type AtomTagsConnectionSort = {
  node?: InputMaybe<TagSort>
}

export type AtomTagsConnectionWhere = {
  AND?: InputMaybe<Array<AtomTagsConnectionWhere>>
  NOT?: InputMaybe<AtomTagsConnectionWhere>
  OR?: InputMaybe<Array<AtomTagsConnectionWhere>>
  node?: InputMaybe<TagWhere>
}

export type AtomTagsCreateFieldInput = {
  node: TagCreateInput
}

export type AtomTagsDeleteFieldInput = {
  delete?: InputMaybe<TagDeleteInput>
  where?: InputMaybe<AtomTagsConnectionWhere>
}

export type AtomTagsDisconnectFieldInput = {
  disconnect?: InputMaybe<TagDisconnectInput>
  where?: InputMaybe<AtomTagsConnectionWhere>
}

export type AtomTagsFieldInput = {
  connect?: InputMaybe<Array<AtomTagsConnectFieldInput>>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<Array<AtomTagsConnectOrCreateFieldInput>>
  create?: InputMaybe<Array<AtomTagsCreateFieldInput>>
}

export type AtomTagsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<AtomTagsNodeAggregationWhereInput>>
  NOT?: InputMaybe<AtomTagsNodeAggregationWhereInput>
  OR?: InputMaybe<Array<AtomTagsNodeAggregationWhereInput>>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type AtomTagsRelationship = {
  cursor: Scalars['String']['output']
  node: Tag
}

export type AtomTagsUpdateConnectionInput = {
  node?: InputMaybe<TagUpdateInput>
}

export type AtomTagsUpdateFieldInput = {
  connect?: InputMaybe<Array<AtomTagsConnectFieldInput>>
  connectOrCreate?: InputMaybe<Array<AtomTagsConnectOrCreateFieldInput>>
  create?: InputMaybe<Array<AtomTagsCreateFieldInput>>
  delete?: InputMaybe<Array<AtomTagsDeleteFieldInput>>
  disconnect?: InputMaybe<Array<AtomTagsDisconnectFieldInput>>
  update?: InputMaybe<AtomTagsUpdateConnectionInput>
  where?: InputMaybe<AtomTagsConnectionWhere>
}

export enum AtomType {
  AntDesignAffix = 'AntDesignAffix',
  AntDesignAlert = 'AntDesignAlert',
  AntDesignAnchor = 'AntDesignAnchor',
  AntDesignAnchorLink = 'AntDesignAnchorLink',
  AntDesignAutoComplete = 'AntDesignAutoComplete',
  AntDesignAvatar = 'AntDesignAvatar',
  AntDesignBackTop = 'AntDesignBackTop',
  AntDesignBadge = 'AntDesignBadge',
  AntDesignBreadcrumb = 'AntDesignBreadcrumb',
  AntDesignBreadcrumbItem = 'AntDesignBreadcrumbItem',
  AntDesignBreadcrumbSeparator = 'AntDesignBreadcrumbSeparator',
  AntDesignButton = 'AntDesignButton',
  AntDesignCalendar = 'AntDesignCalendar',
  AntDesignCard = 'AntDesignCard',
  AntDesignCardGrid = 'AntDesignCardGrid',
  AntDesignCardMeta = 'AntDesignCardMeta',
  AntDesignCarousel = 'AntDesignCarousel',
  AntDesignCascader = 'AntDesignCascader',
  AntDesignCheckbox = 'AntDesignCheckbox',
  AntDesignCheckboxGroup = 'AntDesignCheckboxGroup',
  AntDesignCollapse = 'AntDesignCollapse',
  AntDesignCollapsePanel = 'AntDesignCollapsePanel',
  AntDesignComment = 'AntDesignComment',
  AntDesignConfigProvider = 'AntDesignConfigProvider',
  AntDesignDatePicker = 'AntDesignDatePicker',
  AntDesignDescriptions = 'AntDesignDescriptions',
  AntDesignDescriptionsItem = 'AntDesignDescriptionsItem',
  AntDesignDivider = 'AntDesignDivider',
  AntDesignDrawer = 'AntDesignDrawer',
  AntDesignDropdown = 'AntDesignDropdown',
  AntDesignDropdownButton = 'AntDesignDropdownButton',
  AntDesignEmpty = 'AntDesignEmpty',
  AntDesignForm = 'AntDesignForm',
  AntDesignFormErrorList = 'AntDesignFormErrorList',
  AntDesignFormItem = 'AntDesignFormItem',
  AntDesignFormList = 'AntDesignFormList',
  AntDesignFormProvider = 'AntDesignFormProvider',
  AntDesignGridCol = 'AntDesignGridCol',
  AntDesignGridRow = 'AntDesignGridRow',
  AntDesignIcon = 'AntDesignIcon',
  AntDesignImage = 'AntDesignImage',
  AntDesignInput = 'AntDesignInput',
  AntDesignInputNumber = 'AntDesignInputNumber',
  AntDesignInputSearch = 'AntDesignInputSearch',
  AntDesignInputTextArea = 'AntDesignInputTextArea',
  AntDesignLayout = 'AntDesignLayout',
  AntDesignLayoutContent = 'AntDesignLayoutContent',
  AntDesignLayoutFooter = 'AntDesignLayoutFooter',
  AntDesignLayoutHeader = 'AntDesignLayoutHeader',
  AntDesignLayoutSider = 'AntDesignLayoutSider',
  AntDesignList = 'AntDesignList',
  AntDesignListItem = 'AntDesignListItem',
  AntDesignListItemMeta = 'AntDesignListItemMeta',
  AntDesignMentions = 'AntDesignMentions',
  AntDesignMentionsOption = 'AntDesignMentionsOption',
  AntDesignMenu = 'AntDesignMenu',
  AntDesignMessage = 'AntDesignMessage',
  AntDesignModal = 'AntDesignModal',
  AntDesignNotification = 'AntDesignNotification',
  AntDesignPagination = 'AntDesignPagination',
  AntDesignPopconfirm = 'AntDesignPopconfirm',
  AntDesignPopover = 'AntDesignPopover',
  AntDesignProgress = 'AntDesignProgress',
  AntDesignRadio = 'AntDesignRadio',
  AntDesignRadioGroup = 'AntDesignRadioGroup',
  AntDesignRate = 'AntDesignRate',
  AntDesignResult = 'AntDesignResult',
  AntDesignSegmented = 'AntDesignSegmented',
  AntDesignSelect = 'AntDesignSelect',
  AntDesignSelectOption = 'AntDesignSelectOption',
  AntDesignSkeleton = 'AntDesignSkeleton',
  AntDesignSlider = 'AntDesignSlider',
  AntDesignSpace = 'AntDesignSpace',
  AntDesignSpin = 'AntDesignSpin',
  AntDesignStatistic = 'AntDesignStatistic',
  AntDesignSteps = 'AntDesignSteps',
  AntDesignStepsStep = 'AntDesignStepsStep',
  AntDesignSwitch = 'AntDesignSwitch',
  AntDesignTable = 'AntDesignTable',
  AntDesignTabs = 'AntDesignTabs',
  AntDesignTabsTabPane = 'AntDesignTabsTabPane',
  AntDesignTag = 'AntDesignTag',
  AntDesignTimePicker = 'AntDesignTimePicker',
  AntDesignTimeline = 'AntDesignTimeline',
  AntDesignTimelineItem = 'AntDesignTimelineItem',
  AntDesignTooltip = 'AntDesignTooltip',
  AntDesignTransfer = 'AntDesignTransfer',
  AntDesignTree = 'AntDesignTree',
  AntDesignTreeSelect = 'AntDesignTreeSelect',
  AntDesignTypographyParagraph = 'AntDesignTypographyParagraph',
  AntDesignTypographyText = 'AntDesignTypographyText',
  AntDesignTypographyTitle = 'AntDesignTypographyTitle',
  AntDesignUpload = 'AntDesignUpload',
  ExternalComponent = 'ExternalComponent',
  GridLayout = 'GridLayout',
  HookGraphqlMutation = 'HookGraphqlMutation',
  HookGraphqlQuery = 'HookGraphqlQuery',
  HookQueryConfig = 'HookQueryConfig',
  HookQueryLambda = 'HookQueryLambda',
  HookQueryPage = 'HookQueryPage',
  HookQueryPages = 'HookQueryPages',
  HookRecoilState = 'HookRecoilState',
  HookRouter = 'HookRouter',
  HtmlA = 'HtmlA',
  HtmlAbbr = 'HtmlAbbr',
  HtmlArea = 'HtmlArea',
  HtmlArticle = 'HtmlArticle',
  HtmlAside = 'HtmlAside',
  HtmlAudio = 'HtmlAudio',
  HtmlB = 'HtmlB',
  HtmlBase = 'HtmlBase',
  HtmlBdo = 'HtmlBdo',
  HtmlBlockquote = 'HtmlBlockquote',
  HtmlBr = 'HtmlBr',
  HtmlButton = 'HtmlButton',
  HtmlCanvas = 'HtmlCanvas',
  HtmlCaption = 'HtmlCaption',
  HtmlCite = 'HtmlCite',
  HtmlCode = 'HtmlCode',
  HtmlCol = 'HtmlCol',
  HtmlData = 'HtmlData',
  HtmlDatalist = 'HtmlDatalist',
  HtmlDetails = 'HtmlDetails',
  HtmlDfn = 'HtmlDfn',
  HtmlDialog = 'HtmlDialog',
  HtmlDiv = 'HtmlDiv',
  HtmlDl = 'HtmlDl',
  HtmlEm = 'HtmlEm',
  HtmlEmbed = 'HtmlEmbed',
  HtmlFieldset = 'HtmlFieldset',
  HtmlFooter = 'HtmlFooter',
  HtmlForm = 'HtmlForm',
  HtmlH1 = 'HtmlH1',
  HtmlH2 = 'HtmlH2',
  HtmlH3 = 'HtmlH3',
  HtmlH4 = 'HtmlH4',
  HtmlH5 = 'HtmlH5',
  HtmlH6 = 'HtmlH6',
  HtmlHead = 'HtmlHead',
  HtmlHeader = 'HtmlHeader',
  HtmlHr = 'HtmlHr',
  HtmlI = 'HtmlI',
  HtmlIframe = 'HtmlIframe',
  HtmlImg = 'HtmlImg',
  HtmlInput = 'HtmlInput',
  HtmlKbd = 'HtmlKbd',
  HtmlLabel = 'HtmlLabel',
  HtmlLegend = 'HtmlLegend',
  HtmlLi = 'HtmlLi',
  HtmlLink = 'HtmlLink',
  HtmlMain = 'HtmlMain',
  HtmlMap = 'HtmlMap',
  HtmlMark = 'HtmlMark',
  HtmlMath = 'HtmlMath',
  HtmlMeta = 'HtmlMeta',
  HtmlMeter = 'HtmlMeter',
  HtmlNav = 'HtmlNav',
  HtmlNoscript = 'HtmlNoscript',
  HtmlObject = 'HtmlObject',
  HtmlOl = 'HtmlOl',
  HtmlOptgroup = 'HtmlOptgroup',
  HtmlOption = 'HtmlOption',
  HtmlOutput = 'HtmlOutput',
  HtmlP = 'HtmlP',
  HtmlParam = 'HtmlParam',
  HtmlPicture = 'HtmlPicture',
  HtmlPre = 'HtmlPre',
  HtmlProgress = 'HtmlProgress',
  HtmlQ = 'HtmlQ',
  HtmlRuby = 'HtmlRuby',
  HtmlS = 'HtmlS',
  HtmlSamp = 'HtmlSamp',
  HtmlScript = 'HtmlScript',
  HtmlSection = 'HtmlSection',
  HtmlSelect = 'HtmlSelect',
  HtmlSmall = 'HtmlSmall',
  HtmlSource = 'HtmlSource',
  HtmlSpan = 'HtmlSpan',
  HtmlStrong = 'HtmlStrong',
  HtmlStyle = 'HtmlStyle',
  HtmlSub = 'HtmlSub',
  HtmlSup = 'HtmlSup',
  HtmlSvg = 'HtmlSvg',
  HtmlTable = 'HtmlTable',
  HtmlTd = 'HtmlTd',
  HtmlTemplate = 'HtmlTemplate',
  HtmlTextarea = 'HtmlTextarea',
  HtmlTh = 'HtmlTh',
  HtmlTime = 'HtmlTime',
  HtmlTitle = 'HtmlTitle',
  HtmlTr = 'HtmlTr',
  HtmlTrack = 'HtmlTrack',
  HtmlU = 'HtmlU',
  HtmlUl = 'HtmlUl',
  HtmlVar = 'HtmlVar',
  HtmlVideo = 'HtmlVideo',
  HtmlWbr = 'HtmlWbr',
  LexicalEditor = 'LexicalEditor',
  MuiAccordion = 'MuiAccordion',
  MuiAccordionActions = 'MuiAccordionActions',
  MuiAccordionDetails = 'MuiAccordionDetails',
  MuiAccordionSummary = 'MuiAccordionSummary',
  MuiAlert = 'MuiAlert',
  MuiAlertTitle = 'MuiAlertTitle',
  MuiAppBar = 'MuiAppBar',
  MuiAutocomplete = 'MuiAutocomplete',
  MuiAvatar = 'MuiAvatar',
  MuiAvatarGroup = 'MuiAvatarGroup',
  MuiBackdrop = 'MuiBackdrop',
  MuiBadge = 'MuiBadge',
  MuiBadgeUnstyled = 'MuiBadgeUnstyled',
  MuiBottomNavigation = 'MuiBottomNavigation',
  MuiBottomNavigationAction = 'MuiBottomNavigationAction',
  MuiBox = 'MuiBox',
  MuiBreadcrumbs = 'MuiBreadcrumbs',
  MuiButton = 'MuiButton',
  MuiButtonBase = 'MuiButtonBase',
  MuiButtonGroup = 'MuiButtonGroup',
  MuiButtonUnstyled = 'MuiButtonUnstyled',
  MuiCalendarPicker = 'MuiCalendarPicker',
  MuiCalendarPickerSkeleton = 'MuiCalendarPickerSkeleton',
  MuiCard = 'MuiCard',
  MuiCardActionArea = 'MuiCardActionArea',
  MuiCardActions = 'MuiCardActions',
  MuiCardContent = 'MuiCardContent',
  MuiCardHeader = 'MuiCardHeader',
  MuiCardMedia = 'MuiCardMedia',
  MuiCheckbox = 'MuiCheckbox',
  MuiChip = 'MuiChip',
  MuiCircularProgress = 'MuiCircularProgress',
  MuiClickAwayListener = 'MuiClickAwayListener',
  MuiClockPicker = 'MuiClockPicker',
  MuiCollapse = 'MuiCollapse',
  MuiContainer = 'MuiContainer',
  MuiCssBaseline = 'MuiCssBaseline',
  MuiDataGrid = 'MuiDataGrid',
  MuiDatePicker = 'MuiDatePicker',
  MuiDateRangePicker = 'MuiDateRangePicker',
  MuiDateRangePickerDay = 'MuiDateRangePickerDay',
  MuiDateTimePicker = 'MuiDateTimePicker',
  MuiDesktopDatePicker = 'MuiDesktopDatePicker',
  MuiDesktopDateRangePicker = 'MuiDesktopDateRangePicker',
  MuiDesktopDateTimePicker = 'MuiDesktopDateTimePicker',
  MuiDesktopTimePicker = 'MuiDesktopTimePicker',
  MuiDialog = 'MuiDialog',
  MuiDialogActions = 'MuiDialogActions',
  MuiDialogContent = 'MuiDialogContent',
  MuiDialogContentText = 'MuiDialogContentText',
  MuiDialogTitle = 'MuiDialogTitle',
  MuiDivider = 'MuiDivider',
  MuiDrawer = 'MuiDrawer',
  MuiFab = 'MuiFab',
  MuiFade = 'MuiFade',
  MuiFilledInput = 'MuiFilledInput',
  MuiFormControl = 'MuiFormControl',
  MuiFormControlLabel = 'MuiFormControlLabel',
  MuiFormControlUnstyled = 'MuiFormControlUnstyled',
  MuiFormGroup = 'MuiFormGroup',
  MuiFormHelperText = 'MuiFormHelperText',
  MuiFormLabel = 'MuiFormLabel',
  MuiGlobalStyles = 'MuiGlobalStyles',
  MuiGrid = 'MuiGrid',
  MuiGridColDef = 'MuiGridColDef',
  MuiGrow = 'MuiGrow',
  MuiHidden = 'MuiHidden',
  MuiIcon = 'MuiIcon',
  MuiIconButton = 'MuiIconButton',
  MuiImageList = 'MuiImageList',
  MuiImageListItem = 'MuiImageListItem',
  MuiImageListItemBar = 'MuiImageListItemBar',
  MuiInput = 'MuiInput',
  MuiInputAdornment = 'MuiInputAdornment',
  MuiInputBase = 'MuiInputBase',
  MuiInputLabel = 'MuiInputLabel',
  MuiLinearProgress = 'MuiLinearProgress',
  MuiLink = 'MuiLink',
  MuiList = 'MuiList',
  MuiListItem = 'MuiListItem',
  MuiListItemAvatar = 'MuiListItemAvatar',
  MuiListItemButton = 'MuiListItemButton',
  MuiListItemIcon = 'MuiListItemIcon',
  MuiListItemSecondaryAction = 'MuiListItemSecondaryAction',
  MuiListItemText = 'MuiListItemText',
  MuiListSubheader = 'MuiListSubheader',
  MuiLoadingButton = 'MuiLoadingButton',
  MuiMasonry = 'MuiMasonry',
  MuiMasonryItem = 'MuiMasonryItem',
  MuiMenu = 'MuiMenu',
  MuiMenuItem = 'MuiMenuItem',
  MuiMenuList = 'MuiMenuList',
  MuiMobileDatePicker = 'MuiMobileDatePicker',
  MuiMobileDateRangePicker = 'MuiMobileDateRangePicker',
  MuiMobileDateTimePicker = 'MuiMobileDateTimePicker',
  MuiMobileStepper = 'MuiMobileStepper',
  MuiMobileTimePicker = 'MuiMobileTimePicker',
  MuiModal = 'MuiModal',
  MuiModalUnstyled = 'MuiModalUnstyled',
  MuiMonthPicker = 'MuiMonthPicker',
  MuiNativeSelect = 'MuiNativeSelect',
  MuiNoSsr = 'MuiNoSsr',
  MuiOutlinedInput = 'MuiOutlinedInput',
  MuiPagination = 'MuiPagination',
  MuiPaginationItem = 'MuiPaginationItem',
  MuiPaper = 'MuiPaper',
  MuiPickersDay = 'MuiPickersDay',
  MuiPopover = 'MuiPopover',
  MuiPopper = 'MuiPopper',
  MuiPortal = 'MuiPortal',
  MuiRadio = 'MuiRadio',
  MuiRadioGroup = 'MuiRadioGroup',
  MuiRating = 'MuiRating',
  MuiScopedCssBaseline = 'MuiScopedCssBaseline',
  MuiSelect = 'MuiSelect',
  MuiSkeleton = 'MuiSkeleton',
  MuiSlide = 'MuiSlide',
  MuiSlider = 'MuiSlider',
  MuiSliderUnstyled = 'MuiSliderUnstyled',
  MuiSnackbar = 'MuiSnackbar',
  MuiSnackbarContent = 'MuiSnackbarContent',
  MuiSpeedDial = 'MuiSpeedDial',
  MuiSpeedDialAction = 'MuiSpeedDialAction',
  MuiSpeedDialIcon = 'MuiSpeedDialIcon',
  MuiStack = 'MuiStack',
  MuiStaticDatePicker = 'MuiStaticDatePicker',
  MuiStaticDateRangePicker = 'MuiStaticDateRangePicker',
  MuiStaticDateTimePicker = 'MuiStaticDateTimePicker',
  MuiStaticTimePicker = 'MuiStaticTimePicker',
  MuiStep = 'MuiStep',
  MuiStepButton = 'MuiStepButton',
  MuiStepConnector = 'MuiStepConnector',
  MuiStepContent = 'MuiStepContent',
  MuiStepIcon = 'MuiStepIcon',
  MuiStepLabel = 'MuiStepLabel',
  MuiStepper = 'MuiStepper',
  MuiSvgIcon = 'MuiSvgIcon',
  MuiSwipeableDrawer = 'MuiSwipeableDrawer',
  MuiSwitch = 'MuiSwitch',
  MuiSwitchUnstyled = 'MuiSwitchUnstyled',
  MuiTab = 'MuiTab',
  MuiTabContext = 'MuiTabContext',
  MuiTabList = 'MuiTabList',
  MuiTabPanel = 'MuiTabPanel',
  MuiTabScrollButton = 'MuiTabScrollButton',
  MuiTable = 'MuiTable',
  MuiTableBody = 'MuiTableBody',
  MuiTableCell = 'MuiTableCell',
  MuiTableContainer = 'MuiTableContainer',
  MuiTableFooter = 'MuiTableFooter',
  MuiTableHead = 'MuiTableHead',
  MuiTablePagination = 'MuiTablePagination',
  MuiTableRow = 'MuiTableRow',
  MuiTableSortLabel = 'MuiTableSortLabel',
  MuiTabs = 'MuiTabs',
  MuiTextField = 'MuiTextField',
  MuiTextareaAutosize = 'MuiTextareaAutosize',
  MuiTimePicker = 'MuiTimePicker',
  MuiTimeline = 'MuiTimeline',
  MuiTimelineConnector = 'MuiTimelineConnector',
  MuiTimelineContent = 'MuiTimelineContent',
  MuiTimelineDot = 'MuiTimelineDot',
  MuiTimelineItem = 'MuiTimelineItem',
  MuiTimelineOppositeContent = 'MuiTimelineOppositeContent',
  MuiTimelineSeparator = 'MuiTimelineSeparator',
  MuiToggleButton = 'MuiToggleButton',
  MuiToggleButtonGroup = 'MuiToggleButtonGroup',
  MuiToolbar = 'MuiToolbar',
  MuiTooltip = 'MuiTooltip',
  MuiTreeItem = 'MuiTreeItem',
  MuiTreeView = 'MuiTreeView',
  MuiTypography = 'MuiTypography',
  MuiUnstableTrapFocus = 'MuiUnstableTrapFocus',
  MuiYearPicker = 'MuiYearPicker',
  MuiZoom = 'MuiZoom',
  NextLink = 'NextLink',
  Query = 'Query',
  ReactFragment = 'ReactFragment',
  Script = 'Script',
  State = 'State',
  Text = 'Text',
  TextList = 'TextList',
}

export type AtomUniqueWhere = {
  /** @deprecated Please use the explicit _EQ version */
  externalSourceType?: InputMaybe<Scalars['String']['input']>
  externalSourceType_EQ?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  type?: InputMaybe<AtomType>
  type_EQ?: InputMaybe<AtomType>
}

export type AtomUpdateInput = {
  api?: InputMaybe<AtomApiUpdateFieldInput>
  elements?: InputMaybe<Array<AtomElementsUpdateFieldInput>>
  /** @deprecated Please use the explicit _SET field */
  externalCssSource?: InputMaybe<Scalars['String']['input']>
  externalCssSource_SET?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _SET field */
  externalJsSource?: InputMaybe<Scalars['String']['input']>
  externalJsSource_SET?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _SET field */
  externalSourceType?: InputMaybe<Scalars['String']['input']>
  externalSourceType_SET?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _SET field */
  icon?: InputMaybe<Scalars['String']['input']>
  icon_SET?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _SET field */
  name?: InputMaybe<Scalars['String']['input']>
  name_SET?: InputMaybe<Scalars['String']['input']>
  owner?: InputMaybe<AtomOwnerUpdateFieldInput>
  requiredParents?: InputMaybe<Array<AtomRequiredParentsUpdateFieldInput>>
  suggestedChildren?: InputMaybe<Array<AtomSuggestedChildrenUpdateFieldInput>>
  tags?: InputMaybe<Array<AtomTagsUpdateFieldInput>>
  /** @deprecated Please use the explicit _SET field */
  type?: InputMaybe<AtomType>
  type_SET?: InputMaybe<AtomType>
}

export type AtomUpdatedEvent = {
  event: EventType
  previousState: AtomEventPayload
  timestamp: Scalars['Float']['output']
  updatedAtom: AtomEventPayload
}

export type AtomUserOwnerAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<AtomUserOwnerNodeAggregateSelection>
}

export type AtomUserOwnerNodeAggregateSelection = {
  auth0Id: StringAggregateSelection
  email: StringAggregateSelection
  id: IdAggregateSelection
  username: StringAggregateSelection
}

export type AtomWhere = {
  AND?: InputMaybe<Array<AtomWhere>>
  NOT?: InputMaybe<AtomWhere>
  OR?: InputMaybe<Array<AtomWhere>>
  api?: InputMaybe<InterfaceTypeWhere>
  apiAggregate?: InputMaybe<AtomApiAggregateInput>
  apiConnection?: InputMaybe<AtomApiConnectionWhere>
  elementsAggregate?: InputMaybe<AtomElementsAggregateInput>
  /** Return Atoms where all of the related AtomElementsConnections match this filter */
  elementsConnection_ALL?: InputMaybe<AtomElementsConnectionWhere>
  /** Return Atoms where none of the related AtomElementsConnections match this filter */
  elementsConnection_NONE?: InputMaybe<AtomElementsConnectionWhere>
  /** Return Atoms where one of the related AtomElementsConnections match this filter */
  elementsConnection_SINGLE?: InputMaybe<AtomElementsConnectionWhere>
  /** Return Atoms where some of the related AtomElementsConnections match this filter */
  elementsConnection_SOME?: InputMaybe<AtomElementsConnectionWhere>
  /** Return Atoms where all of the related Elements match this filter */
  elements_ALL?: InputMaybe<ElementWhere>
  /** Return Atoms where none of the related Elements match this filter */
  elements_NONE?: InputMaybe<ElementWhere>
  /** Return Atoms where one of the related Elements match this filter */
  elements_SINGLE?: InputMaybe<ElementWhere>
  /** Return Atoms where some of the related Elements match this filter */
  elements_SOME?: InputMaybe<ElementWhere>
  /** @deprecated Please use the explicit _EQ version */
  externalCssSource?: InputMaybe<Scalars['String']['input']>
  externalCssSource_CONTAINS?: InputMaybe<Scalars['String']['input']>
  externalCssSource_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  externalCssSource_EQ?: InputMaybe<Scalars['String']['input']>
  externalCssSource_IN?: InputMaybe<
    Array<InputMaybe<Scalars['String']['input']>>
  >
  externalCssSource_MATCHES?: InputMaybe<Scalars['String']['input']>
  externalCssSource_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  externalJsSource?: InputMaybe<Scalars['String']['input']>
  externalJsSource_CONTAINS?: InputMaybe<Scalars['String']['input']>
  externalJsSource_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  externalJsSource_EQ?: InputMaybe<Scalars['String']['input']>
  externalJsSource_IN?: InputMaybe<
    Array<InputMaybe<Scalars['String']['input']>>
  >
  externalJsSource_MATCHES?: InputMaybe<Scalars['String']['input']>
  externalJsSource_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  externalSourceType?: InputMaybe<Scalars['String']['input']>
  externalSourceType_CONTAINS?: InputMaybe<Scalars['String']['input']>
  externalSourceType_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  externalSourceType_EQ?: InputMaybe<Scalars['String']['input']>
  externalSourceType_IN?: InputMaybe<
    Array<InputMaybe<Scalars['String']['input']>>
  >
  externalSourceType_MATCHES?: InputMaybe<Scalars['String']['input']>
  externalSourceType_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  icon?: InputMaybe<Scalars['String']['input']>
  icon_CONTAINS?: InputMaybe<Scalars['String']['input']>
  icon_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  icon_EQ?: InputMaybe<Scalars['String']['input']>
  icon_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>
  icon_MATCHES?: InputMaybe<Scalars['String']['input']>
  icon_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>
  name_MATCHES?: InputMaybe<Scalars['String']['input']>
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  owner?: InputMaybe<UserWhere>
  ownerAggregate?: InputMaybe<AtomOwnerAggregateInput>
  ownerConnection?: InputMaybe<WithOwnerOwnerConnectionWhere>
  requiredParentsAggregate?: InputMaybe<AtomRequiredParentsAggregateInput>
  /** Return Atoms where all of the related AtomRequiredParentsConnections match this filter */
  requiredParentsConnection_ALL?: InputMaybe<AtomRequiredParentsConnectionWhere>
  /** Return Atoms where none of the related AtomRequiredParentsConnections match this filter */
  requiredParentsConnection_NONE?: InputMaybe<AtomRequiredParentsConnectionWhere>
  /** Return Atoms where one of the related AtomRequiredParentsConnections match this filter */
  requiredParentsConnection_SINGLE?: InputMaybe<AtomRequiredParentsConnectionWhere>
  /** Return Atoms where some of the related AtomRequiredParentsConnections match this filter */
  requiredParentsConnection_SOME?: InputMaybe<AtomRequiredParentsConnectionWhere>
  /** Return Atoms where all of the related Atoms match this filter */
  requiredParents_ALL?: InputMaybe<AtomWhere>
  /** Return Atoms where none of the related Atoms match this filter */
  requiredParents_NONE?: InputMaybe<AtomWhere>
  /** Return Atoms where one of the related Atoms match this filter */
  requiredParents_SINGLE?: InputMaybe<AtomWhere>
  /** Return Atoms where some of the related Atoms match this filter */
  requiredParents_SOME?: InputMaybe<AtomWhere>
  suggestedChildrenAggregate?: InputMaybe<AtomSuggestedChildrenAggregateInput>
  /** Return Atoms where all of the related AtomSuggestedChildrenConnections match this filter */
  suggestedChildrenConnection_ALL?: InputMaybe<AtomSuggestedChildrenConnectionWhere>
  /** Return Atoms where none of the related AtomSuggestedChildrenConnections match this filter */
  suggestedChildrenConnection_NONE?: InputMaybe<AtomSuggestedChildrenConnectionWhere>
  /** Return Atoms where one of the related AtomSuggestedChildrenConnections match this filter */
  suggestedChildrenConnection_SINGLE?: InputMaybe<AtomSuggestedChildrenConnectionWhere>
  /** Return Atoms where some of the related AtomSuggestedChildrenConnections match this filter */
  suggestedChildrenConnection_SOME?: InputMaybe<AtomSuggestedChildrenConnectionWhere>
  /** Return Atoms where all of the related Atoms match this filter */
  suggestedChildren_ALL?: InputMaybe<AtomWhere>
  /** Return Atoms where none of the related Atoms match this filter */
  suggestedChildren_NONE?: InputMaybe<AtomWhere>
  /** Return Atoms where one of the related Atoms match this filter */
  suggestedChildren_SINGLE?: InputMaybe<AtomWhere>
  /** Return Atoms where some of the related Atoms match this filter */
  suggestedChildren_SOME?: InputMaybe<AtomWhere>
  tagsAggregate?: InputMaybe<AtomTagsAggregateInput>
  /** Return Atoms where all of the related AtomTagsConnections match this filter */
  tagsConnection_ALL?: InputMaybe<AtomTagsConnectionWhere>
  /** Return Atoms where none of the related AtomTagsConnections match this filter */
  tagsConnection_NONE?: InputMaybe<AtomTagsConnectionWhere>
  /** Return Atoms where one of the related AtomTagsConnections match this filter */
  tagsConnection_SINGLE?: InputMaybe<AtomTagsConnectionWhere>
  /** Return Atoms where some of the related AtomTagsConnections match this filter */
  tagsConnection_SOME?: InputMaybe<AtomTagsConnectionWhere>
  /** Return Atoms where all of the related Tags match this filter */
  tags_ALL?: InputMaybe<TagWhere>
  /** Return Atoms where none of the related Tags match this filter */
  tags_NONE?: InputMaybe<TagWhere>
  /** Return Atoms where one of the related Tags match this filter */
  tags_SINGLE?: InputMaybe<TagWhere>
  /** Return Atoms where some of the related Tags match this filter */
  tags_SOME?: InputMaybe<TagWhere>
  /** @deprecated Please use the explicit _EQ version */
  type?: InputMaybe<AtomType>
  type_EQ?: InputMaybe<AtomType>
  type_IN?: InputMaybe<Array<AtomType>>
}

export type AtomsConnection = {
  edges: Array<AtomEdge>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type AuthGuard = WithOwner & {
  config: Prop
  configAggregate?: Maybe<AuthGuardPropConfigAggregationSelection>
  configConnection: AuthGuardConfigConnection
  id: Scalars['ID']['output']
  name: Scalars['String']['output']
  owner: User
  ownerAggregate?: Maybe<AuthGuardUserOwnerAggregationSelection>
  ownerConnection: WithOwnerOwnerConnection
  resource: Resource
  resourceAggregate?: Maybe<AuthGuardResourceResourceAggregationSelection>
  resourceConnection: AuthGuardResourceConnection
  responseTransformer: Scalars['String']['output']
}

export type AuthGuardConfigArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<PropOptions>
  sort?: InputMaybe<Array<PropSort>>
  where?: InputMaybe<PropWhere>
}

export type AuthGuardConfigAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<PropWhere>
}

export type AuthGuardConfigConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<AuthGuardConfigConnectionSort>>
  where?: InputMaybe<AuthGuardConfigConnectionWhere>
}

export type AuthGuardOwnerArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<UserOptions>
  sort?: InputMaybe<Array<UserSort>>
  where?: InputMaybe<UserWhere>
}

export type AuthGuardOwnerAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<UserWhere>
}

export type AuthGuardOwnerConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<WithOwnerOwnerConnectionSort>>
  where?: InputMaybe<WithOwnerOwnerConnectionWhere>
}

export type AuthGuardResourceArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<ResourceOptions>
  sort?: InputMaybe<Array<ResourceSort>>
  where?: InputMaybe<ResourceWhere>
}

export type AuthGuardResourceAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<ResourceWhere>
}

export type AuthGuardResourceConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<AuthGuardResourceConnectionSort>>
  where?: InputMaybe<AuthGuardResourceConnectionWhere>
}

export type AuthGuardAggregateSelection = {
  count: Scalars['Int']['output']
  id: IdAggregateSelection
  name: StringAggregateSelection
  responseTransformer: StringAggregateSelection
}

export type AuthGuardConfigAggregateInput = {
  AND?: InputMaybe<Array<AuthGuardConfigAggregateInput>>
  NOT?: InputMaybe<AuthGuardConfigAggregateInput>
  OR?: InputMaybe<Array<AuthGuardConfigAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<AuthGuardConfigNodeAggregationWhereInput>
}

export type AuthGuardConfigConnectFieldInput = {
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<PropConnectWhere>
}

export type AuthGuardConfigConnectOrCreateFieldInput = {
  onCreate: AuthGuardConfigConnectOrCreateFieldInputOnCreate
  where: PropConnectOrCreateWhere
}

export type AuthGuardConfigConnectOrCreateFieldInputOnCreate = {
  node: PropOnCreateInput
}

export type AuthGuardConfigConnection = {
  edges: Array<AuthGuardConfigRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type AuthGuardConfigConnectionSort = {
  node?: InputMaybe<PropSort>
}

export type AuthGuardConfigConnectionWhere = {
  AND?: InputMaybe<Array<AuthGuardConfigConnectionWhere>>
  NOT?: InputMaybe<AuthGuardConfigConnectionWhere>
  OR?: InputMaybe<Array<AuthGuardConfigConnectionWhere>>
  node?: InputMaybe<PropWhere>
}

export type AuthGuardConfigCreateFieldInput = {
  node: PropCreateInput
}

export type AuthGuardConfigDeleteFieldInput = {
  where?: InputMaybe<AuthGuardConfigConnectionWhere>
}

export type AuthGuardConfigDisconnectFieldInput = {
  where?: InputMaybe<AuthGuardConfigConnectionWhere>
}

export type AuthGuardConfigFieldInput = {
  connect?: InputMaybe<AuthGuardConfigConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<AuthGuardConfigConnectOrCreateFieldInput>
  create?: InputMaybe<AuthGuardConfigCreateFieldInput>
}

export type AuthGuardConfigNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<AuthGuardConfigNodeAggregationWhereInput>>
  NOT?: InputMaybe<AuthGuardConfigNodeAggregationWhereInput>
  OR?: InputMaybe<Array<AuthGuardConfigNodeAggregationWhereInput>>
  data_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  data_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  data_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  data_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  data_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  data_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  data_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  data_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  data_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  data_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  data_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  data_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  data_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  data_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  data_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
}

export type AuthGuardConfigRelationship = {
  cursor: Scalars['String']['output']
  node: Prop
}

export type AuthGuardConfigUpdateConnectionInput = {
  node?: InputMaybe<PropUpdateInput>
}

export type AuthGuardConfigUpdateFieldInput = {
  connect?: InputMaybe<AuthGuardConfigConnectFieldInput>
  connectOrCreate?: InputMaybe<AuthGuardConfigConnectOrCreateFieldInput>
  create?: InputMaybe<AuthGuardConfigCreateFieldInput>
  delete?: InputMaybe<AuthGuardConfigDeleteFieldInput>
  disconnect?: InputMaybe<AuthGuardConfigDisconnectFieldInput>
  update?: InputMaybe<AuthGuardConfigUpdateConnectionInput>
  where?: InputMaybe<AuthGuardConfigConnectionWhere>
}

export type AuthGuardConnectInput = {
  config?: InputMaybe<AuthGuardConfigConnectFieldInput>
  owner?: InputMaybe<AuthGuardOwnerConnectFieldInput>
  resource?: InputMaybe<AuthGuardResourceConnectFieldInput>
}

export type AuthGuardConnectOrCreateWhere = {
  node: AuthGuardUniqueWhere
}

export type AuthGuardConnectWhere = {
  node: AuthGuardWhere
}

export type AuthGuardCreateInput = {
  config?: InputMaybe<AuthGuardConfigFieldInput>
  id: Scalars['ID']['input']
  name: Scalars['String']['input']
  owner?: InputMaybe<AuthGuardOwnerFieldInput>
  resource?: InputMaybe<AuthGuardResourceFieldInput>
  responseTransformer: Scalars['String']['input']
}

export type AuthGuardCreatedEvent = {
  createdAuthGuard: AuthGuardEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type AuthGuardDeleteInput = {
  config?: InputMaybe<AuthGuardConfigDeleteFieldInput>
  owner?: InputMaybe<WithOwnerOwnerDeleteFieldInput>
  resource?: InputMaybe<AuthGuardResourceDeleteFieldInput>
}

export type AuthGuardDeletedEvent = {
  deletedAuthGuard: AuthGuardEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type AuthGuardDisconnectInput = {
  config?: InputMaybe<AuthGuardConfigDisconnectFieldInput>
  owner?: InputMaybe<WithOwnerOwnerDisconnectFieldInput>
  resource?: InputMaybe<AuthGuardResourceDisconnectFieldInput>
}

export type AuthGuardEdge = {
  cursor: Scalars['String']['output']
  node: AuthGuard
}

export type AuthGuardEventPayload = {
  id: Scalars['ID']['output']
  name: Scalars['String']['output']
  responseTransformer: Scalars['String']['output']
}

export type AuthGuardOnCreateInput = {
  id: Scalars['ID']['input']
  name: Scalars['String']['input']
  responseTransformer: Scalars['String']['input']
}

export type AuthGuardOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  /** Specify one or more AuthGuardSort objects to sort AuthGuards by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<AuthGuardSort>>
}

export type AuthGuardOwnerAggregateInput = {
  AND?: InputMaybe<Array<AuthGuardOwnerAggregateInput>>
  NOT?: InputMaybe<AuthGuardOwnerAggregateInput>
  OR?: InputMaybe<Array<AuthGuardOwnerAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<AuthGuardOwnerNodeAggregationWhereInput>
}

export type AuthGuardOwnerConnectFieldInput = {
  connect?: InputMaybe<UserConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<UserConnectWhere>
}

export type AuthGuardOwnerConnectOrCreateFieldInput = {
  onCreate: AuthGuardOwnerConnectOrCreateFieldInputOnCreate
  where: UserConnectOrCreateWhere
}

export type AuthGuardOwnerConnectOrCreateFieldInputOnCreate = {
  node: UserOnCreateInput
}

export type AuthGuardOwnerCreateFieldInput = {
  node: UserCreateInput
}

export type AuthGuardOwnerFieldInput = {
  connect?: InputMaybe<AuthGuardOwnerConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<AuthGuardOwnerConnectOrCreateFieldInput>
  create?: InputMaybe<AuthGuardOwnerCreateFieldInput>
}

export type AuthGuardOwnerNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<AuthGuardOwnerNodeAggregationWhereInput>>
  NOT?: InputMaybe<AuthGuardOwnerNodeAggregationWhereInput>
  OR?: InputMaybe<Array<AuthGuardOwnerNodeAggregationWhereInput>>
  auth0Id_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  auth0Id_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  email_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  email_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  username_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  username_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type AuthGuardOwnerUpdateConnectionInput = {
  node?: InputMaybe<UserUpdateInput>
}

export type AuthGuardOwnerUpdateFieldInput = {
  connect?: InputMaybe<AuthGuardOwnerConnectFieldInput>
  connectOrCreate?: InputMaybe<AuthGuardOwnerConnectOrCreateFieldInput>
  create?: InputMaybe<AuthGuardOwnerCreateFieldInput>
  delete?: InputMaybe<WithOwnerOwnerDeleteFieldInput>
  disconnect?: InputMaybe<WithOwnerOwnerDisconnectFieldInput>
  update?: InputMaybe<AuthGuardOwnerUpdateConnectionInput>
  where?: InputMaybe<WithOwnerOwnerConnectionWhere>
}

export type AuthGuardPropConfigAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<AuthGuardPropConfigNodeAggregateSelection>
}

export type AuthGuardPropConfigNodeAggregateSelection = {
  data: StringAggregateSelection
  id: IdAggregateSelection
}

export type AuthGuardResourceAggregateInput = {
  AND?: InputMaybe<Array<AuthGuardResourceAggregateInput>>
  NOT?: InputMaybe<AuthGuardResourceAggregateInput>
  OR?: InputMaybe<Array<AuthGuardResourceAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<AuthGuardResourceNodeAggregationWhereInput>
}

export type AuthGuardResourceConnectFieldInput = {
  connect?: InputMaybe<ResourceConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<ResourceConnectWhere>
}

export type AuthGuardResourceConnectOrCreateFieldInput = {
  onCreate: AuthGuardResourceConnectOrCreateFieldInputOnCreate
  where: ResourceConnectOrCreateWhere
}

export type AuthGuardResourceConnectOrCreateFieldInputOnCreate = {
  node: ResourceOnCreateInput
}

export type AuthGuardResourceConnection = {
  edges: Array<AuthGuardResourceRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type AuthGuardResourceConnectionSort = {
  node?: InputMaybe<ResourceSort>
}

export type AuthGuardResourceConnectionWhere = {
  AND?: InputMaybe<Array<AuthGuardResourceConnectionWhere>>
  NOT?: InputMaybe<AuthGuardResourceConnectionWhere>
  OR?: InputMaybe<Array<AuthGuardResourceConnectionWhere>>
  node?: InputMaybe<ResourceWhere>
}

export type AuthGuardResourceCreateFieldInput = {
  node: ResourceCreateInput
}

export type AuthGuardResourceDeleteFieldInput = {
  delete?: InputMaybe<ResourceDeleteInput>
  where?: InputMaybe<AuthGuardResourceConnectionWhere>
}

export type AuthGuardResourceDisconnectFieldInput = {
  disconnect?: InputMaybe<ResourceDisconnectInput>
  where?: InputMaybe<AuthGuardResourceConnectionWhere>
}

export type AuthGuardResourceFieldInput = {
  connect?: InputMaybe<AuthGuardResourceConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<AuthGuardResourceConnectOrCreateFieldInput>
  create?: InputMaybe<AuthGuardResourceCreateFieldInput>
}

export type AuthGuardResourceNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<AuthGuardResourceNodeAggregationWhereInput>>
  NOT?: InputMaybe<AuthGuardResourceNodeAggregationWhereInput>
  OR?: InputMaybe<Array<AuthGuardResourceNodeAggregationWhereInput>>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type AuthGuardResourceRelationship = {
  cursor: Scalars['String']['output']
  node: Resource
}

export type AuthGuardResourceResourceAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<AuthGuardResourceResourceNodeAggregateSelection>
}

export type AuthGuardResourceResourceNodeAggregateSelection = {
  id: IdAggregateSelection
  name: StringAggregateSelection
}

export type AuthGuardResourceUpdateConnectionInput = {
  node?: InputMaybe<ResourceUpdateInput>
}

export type AuthGuardResourceUpdateFieldInput = {
  connect?: InputMaybe<AuthGuardResourceConnectFieldInput>
  connectOrCreate?: InputMaybe<AuthGuardResourceConnectOrCreateFieldInput>
  create?: InputMaybe<AuthGuardResourceCreateFieldInput>
  delete?: InputMaybe<AuthGuardResourceDeleteFieldInput>
  disconnect?: InputMaybe<AuthGuardResourceDisconnectFieldInput>
  update?: InputMaybe<AuthGuardResourceUpdateConnectionInput>
  where?: InputMaybe<AuthGuardResourceConnectionWhere>
}

/** Fields to sort AuthGuards by. The order in which sorts are applied is not guaranteed when specifying many fields in one AuthGuardSort object. */
export type AuthGuardSort = {
  id?: InputMaybe<SortDirection>
  name?: InputMaybe<SortDirection>
  responseTransformer?: InputMaybe<SortDirection>
}

export type AuthGuardSubscriptionWhere = {
  AND?: InputMaybe<Array<AuthGuardSubscriptionWhere>>
  NOT?: InputMaybe<AuthGuardSubscriptionWhere>
  OR?: InputMaybe<Array<AuthGuardSubscriptionWhere>>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>
  name_MATCHES?: InputMaybe<Scalars['String']['input']>
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  responseTransformer?: InputMaybe<Scalars['String']['input']>
  responseTransformer_CONTAINS?: InputMaybe<Scalars['String']['input']>
  responseTransformer_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  responseTransformer_EQ?: InputMaybe<Scalars['String']['input']>
  responseTransformer_IN?: InputMaybe<Array<Scalars['String']['input']>>
  responseTransformer_MATCHES?: InputMaybe<Scalars['String']['input']>
  responseTransformer_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
}

export type AuthGuardUniqueWhere = {
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
}

export type AuthGuardUpdateInput = {
  config?: InputMaybe<AuthGuardConfigUpdateFieldInput>
  /** @deprecated Please use the explicit _SET field */
  name?: InputMaybe<Scalars['String']['input']>
  name_SET?: InputMaybe<Scalars['String']['input']>
  owner?: InputMaybe<AuthGuardOwnerUpdateFieldInput>
  resource?: InputMaybe<AuthGuardResourceUpdateFieldInput>
  /** @deprecated Please use the explicit _SET field */
  responseTransformer?: InputMaybe<Scalars['String']['input']>
  responseTransformer_SET?: InputMaybe<Scalars['String']['input']>
}

export type AuthGuardUpdatedEvent = {
  event: EventType
  previousState: AuthGuardEventPayload
  timestamp: Scalars['Float']['output']
  updatedAuthGuard: AuthGuardEventPayload
}

export type AuthGuardUserOwnerAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<AuthGuardUserOwnerNodeAggregateSelection>
}

export type AuthGuardUserOwnerNodeAggregateSelection = {
  auth0Id: StringAggregateSelection
  email: StringAggregateSelection
  id: IdAggregateSelection
  username: StringAggregateSelection
}

export type AuthGuardWhere = {
  AND?: InputMaybe<Array<AuthGuardWhere>>
  NOT?: InputMaybe<AuthGuardWhere>
  OR?: InputMaybe<Array<AuthGuardWhere>>
  config?: InputMaybe<PropWhere>
  configAggregate?: InputMaybe<AuthGuardConfigAggregateInput>
  configConnection?: InputMaybe<AuthGuardConfigConnectionWhere>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>
  name_MATCHES?: InputMaybe<Scalars['String']['input']>
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  owner?: InputMaybe<UserWhere>
  ownerAggregate?: InputMaybe<AuthGuardOwnerAggregateInput>
  ownerConnection?: InputMaybe<WithOwnerOwnerConnectionWhere>
  resource?: InputMaybe<ResourceWhere>
  resourceAggregate?: InputMaybe<AuthGuardResourceAggregateInput>
  resourceConnection?: InputMaybe<AuthGuardResourceConnectionWhere>
  /** @deprecated Please use the explicit _EQ version */
  responseTransformer?: InputMaybe<Scalars['String']['input']>
  responseTransformer_CONTAINS?: InputMaybe<Scalars['String']['input']>
  responseTransformer_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  responseTransformer_EQ?: InputMaybe<Scalars['String']['input']>
  responseTransformer_IN?: InputMaybe<Array<Scalars['String']['input']>>
  responseTransformer_MATCHES?: InputMaybe<Scalars['String']['input']>
  responseTransformer_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
}

export type AuthGuardsConnection = {
  edges: Array<AuthGuardEdge>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type BaseAction = {
  id: Scalars['ID']['output']
  name: Scalars['String']['output']
  postRenderElement?: Maybe<Element>
  postRenderElementConnection: BaseActionPostRenderElementConnection
  preRenderElement?: Maybe<Element>
  preRenderElementConnection: BaseActionPreRenderElementConnection
  store: Store
  storeConnection: BaseActionStoreConnection
  type: ActionKind
}

export type BaseActionPostRenderElementArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<ElementOptions>
  sort?: InputMaybe<Array<ElementSort>>
  where?: InputMaybe<ElementWhere>
}

export type BaseActionPostRenderElementConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<BaseActionPostRenderElementConnectionSort>>
  where?: InputMaybe<BaseActionPostRenderElementConnectionWhere>
}

export type BaseActionPreRenderElementArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<ElementOptions>
  sort?: InputMaybe<Array<ElementSort>>
  where?: InputMaybe<ElementWhere>
}

export type BaseActionPreRenderElementConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<BaseActionPreRenderElementConnectionSort>>
  where?: InputMaybe<BaseActionPreRenderElementConnectionWhere>
}

export type BaseActionStoreArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<StoreOptions>
  sort?: InputMaybe<Array<StoreSort>>
  where?: InputMaybe<StoreWhere>
}

export type BaseActionStoreConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<BaseActionStoreConnectionSort>>
  where?: InputMaybe<BaseActionStoreConnectionWhere>
}

export type BaseActionAggregateSelection = {
  count: Scalars['Int']['output']
  id: IdAggregateSelection
  name: StringAggregateSelection
}

export type BaseActionConnectInput = {
  postRenderElement?: InputMaybe<BaseActionPostRenderElementConnectFieldInput>
  preRenderElement?: InputMaybe<BaseActionPreRenderElementConnectFieldInput>
  store?: InputMaybe<BaseActionStoreConnectFieldInput>
}

export type BaseActionConnectWhere = {
  node: BaseActionWhere
}

export type BaseActionCreateInput = {
  ApiAction?: InputMaybe<ApiActionCreateInput>
  CodeAction?: InputMaybe<CodeActionCreateInput>
}

export type BaseActionDeleteInput = {
  postRenderElement?: InputMaybe<BaseActionPostRenderElementDeleteFieldInput>
  preRenderElement?: InputMaybe<BaseActionPreRenderElementDeleteFieldInput>
  store?: InputMaybe<BaseActionStoreDeleteFieldInput>
}

export type BaseActionDisconnectInput = {
  postRenderElement?: InputMaybe<BaseActionPostRenderElementDisconnectFieldInput>
  preRenderElement?: InputMaybe<BaseActionPreRenderElementDisconnectFieldInput>
  store?: InputMaybe<BaseActionStoreDisconnectFieldInput>
}

export type BaseActionEdge = {
  cursor: Scalars['String']['output']
  node: BaseAction
}

export enum BaseActionImplementation {
  ApiAction = 'ApiAction',
  CodeAction = 'CodeAction',
}

export type BaseActionOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  /** Specify one or more BaseActionSort objects to sort BaseActions by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<BaseActionSort>>
}

export type BaseActionPostRenderElementAggregateInput = {
  AND?: InputMaybe<Array<BaseActionPostRenderElementAggregateInput>>
  NOT?: InputMaybe<BaseActionPostRenderElementAggregateInput>
  OR?: InputMaybe<Array<BaseActionPostRenderElementAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<BaseActionPostRenderElementNodeAggregationWhereInput>
}

export type BaseActionPostRenderElementConnectFieldInput = {
  connect?: InputMaybe<ElementConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<ElementConnectWhere>
}

export type BaseActionPostRenderElementConnectOrCreateFieldInput = {
  onCreate: BaseActionPostRenderElementConnectOrCreateFieldInputOnCreate
  where: ElementConnectOrCreateWhere
}

export type BaseActionPostRenderElementConnectOrCreateFieldInputOnCreate = {
  node: ElementOnCreateInput
}

export type BaseActionPostRenderElementConnection = {
  edges: Array<BaseActionPostRenderElementRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type BaseActionPostRenderElementConnectionSort = {
  node?: InputMaybe<ElementSort>
}

export type BaseActionPostRenderElementConnectionWhere = {
  AND?: InputMaybe<Array<BaseActionPostRenderElementConnectionWhere>>
  NOT?: InputMaybe<BaseActionPostRenderElementConnectionWhere>
  OR?: InputMaybe<Array<BaseActionPostRenderElementConnectionWhere>>
  node?: InputMaybe<ElementWhere>
}

export type BaseActionPostRenderElementCreateFieldInput = {
  node: ElementCreateInput
}

export type BaseActionPostRenderElementDeleteFieldInput = {
  delete?: InputMaybe<ElementDeleteInput>
  where?: InputMaybe<BaseActionPostRenderElementConnectionWhere>
}

export type BaseActionPostRenderElementDisconnectFieldInput = {
  disconnect?: InputMaybe<ElementDisconnectInput>
  where?: InputMaybe<BaseActionPostRenderElementConnectionWhere>
}

export type BaseActionPostRenderElementNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<BaseActionPostRenderElementNodeAggregationWhereInput>>
  NOT?: InputMaybe<BaseActionPostRenderElementNodeAggregationWhereInput>
  OR?: InputMaybe<Array<BaseActionPostRenderElementNodeAggregationWhereInput>>
  childMapperPropKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  childMapperPropKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_GTE?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_LTE?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_LONGEST_LENGTH_EQUAL?: InputMaybe<
    Scalars['Int']['input']
  >
  renderForEachPropKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<
    Scalars['Int']['input']
  >
  renderForEachPropKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  renderIfExpression_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  style_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  style_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type BaseActionPostRenderElementRelationship = {
  cursor: Scalars['String']['output']
  node: Element
}

export type BaseActionPostRenderElementUpdateConnectionInput = {
  node?: InputMaybe<ElementUpdateInput>
}

export type BaseActionPostRenderElementUpdateFieldInput = {
  connect?: InputMaybe<BaseActionPostRenderElementConnectFieldInput>
  connectOrCreate?: InputMaybe<BaseActionPostRenderElementConnectOrCreateFieldInput>
  create?: InputMaybe<BaseActionPostRenderElementCreateFieldInput>
  delete?: InputMaybe<BaseActionPostRenderElementDeleteFieldInput>
  disconnect?: InputMaybe<BaseActionPostRenderElementDisconnectFieldInput>
  update?: InputMaybe<BaseActionPostRenderElementUpdateConnectionInput>
  where?: InputMaybe<BaseActionPostRenderElementConnectionWhere>
}

export type BaseActionPreRenderElementAggregateInput = {
  AND?: InputMaybe<Array<BaseActionPreRenderElementAggregateInput>>
  NOT?: InputMaybe<BaseActionPreRenderElementAggregateInput>
  OR?: InputMaybe<Array<BaseActionPreRenderElementAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<BaseActionPreRenderElementNodeAggregationWhereInput>
}

export type BaseActionPreRenderElementConnectFieldInput = {
  connect?: InputMaybe<ElementConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<ElementConnectWhere>
}

export type BaseActionPreRenderElementConnectOrCreateFieldInput = {
  onCreate: BaseActionPreRenderElementConnectOrCreateFieldInputOnCreate
  where: ElementConnectOrCreateWhere
}

export type BaseActionPreRenderElementConnectOrCreateFieldInputOnCreate = {
  node: ElementOnCreateInput
}

export type BaseActionPreRenderElementConnection = {
  edges: Array<BaseActionPreRenderElementRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type BaseActionPreRenderElementConnectionSort = {
  node?: InputMaybe<ElementSort>
}

export type BaseActionPreRenderElementConnectionWhere = {
  AND?: InputMaybe<Array<BaseActionPreRenderElementConnectionWhere>>
  NOT?: InputMaybe<BaseActionPreRenderElementConnectionWhere>
  OR?: InputMaybe<Array<BaseActionPreRenderElementConnectionWhere>>
  node?: InputMaybe<ElementWhere>
}

export type BaseActionPreRenderElementCreateFieldInput = {
  node: ElementCreateInput
}

export type BaseActionPreRenderElementDeleteFieldInput = {
  delete?: InputMaybe<ElementDeleteInput>
  where?: InputMaybe<BaseActionPreRenderElementConnectionWhere>
}

export type BaseActionPreRenderElementDisconnectFieldInput = {
  disconnect?: InputMaybe<ElementDisconnectInput>
  where?: InputMaybe<BaseActionPreRenderElementConnectionWhere>
}

export type BaseActionPreRenderElementNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<BaseActionPreRenderElementNodeAggregationWhereInput>>
  NOT?: InputMaybe<BaseActionPreRenderElementNodeAggregationWhereInput>
  OR?: InputMaybe<Array<BaseActionPreRenderElementNodeAggregationWhereInput>>
  childMapperPropKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  childMapperPropKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_GTE?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_LTE?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_LONGEST_LENGTH_EQUAL?: InputMaybe<
    Scalars['Int']['input']
  >
  renderForEachPropKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<
    Scalars['Int']['input']
  >
  renderForEachPropKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  renderIfExpression_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  style_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  style_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type BaseActionPreRenderElementRelationship = {
  cursor: Scalars['String']['output']
  node: Element
}

export type BaseActionPreRenderElementUpdateConnectionInput = {
  node?: InputMaybe<ElementUpdateInput>
}

export type BaseActionPreRenderElementUpdateFieldInput = {
  connect?: InputMaybe<BaseActionPreRenderElementConnectFieldInput>
  connectOrCreate?: InputMaybe<BaseActionPreRenderElementConnectOrCreateFieldInput>
  create?: InputMaybe<BaseActionPreRenderElementCreateFieldInput>
  delete?: InputMaybe<BaseActionPreRenderElementDeleteFieldInput>
  disconnect?: InputMaybe<BaseActionPreRenderElementDisconnectFieldInput>
  update?: InputMaybe<BaseActionPreRenderElementUpdateConnectionInput>
  where?: InputMaybe<BaseActionPreRenderElementConnectionWhere>
}

/** Fields to sort BaseActions by. The order in which sorts are applied is not guaranteed when specifying many fields in one BaseActionSort object. */
export type BaseActionSort = {
  id?: InputMaybe<SortDirection>
  name?: InputMaybe<SortDirection>
  type?: InputMaybe<SortDirection>
}

export type BaseActionStoreAggregateInput = {
  AND?: InputMaybe<Array<BaseActionStoreAggregateInput>>
  NOT?: InputMaybe<BaseActionStoreAggregateInput>
  OR?: InputMaybe<Array<BaseActionStoreAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<BaseActionStoreNodeAggregationWhereInput>
}

export type BaseActionStoreConnectFieldInput = {
  connect?: InputMaybe<StoreConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<StoreConnectWhere>
}

export type BaseActionStoreConnectOrCreateFieldInput = {
  onCreate: BaseActionStoreConnectOrCreateFieldInputOnCreate
  where: StoreConnectOrCreateWhere
}

export type BaseActionStoreConnectOrCreateFieldInputOnCreate = {
  node: StoreOnCreateInput
}

export type BaseActionStoreConnection = {
  edges: Array<BaseActionStoreRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type BaseActionStoreConnectionSort = {
  node?: InputMaybe<StoreSort>
}

export type BaseActionStoreConnectionWhere = {
  AND?: InputMaybe<Array<BaseActionStoreConnectionWhere>>
  NOT?: InputMaybe<BaseActionStoreConnectionWhere>
  OR?: InputMaybe<Array<BaseActionStoreConnectionWhere>>
  node?: InputMaybe<StoreWhere>
}

export type BaseActionStoreCreateFieldInput = {
  node: StoreCreateInput
}

export type BaseActionStoreDeleteFieldInput = {
  delete?: InputMaybe<StoreDeleteInput>
  where?: InputMaybe<BaseActionStoreConnectionWhere>
}

export type BaseActionStoreDisconnectFieldInput = {
  disconnect?: InputMaybe<StoreDisconnectInput>
  where?: InputMaybe<BaseActionStoreConnectionWhere>
}

export type BaseActionStoreNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<BaseActionStoreNodeAggregationWhereInput>>
  NOT?: InputMaybe<BaseActionStoreNodeAggregationWhereInput>
  OR?: InputMaybe<Array<BaseActionStoreNodeAggregationWhereInput>>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type BaseActionStoreRelationship = {
  cursor: Scalars['String']['output']
  node: Store
}

export type BaseActionStoreUpdateConnectionInput = {
  node?: InputMaybe<StoreUpdateInput>
}

export type BaseActionStoreUpdateFieldInput = {
  connect?: InputMaybe<BaseActionStoreConnectFieldInput>
  connectOrCreate?: InputMaybe<BaseActionStoreConnectOrCreateFieldInput>
  create?: InputMaybe<BaseActionStoreCreateFieldInput>
  delete?: InputMaybe<BaseActionStoreDeleteFieldInput>
  disconnect?: InputMaybe<BaseActionStoreDisconnectFieldInput>
  update?: InputMaybe<BaseActionStoreUpdateConnectionInput>
  where?: InputMaybe<BaseActionStoreConnectionWhere>
}

export type BaseActionUpdateInput = {
  /** @deprecated Please use the explicit _SET field */
  id?: InputMaybe<Scalars['ID']['input']>
  id_SET?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _SET field */
  name?: InputMaybe<Scalars['String']['input']>
  name_SET?: InputMaybe<Scalars['String']['input']>
  postRenderElement?: InputMaybe<BaseActionPostRenderElementUpdateFieldInput>
  preRenderElement?: InputMaybe<BaseActionPreRenderElementUpdateFieldInput>
  store?: InputMaybe<BaseActionStoreUpdateFieldInput>
}

export type BaseActionWhere = {
  AND?: InputMaybe<Array<BaseActionWhere>>
  NOT?: InputMaybe<BaseActionWhere>
  OR?: InputMaybe<Array<BaseActionWhere>>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>
  name_MATCHES?: InputMaybe<Scalars['String']['input']>
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  postRenderElement?: InputMaybe<ElementWhere>
  postRenderElementAggregate?: InputMaybe<BaseActionPostRenderElementAggregateInput>
  postRenderElementConnection?: InputMaybe<BaseActionPostRenderElementConnectionWhere>
  preRenderElement?: InputMaybe<ElementWhere>
  preRenderElementAggregate?: InputMaybe<BaseActionPreRenderElementAggregateInput>
  preRenderElementConnection?: InputMaybe<BaseActionPreRenderElementConnectionWhere>
  store?: InputMaybe<StoreWhere>
  storeAggregate?: InputMaybe<BaseActionStoreAggregateInput>
  storeConnection?: InputMaybe<BaseActionStoreConnectionWhere>
  /** @deprecated Please use the explicit _EQ version */
  type?: InputMaybe<ActionKind>
  type_EQ?: InputMaybe<ActionKind>
  type_IN?: InputMaybe<Array<ActionKind>>
  typename_IN?: InputMaybe<Array<BaseActionImplementation>>
}

export type BaseActionsConnection = {
  edges: Array<BaseActionEdge>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export enum BreakpointType {
  Desktop = 'Desktop',
  MobileLandscape = 'MobileLandscape',
  MobilePortrait = 'MobilePortrait',
  Tablet = 'Tablet',
}

export type CodeAction = BaseAction & {
  /** Code to run when action is triggered */
  code: Scalars['String']['output']
  id: Scalars['ID']['output']
  name: Scalars['String']['output']
  postRenderElement?: Maybe<Element>
  postRenderElementAggregate?: Maybe<CodeActionElementPostRenderElementAggregationSelection>
  postRenderElementConnection: BaseActionPostRenderElementConnection
  preRenderElement?: Maybe<Element>
  preRenderElementAggregate?: Maybe<CodeActionElementPreRenderElementAggregationSelection>
  preRenderElementConnection: BaseActionPreRenderElementConnection
  store: Store
  storeAggregate?: Maybe<CodeActionStoreStoreAggregationSelection>
  storeConnection: BaseActionStoreConnection
  type: ActionKind
}

export type CodeActionPostRenderElementArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<ElementOptions>
  sort?: InputMaybe<Array<ElementSort>>
  where?: InputMaybe<ElementWhere>
}

export type CodeActionPostRenderElementAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<ElementWhere>
}

export type CodeActionPostRenderElementConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<BaseActionPostRenderElementConnectionSort>>
  where?: InputMaybe<BaseActionPostRenderElementConnectionWhere>
}

export type CodeActionPreRenderElementArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<ElementOptions>
  sort?: InputMaybe<Array<ElementSort>>
  where?: InputMaybe<ElementWhere>
}

export type CodeActionPreRenderElementAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<ElementWhere>
}

export type CodeActionPreRenderElementConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<BaseActionPreRenderElementConnectionSort>>
  where?: InputMaybe<BaseActionPreRenderElementConnectionWhere>
}

export type CodeActionStoreArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<StoreOptions>
  sort?: InputMaybe<Array<StoreSort>>
  where?: InputMaybe<StoreWhere>
}

export type CodeActionStoreAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<StoreWhere>
}

export type CodeActionStoreConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<BaseActionStoreConnectionSort>>
  where?: InputMaybe<BaseActionStoreConnectionWhere>
}

export type CodeActionAggregateSelection = {
  code: StringAggregateSelection
  count: Scalars['Int']['output']
  id: IdAggregateSelection
  name: StringAggregateSelection
}

export type CodeActionConnectInput = {
  postRenderElement?: InputMaybe<CodeActionPostRenderElementConnectFieldInput>
  preRenderElement?: InputMaybe<CodeActionPreRenderElementConnectFieldInput>
  store?: InputMaybe<CodeActionStoreConnectFieldInput>
}

export type CodeActionConnectWhere = {
  node: CodeActionWhere
}

export type CodeActionCreateInput = {
  code: Scalars['String']['input']
  id: Scalars['ID']['input']
  name: Scalars['String']['input']
  postRenderElement?: InputMaybe<CodeActionPostRenderElementFieldInput>
  preRenderElement?: InputMaybe<CodeActionPreRenderElementFieldInput>
  store?: InputMaybe<CodeActionStoreFieldInput>
  type?: ActionKind
}

export type CodeActionCreatedEvent = {
  createdCodeAction: CodeActionEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type CodeActionDeleteInput = {
  postRenderElement?: InputMaybe<BaseActionPostRenderElementDeleteFieldInput>
  preRenderElement?: InputMaybe<BaseActionPreRenderElementDeleteFieldInput>
  store?: InputMaybe<BaseActionStoreDeleteFieldInput>
}

export type CodeActionDeletedEvent = {
  deletedCodeAction: CodeActionEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type CodeActionDisconnectInput = {
  postRenderElement?: InputMaybe<BaseActionPostRenderElementDisconnectFieldInput>
  preRenderElement?: InputMaybe<BaseActionPreRenderElementDisconnectFieldInput>
  store?: InputMaybe<BaseActionStoreDisconnectFieldInput>
}

export type CodeActionEdge = {
  cursor: Scalars['String']['output']
  node: CodeAction
}

export type CodeActionElementPostRenderElementAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<CodeActionElementPostRenderElementNodeAggregateSelection>
}

export type CodeActionElementPostRenderElementNodeAggregateSelection = {
  childMapperPropKey: StringAggregateSelection
  compositeKey: StringAggregateSelection
  id: IdAggregateSelection
  renderForEachPropKey: StringAggregateSelection
  renderIfExpression: StringAggregateSelection
  style: StringAggregateSelection
}

export type CodeActionElementPreRenderElementAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<CodeActionElementPreRenderElementNodeAggregateSelection>
}

export type CodeActionElementPreRenderElementNodeAggregateSelection = {
  childMapperPropKey: StringAggregateSelection
  compositeKey: StringAggregateSelection
  id: IdAggregateSelection
  renderForEachPropKey: StringAggregateSelection
  renderIfExpression: StringAggregateSelection
  style: StringAggregateSelection
}

export type CodeActionEventPayload = {
  /** Code to run when action is triggered */
  code: Scalars['String']['output']
  id: Scalars['ID']['output']
  name: Scalars['String']['output']
  type: ActionKind
}

export type CodeActionOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  /** Specify one or more CodeActionSort objects to sort CodeActions by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<CodeActionSort>>
}

export type CodeActionPostRenderElementAggregateInput = {
  AND?: InputMaybe<Array<CodeActionPostRenderElementAggregateInput>>
  NOT?: InputMaybe<CodeActionPostRenderElementAggregateInput>
  OR?: InputMaybe<Array<CodeActionPostRenderElementAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<CodeActionPostRenderElementNodeAggregationWhereInput>
}

export type CodeActionPostRenderElementConnectFieldInput = {
  connect?: InputMaybe<ElementConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<ElementConnectWhere>
}

export type CodeActionPostRenderElementConnectOrCreateFieldInput = {
  onCreate: CodeActionPostRenderElementConnectOrCreateFieldInputOnCreate
  where: ElementConnectOrCreateWhere
}

export type CodeActionPostRenderElementConnectOrCreateFieldInputOnCreate = {
  node: ElementOnCreateInput
}

export type CodeActionPostRenderElementCreateFieldInput = {
  node: ElementCreateInput
}

export type CodeActionPostRenderElementFieldInput = {
  connect?: InputMaybe<CodeActionPostRenderElementConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<CodeActionPostRenderElementConnectOrCreateFieldInput>
  create?: InputMaybe<CodeActionPostRenderElementCreateFieldInput>
}

export type CodeActionPostRenderElementNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<CodeActionPostRenderElementNodeAggregationWhereInput>>
  NOT?: InputMaybe<CodeActionPostRenderElementNodeAggregationWhereInput>
  OR?: InputMaybe<Array<CodeActionPostRenderElementNodeAggregationWhereInput>>
  childMapperPropKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  childMapperPropKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_GTE?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_LTE?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_LONGEST_LENGTH_EQUAL?: InputMaybe<
    Scalars['Int']['input']
  >
  renderForEachPropKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<
    Scalars['Int']['input']
  >
  renderForEachPropKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  renderIfExpression_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  style_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  style_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type CodeActionPostRenderElementUpdateConnectionInput = {
  node?: InputMaybe<ElementUpdateInput>
}

export type CodeActionPostRenderElementUpdateFieldInput = {
  connect?: InputMaybe<CodeActionPostRenderElementConnectFieldInput>
  connectOrCreate?: InputMaybe<CodeActionPostRenderElementConnectOrCreateFieldInput>
  create?: InputMaybe<CodeActionPostRenderElementCreateFieldInput>
  delete?: InputMaybe<BaseActionPostRenderElementDeleteFieldInput>
  disconnect?: InputMaybe<BaseActionPostRenderElementDisconnectFieldInput>
  update?: InputMaybe<CodeActionPostRenderElementUpdateConnectionInput>
  where?: InputMaybe<BaseActionPostRenderElementConnectionWhere>
}

export type CodeActionPreRenderElementAggregateInput = {
  AND?: InputMaybe<Array<CodeActionPreRenderElementAggregateInput>>
  NOT?: InputMaybe<CodeActionPreRenderElementAggregateInput>
  OR?: InputMaybe<Array<CodeActionPreRenderElementAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<CodeActionPreRenderElementNodeAggregationWhereInput>
}

export type CodeActionPreRenderElementConnectFieldInput = {
  connect?: InputMaybe<ElementConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<ElementConnectWhere>
}

export type CodeActionPreRenderElementConnectOrCreateFieldInput = {
  onCreate: CodeActionPreRenderElementConnectOrCreateFieldInputOnCreate
  where: ElementConnectOrCreateWhere
}

export type CodeActionPreRenderElementConnectOrCreateFieldInputOnCreate = {
  node: ElementOnCreateInput
}

export type CodeActionPreRenderElementCreateFieldInput = {
  node: ElementCreateInput
}

export type CodeActionPreRenderElementFieldInput = {
  connect?: InputMaybe<CodeActionPreRenderElementConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<CodeActionPreRenderElementConnectOrCreateFieldInput>
  create?: InputMaybe<CodeActionPreRenderElementCreateFieldInput>
}

export type CodeActionPreRenderElementNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<CodeActionPreRenderElementNodeAggregationWhereInput>>
  NOT?: InputMaybe<CodeActionPreRenderElementNodeAggregationWhereInput>
  OR?: InputMaybe<Array<CodeActionPreRenderElementNodeAggregationWhereInput>>
  childMapperPropKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  childMapperPropKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_GTE?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_LTE?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_LONGEST_LENGTH_EQUAL?: InputMaybe<
    Scalars['Int']['input']
  >
  renderForEachPropKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<
    Scalars['Int']['input']
  >
  renderForEachPropKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  renderIfExpression_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  style_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  style_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type CodeActionPreRenderElementUpdateConnectionInput = {
  node?: InputMaybe<ElementUpdateInput>
}

export type CodeActionPreRenderElementUpdateFieldInput = {
  connect?: InputMaybe<CodeActionPreRenderElementConnectFieldInput>
  connectOrCreate?: InputMaybe<CodeActionPreRenderElementConnectOrCreateFieldInput>
  create?: InputMaybe<CodeActionPreRenderElementCreateFieldInput>
  delete?: InputMaybe<BaseActionPreRenderElementDeleteFieldInput>
  disconnect?: InputMaybe<BaseActionPreRenderElementDisconnectFieldInput>
  update?: InputMaybe<CodeActionPreRenderElementUpdateConnectionInput>
  where?: InputMaybe<BaseActionPreRenderElementConnectionWhere>
}

/** Fields to sort CodeActions by. The order in which sorts are applied is not guaranteed when specifying many fields in one CodeActionSort object. */
export type CodeActionSort = {
  code?: InputMaybe<SortDirection>
  id?: InputMaybe<SortDirection>
  name?: InputMaybe<SortDirection>
  type?: InputMaybe<SortDirection>
}

export type CodeActionStoreAggregateInput = {
  AND?: InputMaybe<Array<CodeActionStoreAggregateInput>>
  NOT?: InputMaybe<CodeActionStoreAggregateInput>
  OR?: InputMaybe<Array<CodeActionStoreAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<CodeActionStoreNodeAggregationWhereInput>
}

export type CodeActionStoreConnectFieldInput = {
  connect?: InputMaybe<StoreConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<StoreConnectWhere>
}

export type CodeActionStoreConnectOrCreateFieldInput = {
  onCreate: CodeActionStoreConnectOrCreateFieldInputOnCreate
  where: StoreConnectOrCreateWhere
}

export type CodeActionStoreConnectOrCreateFieldInputOnCreate = {
  node: StoreOnCreateInput
}

export type CodeActionStoreCreateFieldInput = {
  node: StoreCreateInput
}

export type CodeActionStoreFieldInput = {
  connect?: InputMaybe<CodeActionStoreConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<CodeActionStoreConnectOrCreateFieldInput>
  create?: InputMaybe<CodeActionStoreCreateFieldInput>
}

export type CodeActionStoreNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<CodeActionStoreNodeAggregationWhereInput>>
  NOT?: InputMaybe<CodeActionStoreNodeAggregationWhereInput>
  OR?: InputMaybe<Array<CodeActionStoreNodeAggregationWhereInput>>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type CodeActionStoreStoreAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<CodeActionStoreStoreNodeAggregateSelection>
}

export type CodeActionStoreStoreNodeAggregateSelection = {
  id: IdAggregateSelection
  name: StringAggregateSelection
}

export type CodeActionStoreUpdateConnectionInput = {
  node?: InputMaybe<StoreUpdateInput>
}

export type CodeActionStoreUpdateFieldInput = {
  connect?: InputMaybe<CodeActionStoreConnectFieldInput>
  connectOrCreate?: InputMaybe<CodeActionStoreConnectOrCreateFieldInput>
  create?: InputMaybe<CodeActionStoreCreateFieldInput>
  delete?: InputMaybe<BaseActionStoreDeleteFieldInput>
  disconnect?: InputMaybe<BaseActionStoreDisconnectFieldInput>
  update?: InputMaybe<CodeActionStoreUpdateConnectionInput>
  where?: InputMaybe<BaseActionStoreConnectionWhere>
}

export type CodeActionSubscriptionWhere = {
  AND?: InputMaybe<Array<CodeActionSubscriptionWhere>>
  NOT?: InputMaybe<CodeActionSubscriptionWhere>
  OR?: InputMaybe<Array<CodeActionSubscriptionWhere>>
  /** @deprecated Please use the explicit _EQ version */
  code?: InputMaybe<Scalars['String']['input']>
  code_CONTAINS?: InputMaybe<Scalars['String']['input']>
  code_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  code_EQ?: InputMaybe<Scalars['String']['input']>
  code_IN?: InputMaybe<Array<Scalars['String']['input']>>
  code_MATCHES?: InputMaybe<Scalars['String']['input']>
  code_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>
  name_MATCHES?: InputMaybe<Scalars['String']['input']>
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  type?: InputMaybe<ActionKind>
  type_EQ?: InputMaybe<ActionKind>
  type_IN?: InputMaybe<Array<ActionKind>>
}

export type CodeActionUpdateInput = {
  /** @deprecated Please use the explicit _SET field */
  code?: InputMaybe<Scalars['String']['input']>
  code_SET?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _SET field */
  id?: InputMaybe<Scalars['ID']['input']>
  id_SET?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _SET field */
  name?: InputMaybe<Scalars['String']['input']>
  name_SET?: InputMaybe<Scalars['String']['input']>
  postRenderElement?: InputMaybe<CodeActionPostRenderElementUpdateFieldInput>
  preRenderElement?: InputMaybe<CodeActionPreRenderElementUpdateFieldInput>
  store?: InputMaybe<CodeActionStoreUpdateFieldInput>
  /** @deprecated Please use the explicit _SET field */
  type?: InputMaybe<ActionKind>
  type_SET?: InputMaybe<ActionKind>
}

export type CodeActionUpdatedEvent = {
  event: EventType
  previousState: CodeActionEventPayload
  timestamp: Scalars['Float']['output']
  updatedCodeAction: CodeActionEventPayload
}

export type CodeActionWhere = {
  AND?: InputMaybe<Array<CodeActionWhere>>
  NOT?: InputMaybe<CodeActionWhere>
  OR?: InputMaybe<Array<CodeActionWhere>>
  /** @deprecated Please use the explicit _EQ version */
  code?: InputMaybe<Scalars['String']['input']>
  code_CONTAINS?: InputMaybe<Scalars['String']['input']>
  code_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  code_EQ?: InputMaybe<Scalars['String']['input']>
  code_IN?: InputMaybe<Array<Scalars['String']['input']>>
  code_MATCHES?: InputMaybe<Scalars['String']['input']>
  code_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>
  name_MATCHES?: InputMaybe<Scalars['String']['input']>
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  postRenderElement?: InputMaybe<ElementWhere>
  postRenderElementAggregate?: InputMaybe<CodeActionPostRenderElementAggregateInput>
  postRenderElementConnection?: InputMaybe<BaseActionPostRenderElementConnectionWhere>
  preRenderElement?: InputMaybe<ElementWhere>
  preRenderElementAggregate?: InputMaybe<CodeActionPreRenderElementAggregateInput>
  preRenderElementConnection?: InputMaybe<BaseActionPreRenderElementConnectionWhere>
  store?: InputMaybe<StoreWhere>
  storeAggregate?: InputMaybe<CodeActionStoreAggregateInput>
  storeConnection?: InputMaybe<BaseActionStoreConnectionWhere>
  /** @deprecated Please use the explicit _EQ version */
  type?: InputMaybe<ActionKind>
  type_EQ?: InputMaybe<ActionKind>
  type_IN?: InputMaybe<Array<ActionKind>>
}

export type CodeActionsConnection = {
  edges: Array<CodeActionEdge>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export enum CodeMirrorLanguage {
  Css = 'Css',
  CssInJs = 'CssInJs',
  Graphql = 'Graphql',
  Javascript = 'Javascript',
  Json = 'Json',
  Typescript = 'Typescript',
}

/** Allows editing the value using a code mirror editor */
export type CodeMirrorType = IBaseType & {
  fieldRefs: Array<Field>
  fieldRefsAggregate?: Maybe<CodeMirrorTypeFieldFieldRefsAggregationSelection>
  fieldRefsConnection: IBaseTypeFieldRefsConnection
  id: Scalars['ID']['output']
  kind: TypeKind
  language: CodeMirrorLanguage
  name: Scalars['String']['output']
  owner: User
  ownerAggregate?: Maybe<CodeMirrorTypeUserOwnerAggregationSelection>
  ownerConnection: IBaseTypeOwnerConnection
}

/** Allows editing the value using a code mirror editor */
export type CodeMirrorTypeFieldRefsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<FieldOptions>
  sort?: InputMaybe<Array<FieldSort>>
  where?: InputMaybe<FieldWhere>
}

/** Allows editing the value using a code mirror editor */
export type CodeMirrorTypeFieldRefsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<FieldWhere>
}

/** Allows editing the value using a code mirror editor */
export type CodeMirrorTypeFieldRefsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<IBaseTypeFieldRefsConnectionSort>>
  where?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
}

/** Allows editing the value using a code mirror editor */
export type CodeMirrorTypeOwnerArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<UserOptions>
  sort?: InputMaybe<Array<UserSort>>
  where?: InputMaybe<UserWhere>
}

/** Allows editing the value using a code mirror editor */
export type CodeMirrorTypeOwnerAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<UserWhere>
}

/** Allows editing the value using a code mirror editor */
export type CodeMirrorTypeOwnerConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<IBaseTypeOwnerConnectionSort>>
  where?: InputMaybe<IBaseTypeOwnerConnectionWhere>
}

export type CodeMirrorTypeAggregateSelection = {
  count: Scalars['Int']['output']
  id: IdAggregateSelection
  name: StringAggregateSelection
}

export type CodeMirrorTypeConnectInput = {
  fieldRefs?: InputMaybe<Array<CodeMirrorTypeFieldRefsConnectFieldInput>>
  owner?: InputMaybe<CodeMirrorTypeOwnerConnectFieldInput>
}

export type CodeMirrorTypeConnectWhere = {
  node: CodeMirrorTypeWhere
}

export type CodeMirrorTypeCreateInput = {
  fieldRefs?: InputMaybe<CodeMirrorTypeFieldRefsFieldInput>
  id: Scalars['ID']['input']
  kind?: TypeKind
  language: CodeMirrorLanguage
  name: Scalars['String']['input']
  owner?: InputMaybe<CodeMirrorTypeOwnerFieldInput>
}

export type CodeMirrorTypeCreatedEvent = {
  createdCodeMirrorType: CodeMirrorTypeEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type CodeMirrorTypeDeleteInput = {
  fieldRefs?: InputMaybe<Array<IBaseTypeFieldRefsDeleteFieldInput>>
  owner?: InputMaybe<IBaseTypeOwnerDeleteFieldInput>
}

export type CodeMirrorTypeDeletedEvent = {
  deletedCodeMirrorType: CodeMirrorTypeEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type CodeMirrorTypeDisconnectInput = {
  fieldRefs?: InputMaybe<Array<IBaseTypeFieldRefsDisconnectFieldInput>>
  owner?: InputMaybe<IBaseTypeOwnerDisconnectFieldInput>
}

export type CodeMirrorTypeEdge = {
  cursor: Scalars['String']['output']
  node: CodeMirrorType
}

export type CodeMirrorTypeEventPayload = {
  id: Scalars['ID']['output']
  kind: TypeKind
  language: CodeMirrorLanguage
  name: Scalars['String']['output']
}

export type CodeMirrorTypeFieldFieldRefsAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<CodeMirrorTypeFieldFieldRefsNodeAggregateSelection>
}

export type CodeMirrorTypeFieldFieldRefsNodeAggregateSelection = {
  defaultValues: StringAggregateSelection
  description: StringAggregateSelection
  id: IdAggregateSelection
  key: StringAggregateSelection
  name: StringAggregateSelection
  validationRules: StringAggregateSelection
}

export type CodeMirrorTypeFieldRefsAggregateInput = {
  AND?: InputMaybe<Array<CodeMirrorTypeFieldRefsAggregateInput>>
  NOT?: InputMaybe<CodeMirrorTypeFieldRefsAggregateInput>
  OR?: InputMaybe<Array<CodeMirrorTypeFieldRefsAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<CodeMirrorTypeFieldRefsNodeAggregationWhereInput>
}

export type CodeMirrorTypeFieldRefsConnectFieldInput = {
  connect?: InputMaybe<Array<FieldConnectInput>>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<FieldConnectWhere>
}

export type CodeMirrorTypeFieldRefsConnectOrCreateFieldInput = {
  onCreate: CodeMirrorTypeFieldRefsConnectOrCreateFieldInputOnCreate
  where: FieldConnectOrCreateWhere
}

export type CodeMirrorTypeFieldRefsConnectOrCreateFieldInputOnCreate = {
  node: FieldOnCreateInput
}

export type CodeMirrorTypeFieldRefsCreateFieldInput = {
  node: FieldCreateInput
}

export type CodeMirrorTypeFieldRefsFieldInput = {
  connect?: InputMaybe<Array<CodeMirrorTypeFieldRefsConnectFieldInput>>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<
    Array<CodeMirrorTypeFieldRefsConnectOrCreateFieldInput>
  >
  create?: InputMaybe<Array<CodeMirrorTypeFieldRefsCreateFieldInput>>
}

export type CodeMirrorTypeFieldRefsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<CodeMirrorTypeFieldRefsNodeAggregationWhereInput>>
  NOT?: InputMaybe<CodeMirrorTypeFieldRefsNodeAggregationWhereInput>
  OR?: InputMaybe<Array<CodeMirrorTypeFieldRefsNodeAggregationWhereInput>>
  defaultValues_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  defaultValues_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  description_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  description_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  key_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  key_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  validationRules_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type CodeMirrorTypeFieldRefsUpdateConnectionInput = {
  node?: InputMaybe<FieldUpdateInput>
}

export type CodeMirrorTypeFieldRefsUpdateFieldInput = {
  connect?: InputMaybe<Array<CodeMirrorTypeFieldRefsConnectFieldInput>>
  connectOrCreate?: InputMaybe<
    Array<CodeMirrorTypeFieldRefsConnectOrCreateFieldInput>
  >
  create?: InputMaybe<Array<CodeMirrorTypeFieldRefsCreateFieldInput>>
  delete?: InputMaybe<Array<IBaseTypeFieldRefsDeleteFieldInput>>
  disconnect?: InputMaybe<Array<IBaseTypeFieldRefsDisconnectFieldInput>>
  update?: InputMaybe<CodeMirrorTypeFieldRefsUpdateConnectionInput>
  where?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
}

export type CodeMirrorTypeOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  /** Specify one or more CodeMirrorTypeSort objects to sort CodeMirrorTypes by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<CodeMirrorTypeSort>>
}

export type CodeMirrorTypeOwnerAggregateInput = {
  AND?: InputMaybe<Array<CodeMirrorTypeOwnerAggregateInput>>
  NOT?: InputMaybe<CodeMirrorTypeOwnerAggregateInput>
  OR?: InputMaybe<Array<CodeMirrorTypeOwnerAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<CodeMirrorTypeOwnerNodeAggregationWhereInput>
}

export type CodeMirrorTypeOwnerConnectFieldInput = {
  connect?: InputMaybe<UserConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<UserConnectWhere>
}

export type CodeMirrorTypeOwnerConnectOrCreateFieldInput = {
  onCreate: CodeMirrorTypeOwnerConnectOrCreateFieldInputOnCreate
  where: UserConnectOrCreateWhere
}

export type CodeMirrorTypeOwnerConnectOrCreateFieldInputOnCreate = {
  node: UserOnCreateInput
}

export type CodeMirrorTypeOwnerCreateFieldInput = {
  node: UserCreateInput
}

export type CodeMirrorTypeOwnerFieldInput = {
  connect?: InputMaybe<CodeMirrorTypeOwnerConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<CodeMirrorTypeOwnerConnectOrCreateFieldInput>
  create?: InputMaybe<CodeMirrorTypeOwnerCreateFieldInput>
}

export type CodeMirrorTypeOwnerNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<CodeMirrorTypeOwnerNodeAggregationWhereInput>>
  NOT?: InputMaybe<CodeMirrorTypeOwnerNodeAggregationWhereInput>
  OR?: InputMaybe<Array<CodeMirrorTypeOwnerNodeAggregationWhereInput>>
  auth0Id_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  auth0Id_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  email_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  email_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  username_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  username_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type CodeMirrorTypeOwnerUpdateConnectionInput = {
  node?: InputMaybe<UserUpdateInput>
}

export type CodeMirrorTypeOwnerUpdateFieldInput = {
  connect?: InputMaybe<CodeMirrorTypeOwnerConnectFieldInput>
  connectOrCreate?: InputMaybe<CodeMirrorTypeOwnerConnectOrCreateFieldInput>
  create?: InputMaybe<CodeMirrorTypeOwnerCreateFieldInput>
  delete?: InputMaybe<IBaseTypeOwnerDeleteFieldInput>
  disconnect?: InputMaybe<IBaseTypeOwnerDisconnectFieldInput>
  update?: InputMaybe<CodeMirrorTypeOwnerUpdateConnectionInput>
  where?: InputMaybe<IBaseTypeOwnerConnectionWhere>
}

/** Fields to sort CodeMirrorTypes by. The order in which sorts are applied is not guaranteed when specifying many fields in one CodeMirrorTypeSort object. */
export type CodeMirrorTypeSort = {
  id?: InputMaybe<SortDirection>
  kind?: InputMaybe<SortDirection>
  language?: InputMaybe<SortDirection>
  name?: InputMaybe<SortDirection>
}

export type CodeMirrorTypeSubscriptionWhere = {
  AND?: InputMaybe<Array<CodeMirrorTypeSubscriptionWhere>>
  NOT?: InputMaybe<CodeMirrorTypeSubscriptionWhere>
  OR?: InputMaybe<Array<CodeMirrorTypeSubscriptionWhere>>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  kind?: InputMaybe<TypeKind>
  kind_EQ?: InputMaybe<TypeKind>
  kind_IN?: InputMaybe<Array<TypeKind>>
  /** @deprecated Please use the explicit _EQ version */
  language?: InputMaybe<CodeMirrorLanguage>
  language_EQ?: InputMaybe<CodeMirrorLanguage>
  language_IN?: InputMaybe<Array<CodeMirrorLanguage>>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>
  name_MATCHES?: InputMaybe<Scalars['String']['input']>
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
}

export type CodeMirrorTypeUpdateInput = {
  fieldRefs?: InputMaybe<Array<CodeMirrorTypeFieldRefsUpdateFieldInput>>
  /** @deprecated Please use the explicit _SET field */
  id?: InputMaybe<Scalars['ID']['input']>
  id_SET?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _SET field */
  kind?: InputMaybe<TypeKind>
  kind_SET?: InputMaybe<TypeKind>
  /** @deprecated Please use the explicit _SET field */
  language?: InputMaybe<CodeMirrorLanguage>
  language_SET?: InputMaybe<CodeMirrorLanguage>
  /** @deprecated Please use the explicit _SET field */
  name?: InputMaybe<Scalars['String']['input']>
  name_SET?: InputMaybe<Scalars['String']['input']>
  owner?: InputMaybe<CodeMirrorTypeOwnerUpdateFieldInput>
}

export type CodeMirrorTypeUpdatedEvent = {
  event: EventType
  previousState: CodeMirrorTypeEventPayload
  timestamp: Scalars['Float']['output']
  updatedCodeMirrorType: CodeMirrorTypeEventPayload
}

export type CodeMirrorTypeUserOwnerAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<CodeMirrorTypeUserOwnerNodeAggregateSelection>
}

export type CodeMirrorTypeUserOwnerNodeAggregateSelection = {
  auth0Id: StringAggregateSelection
  email: StringAggregateSelection
  id: IdAggregateSelection
  username: StringAggregateSelection
}

export type CodeMirrorTypeWhere = {
  AND?: InputMaybe<Array<CodeMirrorTypeWhere>>
  NOT?: InputMaybe<CodeMirrorTypeWhere>
  OR?: InputMaybe<Array<CodeMirrorTypeWhere>>
  fieldRefsAggregate?: InputMaybe<CodeMirrorTypeFieldRefsAggregateInput>
  /** Return CodeMirrorTypes where all of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_ALL?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return CodeMirrorTypes where none of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_NONE?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return CodeMirrorTypes where one of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_SINGLE?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return CodeMirrorTypes where some of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_SOME?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return CodeMirrorTypes where all of the related Fields match this filter */
  fieldRefs_ALL?: InputMaybe<FieldWhere>
  /** Return CodeMirrorTypes where none of the related Fields match this filter */
  fieldRefs_NONE?: InputMaybe<FieldWhere>
  /** Return CodeMirrorTypes where one of the related Fields match this filter */
  fieldRefs_SINGLE?: InputMaybe<FieldWhere>
  /** Return CodeMirrorTypes where some of the related Fields match this filter */
  fieldRefs_SOME?: InputMaybe<FieldWhere>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  kind?: InputMaybe<TypeKind>
  kind_EQ?: InputMaybe<TypeKind>
  kind_IN?: InputMaybe<Array<TypeKind>>
  /** @deprecated Please use the explicit _EQ version */
  language?: InputMaybe<CodeMirrorLanguage>
  language_EQ?: InputMaybe<CodeMirrorLanguage>
  language_IN?: InputMaybe<Array<CodeMirrorLanguage>>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>
  name_MATCHES?: InputMaybe<Scalars['String']['input']>
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  owner?: InputMaybe<UserWhere>
  ownerAggregate?: InputMaybe<CodeMirrorTypeOwnerAggregateInput>
  ownerConnection?: InputMaybe<IBaseTypeOwnerConnectionWhere>
}

export type CodeMirrorTypesConnection = {
  edges: Array<CodeMirrorTypeEdge>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type Component = WithOwner & {
  api: InterfaceType
  apiAggregate?: Maybe<ComponentInterfaceTypeApiAggregationSelection>
  apiConnection: ComponentApiConnection
  compositeKey: Scalars['String']['output']
  elements: Array<Element>
  elementsAggregate?: Maybe<ComponentElementElementsAggregationSelection>
  elementsConnection: ComponentElementsConnection
  id: Scalars['ID']['output']
  name: Scalars['String']['output']
  owner: User
  ownerAggregate?: Maybe<ComponentUserOwnerAggregationSelection>
  ownerConnection: WithOwnerOwnerConnection
  props: Prop
  propsAggregate?: Maybe<ComponentPropPropsAggregationSelection>
  propsConnection: ComponentPropsConnection
  rootElement: Element
  rootElementAggregate?: Maybe<ComponentElementRootElementAggregationSelection>
  rootElementConnection: ComponentRootElementConnection
  slug: Scalars['String']['output']
  store: Store
  storeAggregate?: Maybe<ComponentStoreStoreAggregationSelection>
  storeConnection: ComponentStoreConnection
}

export type ComponentApiArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<InterfaceTypeOptions>
  sort?: InputMaybe<Array<InterfaceTypeSort>>
  where?: InputMaybe<InterfaceTypeWhere>
}

export type ComponentApiAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<InterfaceTypeWhere>
}

export type ComponentApiConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<ComponentApiConnectionSort>>
  where?: InputMaybe<ComponentApiConnectionWhere>
}

export type ComponentElementsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<ElementOptions>
  sort?: InputMaybe<Array<ElementSort>>
  where?: InputMaybe<ElementWhere>
}

export type ComponentElementsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<ElementWhere>
}

export type ComponentElementsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<ComponentElementsConnectionSort>>
  where?: InputMaybe<ComponentElementsConnectionWhere>
}

export type ComponentOwnerArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<UserOptions>
  sort?: InputMaybe<Array<UserSort>>
  where?: InputMaybe<UserWhere>
}

export type ComponentOwnerAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<UserWhere>
}

export type ComponentOwnerConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<WithOwnerOwnerConnectionSort>>
  where?: InputMaybe<WithOwnerOwnerConnectionWhere>
}

export type ComponentPropsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<PropOptions>
  sort?: InputMaybe<Array<PropSort>>
  where?: InputMaybe<PropWhere>
}

export type ComponentPropsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<PropWhere>
}

export type ComponentPropsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<ComponentPropsConnectionSort>>
  where?: InputMaybe<ComponentPropsConnectionWhere>
}

export type ComponentRootElementArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<ElementOptions>
  sort?: InputMaybe<Array<ElementSort>>
  where?: InputMaybe<ElementWhere>
}

export type ComponentRootElementAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<ElementWhere>
}

export type ComponentRootElementConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<ComponentRootElementConnectionSort>>
  where?: InputMaybe<ComponentRootElementConnectionWhere>
}

export type ComponentStoreArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<StoreOptions>
  sort?: InputMaybe<Array<StoreSort>>
  where?: InputMaybe<StoreWhere>
}

export type ComponentStoreAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<StoreWhere>
}

export type ComponentStoreConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<ComponentStoreConnectionSort>>
  where?: InputMaybe<ComponentStoreConnectionWhere>
}

export type ComponentAggregateSelection = {
  compositeKey: StringAggregateSelection
  count: Scalars['Int']['output']
  id: IdAggregateSelection
}

export type ComponentApiAggregateInput = {
  AND?: InputMaybe<Array<ComponentApiAggregateInput>>
  NOT?: InputMaybe<ComponentApiAggregateInput>
  OR?: InputMaybe<Array<ComponentApiAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<ComponentApiNodeAggregationWhereInput>
}

export type ComponentApiConnectFieldInput = {
  connect?: InputMaybe<InterfaceTypeConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<InterfaceTypeConnectWhere>
}

export type ComponentApiConnection = {
  edges: Array<ComponentApiRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type ComponentApiConnectionSort = {
  node?: InputMaybe<InterfaceTypeSort>
}

export type ComponentApiConnectionWhere = {
  AND?: InputMaybe<Array<ComponentApiConnectionWhere>>
  NOT?: InputMaybe<ComponentApiConnectionWhere>
  OR?: InputMaybe<Array<ComponentApiConnectionWhere>>
  node?: InputMaybe<InterfaceTypeWhere>
}

export type ComponentApiCreateFieldInput = {
  node: InterfaceTypeCreateInput
}

export type ComponentApiDeleteFieldInput = {
  delete?: InputMaybe<InterfaceTypeDeleteInput>
  where?: InputMaybe<ComponentApiConnectionWhere>
}

export type ComponentApiDisconnectFieldInput = {
  disconnect?: InputMaybe<InterfaceTypeDisconnectInput>
  where?: InputMaybe<ComponentApiConnectionWhere>
}

export type ComponentApiFieldInput = {
  connect?: InputMaybe<ComponentApiConnectFieldInput>
  create?: InputMaybe<ComponentApiCreateFieldInput>
}

export type ComponentApiNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<ComponentApiNodeAggregationWhereInput>>
  NOT?: InputMaybe<ComponentApiNodeAggregationWhereInput>
  OR?: InputMaybe<Array<ComponentApiNodeAggregationWhereInput>>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type ComponentApiRelationship = {
  cursor: Scalars['String']['output']
  node: InterfaceType
}

export type ComponentApiUpdateConnectionInput = {
  node?: InputMaybe<InterfaceTypeUpdateInput>
}

export type ComponentApiUpdateFieldInput = {
  connect?: InputMaybe<ComponentApiConnectFieldInput>
  create?: InputMaybe<ComponentApiCreateFieldInput>
  delete?: InputMaybe<ComponentApiDeleteFieldInput>
  disconnect?: InputMaybe<ComponentApiDisconnectFieldInput>
  update?: InputMaybe<ComponentApiUpdateConnectionInput>
  where?: InputMaybe<ComponentApiConnectionWhere>
}

export type ComponentConnectInput = {
  api?: InputMaybe<ComponentApiConnectFieldInput>
  elements?: InputMaybe<Array<ComponentElementsConnectFieldInput>>
  owner?: InputMaybe<ComponentOwnerConnectFieldInput>
  props?: InputMaybe<ComponentPropsConnectFieldInput>
  rootElement?: InputMaybe<ComponentRootElementConnectFieldInput>
  store?: InputMaybe<ComponentStoreConnectFieldInput>
}

export type ComponentConnectOrCreateWhere = {
  node: ComponentUniqueWhere
}

export type ComponentConnectWhere = {
  node: ComponentWhere
}

export type ComponentCreateInput = {
  api?: InputMaybe<ComponentApiFieldInput>
  compositeKey: Scalars['String']['input']
  elements?: InputMaybe<ComponentElementsFieldInput>
  id: Scalars['ID']['input']
  owner?: InputMaybe<ComponentOwnerFieldInput>
  props?: InputMaybe<ComponentPropsFieldInput>
  rootElement?: InputMaybe<ComponentRootElementFieldInput>
  store?: InputMaybe<ComponentStoreFieldInput>
}

export type ComponentCreatedEvent = {
  createdComponent: ComponentEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type ComponentDeleteInput = {
  api?: InputMaybe<ComponentApiDeleteFieldInput>
  elements?: InputMaybe<Array<ComponentElementsDeleteFieldInput>>
  owner?: InputMaybe<WithOwnerOwnerDeleteFieldInput>
  props?: InputMaybe<ComponentPropsDeleteFieldInput>
  rootElement?: InputMaybe<ComponentRootElementDeleteFieldInput>
  store?: InputMaybe<ComponentStoreDeleteFieldInput>
}

export type ComponentDeletedEvent = {
  deletedComponent: ComponentEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type ComponentDisconnectInput = {
  api?: InputMaybe<ComponentApiDisconnectFieldInput>
  elements?: InputMaybe<Array<ComponentElementsDisconnectFieldInput>>
  owner?: InputMaybe<WithOwnerOwnerDisconnectFieldInput>
  props?: InputMaybe<ComponentPropsDisconnectFieldInput>
  rootElement?: InputMaybe<ComponentRootElementDisconnectFieldInput>
  store?: InputMaybe<ComponentStoreDisconnectFieldInput>
}

export type ComponentEdge = {
  cursor: Scalars['String']['output']
  node: Component
}

export type ComponentElementElementsAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<ComponentElementElementsNodeAggregateSelection>
}

export type ComponentElementElementsNodeAggregateSelection = {
  childMapperPropKey: StringAggregateSelection
  compositeKey: StringAggregateSelection
  id: IdAggregateSelection
  renderForEachPropKey: StringAggregateSelection
  renderIfExpression: StringAggregateSelection
  style: StringAggregateSelection
}

export type ComponentElementRootElementAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<ComponentElementRootElementNodeAggregateSelection>
}

export type ComponentElementRootElementNodeAggregateSelection = {
  childMapperPropKey: StringAggregateSelection
  compositeKey: StringAggregateSelection
  id: IdAggregateSelection
  renderForEachPropKey: StringAggregateSelection
  renderIfExpression: StringAggregateSelection
  style: StringAggregateSelection
}

export type ComponentElementsAggregateInput = {
  AND?: InputMaybe<Array<ComponentElementsAggregateInput>>
  NOT?: InputMaybe<ComponentElementsAggregateInput>
  OR?: InputMaybe<Array<ComponentElementsAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<ComponentElementsNodeAggregationWhereInput>
}

export type ComponentElementsConnectFieldInput = {
  connect?: InputMaybe<Array<ElementConnectInput>>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<ElementConnectWhere>
}

export type ComponentElementsConnectOrCreateFieldInput = {
  onCreate: ComponentElementsConnectOrCreateFieldInputOnCreate
  where: ElementConnectOrCreateWhere
}

export type ComponentElementsConnectOrCreateFieldInputOnCreate = {
  node: ElementOnCreateInput
}

export type ComponentElementsConnection = {
  edges: Array<ComponentElementsRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type ComponentElementsConnectionSort = {
  node?: InputMaybe<ElementSort>
}

export type ComponentElementsConnectionWhere = {
  AND?: InputMaybe<Array<ComponentElementsConnectionWhere>>
  NOT?: InputMaybe<ComponentElementsConnectionWhere>
  OR?: InputMaybe<Array<ComponentElementsConnectionWhere>>
  node?: InputMaybe<ElementWhere>
}

export type ComponentElementsCreateFieldInput = {
  node: ElementCreateInput
}

export type ComponentElementsDeleteFieldInput = {
  delete?: InputMaybe<ElementDeleteInput>
  where?: InputMaybe<ComponentElementsConnectionWhere>
}

export type ComponentElementsDisconnectFieldInput = {
  disconnect?: InputMaybe<ElementDisconnectInput>
  where?: InputMaybe<ComponentElementsConnectionWhere>
}

export type ComponentElementsFieldInput = {
  connect?: InputMaybe<Array<ComponentElementsConnectFieldInput>>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<
    Array<ComponentElementsConnectOrCreateFieldInput>
  >
  create?: InputMaybe<Array<ComponentElementsCreateFieldInput>>
}

export type ComponentElementsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<ComponentElementsNodeAggregationWhereInput>>
  NOT?: InputMaybe<ComponentElementsNodeAggregationWhereInput>
  OR?: InputMaybe<Array<ComponentElementsNodeAggregationWhereInput>>
  childMapperPropKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  childMapperPropKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_GTE?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_LTE?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_LONGEST_LENGTH_EQUAL?: InputMaybe<
    Scalars['Int']['input']
  >
  renderForEachPropKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<
    Scalars['Int']['input']
  >
  renderForEachPropKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  renderIfExpression_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  style_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  style_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type ComponentElementsRelationship = {
  cursor: Scalars['String']['output']
  node: Element
}

export type ComponentElementsUpdateConnectionInput = {
  node?: InputMaybe<ElementUpdateInput>
}

export type ComponentElementsUpdateFieldInput = {
  connect?: InputMaybe<Array<ComponentElementsConnectFieldInput>>
  connectOrCreate?: InputMaybe<
    Array<ComponentElementsConnectOrCreateFieldInput>
  >
  create?: InputMaybe<Array<ComponentElementsCreateFieldInput>>
  delete?: InputMaybe<Array<ComponentElementsDeleteFieldInput>>
  disconnect?: InputMaybe<Array<ComponentElementsDisconnectFieldInput>>
  update?: InputMaybe<ComponentElementsUpdateConnectionInput>
  where?: InputMaybe<ComponentElementsConnectionWhere>
}

export type ComponentEventPayload = {
  compositeKey: Scalars['String']['output']
  id: Scalars['ID']['output']
}

export type ComponentInterfaceTypeApiAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<ComponentInterfaceTypeApiNodeAggregateSelection>
}

export type ComponentInterfaceTypeApiNodeAggregateSelection = {
  id: IdAggregateSelection
  name: StringAggregateSelection
}

export type ComponentOnCreateInput = {
  compositeKey: Scalars['String']['input']
  id: Scalars['ID']['input']
}

export type ComponentOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  /** Specify one or more ComponentSort objects to sort Components by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<ComponentSort>>
}

export type ComponentOwnerAggregateInput = {
  AND?: InputMaybe<Array<ComponentOwnerAggregateInput>>
  NOT?: InputMaybe<ComponentOwnerAggregateInput>
  OR?: InputMaybe<Array<ComponentOwnerAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<ComponentOwnerNodeAggregationWhereInput>
}

export type ComponentOwnerConnectFieldInput = {
  connect?: InputMaybe<UserConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<UserConnectWhere>
}

export type ComponentOwnerConnectOrCreateFieldInput = {
  onCreate: ComponentOwnerConnectOrCreateFieldInputOnCreate
  where: UserConnectOrCreateWhere
}

export type ComponentOwnerConnectOrCreateFieldInputOnCreate = {
  node: UserOnCreateInput
}

export type ComponentOwnerCreateFieldInput = {
  node: UserCreateInput
}

export type ComponentOwnerFieldInput = {
  connect?: InputMaybe<ComponentOwnerConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<ComponentOwnerConnectOrCreateFieldInput>
  create?: InputMaybe<ComponentOwnerCreateFieldInput>
}

export type ComponentOwnerNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<ComponentOwnerNodeAggregationWhereInput>>
  NOT?: InputMaybe<ComponentOwnerNodeAggregationWhereInput>
  OR?: InputMaybe<Array<ComponentOwnerNodeAggregationWhereInput>>
  auth0Id_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  auth0Id_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  email_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  email_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  username_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  username_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type ComponentOwnerUpdateConnectionInput = {
  node?: InputMaybe<UserUpdateInput>
}

export type ComponentOwnerUpdateFieldInput = {
  connect?: InputMaybe<ComponentOwnerConnectFieldInput>
  connectOrCreate?: InputMaybe<ComponentOwnerConnectOrCreateFieldInput>
  create?: InputMaybe<ComponentOwnerCreateFieldInput>
  delete?: InputMaybe<WithOwnerOwnerDeleteFieldInput>
  disconnect?: InputMaybe<WithOwnerOwnerDisconnectFieldInput>
  update?: InputMaybe<ComponentOwnerUpdateConnectionInput>
  where?: InputMaybe<WithOwnerOwnerConnectionWhere>
}

export type ComponentPropPropsAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<ComponentPropPropsNodeAggregateSelection>
}

export type ComponentPropPropsNodeAggregateSelection = {
  data: StringAggregateSelection
  id: IdAggregateSelection
}

export type ComponentPropsAggregateInput = {
  AND?: InputMaybe<Array<ComponentPropsAggregateInput>>
  NOT?: InputMaybe<ComponentPropsAggregateInput>
  OR?: InputMaybe<Array<ComponentPropsAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<ComponentPropsNodeAggregationWhereInput>
}

export type ComponentPropsConnectFieldInput = {
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<PropConnectWhere>
}

export type ComponentPropsConnectOrCreateFieldInput = {
  onCreate: ComponentPropsConnectOrCreateFieldInputOnCreate
  where: PropConnectOrCreateWhere
}

export type ComponentPropsConnectOrCreateFieldInputOnCreate = {
  node: PropOnCreateInput
}

export type ComponentPropsConnection = {
  edges: Array<ComponentPropsRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type ComponentPropsConnectionSort = {
  node?: InputMaybe<PropSort>
}

export type ComponentPropsConnectionWhere = {
  AND?: InputMaybe<Array<ComponentPropsConnectionWhere>>
  NOT?: InputMaybe<ComponentPropsConnectionWhere>
  OR?: InputMaybe<Array<ComponentPropsConnectionWhere>>
  node?: InputMaybe<PropWhere>
}

export type ComponentPropsCreateFieldInput = {
  node: PropCreateInput
}

export type ComponentPropsDeleteFieldInput = {
  where?: InputMaybe<ComponentPropsConnectionWhere>
}

export type ComponentPropsDisconnectFieldInput = {
  where?: InputMaybe<ComponentPropsConnectionWhere>
}

export type ComponentPropsFieldInput = {
  connect?: InputMaybe<ComponentPropsConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<ComponentPropsConnectOrCreateFieldInput>
  create?: InputMaybe<ComponentPropsCreateFieldInput>
}

export type ComponentPropsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<ComponentPropsNodeAggregationWhereInput>>
  NOT?: InputMaybe<ComponentPropsNodeAggregationWhereInput>
  OR?: InputMaybe<Array<ComponentPropsNodeAggregationWhereInput>>
  data_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  data_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  data_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  data_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  data_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  data_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  data_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  data_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  data_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  data_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  data_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  data_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  data_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  data_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  data_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
}

export type ComponentPropsRelationship = {
  cursor: Scalars['String']['output']
  node: Prop
}

export type ComponentPropsUpdateConnectionInput = {
  node?: InputMaybe<PropUpdateInput>
}

export type ComponentPropsUpdateFieldInput = {
  connect?: InputMaybe<ComponentPropsConnectFieldInput>
  connectOrCreate?: InputMaybe<ComponentPropsConnectOrCreateFieldInput>
  create?: InputMaybe<ComponentPropsCreateFieldInput>
  delete?: InputMaybe<ComponentPropsDeleteFieldInput>
  disconnect?: InputMaybe<ComponentPropsDisconnectFieldInput>
  update?: InputMaybe<ComponentPropsUpdateConnectionInput>
  where?: InputMaybe<ComponentPropsConnectionWhere>
}

export type ComponentRootElementAggregateInput = {
  AND?: InputMaybe<Array<ComponentRootElementAggregateInput>>
  NOT?: InputMaybe<ComponentRootElementAggregateInput>
  OR?: InputMaybe<Array<ComponentRootElementAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<ComponentRootElementNodeAggregationWhereInput>
}

export type ComponentRootElementConnectFieldInput = {
  connect?: InputMaybe<ElementConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<ElementConnectWhere>
}

export type ComponentRootElementConnectOrCreateFieldInput = {
  onCreate: ComponentRootElementConnectOrCreateFieldInputOnCreate
  where: ElementConnectOrCreateWhere
}

export type ComponentRootElementConnectOrCreateFieldInputOnCreate = {
  node: ElementOnCreateInput
}

export type ComponentRootElementConnection = {
  edges: Array<ComponentRootElementRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type ComponentRootElementConnectionSort = {
  node?: InputMaybe<ElementSort>
}

export type ComponentRootElementConnectionWhere = {
  AND?: InputMaybe<Array<ComponentRootElementConnectionWhere>>
  NOT?: InputMaybe<ComponentRootElementConnectionWhere>
  OR?: InputMaybe<Array<ComponentRootElementConnectionWhere>>
  node?: InputMaybe<ElementWhere>
}

export type ComponentRootElementCreateFieldInput = {
  node: ElementCreateInput
}

export type ComponentRootElementDeleteFieldInput = {
  delete?: InputMaybe<ElementDeleteInput>
  where?: InputMaybe<ComponentRootElementConnectionWhere>
}

export type ComponentRootElementDisconnectFieldInput = {
  disconnect?: InputMaybe<ElementDisconnectInput>
  where?: InputMaybe<ComponentRootElementConnectionWhere>
}

export type ComponentRootElementFieldInput = {
  connect?: InputMaybe<ComponentRootElementConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<ComponentRootElementConnectOrCreateFieldInput>
  create?: InputMaybe<ComponentRootElementCreateFieldInput>
}

export type ComponentRootElementNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<ComponentRootElementNodeAggregationWhereInput>>
  NOT?: InputMaybe<ComponentRootElementNodeAggregationWhereInput>
  OR?: InputMaybe<Array<ComponentRootElementNodeAggregationWhereInput>>
  childMapperPropKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  childMapperPropKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_GTE?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_LTE?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_LONGEST_LENGTH_EQUAL?: InputMaybe<
    Scalars['Int']['input']
  >
  renderForEachPropKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<
    Scalars['Int']['input']
  >
  renderForEachPropKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  renderIfExpression_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  style_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  style_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type ComponentRootElementRelationship = {
  cursor: Scalars['String']['output']
  node: Element
}

export type ComponentRootElementUpdateConnectionInput = {
  node?: InputMaybe<ElementUpdateInput>
}

export type ComponentRootElementUpdateFieldInput = {
  connect?: InputMaybe<ComponentRootElementConnectFieldInput>
  connectOrCreate?: InputMaybe<ComponentRootElementConnectOrCreateFieldInput>
  create?: InputMaybe<ComponentRootElementCreateFieldInput>
  delete?: InputMaybe<ComponentRootElementDeleteFieldInput>
  disconnect?: InputMaybe<ComponentRootElementDisconnectFieldInput>
  update?: InputMaybe<ComponentRootElementUpdateConnectionInput>
  where?: InputMaybe<ComponentRootElementConnectionWhere>
}

/** Fields to sort Components by. The order in which sorts are applied is not guaranteed when specifying many fields in one ComponentSort object. */
export type ComponentSort = {
  compositeKey?: InputMaybe<SortDirection>
  id?: InputMaybe<SortDirection>
}

export type ComponentStoreAggregateInput = {
  AND?: InputMaybe<Array<ComponentStoreAggregateInput>>
  NOT?: InputMaybe<ComponentStoreAggregateInput>
  OR?: InputMaybe<Array<ComponentStoreAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<ComponentStoreNodeAggregationWhereInput>
}

export type ComponentStoreConnectFieldInput = {
  connect?: InputMaybe<StoreConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<StoreConnectWhere>
}

export type ComponentStoreConnectOrCreateFieldInput = {
  onCreate: ComponentStoreConnectOrCreateFieldInputOnCreate
  where: StoreConnectOrCreateWhere
}

export type ComponentStoreConnectOrCreateFieldInputOnCreate = {
  node: StoreOnCreateInput
}

export type ComponentStoreConnection = {
  edges: Array<ComponentStoreRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type ComponentStoreConnectionSort = {
  node?: InputMaybe<StoreSort>
}

export type ComponentStoreConnectionWhere = {
  AND?: InputMaybe<Array<ComponentStoreConnectionWhere>>
  NOT?: InputMaybe<ComponentStoreConnectionWhere>
  OR?: InputMaybe<Array<ComponentStoreConnectionWhere>>
  node?: InputMaybe<StoreWhere>
}

export type ComponentStoreCreateFieldInput = {
  node: StoreCreateInput
}

export type ComponentStoreDeleteFieldInput = {
  delete?: InputMaybe<StoreDeleteInput>
  where?: InputMaybe<ComponentStoreConnectionWhere>
}

export type ComponentStoreDisconnectFieldInput = {
  disconnect?: InputMaybe<StoreDisconnectInput>
  where?: InputMaybe<ComponentStoreConnectionWhere>
}

export type ComponentStoreFieldInput = {
  connect?: InputMaybe<ComponentStoreConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<ComponentStoreConnectOrCreateFieldInput>
  create?: InputMaybe<ComponentStoreCreateFieldInput>
}

export type ComponentStoreNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<ComponentStoreNodeAggregationWhereInput>>
  NOT?: InputMaybe<ComponentStoreNodeAggregationWhereInput>
  OR?: InputMaybe<Array<ComponentStoreNodeAggregationWhereInput>>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type ComponentStoreRelationship = {
  cursor: Scalars['String']['output']
  node: Store
}

export type ComponentStoreStoreAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<ComponentStoreStoreNodeAggregateSelection>
}

export type ComponentStoreStoreNodeAggregateSelection = {
  id: IdAggregateSelection
  name: StringAggregateSelection
}

export type ComponentStoreUpdateConnectionInput = {
  node?: InputMaybe<StoreUpdateInput>
}

export type ComponentStoreUpdateFieldInput = {
  connect?: InputMaybe<ComponentStoreConnectFieldInput>
  connectOrCreate?: InputMaybe<ComponentStoreConnectOrCreateFieldInput>
  create?: InputMaybe<ComponentStoreCreateFieldInput>
  delete?: InputMaybe<ComponentStoreDeleteFieldInput>
  disconnect?: InputMaybe<ComponentStoreDisconnectFieldInput>
  update?: InputMaybe<ComponentStoreUpdateConnectionInput>
  where?: InputMaybe<ComponentStoreConnectionWhere>
}

export type ComponentSubscriptionWhere = {
  AND?: InputMaybe<Array<ComponentSubscriptionWhere>>
  NOT?: InputMaybe<ComponentSubscriptionWhere>
  OR?: InputMaybe<Array<ComponentSubscriptionWhere>>
  /** @deprecated Please use the explicit _EQ version */
  compositeKey?: InputMaybe<Scalars['String']['input']>
  compositeKey_CONTAINS?: InputMaybe<Scalars['String']['input']>
  compositeKey_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  compositeKey_EQ?: InputMaybe<Scalars['String']['input']>
  compositeKey_IN?: InputMaybe<Array<Scalars['String']['input']>>
  compositeKey_MATCHES?: InputMaybe<Scalars['String']['input']>
  compositeKey_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
}

export type ComponentUniqueWhere = {
  /** @deprecated Please use the explicit _EQ version */
  compositeKey?: InputMaybe<Scalars['String']['input']>
  compositeKey_EQ?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
}

export type ComponentUpdateInput = {
  api?: InputMaybe<ComponentApiUpdateFieldInput>
  /** @deprecated Please use the explicit _SET field */
  compositeKey?: InputMaybe<Scalars['String']['input']>
  compositeKey_SET?: InputMaybe<Scalars['String']['input']>
  elements?: InputMaybe<Array<ComponentElementsUpdateFieldInput>>
  owner?: InputMaybe<ComponentOwnerUpdateFieldInput>
  props?: InputMaybe<ComponentPropsUpdateFieldInput>
  rootElement?: InputMaybe<ComponentRootElementUpdateFieldInput>
  store?: InputMaybe<ComponentStoreUpdateFieldInput>
}

export type ComponentUpdatedEvent = {
  event: EventType
  previousState: ComponentEventPayload
  timestamp: Scalars['Float']['output']
  updatedComponent: ComponentEventPayload
}

export type ComponentUserOwnerAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<ComponentUserOwnerNodeAggregateSelection>
}

export type ComponentUserOwnerNodeAggregateSelection = {
  auth0Id: StringAggregateSelection
  email: StringAggregateSelection
  id: IdAggregateSelection
  username: StringAggregateSelection
}

export type ComponentWhere = {
  AND?: InputMaybe<Array<ComponentWhere>>
  NOT?: InputMaybe<ComponentWhere>
  OR?: InputMaybe<Array<ComponentWhere>>
  api?: InputMaybe<InterfaceTypeWhere>
  apiAggregate?: InputMaybe<ComponentApiAggregateInput>
  apiConnection?: InputMaybe<ComponentApiConnectionWhere>
  /** @deprecated Please use the explicit _EQ version */
  compositeKey?: InputMaybe<Scalars['String']['input']>
  compositeKey_CONTAINS?: InputMaybe<Scalars['String']['input']>
  compositeKey_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  compositeKey_EQ?: InputMaybe<Scalars['String']['input']>
  compositeKey_IN?: InputMaybe<Array<Scalars['String']['input']>>
  compositeKey_MATCHES?: InputMaybe<Scalars['String']['input']>
  compositeKey_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  elementsAggregate?: InputMaybe<ComponentElementsAggregateInput>
  /** Return Components where all of the related ComponentElementsConnections match this filter */
  elementsConnection_ALL?: InputMaybe<ComponentElementsConnectionWhere>
  /** Return Components where none of the related ComponentElementsConnections match this filter */
  elementsConnection_NONE?: InputMaybe<ComponentElementsConnectionWhere>
  /** Return Components where one of the related ComponentElementsConnections match this filter */
  elementsConnection_SINGLE?: InputMaybe<ComponentElementsConnectionWhere>
  /** Return Components where some of the related ComponentElementsConnections match this filter */
  elementsConnection_SOME?: InputMaybe<ComponentElementsConnectionWhere>
  /** Return Components where all of the related Elements match this filter */
  elements_ALL?: InputMaybe<ElementWhere>
  /** Return Components where none of the related Elements match this filter */
  elements_NONE?: InputMaybe<ElementWhere>
  /** Return Components where one of the related Elements match this filter */
  elements_SINGLE?: InputMaybe<ElementWhere>
  /** Return Components where some of the related Elements match this filter */
  elements_SOME?: InputMaybe<ElementWhere>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  owner?: InputMaybe<UserWhere>
  ownerAggregate?: InputMaybe<ComponentOwnerAggregateInput>
  ownerConnection?: InputMaybe<WithOwnerOwnerConnectionWhere>
  props?: InputMaybe<PropWhere>
  propsAggregate?: InputMaybe<ComponentPropsAggregateInput>
  propsConnection?: InputMaybe<ComponentPropsConnectionWhere>
  rootElement?: InputMaybe<ElementWhere>
  rootElementAggregate?: InputMaybe<ComponentRootElementAggregateInput>
  rootElementConnection?: InputMaybe<ComponentRootElementConnectionWhere>
  store?: InputMaybe<StoreWhere>
  storeAggregate?: InputMaybe<ComponentStoreAggregateInput>
  storeConnection?: InputMaybe<ComponentStoreConnectionWhere>
}

export type ComponentsConnection = {
  edges: Array<ComponentEdge>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type ContainerNode = Component | Page

export type ContainerNodeWhere = {
  Component?: InputMaybe<ComponentWhere>
  Page?: InputMaybe<PageWhere>
}

export type CreateActionTypesMutationResponse = {
  actionTypes: Array<ActionType>
  info: CreateInfo
}

export type CreateApiActionsMutationResponse = {
  apiActions: Array<ApiAction>
  info: CreateInfo
}

export type CreateAppTypesMutationResponse = {
  appTypes: Array<AppType>
  info: CreateInfo
}

export type CreateAppsMutationResponse = {
  apps: Array<App>
  info: CreateInfo
}

export type CreateArrayTypesMutationResponse = {
  arrayTypes: Array<ArrayType>
  info: CreateInfo
}

export type CreateAtomsMutationResponse = {
  atoms: Array<Atom>
  info: CreateInfo
}

export type CreateAuthGuardsMutationResponse = {
  authGuards: Array<AuthGuard>
  info: CreateInfo
}

export type CreateCodeActionsMutationResponse = {
  codeActions: Array<CodeAction>
  info: CreateInfo
}

export type CreateCodeMirrorTypesMutationResponse = {
  codeMirrorTypes: Array<CodeMirrorType>
  info: CreateInfo
}

export type CreateComponentsMutationResponse = {
  components: Array<Component>
  info: CreateInfo
}

export type CreateDomainsMutationResponse = {
  domains: Array<Domain>
  info: CreateInfo
}

export type CreateElementTypesMutationResponse = {
  elementTypes: Array<ElementType>
  info: CreateInfo
}

export type CreateElementsMutationResponse = {
  elements: Array<Element>
  info: CreateInfo
}

export type CreateEnumTypeValuesMutationResponse = {
  enumTypeValues: Array<EnumTypeValue>
  info: CreateInfo
}

export type CreateEnumTypesMutationResponse = {
  enumTypes: Array<EnumType>
  info: CreateInfo
}

export type CreateFieldsMutationResponse = {
  fields: Array<Field>
  info: CreateInfo
}

export type CreateHooksMutationResponse = {
  hooks: Array<Hook>
  info: CreateInfo
}

/** Information about the number of nodes and relationships created during a create mutation */
export type CreateInfo = {
  nodesCreated: Scalars['Int']['output']
  relationshipsCreated: Scalars['Int']['output']
}

export type CreateInterfaceTypesMutationResponse = {
  info: CreateInfo
  interfaceTypes: Array<InterfaceType>
}

export type CreateLambdaTypesMutationResponse = {
  info: CreateInfo
  lambdaTypes: Array<LambdaType>
}

export type CreatePageTypesMutationResponse = {
  info: CreateInfo
  pageTypes: Array<PageType>
}

export type CreatePagesMutationResponse = {
  info: CreateInfo
  pages: Array<Page>
}

export type CreatePreferencesMutationResponse = {
  info: CreateInfo
  preferences: Array<Preference>
}

export type CreatePrimitiveTypesMutationResponse = {
  info: CreateInfo
  primitiveTypes: Array<PrimitiveType>
}

export type CreatePropsMutationResponse = {
  info: CreateInfo
  props: Array<Prop>
}

export type CreateReactNodeTypesMutationResponse = {
  info: CreateInfo
  reactNodeTypes: Array<ReactNodeType>
}

export type CreateRedirectsMutationResponse = {
  info: CreateInfo
  redirects: Array<Redirect>
}

export type CreateRenderPropTypesMutationResponse = {
  info: CreateInfo
  renderPropTypes: Array<RenderPropType>
}

export type CreateResourcesMutationResponse = {
  info: CreateInfo
  resources: Array<Resource>
}

export type CreateRichTextTypesMutationResponse = {
  info: CreateInfo
  richTextTypes: Array<RichTextType>
}

export type CreateStoresMutationResponse = {
  info: CreateInfo
  stores: Array<Store>
}

export type CreateTagsMutationResponse = {
  info: CreateInfo
  tags: Array<Tag>
}

export type CreateTypeReferencesMutationResponse = {
  info: CreateInfo
  typeReferences: Array<TypeReference>
}

export type CreateUnionTypesMutationResponse = {
  info: CreateInfo
  unionTypes: Array<UnionType>
}

export type CreateUsersMutationResponse = {
  info: CreateInfo
  users: Array<User>
}

/** Information about the number of nodes and relationships deleted during a delete mutation */
export type DeleteInfo = {
  nodesDeleted: Scalars['Int']['output']
  relationshipsDeleted: Scalars['Int']['output']
}

export type Domain = {
  app: App
  appAggregate?: Maybe<DomainAppAppAggregationSelection>
  appConnection: DomainAppConnection
  domainConfig: ProductionDomainConfig
  id: Scalars['ID']['output']
  name: Scalars['String']['output']
}

export type DomainAppArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<AppOptions>
  sort?: InputMaybe<Array<AppSort>>
  where?: InputMaybe<AppWhere>
}

export type DomainAppAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<AppWhere>
}

export type DomainAppConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<DomainAppConnectionSort>>
  where?: InputMaybe<DomainAppConnectionWhere>
}

export type DomainAggregateSelection = {
  count: Scalars['Int']['output']
  id: IdAggregateSelection
  name: StringAggregateSelection
}

export type DomainAppAggregateInput = {
  AND?: InputMaybe<Array<DomainAppAggregateInput>>
  NOT?: InputMaybe<DomainAppAggregateInput>
  OR?: InputMaybe<Array<DomainAppAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<DomainAppNodeAggregationWhereInput>
}

export type DomainAppAppAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<DomainAppAppNodeAggregateSelection>
}

export type DomainAppAppNodeAggregateSelection = {
  compositeKey: StringAggregateSelection
  id: IdAggregateSelection
}

export type DomainAppConnectFieldInput = {
  connect?: InputMaybe<AppConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<AppConnectWhere>
}

export type DomainAppConnectOrCreateFieldInput = {
  onCreate: DomainAppConnectOrCreateFieldInputOnCreate
  where: AppConnectOrCreateWhere
}

export type DomainAppConnectOrCreateFieldInputOnCreate = {
  node: AppOnCreateInput
}

export type DomainAppConnection = {
  edges: Array<DomainAppRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type DomainAppConnectionSort = {
  node?: InputMaybe<AppSort>
}

export type DomainAppConnectionWhere = {
  AND?: InputMaybe<Array<DomainAppConnectionWhere>>
  NOT?: InputMaybe<DomainAppConnectionWhere>
  OR?: InputMaybe<Array<DomainAppConnectionWhere>>
  node?: InputMaybe<AppWhere>
}

export type DomainAppCreateFieldInput = {
  node: AppCreateInput
}

export type DomainAppDeleteFieldInput = {
  delete?: InputMaybe<AppDeleteInput>
  where?: InputMaybe<DomainAppConnectionWhere>
}

export type DomainAppDisconnectFieldInput = {
  disconnect?: InputMaybe<AppDisconnectInput>
  where?: InputMaybe<DomainAppConnectionWhere>
}

export type DomainAppFieldInput = {
  connect?: InputMaybe<DomainAppConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<DomainAppConnectOrCreateFieldInput>
  create?: InputMaybe<DomainAppCreateFieldInput>
}

export type DomainAppNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<DomainAppNodeAggregationWhereInput>>
  NOT?: InputMaybe<DomainAppNodeAggregationWhereInput>
  OR?: InputMaybe<Array<DomainAppNodeAggregationWhereInput>>
  compositeKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
}

export type DomainAppRelationship = {
  cursor: Scalars['String']['output']
  node: App
}

export type DomainAppUpdateConnectionInput = {
  node?: InputMaybe<AppUpdateInput>
}

export type DomainAppUpdateFieldInput = {
  connect?: InputMaybe<DomainAppConnectFieldInput>
  connectOrCreate?: InputMaybe<DomainAppConnectOrCreateFieldInput>
  create?: InputMaybe<DomainAppCreateFieldInput>
  delete?: InputMaybe<DomainAppDeleteFieldInput>
  disconnect?: InputMaybe<DomainAppDisconnectFieldInput>
  update?: InputMaybe<DomainAppUpdateConnectionInput>
  where?: InputMaybe<DomainAppConnectionWhere>
}

export type DomainConnectInput = {
  app?: InputMaybe<DomainAppConnectFieldInput>
}

export type DomainConnectOrCreateWhere = {
  node: DomainUniqueWhere
}

export type DomainConnectWhere = {
  node: DomainWhere
}

export type DomainCreateInput = {
  app?: InputMaybe<DomainAppFieldInput>
  id: Scalars['ID']['input']
  name: Scalars['String']['input']
}

export type DomainCreatedEvent = {
  createdDomain: DomainEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type DomainDeleteInput = {
  app?: InputMaybe<DomainAppDeleteFieldInput>
}

export type DomainDeletedEvent = {
  deletedDomain: DomainEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type DomainDisconnectInput = {
  app?: InputMaybe<DomainAppDisconnectFieldInput>
}

export type DomainEdge = {
  cursor: Scalars['String']['output']
  node: Domain
}

export type DomainEventPayload = {
  id: Scalars['ID']['output']
  name: Scalars['String']['output']
}

export type DomainOnCreateInput = {
  id: Scalars['ID']['input']
  name: Scalars['String']['input']
}

export type DomainOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  /** Specify one or more DomainSort objects to sort Domains by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<DomainSort>>
}

/** Fields to sort Domains by. The order in which sorts are applied is not guaranteed when specifying many fields in one DomainSort object. */
export type DomainSort = {
  id?: InputMaybe<SortDirection>
  name?: InputMaybe<SortDirection>
}

export type DomainSubscriptionWhere = {
  AND?: InputMaybe<Array<DomainSubscriptionWhere>>
  NOT?: InputMaybe<DomainSubscriptionWhere>
  OR?: InputMaybe<Array<DomainSubscriptionWhere>>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>
  name_MATCHES?: InputMaybe<Scalars['String']['input']>
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
}

export type DomainUniqueWhere = {
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
}

export type DomainUpdateInput = {
  app?: InputMaybe<DomainAppUpdateFieldInput>
  /** @deprecated Please use the explicit _SET field */
  name?: InputMaybe<Scalars['String']['input']>
  name_SET?: InputMaybe<Scalars['String']['input']>
}

export type DomainUpdatedEvent = {
  event: EventType
  previousState: DomainEventPayload
  timestamp: Scalars['Float']['output']
  updatedDomain: DomainEventPayload
}

export type DomainWhere = {
  AND?: InputMaybe<Array<DomainWhere>>
  NOT?: InputMaybe<DomainWhere>
  OR?: InputMaybe<Array<DomainWhere>>
  app?: InputMaybe<AppWhere>
  appAggregate?: InputMaybe<DomainAppAggregateInput>
  appConnection?: InputMaybe<DomainAppConnectionWhere>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>
  name_MATCHES?: InputMaybe<Scalars['String']['input']>
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
}

export type DomainsConnection = {
  edges: Array<DomainEdge>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type Element = {
  childMapperComponent?: Maybe<Component>
  childMapperComponentAggregate?: Maybe<ElementComponentChildMapperComponentAggregationSelection>
  childMapperComponentConnection: ElementChildMapperComponentConnection
  childMapperPreviousSibling?: Maybe<Element>
  childMapperPreviousSiblingAggregate?: Maybe<ElementElementChildMapperPreviousSiblingAggregationSelection>
  childMapperPreviousSiblingConnection: ElementChildMapperPreviousSiblingConnection
  childMapperPropKey?: Maybe<Scalars['String']['output']>
  closestContainerNode: ContainerNode
  compositeKey: Scalars['String']['output']
  dependantTypes: Array<AnyType>
  expanded?: Maybe<Scalars['Boolean']['output']>
  firstChild?: Maybe<Element>
  firstChildAggregate?: Maybe<ElementElementFirstChildAggregationSelection>
  firstChildConnection: ElementFirstChildConnection
  id: Scalars['ID']['output']
  name: Scalars['String']['output']
  nextSibling?: Maybe<Element>
  nextSiblingAggregate?: Maybe<ElementElementNextSiblingAggregationSelection>
  nextSiblingConnection: ElementNextSiblingConnection
  page?: Maybe<Page>
  pageAggregate?: Maybe<ElementPagePageAggregationSelection>
  pageConnection: ElementPageConnection
  parentComponent?: Maybe<Component>
  parentComponentAggregate?: Maybe<ElementComponentParentComponentAggregationSelection>
  parentComponentConnection: ElementParentComponentConnection
  parentElement?: Maybe<Element>
  parentElementAggregate?: Maybe<ElementElementParentElementAggregationSelection>
  parentElementConnection: ElementParentElementConnection
  postRenderActions: Array<BaseAction>
  postRenderActionsAggregate?: Maybe<ElementBaseActionPostRenderActionsAggregationSelection>
  postRenderActionsConnection: ElementPostRenderActionsConnection
  preRenderActions: Array<BaseAction>
  preRenderActionsAggregate?: Maybe<ElementBaseActionPreRenderActionsAggregationSelection>
  preRenderActionsConnection: ElementPreRenderActionsConnection
  prevSibling?: Maybe<Element>
  prevSiblingAggregate?: Maybe<ElementElementPrevSiblingAggregationSelection>
  prevSiblingConnection: ElementPrevSiblingConnection
  props: Prop
  propsAggregate?: Maybe<ElementPropPropsAggregationSelection>
  propsConnection: ElementPropsConnection
  renderForEachPropKey?: Maybe<Scalars['String']['output']>
  renderIfExpression?: Maybe<Scalars['String']['output']>
  renderType: ElementRenderType
  renderTypeConnection: ElementRenderTypeConnection
  slug: Scalars['String']['output']
  style?: Maybe<Scalars['String']['output']>
  tailwindClassNames?: Maybe<Array<Scalars['String']['output']>>
}

export type ElementChildMapperComponentArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<ComponentOptions>
  sort?: InputMaybe<Array<ComponentSort>>
  where?: InputMaybe<ComponentWhere>
}

export type ElementChildMapperComponentAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<ComponentWhere>
}

export type ElementChildMapperComponentConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<ElementChildMapperComponentConnectionSort>>
  where?: InputMaybe<ElementChildMapperComponentConnectionWhere>
}

export type ElementChildMapperPreviousSiblingArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<ElementOptions>
  sort?: InputMaybe<Array<ElementSort>>
  where?: InputMaybe<ElementWhere>
}

export type ElementChildMapperPreviousSiblingAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<ElementWhere>
}

export type ElementChildMapperPreviousSiblingConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<ElementChildMapperPreviousSiblingConnectionSort>>
  where?: InputMaybe<ElementChildMapperPreviousSiblingConnectionWhere>
}

export type ElementFirstChildArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<ElementOptions>
  sort?: InputMaybe<Array<ElementSort>>
  where?: InputMaybe<ElementWhere>
}

export type ElementFirstChildAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<ElementWhere>
}

export type ElementFirstChildConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<ElementFirstChildConnectionSort>>
  where?: InputMaybe<ElementFirstChildConnectionWhere>
}

export type ElementNextSiblingArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<ElementOptions>
  sort?: InputMaybe<Array<ElementSort>>
  where?: InputMaybe<ElementWhere>
}

export type ElementNextSiblingAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<ElementWhere>
}

export type ElementNextSiblingConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<ElementNextSiblingConnectionSort>>
  where?: InputMaybe<ElementNextSiblingConnectionWhere>
}

export type ElementPageArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<PageOptions>
  sort?: InputMaybe<Array<PageSort>>
  where?: InputMaybe<PageWhere>
}

export type ElementPageAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<PageWhere>
}

export type ElementPageConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<ElementPageConnectionSort>>
  where?: InputMaybe<ElementPageConnectionWhere>
}

export type ElementParentComponentArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<ComponentOptions>
  sort?: InputMaybe<Array<ComponentSort>>
  where?: InputMaybe<ComponentWhere>
}

export type ElementParentComponentAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<ComponentWhere>
}

export type ElementParentComponentConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<ElementParentComponentConnectionSort>>
  where?: InputMaybe<ElementParentComponentConnectionWhere>
}

export type ElementParentElementArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<ElementOptions>
  sort?: InputMaybe<Array<ElementSort>>
  where?: InputMaybe<ElementWhere>
}

export type ElementParentElementAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<ElementWhere>
}

export type ElementParentElementConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<ElementParentElementConnectionSort>>
  where?: InputMaybe<ElementParentElementConnectionWhere>
}

export type ElementPostRenderActionsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<BaseActionOptions>
  sort?: InputMaybe<Array<BaseActionSort>>
  where?: InputMaybe<BaseActionWhere>
}

export type ElementPostRenderActionsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<BaseActionWhere>
}

export type ElementPostRenderActionsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<ElementPostRenderActionsConnectionSort>>
  where?: InputMaybe<ElementPostRenderActionsConnectionWhere>
}

export type ElementPreRenderActionsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<BaseActionOptions>
  sort?: InputMaybe<Array<BaseActionSort>>
  where?: InputMaybe<BaseActionWhere>
}

export type ElementPreRenderActionsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<BaseActionWhere>
}

export type ElementPreRenderActionsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<ElementPreRenderActionsConnectionSort>>
  where?: InputMaybe<ElementPreRenderActionsConnectionWhere>
}

export type ElementPrevSiblingArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<ElementOptions>
  sort?: InputMaybe<Array<ElementSort>>
  where?: InputMaybe<ElementWhere>
}

export type ElementPrevSiblingAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<ElementWhere>
}

export type ElementPrevSiblingConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<ElementPrevSiblingConnectionSort>>
  where?: InputMaybe<ElementPrevSiblingConnectionWhere>
}

export type ElementPropsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<PropOptions>
  sort?: InputMaybe<Array<PropSort>>
  where?: InputMaybe<PropWhere>
}

export type ElementPropsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<PropWhere>
}

export type ElementPropsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<ElementPropsConnectionSort>>
  where?: InputMaybe<ElementPropsConnectionWhere>
}

export type ElementRenderTypeArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<QueryOptions>
  where?: InputMaybe<ElementRenderTypeWhere>
}

export type ElementRenderTypeConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  where?: InputMaybe<ElementRenderTypeConnectionWhere>
}

export type ElementAggregateSelection = {
  childMapperPropKey: StringAggregateSelection
  compositeKey: StringAggregateSelection
  count: Scalars['Int']['output']
  id: IdAggregateSelection
  renderForEachPropKey: StringAggregateSelection
  renderIfExpression: StringAggregateSelection
  style: StringAggregateSelection
}

export type ElementBaseActionPostRenderActionsAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<ElementBaseActionPostRenderActionsNodeAggregateSelection>
}

export type ElementBaseActionPostRenderActionsNodeAggregateSelection = {
  id: IdAggregateSelection
  name: StringAggregateSelection
}

export type ElementBaseActionPreRenderActionsAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<ElementBaseActionPreRenderActionsNodeAggregateSelection>
}

export type ElementBaseActionPreRenderActionsNodeAggregateSelection = {
  id: IdAggregateSelection
  name: StringAggregateSelection
}

export type ElementChildMapperComponentAggregateInput = {
  AND?: InputMaybe<Array<ElementChildMapperComponentAggregateInput>>
  NOT?: InputMaybe<ElementChildMapperComponentAggregateInput>
  OR?: InputMaybe<Array<ElementChildMapperComponentAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<ElementChildMapperComponentNodeAggregationWhereInput>
}

export type ElementChildMapperComponentConnectFieldInput = {
  connect?: InputMaybe<ComponentConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<ComponentConnectWhere>
}

export type ElementChildMapperComponentConnectOrCreateFieldInput = {
  onCreate: ElementChildMapperComponentConnectOrCreateFieldInputOnCreate
  where: ComponentConnectOrCreateWhere
}

export type ElementChildMapperComponentConnectOrCreateFieldInputOnCreate = {
  node: ComponentOnCreateInput
}

export type ElementChildMapperComponentConnection = {
  edges: Array<ElementChildMapperComponentRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type ElementChildMapperComponentConnectionSort = {
  node?: InputMaybe<ComponentSort>
}

export type ElementChildMapperComponentConnectionWhere = {
  AND?: InputMaybe<Array<ElementChildMapperComponentConnectionWhere>>
  NOT?: InputMaybe<ElementChildMapperComponentConnectionWhere>
  OR?: InputMaybe<Array<ElementChildMapperComponentConnectionWhere>>
  node?: InputMaybe<ComponentWhere>
}

export type ElementChildMapperComponentCreateFieldInput = {
  node: ComponentCreateInput
}

export type ElementChildMapperComponentDeleteFieldInput = {
  delete?: InputMaybe<ComponentDeleteInput>
  where?: InputMaybe<ElementChildMapperComponentConnectionWhere>
}

export type ElementChildMapperComponentDisconnectFieldInput = {
  disconnect?: InputMaybe<ComponentDisconnectInput>
  where?: InputMaybe<ElementChildMapperComponentConnectionWhere>
}

export type ElementChildMapperComponentFieldInput = {
  connect?: InputMaybe<ElementChildMapperComponentConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<ElementChildMapperComponentConnectOrCreateFieldInput>
  create?: InputMaybe<ElementChildMapperComponentCreateFieldInput>
}

export type ElementChildMapperComponentNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<ElementChildMapperComponentNodeAggregationWhereInput>>
  NOT?: InputMaybe<ElementChildMapperComponentNodeAggregationWhereInput>
  OR?: InputMaybe<Array<ElementChildMapperComponentNodeAggregationWhereInput>>
  compositeKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
}

export type ElementChildMapperComponentRelationship = {
  cursor: Scalars['String']['output']
  node: Component
}

export type ElementChildMapperComponentUpdateConnectionInput = {
  node?: InputMaybe<ComponentUpdateInput>
}

export type ElementChildMapperComponentUpdateFieldInput = {
  connect?: InputMaybe<ElementChildMapperComponentConnectFieldInput>
  connectOrCreate?: InputMaybe<ElementChildMapperComponentConnectOrCreateFieldInput>
  create?: InputMaybe<ElementChildMapperComponentCreateFieldInput>
  delete?: InputMaybe<ElementChildMapperComponentDeleteFieldInput>
  disconnect?: InputMaybe<ElementChildMapperComponentDisconnectFieldInput>
  update?: InputMaybe<ElementChildMapperComponentUpdateConnectionInput>
  where?: InputMaybe<ElementChildMapperComponentConnectionWhere>
}

export type ElementChildMapperPreviousSiblingAggregateInput = {
  AND?: InputMaybe<Array<ElementChildMapperPreviousSiblingAggregateInput>>
  NOT?: InputMaybe<ElementChildMapperPreviousSiblingAggregateInput>
  OR?: InputMaybe<Array<ElementChildMapperPreviousSiblingAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<ElementChildMapperPreviousSiblingNodeAggregationWhereInput>
}

export type ElementChildMapperPreviousSiblingConnectFieldInput = {
  connect?: InputMaybe<ElementConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<ElementConnectWhere>
}

export type ElementChildMapperPreviousSiblingConnectOrCreateFieldInput = {
  onCreate: ElementChildMapperPreviousSiblingConnectOrCreateFieldInputOnCreate
  where: ElementConnectOrCreateWhere
}

export type ElementChildMapperPreviousSiblingConnectOrCreateFieldInputOnCreate =
  {
    node: ElementOnCreateInput
  }

export type ElementChildMapperPreviousSiblingConnection = {
  edges: Array<ElementChildMapperPreviousSiblingRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type ElementChildMapperPreviousSiblingConnectionSort = {
  node?: InputMaybe<ElementSort>
}

export type ElementChildMapperPreviousSiblingConnectionWhere = {
  AND?: InputMaybe<Array<ElementChildMapperPreviousSiblingConnectionWhere>>
  NOT?: InputMaybe<ElementChildMapperPreviousSiblingConnectionWhere>
  OR?: InputMaybe<Array<ElementChildMapperPreviousSiblingConnectionWhere>>
  node?: InputMaybe<ElementWhere>
}

export type ElementChildMapperPreviousSiblingCreateFieldInput = {
  node: ElementCreateInput
}

export type ElementChildMapperPreviousSiblingDeleteFieldInput = {
  delete?: InputMaybe<ElementDeleteInput>
  where?: InputMaybe<ElementChildMapperPreviousSiblingConnectionWhere>
}

export type ElementChildMapperPreviousSiblingDisconnectFieldInput = {
  disconnect?: InputMaybe<ElementDisconnectInput>
  where?: InputMaybe<ElementChildMapperPreviousSiblingConnectionWhere>
}

export type ElementChildMapperPreviousSiblingFieldInput = {
  connect?: InputMaybe<ElementChildMapperPreviousSiblingConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<ElementChildMapperPreviousSiblingConnectOrCreateFieldInput>
  create?: InputMaybe<ElementChildMapperPreviousSiblingCreateFieldInput>
}

export type ElementChildMapperPreviousSiblingNodeAggregationWhereInput = {
  AND?: InputMaybe<
    Array<ElementChildMapperPreviousSiblingNodeAggregationWhereInput>
  >
  NOT?: InputMaybe<ElementChildMapperPreviousSiblingNodeAggregationWhereInput>
  OR?: InputMaybe<
    Array<ElementChildMapperPreviousSiblingNodeAggregationWhereInput>
  >
  childMapperPropKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  childMapperPropKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_GTE?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_LTE?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_LONGEST_LENGTH_EQUAL?: InputMaybe<
    Scalars['Int']['input']
  >
  renderForEachPropKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<
    Scalars['Int']['input']
  >
  renderForEachPropKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  renderIfExpression_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  style_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  style_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type ElementChildMapperPreviousSiblingRelationship = {
  cursor: Scalars['String']['output']
  node: Element
}

export type ElementChildMapperPreviousSiblingUpdateConnectionInput = {
  node?: InputMaybe<ElementUpdateInput>
}

export type ElementChildMapperPreviousSiblingUpdateFieldInput = {
  connect?: InputMaybe<ElementChildMapperPreviousSiblingConnectFieldInput>
  connectOrCreate?: InputMaybe<ElementChildMapperPreviousSiblingConnectOrCreateFieldInput>
  create?: InputMaybe<ElementChildMapperPreviousSiblingCreateFieldInput>
  delete?: InputMaybe<ElementChildMapperPreviousSiblingDeleteFieldInput>
  disconnect?: InputMaybe<ElementChildMapperPreviousSiblingDisconnectFieldInput>
  update?: InputMaybe<ElementChildMapperPreviousSiblingUpdateConnectionInput>
  where?: InputMaybe<ElementChildMapperPreviousSiblingConnectionWhere>
}

export type ElementComponentChildMapperComponentAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<ElementComponentChildMapperComponentNodeAggregateSelection>
}

export type ElementComponentChildMapperComponentNodeAggregateSelection = {
  compositeKey: StringAggregateSelection
  id: IdAggregateSelection
}

export type ElementComponentParentComponentAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<ElementComponentParentComponentNodeAggregateSelection>
}

export type ElementComponentParentComponentNodeAggregateSelection = {
  compositeKey: StringAggregateSelection
  id: IdAggregateSelection
}

export type ElementConnectInput = {
  childMapperComponent?: InputMaybe<ElementChildMapperComponentConnectFieldInput>
  childMapperPreviousSibling?: InputMaybe<ElementChildMapperPreviousSiblingConnectFieldInput>
  firstChild?: InputMaybe<ElementFirstChildConnectFieldInput>
  nextSibling?: InputMaybe<ElementNextSiblingConnectFieldInput>
  page?: InputMaybe<ElementPageConnectFieldInput>
  parentComponent?: InputMaybe<ElementParentComponentConnectFieldInput>
  parentElement?: InputMaybe<ElementParentElementConnectFieldInput>
  postRenderActions?: InputMaybe<
    Array<ElementPostRenderActionsConnectFieldInput>
  >
  preRenderActions?: InputMaybe<Array<ElementPreRenderActionsConnectFieldInput>>
  prevSibling?: InputMaybe<ElementPrevSiblingConnectFieldInput>
  props?: InputMaybe<ElementPropsConnectFieldInput>
  renderType?: InputMaybe<ElementRenderTypeConnectInput>
}

export type ElementConnectOrCreateWhere = {
  node: ElementUniqueWhere
}

export type ElementConnectWhere = {
  node: ElementWhere
}

export type ElementCreateInput = {
  childMapperComponent?: InputMaybe<ElementChildMapperComponentFieldInput>
  childMapperPreviousSibling?: InputMaybe<ElementChildMapperPreviousSiblingFieldInput>
  childMapperPropKey?: InputMaybe<Scalars['String']['input']>
  compositeKey: Scalars['String']['input']
  expanded?: InputMaybe<Scalars['Boolean']['input']>
  firstChild?: InputMaybe<ElementFirstChildFieldInput>
  id: Scalars['ID']['input']
  nextSibling?: InputMaybe<ElementNextSiblingFieldInput>
  page?: InputMaybe<ElementPageFieldInput>
  parentComponent?: InputMaybe<ElementParentComponentFieldInput>
  parentElement?: InputMaybe<ElementParentElementFieldInput>
  postRenderActions?: InputMaybe<ElementPostRenderActionsFieldInput>
  preRenderActions?: InputMaybe<ElementPreRenderActionsFieldInput>
  prevSibling?: InputMaybe<ElementPrevSiblingFieldInput>
  props?: InputMaybe<ElementPropsFieldInput>
  renderForEachPropKey?: InputMaybe<Scalars['String']['input']>
  renderIfExpression?: InputMaybe<Scalars['String']['input']>
  renderType?: InputMaybe<ElementRenderTypeCreateInput>
  style?: InputMaybe<Scalars['String']['input']>
  tailwindClassNames?: InputMaybe<Array<Scalars['String']['input']>>
}

export type ElementCreatedEvent = {
  createdElement: ElementEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type ElementDeleteInput = {
  childMapperComponent?: InputMaybe<ElementChildMapperComponentDeleteFieldInput>
  childMapperPreviousSibling?: InputMaybe<ElementChildMapperPreviousSiblingDeleteFieldInput>
  firstChild?: InputMaybe<ElementFirstChildDeleteFieldInput>
  nextSibling?: InputMaybe<ElementNextSiblingDeleteFieldInput>
  page?: InputMaybe<ElementPageDeleteFieldInput>
  parentComponent?: InputMaybe<ElementParentComponentDeleteFieldInput>
  parentElement?: InputMaybe<ElementParentElementDeleteFieldInput>
  postRenderActions?: InputMaybe<
    Array<ElementPostRenderActionsDeleteFieldInput>
  >
  preRenderActions?: InputMaybe<Array<ElementPreRenderActionsDeleteFieldInput>>
  prevSibling?: InputMaybe<ElementPrevSiblingDeleteFieldInput>
  props?: InputMaybe<ElementPropsDeleteFieldInput>
  renderType?: InputMaybe<ElementRenderTypeDeleteInput>
}

export type ElementDeletedEvent = {
  deletedElement: ElementEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type ElementDisconnectInput = {
  childMapperComponent?: InputMaybe<ElementChildMapperComponentDisconnectFieldInput>
  childMapperPreviousSibling?: InputMaybe<ElementChildMapperPreviousSiblingDisconnectFieldInput>
  firstChild?: InputMaybe<ElementFirstChildDisconnectFieldInput>
  nextSibling?: InputMaybe<ElementNextSiblingDisconnectFieldInput>
  page?: InputMaybe<ElementPageDisconnectFieldInput>
  parentComponent?: InputMaybe<ElementParentComponentDisconnectFieldInput>
  parentElement?: InputMaybe<ElementParentElementDisconnectFieldInput>
  postRenderActions?: InputMaybe<
    Array<ElementPostRenderActionsDisconnectFieldInput>
  >
  preRenderActions?: InputMaybe<
    Array<ElementPreRenderActionsDisconnectFieldInput>
  >
  prevSibling?: InputMaybe<ElementPrevSiblingDisconnectFieldInput>
  props?: InputMaybe<ElementPropsDisconnectFieldInput>
  renderType?: InputMaybe<ElementRenderTypeDisconnectInput>
}

export type ElementEdge = {
  cursor: Scalars['String']['output']
  node: Element
}

export type ElementElementChildMapperPreviousSiblingAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<ElementElementChildMapperPreviousSiblingNodeAggregateSelection>
}

export type ElementElementChildMapperPreviousSiblingNodeAggregateSelection = {
  childMapperPropKey: StringAggregateSelection
  compositeKey: StringAggregateSelection
  id: IdAggregateSelection
  renderForEachPropKey: StringAggregateSelection
  renderIfExpression: StringAggregateSelection
  style: StringAggregateSelection
}

export type ElementElementFirstChildAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<ElementElementFirstChildNodeAggregateSelection>
}

export type ElementElementFirstChildNodeAggregateSelection = {
  childMapperPropKey: StringAggregateSelection
  compositeKey: StringAggregateSelection
  id: IdAggregateSelection
  renderForEachPropKey: StringAggregateSelection
  renderIfExpression: StringAggregateSelection
  style: StringAggregateSelection
}

export type ElementElementNextSiblingAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<ElementElementNextSiblingNodeAggregateSelection>
}

export type ElementElementNextSiblingNodeAggregateSelection = {
  childMapperPropKey: StringAggregateSelection
  compositeKey: StringAggregateSelection
  id: IdAggregateSelection
  renderForEachPropKey: StringAggregateSelection
  renderIfExpression: StringAggregateSelection
  style: StringAggregateSelection
}

export type ElementElementParentElementAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<ElementElementParentElementNodeAggregateSelection>
}

export type ElementElementParentElementNodeAggregateSelection = {
  childMapperPropKey: StringAggregateSelection
  compositeKey: StringAggregateSelection
  id: IdAggregateSelection
  renderForEachPropKey: StringAggregateSelection
  renderIfExpression: StringAggregateSelection
  style: StringAggregateSelection
}

export type ElementElementPrevSiblingAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<ElementElementPrevSiblingNodeAggregateSelection>
}

export type ElementElementPrevSiblingNodeAggregateSelection = {
  childMapperPropKey: StringAggregateSelection
  compositeKey: StringAggregateSelection
  id: IdAggregateSelection
  renderForEachPropKey: StringAggregateSelection
  renderIfExpression: StringAggregateSelection
  style: StringAggregateSelection
}

export type ElementEventPayload = {
  childMapperPropKey?: Maybe<Scalars['String']['output']>
  compositeKey: Scalars['String']['output']
  expanded?: Maybe<Scalars['Boolean']['output']>
  id: Scalars['ID']['output']
  renderForEachPropKey?: Maybe<Scalars['String']['output']>
  renderIfExpression?: Maybe<Scalars['String']['output']>
  style?: Maybe<Scalars['String']['output']>
  tailwindClassNames?: Maybe<Array<Scalars['String']['output']>>
}

export type ElementFirstChildAggregateInput = {
  AND?: InputMaybe<Array<ElementFirstChildAggregateInput>>
  NOT?: InputMaybe<ElementFirstChildAggregateInput>
  OR?: InputMaybe<Array<ElementFirstChildAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<ElementFirstChildNodeAggregationWhereInput>
}

export type ElementFirstChildConnectFieldInput = {
  connect?: InputMaybe<ElementConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<ElementConnectWhere>
}

export type ElementFirstChildConnectOrCreateFieldInput = {
  onCreate: ElementFirstChildConnectOrCreateFieldInputOnCreate
  where: ElementConnectOrCreateWhere
}

export type ElementFirstChildConnectOrCreateFieldInputOnCreate = {
  node: ElementOnCreateInput
}

export type ElementFirstChildConnection = {
  edges: Array<ElementFirstChildRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type ElementFirstChildConnectionSort = {
  node?: InputMaybe<ElementSort>
}

export type ElementFirstChildConnectionWhere = {
  AND?: InputMaybe<Array<ElementFirstChildConnectionWhere>>
  NOT?: InputMaybe<ElementFirstChildConnectionWhere>
  OR?: InputMaybe<Array<ElementFirstChildConnectionWhere>>
  node?: InputMaybe<ElementWhere>
}

export type ElementFirstChildCreateFieldInput = {
  node: ElementCreateInput
}

export type ElementFirstChildDeleteFieldInput = {
  delete?: InputMaybe<ElementDeleteInput>
  where?: InputMaybe<ElementFirstChildConnectionWhere>
}

export type ElementFirstChildDisconnectFieldInput = {
  disconnect?: InputMaybe<ElementDisconnectInput>
  where?: InputMaybe<ElementFirstChildConnectionWhere>
}

export type ElementFirstChildFieldInput = {
  connect?: InputMaybe<ElementFirstChildConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<ElementFirstChildConnectOrCreateFieldInput>
  create?: InputMaybe<ElementFirstChildCreateFieldInput>
}

export type ElementFirstChildNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<ElementFirstChildNodeAggregationWhereInput>>
  NOT?: InputMaybe<ElementFirstChildNodeAggregationWhereInput>
  OR?: InputMaybe<Array<ElementFirstChildNodeAggregationWhereInput>>
  childMapperPropKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  childMapperPropKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_GTE?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_LTE?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_LONGEST_LENGTH_EQUAL?: InputMaybe<
    Scalars['Int']['input']
  >
  renderForEachPropKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<
    Scalars['Int']['input']
  >
  renderForEachPropKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  renderIfExpression_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  style_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  style_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type ElementFirstChildRelationship = {
  cursor: Scalars['String']['output']
  node: Element
}

export type ElementFirstChildUpdateConnectionInput = {
  node?: InputMaybe<ElementUpdateInput>
}

export type ElementFirstChildUpdateFieldInput = {
  connect?: InputMaybe<ElementFirstChildConnectFieldInput>
  connectOrCreate?: InputMaybe<ElementFirstChildConnectOrCreateFieldInput>
  create?: InputMaybe<ElementFirstChildCreateFieldInput>
  delete?: InputMaybe<ElementFirstChildDeleteFieldInput>
  disconnect?: InputMaybe<ElementFirstChildDisconnectFieldInput>
  update?: InputMaybe<ElementFirstChildUpdateConnectionInput>
  where?: InputMaybe<ElementFirstChildConnectionWhere>
}

export type ElementNextSiblingAggregateInput = {
  AND?: InputMaybe<Array<ElementNextSiblingAggregateInput>>
  NOT?: InputMaybe<ElementNextSiblingAggregateInput>
  OR?: InputMaybe<Array<ElementNextSiblingAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<ElementNextSiblingNodeAggregationWhereInput>
}

export type ElementNextSiblingConnectFieldInput = {
  connect?: InputMaybe<ElementConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<ElementConnectWhere>
}

export type ElementNextSiblingConnectOrCreateFieldInput = {
  onCreate: ElementNextSiblingConnectOrCreateFieldInputOnCreate
  where: ElementConnectOrCreateWhere
}

export type ElementNextSiblingConnectOrCreateFieldInputOnCreate = {
  node: ElementOnCreateInput
}

export type ElementNextSiblingConnection = {
  edges: Array<ElementNextSiblingRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type ElementNextSiblingConnectionSort = {
  node?: InputMaybe<ElementSort>
}

export type ElementNextSiblingConnectionWhere = {
  AND?: InputMaybe<Array<ElementNextSiblingConnectionWhere>>
  NOT?: InputMaybe<ElementNextSiblingConnectionWhere>
  OR?: InputMaybe<Array<ElementNextSiblingConnectionWhere>>
  node?: InputMaybe<ElementWhere>
}

export type ElementNextSiblingCreateFieldInput = {
  node: ElementCreateInput
}

export type ElementNextSiblingDeleteFieldInput = {
  delete?: InputMaybe<ElementDeleteInput>
  where?: InputMaybe<ElementNextSiblingConnectionWhere>
}

export type ElementNextSiblingDisconnectFieldInput = {
  disconnect?: InputMaybe<ElementDisconnectInput>
  where?: InputMaybe<ElementNextSiblingConnectionWhere>
}

export type ElementNextSiblingFieldInput = {
  connect?: InputMaybe<ElementNextSiblingConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<ElementNextSiblingConnectOrCreateFieldInput>
  create?: InputMaybe<ElementNextSiblingCreateFieldInput>
}

export type ElementNextSiblingNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<ElementNextSiblingNodeAggregationWhereInput>>
  NOT?: InputMaybe<ElementNextSiblingNodeAggregationWhereInput>
  OR?: InputMaybe<Array<ElementNextSiblingNodeAggregationWhereInput>>
  childMapperPropKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  childMapperPropKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_GTE?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_LTE?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_LONGEST_LENGTH_EQUAL?: InputMaybe<
    Scalars['Int']['input']
  >
  renderForEachPropKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<
    Scalars['Int']['input']
  >
  renderForEachPropKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  renderIfExpression_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  style_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  style_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type ElementNextSiblingRelationship = {
  cursor: Scalars['String']['output']
  node: Element
}

export type ElementNextSiblingUpdateConnectionInput = {
  node?: InputMaybe<ElementUpdateInput>
}

export type ElementNextSiblingUpdateFieldInput = {
  connect?: InputMaybe<ElementNextSiblingConnectFieldInput>
  connectOrCreate?: InputMaybe<ElementNextSiblingConnectOrCreateFieldInput>
  create?: InputMaybe<ElementNextSiblingCreateFieldInput>
  delete?: InputMaybe<ElementNextSiblingDeleteFieldInput>
  disconnect?: InputMaybe<ElementNextSiblingDisconnectFieldInput>
  update?: InputMaybe<ElementNextSiblingUpdateConnectionInput>
  where?: InputMaybe<ElementNextSiblingConnectionWhere>
}

export type ElementOnCreateInput = {
  childMapperPropKey?: InputMaybe<Scalars['String']['input']>
  compositeKey: Scalars['String']['input']
  expanded?: InputMaybe<Scalars['Boolean']['input']>
  id: Scalars['ID']['input']
  renderForEachPropKey?: InputMaybe<Scalars['String']['input']>
  renderIfExpression?: InputMaybe<Scalars['String']['input']>
  style?: InputMaybe<Scalars['String']['input']>
  tailwindClassNames?: InputMaybe<Array<Scalars['String']['input']>>
}

export type ElementOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  /** Specify one or more ElementSort objects to sort Elements by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<ElementSort>>
}

export type ElementPageAggregateInput = {
  AND?: InputMaybe<Array<ElementPageAggregateInput>>
  NOT?: InputMaybe<ElementPageAggregateInput>
  OR?: InputMaybe<Array<ElementPageAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<ElementPageNodeAggregationWhereInput>
}

export type ElementPageConnectFieldInput = {
  connect?: InputMaybe<PageConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<PageConnectWhere>
}

export type ElementPageConnectOrCreateFieldInput = {
  onCreate: ElementPageConnectOrCreateFieldInputOnCreate
  where: PageConnectOrCreateWhere
}

export type ElementPageConnectOrCreateFieldInputOnCreate = {
  node: PageOnCreateInput
}

export type ElementPageConnection = {
  edges: Array<ElementPageRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type ElementPageConnectionSort = {
  node?: InputMaybe<PageSort>
}

export type ElementPageConnectionWhere = {
  AND?: InputMaybe<Array<ElementPageConnectionWhere>>
  NOT?: InputMaybe<ElementPageConnectionWhere>
  OR?: InputMaybe<Array<ElementPageConnectionWhere>>
  node?: InputMaybe<PageWhere>
}

export type ElementPageCreateFieldInput = {
  node: PageCreateInput
}

export type ElementPageDeleteFieldInput = {
  delete?: InputMaybe<PageDeleteInput>
  where?: InputMaybe<ElementPageConnectionWhere>
}

export type ElementPageDisconnectFieldInput = {
  disconnect?: InputMaybe<PageDisconnectInput>
  where?: InputMaybe<ElementPageConnectionWhere>
}

export type ElementPageFieldInput = {
  connect?: InputMaybe<ElementPageConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<ElementPageConnectOrCreateFieldInput>
  create?: InputMaybe<ElementPageCreateFieldInput>
}

export type ElementPageNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<ElementPageNodeAggregationWhereInput>>
  NOT?: InputMaybe<ElementPageNodeAggregationWhereInput>
  OR?: InputMaybe<Array<ElementPageNodeAggregationWhereInput>>
  compositeKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  urlPattern_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  urlPattern_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  urlPattern_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  urlPattern_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  urlPattern_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  urlPattern_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  urlPattern_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  urlPattern_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  urlPattern_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  urlPattern_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  urlPattern_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  urlPattern_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  urlPattern_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  urlPattern_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  urlPattern_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type ElementPagePageAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<ElementPagePageNodeAggregateSelection>
}

export type ElementPagePageNodeAggregateSelection = {
  compositeKey: StringAggregateSelection
  id: IdAggregateSelection
  urlPattern: StringAggregateSelection
}

export type ElementPageRelationship = {
  cursor: Scalars['String']['output']
  node: Page
}

export type ElementPageUpdateConnectionInput = {
  node?: InputMaybe<PageUpdateInput>
}

export type ElementPageUpdateFieldInput = {
  connect?: InputMaybe<ElementPageConnectFieldInput>
  connectOrCreate?: InputMaybe<ElementPageConnectOrCreateFieldInput>
  create?: InputMaybe<ElementPageCreateFieldInput>
  delete?: InputMaybe<ElementPageDeleteFieldInput>
  disconnect?: InputMaybe<ElementPageDisconnectFieldInput>
  update?: InputMaybe<ElementPageUpdateConnectionInput>
  where?: InputMaybe<ElementPageConnectionWhere>
}

export type ElementParentComponentAggregateInput = {
  AND?: InputMaybe<Array<ElementParentComponentAggregateInput>>
  NOT?: InputMaybe<ElementParentComponentAggregateInput>
  OR?: InputMaybe<Array<ElementParentComponentAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<ElementParentComponentNodeAggregationWhereInput>
}

export type ElementParentComponentConnectFieldInput = {
  connect?: InputMaybe<ComponentConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<ComponentConnectWhere>
}

export type ElementParentComponentConnectOrCreateFieldInput = {
  onCreate: ElementParentComponentConnectOrCreateFieldInputOnCreate
  where: ComponentConnectOrCreateWhere
}

export type ElementParentComponentConnectOrCreateFieldInputOnCreate = {
  node: ComponentOnCreateInput
}

export type ElementParentComponentConnection = {
  edges: Array<ElementParentComponentRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type ElementParentComponentConnectionSort = {
  node?: InputMaybe<ComponentSort>
}

export type ElementParentComponentConnectionWhere = {
  AND?: InputMaybe<Array<ElementParentComponentConnectionWhere>>
  NOT?: InputMaybe<ElementParentComponentConnectionWhere>
  OR?: InputMaybe<Array<ElementParentComponentConnectionWhere>>
  node?: InputMaybe<ComponentWhere>
}

export type ElementParentComponentCreateFieldInput = {
  node: ComponentCreateInput
}

export type ElementParentComponentDeleteFieldInput = {
  delete?: InputMaybe<ComponentDeleteInput>
  where?: InputMaybe<ElementParentComponentConnectionWhere>
}

export type ElementParentComponentDisconnectFieldInput = {
  disconnect?: InputMaybe<ComponentDisconnectInput>
  where?: InputMaybe<ElementParentComponentConnectionWhere>
}

export type ElementParentComponentFieldInput = {
  connect?: InputMaybe<ElementParentComponentConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<ElementParentComponentConnectOrCreateFieldInput>
  create?: InputMaybe<ElementParentComponentCreateFieldInput>
}

export type ElementParentComponentNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<ElementParentComponentNodeAggregationWhereInput>>
  NOT?: InputMaybe<ElementParentComponentNodeAggregationWhereInput>
  OR?: InputMaybe<Array<ElementParentComponentNodeAggregationWhereInput>>
  compositeKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
}

export type ElementParentComponentRelationship = {
  cursor: Scalars['String']['output']
  node: Component
}

export type ElementParentComponentUpdateConnectionInput = {
  node?: InputMaybe<ComponentUpdateInput>
}

export type ElementParentComponentUpdateFieldInput = {
  connect?: InputMaybe<ElementParentComponentConnectFieldInput>
  connectOrCreate?: InputMaybe<ElementParentComponentConnectOrCreateFieldInput>
  create?: InputMaybe<ElementParentComponentCreateFieldInput>
  delete?: InputMaybe<ElementParentComponentDeleteFieldInput>
  disconnect?: InputMaybe<ElementParentComponentDisconnectFieldInput>
  update?: InputMaybe<ElementParentComponentUpdateConnectionInput>
  where?: InputMaybe<ElementParentComponentConnectionWhere>
}

export type ElementParentElementAggregateInput = {
  AND?: InputMaybe<Array<ElementParentElementAggregateInput>>
  NOT?: InputMaybe<ElementParentElementAggregateInput>
  OR?: InputMaybe<Array<ElementParentElementAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<ElementParentElementNodeAggregationWhereInput>
}

export type ElementParentElementConnectFieldInput = {
  connect?: InputMaybe<ElementConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<ElementConnectWhere>
}

export type ElementParentElementConnectOrCreateFieldInput = {
  onCreate: ElementParentElementConnectOrCreateFieldInputOnCreate
  where: ElementConnectOrCreateWhere
}

export type ElementParentElementConnectOrCreateFieldInputOnCreate = {
  node: ElementOnCreateInput
}

export type ElementParentElementConnection = {
  edges: Array<ElementParentElementRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type ElementParentElementConnectionSort = {
  node?: InputMaybe<ElementSort>
}

export type ElementParentElementConnectionWhere = {
  AND?: InputMaybe<Array<ElementParentElementConnectionWhere>>
  NOT?: InputMaybe<ElementParentElementConnectionWhere>
  OR?: InputMaybe<Array<ElementParentElementConnectionWhere>>
  node?: InputMaybe<ElementWhere>
}

export type ElementParentElementCreateFieldInput = {
  node: ElementCreateInput
}

export type ElementParentElementDeleteFieldInput = {
  delete?: InputMaybe<ElementDeleteInput>
  where?: InputMaybe<ElementParentElementConnectionWhere>
}

export type ElementParentElementDisconnectFieldInput = {
  disconnect?: InputMaybe<ElementDisconnectInput>
  where?: InputMaybe<ElementParentElementConnectionWhere>
}

export type ElementParentElementFieldInput = {
  connect?: InputMaybe<ElementParentElementConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<ElementParentElementConnectOrCreateFieldInput>
  create?: InputMaybe<ElementParentElementCreateFieldInput>
}

export type ElementParentElementNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<ElementParentElementNodeAggregationWhereInput>>
  NOT?: InputMaybe<ElementParentElementNodeAggregationWhereInput>
  OR?: InputMaybe<Array<ElementParentElementNodeAggregationWhereInput>>
  childMapperPropKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  childMapperPropKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_GTE?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_LTE?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_LONGEST_LENGTH_EQUAL?: InputMaybe<
    Scalars['Int']['input']
  >
  renderForEachPropKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<
    Scalars['Int']['input']
  >
  renderForEachPropKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  renderIfExpression_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  style_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  style_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type ElementParentElementRelationship = {
  cursor: Scalars['String']['output']
  node: Element
}

export type ElementParentElementUpdateConnectionInput = {
  node?: InputMaybe<ElementUpdateInput>
}

export type ElementParentElementUpdateFieldInput = {
  connect?: InputMaybe<ElementParentElementConnectFieldInput>
  connectOrCreate?: InputMaybe<ElementParentElementConnectOrCreateFieldInput>
  create?: InputMaybe<ElementParentElementCreateFieldInput>
  delete?: InputMaybe<ElementParentElementDeleteFieldInput>
  disconnect?: InputMaybe<ElementParentElementDisconnectFieldInput>
  update?: InputMaybe<ElementParentElementUpdateConnectionInput>
  where?: InputMaybe<ElementParentElementConnectionWhere>
}

export type ElementPostRenderActionsAggregateInput = {
  AND?: InputMaybe<Array<ElementPostRenderActionsAggregateInput>>
  NOT?: InputMaybe<ElementPostRenderActionsAggregateInput>
  OR?: InputMaybe<Array<ElementPostRenderActionsAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<ElementPostRenderActionsNodeAggregationWhereInput>
}

export type ElementPostRenderActionsConnectFieldInput = {
  connect?: InputMaybe<BaseActionConnectInput>
  where?: InputMaybe<BaseActionConnectWhere>
}

export type ElementPostRenderActionsConnection = {
  edges: Array<ElementPostRenderActionsRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type ElementPostRenderActionsConnectionSort = {
  node?: InputMaybe<BaseActionSort>
}

export type ElementPostRenderActionsConnectionWhere = {
  AND?: InputMaybe<Array<ElementPostRenderActionsConnectionWhere>>
  NOT?: InputMaybe<ElementPostRenderActionsConnectionWhere>
  OR?: InputMaybe<Array<ElementPostRenderActionsConnectionWhere>>
  node?: InputMaybe<BaseActionWhere>
}

export type ElementPostRenderActionsCreateFieldInput = {
  node: BaseActionCreateInput
}

export type ElementPostRenderActionsDeleteFieldInput = {
  delete?: InputMaybe<BaseActionDeleteInput>
  where?: InputMaybe<ElementPostRenderActionsConnectionWhere>
}

export type ElementPostRenderActionsDisconnectFieldInput = {
  disconnect?: InputMaybe<BaseActionDisconnectInput>
  where?: InputMaybe<ElementPostRenderActionsConnectionWhere>
}

export type ElementPostRenderActionsFieldInput = {
  connect?: InputMaybe<Array<ElementPostRenderActionsConnectFieldInput>>
  create?: InputMaybe<Array<ElementPostRenderActionsCreateFieldInput>>
}

export type ElementPostRenderActionsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<ElementPostRenderActionsNodeAggregationWhereInput>>
  NOT?: InputMaybe<ElementPostRenderActionsNodeAggregationWhereInput>
  OR?: InputMaybe<Array<ElementPostRenderActionsNodeAggregationWhereInput>>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type ElementPostRenderActionsRelationship = {
  cursor: Scalars['String']['output']
  node: BaseAction
}

export type ElementPostRenderActionsUpdateConnectionInput = {
  node?: InputMaybe<BaseActionUpdateInput>
}

export type ElementPostRenderActionsUpdateFieldInput = {
  connect?: InputMaybe<Array<ElementPostRenderActionsConnectFieldInput>>
  create?: InputMaybe<Array<ElementPostRenderActionsCreateFieldInput>>
  delete?: InputMaybe<Array<ElementPostRenderActionsDeleteFieldInput>>
  disconnect?: InputMaybe<Array<ElementPostRenderActionsDisconnectFieldInput>>
  update?: InputMaybe<ElementPostRenderActionsUpdateConnectionInput>
  where?: InputMaybe<ElementPostRenderActionsConnectionWhere>
}

export type ElementPreRenderActionsAggregateInput = {
  AND?: InputMaybe<Array<ElementPreRenderActionsAggregateInput>>
  NOT?: InputMaybe<ElementPreRenderActionsAggregateInput>
  OR?: InputMaybe<Array<ElementPreRenderActionsAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<ElementPreRenderActionsNodeAggregationWhereInput>
}

export type ElementPreRenderActionsConnectFieldInput = {
  connect?: InputMaybe<BaseActionConnectInput>
  where?: InputMaybe<BaseActionConnectWhere>
}

export type ElementPreRenderActionsConnection = {
  edges: Array<ElementPreRenderActionsRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type ElementPreRenderActionsConnectionSort = {
  node?: InputMaybe<BaseActionSort>
}

export type ElementPreRenderActionsConnectionWhere = {
  AND?: InputMaybe<Array<ElementPreRenderActionsConnectionWhere>>
  NOT?: InputMaybe<ElementPreRenderActionsConnectionWhere>
  OR?: InputMaybe<Array<ElementPreRenderActionsConnectionWhere>>
  node?: InputMaybe<BaseActionWhere>
}

export type ElementPreRenderActionsCreateFieldInput = {
  node: BaseActionCreateInput
}

export type ElementPreRenderActionsDeleteFieldInput = {
  delete?: InputMaybe<BaseActionDeleteInput>
  where?: InputMaybe<ElementPreRenderActionsConnectionWhere>
}

export type ElementPreRenderActionsDisconnectFieldInput = {
  disconnect?: InputMaybe<BaseActionDisconnectInput>
  where?: InputMaybe<ElementPreRenderActionsConnectionWhere>
}

export type ElementPreRenderActionsFieldInput = {
  connect?: InputMaybe<Array<ElementPreRenderActionsConnectFieldInput>>
  create?: InputMaybe<Array<ElementPreRenderActionsCreateFieldInput>>
}

export type ElementPreRenderActionsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<ElementPreRenderActionsNodeAggregationWhereInput>>
  NOT?: InputMaybe<ElementPreRenderActionsNodeAggregationWhereInput>
  OR?: InputMaybe<Array<ElementPreRenderActionsNodeAggregationWhereInput>>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type ElementPreRenderActionsRelationship = {
  cursor: Scalars['String']['output']
  node: BaseAction
}

export type ElementPreRenderActionsUpdateConnectionInput = {
  node?: InputMaybe<BaseActionUpdateInput>
}

export type ElementPreRenderActionsUpdateFieldInput = {
  connect?: InputMaybe<Array<ElementPreRenderActionsConnectFieldInput>>
  create?: InputMaybe<Array<ElementPreRenderActionsCreateFieldInput>>
  delete?: InputMaybe<Array<ElementPreRenderActionsDeleteFieldInput>>
  disconnect?: InputMaybe<Array<ElementPreRenderActionsDisconnectFieldInput>>
  update?: InputMaybe<ElementPreRenderActionsUpdateConnectionInput>
  where?: InputMaybe<ElementPreRenderActionsConnectionWhere>
}

export type ElementPrevSiblingAggregateInput = {
  AND?: InputMaybe<Array<ElementPrevSiblingAggregateInput>>
  NOT?: InputMaybe<ElementPrevSiblingAggregateInput>
  OR?: InputMaybe<Array<ElementPrevSiblingAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<ElementPrevSiblingNodeAggregationWhereInput>
}

export type ElementPrevSiblingConnectFieldInput = {
  connect?: InputMaybe<ElementConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<ElementConnectWhere>
}

export type ElementPrevSiblingConnectOrCreateFieldInput = {
  onCreate: ElementPrevSiblingConnectOrCreateFieldInputOnCreate
  where: ElementConnectOrCreateWhere
}

export type ElementPrevSiblingConnectOrCreateFieldInputOnCreate = {
  node: ElementOnCreateInput
}

export type ElementPrevSiblingConnection = {
  edges: Array<ElementPrevSiblingRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type ElementPrevSiblingConnectionSort = {
  node?: InputMaybe<ElementSort>
}

export type ElementPrevSiblingConnectionWhere = {
  AND?: InputMaybe<Array<ElementPrevSiblingConnectionWhere>>
  NOT?: InputMaybe<ElementPrevSiblingConnectionWhere>
  OR?: InputMaybe<Array<ElementPrevSiblingConnectionWhere>>
  node?: InputMaybe<ElementWhere>
}

export type ElementPrevSiblingCreateFieldInput = {
  node: ElementCreateInput
}

export type ElementPrevSiblingDeleteFieldInput = {
  delete?: InputMaybe<ElementDeleteInput>
  where?: InputMaybe<ElementPrevSiblingConnectionWhere>
}

export type ElementPrevSiblingDisconnectFieldInput = {
  disconnect?: InputMaybe<ElementDisconnectInput>
  where?: InputMaybe<ElementPrevSiblingConnectionWhere>
}

export type ElementPrevSiblingFieldInput = {
  connect?: InputMaybe<ElementPrevSiblingConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<ElementPrevSiblingConnectOrCreateFieldInput>
  create?: InputMaybe<ElementPrevSiblingCreateFieldInput>
}

export type ElementPrevSiblingNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<ElementPrevSiblingNodeAggregationWhereInput>>
  NOT?: InputMaybe<ElementPrevSiblingNodeAggregationWhereInput>
  OR?: InputMaybe<Array<ElementPrevSiblingNodeAggregationWhereInput>>
  childMapperPropKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  childMapperPropKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_GTE?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_LTE?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_LONGEST_LENGTH_EQUAL?: InputMaybe<
    Scalars['Int']['input']
  >
  renderForEachPropKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<
    Scalars['Int']['input']
  >
  renderForEachPropKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  renderIfExpression_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  style_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  style_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type ElementPrevSiblingRelationship = {
  cursor: Scalars['String']['output']
  node: Element
}

export type ElementPrevSiblingUpdateConnectionInput = {
  node?: InputMaybe<ElementUpdateInput>
}

export type ElementPrevSiblingUpdateFieldInput = {
  connect?: InputMaybe<ElementPrevSiblingConnectFieldInput>
  connectOrCreate?: InputMaybe<ElementPrevSiblingConnectOrCreateFieldInput>
  create?: InputMaybe<ElementPrevSiblingCreateFieldInput>
  delete?: InputMaybe<ElementPrevSiblingDeleteFieldInput>
  disconnect?: InputMaybe<ElementPrevSiblingDisconnectFieldInput>
  update?: InputMaybe<ElementPrevSiblingUpdateConnectionInput>
  where?: InputMaybe<ElementPrevSiblingConnectionWhere>
}

export type ElementPropPropsAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<ElementPropPropsNodeAggregateSelection>
}

export type ElementPropPropsNodeAggregateSelection = {
  data: StringAggregateSelection
  id: IdAggregateSelection
}

export type ElementPropsAggregateInput = {
  AND?: InputMaybe<Array<ElementPropsAggregateInput>>
  NOT?: InputMaybe<ElementPropsAggregateInput>
  OR?: InputMaybe<Array<ElementPropsAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<ElementPropsNodeAggregationWhereInput>
}

export type ElementPropsConnectFieldInput = {
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<PropConnectWhere>
}

export type ElementPropsConnectOrCreateFieldInput = {
  onCreate: ElementPropsConnectOrCreateFieldInputOnCreate
  where: PropConnectOrCreateWhere
}

export type ElementPropsConnectOrCreateFieldInputOnCreate = {
  node: PropOnCreateInput
}

export type ElementPropsConnection = {
  edges: Array<ElementPropsRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type ElementPropsConnectionSort = {
  node?: InputMaybe<PropSort>
}

export type ElementPropsConnectionWhere = {
  AND?: InputMaybe<Array<ElementPropsConnectionWhere>>
  NOT?: InputMaybe<ElementPropsConnectionWhere>
  OR?: InputMaybe<Array<ElementPropsConnectionWhere>>
  node?: InputMaybe<PropWhere>
}

export type ElementPropsCreateFieldInput = {
  node: PropCreateInput
}

export type ElementPropsDeleteFieldInput = {
  where?: InputMaybe<ElementPropsConnectionWhere>
}

export type ElementPropsDisconnectFieldInput = {
  where?: InputMaybe<ElementPropsConnectionWhere>
}

export type ElementPropsFieldInput = {
  connect?: InputMaybe<ElementPropsConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<ElementPropsConnectOrCreateFieldInput>
  create?: InputMaybe<ElementPropsCreateFieldInput>
}

export type ElementPropsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<ElementPropsNodeAggregationWhereInput>>
  NOT?: InputMaybe<ElementPropsNodeAggregationWhereInput>
  OR?: InputMaybe<Array<ElementPropsNodeAggregationWhereInput>>
  data_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  data_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  data_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  data_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  data_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  data_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  data_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  data_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  data_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  data_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  data_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  data_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  data_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  data_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  data_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
}

export type ElementPropsRelationship = {
  cursor: Scalars['String']['output']
  node: Prop
}

export type ElementPropsUpdateConnectionInput = {
  node?: InputMaybe<PropUpdateInput>
}

export type ElementPropsUpdateFieldInput = {
  connect?: InputMaybe<ElementPropsConnectFieldInput>
  connectOrCreate?: InputMaybe<ElementPropsConnectOrCreateFieldInput>
  create?: InputMaybe<ElementPropsCreateFieldInput>
  delete?: InputMaybe<ElementPropsDeleteFieldInput>
  disconnect?: InputMaybe<ElementPropsDisconnectFieldInput>
  update?: InputMaybe<ElementPropsUpdateConnectionInput>
  where?: InputMaybe<ElementPropsConnectionWhere>
}

export type ElementRenderType = Atom | Component

export type ElementRenderTypeAtomConnectFieldInput = {
  connect?: InputMaybe<AtomConnectInput>
  where?: InputMaybe<AtomConnectWhere>
}

export type ElementRenderTypeAtomConnectOrCreateFieldInput = {
  onCreate: ElementRenderTypeAtomConnectOrCreateFieldInputOnCreate
  where: AtomConnectOrCreateWhere
}

export type ElementRenderTypeAtomConnectOrCreateFieldInputOnCreate = {
  node: AtomOnCreateInput
}

export type ElementRenderTypeAtomConnectionWhere = {
  AND?: InputMaybe<Array<ElementRenderTypeAtomConnectionWhere>>
  NOT?: InputMaybe<ElementRenderTypeAtomConnectionWhere>
  OR?: InputMaybe<Array<ElementRenderTypeAtomConnectionWhere>>
  node?: InputMaybe<AtomWhere>
}

export type ElementRenderTypeAtomCreateFieldInput = {
  node: AtomCreateInput
}

export type ElementRenderTypeAtomDeleteFieldInput = {
  delete?: InputMaybe<AtomDeleteInput>
  where?: InputMaybe<ElementRenderTypeAtomConnectionWhere>
}

export type ElementRenderTypeAtomDisconnectFieldInput = {
  disconnect?: InputMaybe<AtomDisconnectInput>
  where?: InputMaybe<ElementRenderTypeAtomConnectionWhere>
}

export type ElementRenderTypeAtomFieldInput = {
  connect?: InputMaybe<ElementRenderTypeAtomConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<ElementRenderTypeAtomConnectOrCreateFieldInput>
  create?: InputMaybe<ElementRenderTypeAtomCreateFieldInput>
}

export type ElementRenderTypeAtomUpdateConnectionInput = {
  node?: InputMaybe<AtomUpdateInput>
}

export type ElementRenderTypeAtomUpdateFieldInput = {
  connect?: InputMaybe<ElementRenderTypeAtomConnectFieldInput>
  connectOrCreate?: InputMaybe<ElementRenderTypeAtomConnectOrCreateFieldInput>
  create?: InputMaybe<ElementRenderTypeAtomCreateFieldInput>
  delete?: InputMaybe<ElementRenderTypeAtomDeleteFieldInput>
  disconnect?: InputMaybe<ElementRenderTypeAtomDisconnectFieldInput>
  update?: InputMaybe<ElementRenderTypeAtomUpdateConnectionInput>
  where?: InputMaybe<ElementRenderTypeAtomConnectionWhere>
}

export type ElementRenderTypeComponentConnectFieldInput = {
  connect?: InputMaybe<ComponentConnectInput>
  where?: InputMaybe<ComponentConnectWhere>
}

export type ElementRenderTypeComponentConnectOrCreateFieldInput = {
  onCreate: ElementRenderTypeComponentConnectOrCreateFieldInputOnCreate
  where: ComponentConnectOrCreateWhere
}

export type ElementRenderTypeComponentConnectOrCreateFieldInputOnCreate = {
  node: ComponentOnCreateInput
}

export type ElementRenderTypeComponentConnectionWhere = {
  AND?: InputMaybe<Array<ElementRenderTypeComponentConnectionWhere>>
  NOT?: InputMaybe<ElementRenderTypeComponentConnectionWhere>
  OR?: InputMaybe<Array<ElementRenderTypeComponentConnectionWhere>>
  node?: InputMaybe<ComponentWhere>
}

export type ElementRenderTypeComponentCreateFieldInput = {
  node: ComponentCreateInput
}

export type ElementRenderTypeComponentDeleteFieldInput = {
  delete?: InputMaybe<ComponentDeleteInput>
  where?: InputMaybe<ElementRenderTypeComponentConnectionWhere>
}

export type ElementRenderTypeComponentDisconnectFieldInput = {
  disconnect?: InputMaybe<ComponentDisconnectInput>
  where?: InputMaybe<ElementRenderTypeComponentConnectionWhere>
}

export type ElementRenderTypeComponentFieldInput = {
  connect?: InputMaybe<ElementRenderTypeComponentConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<ElementRenderTypeComponentConnectOrCreateFieldInput>
  create?: InputMaybe<ElementRenderTypeComponentCreateFieldInput>
}

export type ElementRenderTypeComponentUpdateConnectionInput = {
  node?: InputMaybe<ComponentUpdateInput>
}

export type ElementRenderTypeComponentUpdateFieldInput = {
  connect?: InputMaybe<ElementRenderTypeComponentConnectFieldInput>
  connectOrCreate?: InputMaybe<ElementRenderTypeComponentConnectOrCreateFieldInput>
  create?: InputMaybe<ElementRenderTypeComponentCreateFieldInput>
  delete?: InputMaybe<ElementRenderTypeComponentDeleteFieldInput>
  disconnect?: InputMaybe<ElementRenderTypeComponentDisconnectFieldInput>
  update?: InputMaybe<ElementRenderTypeComponentUpdateConnectionInput>
  where?: InputMaybe<ElementRenderTypeComponentConnectionWhere>
}

export type ElementRenderTypeConnectInput = {
  Atom?: InputMaybe<ElementRenderTypeAtomConnectFieldInput>
  Component?: InputMaybe<ElementRenderTypeComponentConnectFieldInput>
}

export type ElementRenderTypeConnection = {
  edges: Array<ElementRenderTypeRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type ElementRenderTypeConnectionWhere = {
  Atom?: InputMaybe<ElementRenderTypeAtomConnectionWhere>
  Component?: InputMaybe<ElementRenderTypeComponentConnectionWhere>
}

export type ElementRenderTypeCreateInput = {
  Atom?: InputMaybe<ElementRenderTypeAtomFieldInput>
  Component?: InputMaybe<ElementRenderTypeComponentFieldInput>
}

export type ElementRenderTypeDeleteInput = {
  Atom?: InputMaybe<ElementRenderTypeAtomDeleteFieldInput>
  Component?: InputMaybe<ElementRenderTypeComponentDeleteFieldInput>
}

export type ElementRenderTypeDisconnectInput = {
  Atom?: InputMaybe<ElementRenderTypeAtomDisconnectFieldInput>
  Component?: InputMaybe<ElementRenderTypeComponentDisconnectFieldInput>
}

export type ElementRenderTypeRelationship = {
  cursor: Scalars['String']['output']
  node: ElementRenderType
}

export type ElementRenderTypeUpdateInput = {
  Atom?: InputMaybe<ElementRenderTypeAtomUpdateFieldInput>
  Component?: InputMaybe<ElementRenderTypeComponentUpdateFieldInput>
}

export type ElementRenderTypeWhere = {
  Atom?: InputMaybe<AtomWhere>
  Component?: InputMaybe<ComponentWhere>
}

/** Fields to sort Elements by. The order in which sorts are applied is not guaranteed when specifying many fields in one ElementSort object. */
export type ElementSort = {
  childMapperPropKey?: InputMaybe<SortDirection>
  compositeKey?: InputMaybe<SortDirection>
  expanded?: InputMaybe<SortDirection>
  id?: InputMaybe<SortDirection>
  renderForEachPropKey?: InputMaybe<SortDirection>
  renderIfExpression?: InputMaybe<SortDirection>
  style?: InputMaybe<SortDirection>
}

export type ElementSubscriptionWhere = {
  AND?: InputMaybe<Array<ElementSubscriptionWhere>>
  NOT?: InputMaybe<ElementSubscriptionWhere>
  OR?: InputMaybe<Array<ElementSubscriptionWhere>>
  /** @deprecated Please use the explicit _EQ version */
  childMapperPropKey?: InputMaybe<Scalars['String']['input']>
  childMapperPropKey_CONTAINS?: InputMaybe<Scalars['String']['input']>
  childMapperPropKey_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  childMapperPropKey_EQ?: InputMaybe<Scalars['String']['input']>
  childMapperPropKey_IN?: InputMaybe<
    Array<InputMaybe<Scalars['String']['input']>>
  >
  childMapperPropKey_MATCHES?: InputMaybe<Scalars['String']['input']>
  childMapperPropKey_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  compositeKey?: InputMaybe<Scalars['String']['input']>
  compositeKey_CONTAINS?: InputMaybe<Scalars['String']['input']>
  compositeKey_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  compositeKey_EQ?: InputMaybe<Scalars['String']['input']>
  compositeKey_IN?: InputMaybe<Array<Scalars['String']['input']>>
  compositeKey_MATCHES?: InputMaybe<Scalars['String']['input']>
  compositeKey_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  expanded?: InputMaybe<Scalars['Boolean']['input']>
  expanded_EQ?: InputMaybe<Scalars['Boolean']['input']>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  renderForEachPropKey?: InputMaybe<Scalars['String']['input']>
  renderForEachPropKey_CONTAINS?: InputMaybe<Scalars['String']['input']>
  renderForEachPropKey_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  renderForEachPropKey_EQ?: InputMaybe<Scalars['String']['input']>
  renderForEachPropKey_IN?: InputMaybe<
    Array<InputMaybe<Scalars['String']['input']>>
  >
  renderForEachPropKey_MATCHES?: InputMaybe<Scalars['String']['input']>
  renderForEachPropKey_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  renderIfExpression?: InputMaybe<Scalars['String']['input']>
  renderIfExpression_CONTAINS?: InputMaybe<Scalars['String']['input']>
  renderIfExpression_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  renderIfExpression_EQ?: InputMaybe<Scalars['String']['input']>
  renderIfExpression_IN?: InputMaybe<
    Array<InputMaybe<Scalars['String']['input']>>
  >
  renderIfExpression_MATCHES?: InputMaybe<Scalars['String']['input']>
  renderIfExpression_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  style?: InputMaybe<Scalars['String']['input']>
  style_CONTAINS?: InputMaybe<Scalars['String']['input']>
  style_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  style_EQ?: InputMaybe<Scalars['String']['input']>
  style_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>
  style_MATCHES?: InputMaybe<Scalars['String']['input']>
  style_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  tailwindClassNames?: InputMaybe<Array<Scalars['String']['input']>>
  tailwindClassNames_EQ?: InputMaybe<Array<Scalars['String']['input']>>
  tailwindClassNames_INCLUDES?: InputMaybe<Scalars['String']['input']>
}

/**
 * Allows picking an element from the current tree
 * Is passed to the rendered element as a React node
 * Prop values for this type have the shape of TypedProp in order to
 * be distinguished from other element types.
 * Comparison between different element types:
 * - RenderPropType: Component select box, results it '(props) => ReactNode' value
 * - ReactNodeType: Component select box, results it 'ReactNode' value
 * - ElementType: Current tree element select box, results it 'ReactNode' value
 */
export type ElementType = IBaseType & {
  /** Allows scoping the type of element to only descendants, children or all elements */
  elementKind: ElementTypeKind
  fieldRefs: Array<Field>
  fieldRefsAggregate?: Maybe<ElementTypeFieldFieldRefsAggregationSelection>
  fieldRefsConnection: IBaseTypeFieldRefsConnection
  id: Scalars['ID']['output']
  kind: TypeKind
  name: Scalars['String']['output']
  owner: User
  ownerAggregate?: Maybe<ElementTypeUserOwnerAggregationSelection>
  ownerConnection: IBaseTypeOwnerConnection
}

/**
 * Allows picking an element from the current tree
 * Is passed to the rendered element as a React node
 * Prop values for this type have the shape of TypedProp in order to
 * be distinguished from other element types.
 * Comparison between different element types:
 * - RenderPropType: Component select box, results it '(props) => ReactNode' value
 * - ReactNodeType: Component select box, results it 'ReactNode' value
 * - ElementType: Current tree element select box, results it 'ReactNode' value
 */
export type ElementTypeFieldRefsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<FieldOptions>
  sort?: InputMaybe<Array<FieldSort>>
  where?: InputMaybe<FieldWhere>
}

/**
 * Allows picking an element from the current tree
 * Is passed to the rendered element as a React node
 * Prop values for this type have the shape of TypedProp in order to
 * be distinguished from other element types.
 * Comparison between different element types:
 * - RenderPropType: Component select box, results it '(props) => ReactNode' value
 * - ReactNodeType: Component select box, results it 'ReactNode' value
 * - ElementType: Current tree element select box, results it 'ReactNode' value
 */
export type ElementTypeFieldRefsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<FieldWhere>
}

/**
 * Allows picking an element from the current tree
 * Is passed to the rendered element as a React node
 * Prop values for this type have the shape of TypedProp in order to
 * be distinguished from other element types.
 * Comparison between different element types:
 * - RenderPropType: Component select box, results it '(props) => ReactNode' value
 * - ReactNodeType: Component select box, results it 'ReactNode' value
 * - ElementType: Current tree element select box, results it 'ReactNode' value
 */
export type ElementTypeFieldRefsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<IBaseTypeFieldRefsConnectionSort>>
  where?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
}

/**
 * Allows picking an element from the current tree
 * Is passed to the rendered element as a React node
 * Prop values for this type have the shape of TypedProp in order to
 * be distinguished from other element types.
 * Comparison between different element types:
 * - RenderPropType: Component select box, results it '(props) => ReactNode' value
 * - ReactNodeType: Component select box, results it 'ReactNode' value
 * - ElementType: Current tree element select box, results it 'ReactNode' value
 */
export type ElementTypeOwnerArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<UserOptions>
  sort?: InputMaybe<Array<UserSort>>
  where?: InputMaybe<UserWhere>
}

/**
 * Allows picking an element from the current tree
 * Is passed to the rendered element as a React node
 * Prop values for this type have the shape of TypedProp in order to
 * be distinguished from other element types.
 * Comparison between different element types:
 * - RenderPropType: Component select box, results it '(props) => ReactNode' value
 * - ReactNodeType: Component select box, results it 'ReactNode' value
 * - ElementType: Current tree element select box, results it 'ReactNode' value
 */
export type ElementTypeOwnerAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<UserWhere>
}

/**
 * Allows picking an element from the current tree
 * Is passed to the rendered element as a React node
 * Prop values for this type have the shape of TypedProp in order to
 * be distinguished from other element types.
 * Comparison between different element types:
 * - RenderPropType: Component select box, results it '(props) => ReactNode' value
 * - ReactNodeType: Component select box, results it 'ReactNode' value
 * - ElementType: Current tree element select box, results it 'ReactNode' value
 */
export type ElementTypeOwnerConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<IBaseTypeOwnerConnectionSort>>
  where?: InputMaybe<IBaseTypeOwnerConnectionWhere>
}

export type ElementTypeAggregateSelection = {
  count: Scalars['Int']['output']
  id: IdAggregateSelection
  name: StringAggregateSelection
}

export type ElementTypeConnectInput = {
  fieldRefs?: InputMaybe<Array<ElementTypeFieldRefsConnectFieldInput>>
  owner?: InputMaybe<ElementTypeOwnerConnectFieldInput>
}

export type ElementTypeConnectWhere = {
  node: ElementTypeWhere
}

export type ElementTypeCreateInput = {
  elementKind: ElementTypeKind
  fieldRefs?: InputMaybe<ElementTypeFieldRefsFieldInput>
  id: Scalars['ID']['input']
  kind?: TypeKind
  name: Scalars['String']['input']
  owner?: InputMaybe<ElementTypeOwnerFieldInput>
}

export type ElementTypeCreatedEvent = {
  createdElementType: ElementTypeEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type ElementTypeDeleteInput = {
  fieldRefs?: InputMaybe<Array<IBaseTypeFieldRefsDeleteFieldInput>>
  owner?: InputMaybe<IBaseTypeOwnerDeleteFieldInput>
}

export type ElementTypeDeletedEvent = {
  deletedElementType: ElementTypeEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type ElementTypeDisconnectInput = {
  fieldRefs?: InputMaybe<Array<IBaseTypeFieldRefsDisconnectFieldInput>>
  owner?: InputMaybe<IBaseTypeOwnerDisconnectFieldInput>
}

export type ElementTypeEdge = {
  cursor: Scalars['String']['output']
  node: ElementType
}

export type ElementTypeEventPayload = {
  /** Allows scoping the type of element to only descendants, children or all elements */
  elementKind: ElementTypeKind
  id: Scalars['ID']['output']
  kind: TypeKind
  name: Scalars['String']['output']
}

export type ElementTypeFieldFieldRefsAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<ElementTypeFieldFieldRefsNodeAggregateSelection>
}

export type ElementTypeFieldFieldRefsNodeAggregateSelection = {
  defaultValues: StringAggregateSelection
  description: StringAggregateSelection
  id: IdAggregateSelection
  key: StringAggregateSelection
  name: StringAggregateSelection
  validationRules: StringAggregateSelection
}

export type ElementTypeFieldRefsAggregateInput = {
  AND?: InputMaybe<Array<ElementTypeFieldRefsAggregateInput>>
  NOT?: InputMaybe<ElementTypeFieldRefsAggregateInput>
  OR?: InputMaybe<Array<ElementTypeFieldRefsAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<ElementTypeFieldRefsNodeAggregationWhereInput>
}

export type ElementTypeFieldRefsConnectFieldInput = {
  connect?: InputMaybe<Array<FieldConnectInput>>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<FieldConnectWhere>
}

export type ElementTypeFieldRefsConnectOrCreateFieldInput = {
  onCreate: ElementTypeFieldRefsConnectOrCreateFieldInputOnCreate
  where: FieldConnectOrCreateWhere
}

export type ElementTypeFieldRefsConnectOrCreateFieldInputOnCreate = {
  node: FieldOnCreateInput
}

export type ElementTypeFieldRefsCreateFieldInput = {
  node: FieldCreateInput
}

export type ElementTypeFieldRefsFieldInput = {
  connect?: InputMaybe<Array<ElementTypeFieldRefsConnectFieldInput>>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<
    Array<ElementTypeFieldRefsConnectOrCreateFieldInput>
  >
  create?: InputMaybe<Array<ElementTypeFieldRefsCreateFieldInput>>
}

export type ElementTypeFieldRefsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<ElementTypeFieldRefsNodeAggregationWhereInput>>
  NOT?: InputMaybe<ElementTypeFieldRefsNodeAggregationWhereInput>
  OR?: InputMaybe<Array<ElementTypeFieldRefsNodeAggregationWhereInput>>
  defaultValues_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  defaultValues_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  description_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  description_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  key_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  key_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  validationRules_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type ElementTypeFieldRefsUpdateConnectionInput = {
  node?: InputMaybe<FieldUpdateInput>
}

export type ElementTypeFieldRefsUpdateFieldInput = {
  connect?: InputMaybe<Array<ElementTypeFieldRefsConnectFieldInput>>
  connectOrCreate?: InputMaybe<
    Array<ElementTypeFieldRefsConnectOrCreateFieldInput>
  >
  create?: InputMaybe<Array<ElementTypeFieldRefsCreateFieldInput>>
  delete?: InputMaybe<Array<IBaseTypeFieldRefsDeleteFieldInput>>
  disconnect?: InputMaybe<Array<IBaseTypeFieldRefsDisconnectFieldInput>>
  update?: InputMaybe<ElementTypeFieldRefsUpdateConnectionInput>
  where?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
}

export enum ElementTypeKind {
  AllElements = 'AllElements',
  ChildrenOnly = 'ChildrenOnly',
  DescendantsOnly = 'DescendantsOnly',
  ExcludeDescendantsElements = 'ExcludeDescendantsElements',
}

export type ElementTypeOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  /** Specify one or more ElementTypeSort objects to sort ElementTypes by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<ElementTypeSort>>
}

export type ElementTypeOwnerAggregateInput = {
  AND?: InputMaybe<Array<ElementTypeOwnerAggregateInput>>
  NOT?: InputMaybe<ElementTypeOwnerAggregateInput>
  OR?: InputMaybe<Array<ElementTypeOwnerAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<ElementTypeOwnerNodeAggregationWhereInput>
}

export type ElementTypeOwnerConnectFieldInput = {
  connect?: InputMaybe<UserConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<UserConnectWhere>
}

export type ElementTypeOwnerConnectOrCreateFieldInput = {
  onCreate: ElementTypeOwnerConnectOrCreateFieldInputOnCreate
  where: UserConnectOrCreateWhere
}

export type ElementTypeOwnerConnectOrCreateFieldInputOnCreate = {
  node: UserOnCreateInput
}

export type ElementTypeOwnerCreateFieldInput = {
  node: UserCreateInput
}

export type ElementTypeOwnerFieldInput = {
  connect?: InputMaybe<ElementTypeOwnerConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<ElementTypeOwnerConnectOrCreateFieldInput>
  create?: InputMaybe<ElementTypeOwnerCreateFieldInput>
}

export type ElementTypeOwnerNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<ElementTypeOwnerNodeAggregationWhereInput>>
  NOT?: InputMaybe<ElementTypeOwnerNodeAggregationWhereInput>
  OR?: InputMaybe<Array<ElementTypeOwnerNodeAggregationWhereInput>>
  auth0Id_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  auth0Id_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  email_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  email_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  username_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  username_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type ElementTypeOwnerUpdateConnectionInput = {
  node?: InputMaybe<UserUpdateInput>
}

export type ElementTypeOwnerUpdateFieldInput = {
  connect?: InputMaybe<ElementTypeOwnerConnectFieldInput>
  connectOrCreate?: InputMaybe<ElementTypeOwnerConnectOrCreateFieldInput>
  create?: InputMaybe<ElementTypeOwnerCreateFieldInput>
  delete?: InputMaybe<IBaseTypeOwnerDeleteFieldInput>
  disconnect?: InputMaybe<IBaseTypeOwnerDisconnectFieldInput>
  update?: InputMaybe<ElementTypeOwnerUpdateConnectionInput>
  where?: InputMaybe<IBaseTypeOwnerConnectionWhere>
}

/** Fields to sort ElementTypes by. The order in which sorts are applied is not guaranteed when specifying many fields in one ElementTypeSort object. */
export type ElementTypeSort = {
  elementKind?: InputMaybe<SortDirection>
  id?: InputMaybe<SortDirection>
  kind?: InputMaybe<SortDirection>
  name?: InputMaybe<SortDirection>
}

export type ElementTypeSubscriptionWhere = {
  AND?: InputMaybe<Array<ElementTypeSubscriptionWhere>>
  NOT?: InputMaybe<ElementTypeSubscriptionWhere>
  OR?: InputMaybe<Array<ElementTypeSubscriptionWhere>>
  /** @deprecated Please use the explicit _EQ version */
  elementKind?: InputMaybe<ElementTypeKind>
  elementKind_EQ?: InputMaybe<ElementTypeKind>
  elementKind_IN?: InputMaybe<Array<ElementTypeKind>>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  kind?: InputMaybe<TypeKind>
  kind_EQ?: InputMaybe<TypeKind>
  kind_IN?: InputMaybe<Array<TypeKind>>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>
  name_MATCHES?: InputMaybe<Scalars['String']['input']>
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
}

export type ElementTypeUpdateInput = {
  /** @deprecated Please use the explicit _SET field */
  elementKind?: InputMaybe<ElementTypeKind>
  elementKind_SET?: InputMaybe<ElementTypeKind>
  fieldRefs?: InputMaybe<Array<ElementTypeFieldRefsUpdateFieldInput>>
  /** @deprecated Please use the explicit _SET field */
  id?: InputMaybe<Scalars['ID']['input']>
  id_SET?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _SET field */
  kind?: InputMaybe<TypeKind>
  kind_SET?: InputMaybe<TypeKind>
  /** @deprecated Please use the explicit _SET field */
  name?: InputMaybe<Scalars['String']['input']>
  name_SET?: InputMaybe<Scalars['String']['input']>
  owner?: InputMaybe<ElementTypeOwnerUpdateFieldInput>
}

export type ElementTypeUpdatedEvent = {
  event: EventType
  previousState: ElementTypeEventPayload
  timestamp: Scalars['Float']['output']
  updatedElementType: ElementTypeEventPayload
}

export type ElementTypeUserOwnerAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<ElementTypeUserOwnerNodeAggregateSelection>
}

export type ElementTypeUserOwnerNodeAggregateSelection = {
  auth0Id: StringAggregateSelection
  email: StringAggregateSelection
  id: IdAggregateSelection
  username: StringAggregateSelection
}

export type ElementTypeWhere = {
  AND?: InputMaybe<Array<ElementTypeWhere>>
  NOT?: InputMaybe<ElementTypeWhere>
  OR?: InputMaybe<Array<ElementTypeWhere>>
  /** @deprecated Please use the explicit _EQ version */
  elementKind?: InputMaybe<ElementTypeKind>
  elementKind_EQ?: InputMaybe<ElementTypeKind>
  elementKind_IN?: InputMaybe<Array<ElementTypeKind>>
  fieldRefsAggregate?: InputMaybe<ElementTypeFieldRefsAggregateInput>
  /** Return ElementTypes where all of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_ALL?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return ElementTypes where none of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_NONE?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return ElementTypes where one of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_SINGLE?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return ElementTypes where some of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_SOME?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return ElementTypes where all of the related Fields match this filter */
  fieldRefs_ALL?: InputMaybe<FieldWhere>
  /** Return ElementTypes where none of the related Fields match this filter */
  fieldRefs_NONE?: InputMaybe<FieldWhere>
  /** Return ElementTypes where one of the related Fields match this filter */
  fieldRefs_SINGLE?: InputMaybe<FieldWhere>
  /** Return ElementTypes where some of the related Fields match this filter */
  fieldRefs_SOME?: InputMaybe<FieldWhere>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  kind?: InputMaybe<TypeKind>
  kind_EQ?: InputMaybe<TypeKind>
  kind_IN?: InputMaybe<Array<TypeKind>>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>
  name_MATCHES?: InputMaybe<Scalars['String']['input']>
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  owner?: InputMaybe<UserWhere>
  ownerAggregate?: InputMaybe<ElementTypeOwnerAggregateInput>
  ownerConnection?: InputMaybe<IBaseTypeOwnerConnectionWhere>
}

export type ElementTypesConnection = {
  edges: Array<ElementTypeEdge>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type ElementUniqueWhere = {
  /** @deprecated Please use the explicit _EQ version */
  compositeKey?: InputMaybe<Scalars['String']['input']>
  compositeKey_EQ?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
}

export type ElementUpdateInput = {
  childMapperComponent?: InputMaybe<ElementChildMapperComponentUpdateFieldInput>
  childMapperPreviousSibling?: InputMaybe<ElementChildMapperPreviousSiblingUpdateFieldInput>
  /** @deprecated Please use the explicit _SET field */
  childMapperPropKey?: InputMaybe<Scalars['String']['input']>
  childMapperPropKey_SET?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _SET field */
  compositeKey?: InputMaybe<Scalars['String']['input']>
  compositeKey_SET?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _SET field */
  expanded?: InputMaybe<Scalars['Boolean']['input']>
  expanded_SET?: InputMaybe<Scalars['Boolean']['input']>
  firstChild?: InputMaybe<ElementFirstChildUpdateFieldInput>
  nextSibling?: InputMaybe<ElementNextSiblingUpdateFieldInput>
  page?: InputMaybe<ElementPageUpdateFieldInput>
  parentComponent?: InputMaybe<ElementParentComponentUpdateFieldInput>
  parentElement?: InputMaybe<ElementParentElementUpdateFieldInput>
  postRenderActions?: InputMaybe<
    Array<ElementPostRenderActionsUpdateFieldInput>
  >
  preRenderActions?: InputMaybe<Array<ElementPreRenderActionsUpdateFieldInput>>
  prevSibling?: InputMaybe<ElementPrevSiblingUpdateFieldInput>
  props?: InputMaybe<ElementPropsUpdateFieldInput>
  /** @deprecated Please use the explicit _SET field */
  renderForEachPropKey?: InputMaybe<Scalars['String']['input']>
  renderForEachPropKey_SET?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _SET field */
  renderIfExpression?: InputMaybe<Scalars['String']['input']>
  renderIfExpression_SET?: InputMaybe<Scalars['String']['input']>
  renderType?: InputMaybe<ElementRenderTypeUpdateInput>
  /** @deprecated Please use the explicit _SET field */
  style?: InputMaybe<Scalars['String']['input']>
  style_SET?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _SET field */
  tailwindClassNames?: InputMaybe<Array<Scalars['String']['input']>>
  tailwindClassNames_POP?: InputMaybe<Scalars['Int']['input']>
  tailwindClassNames_PUSH?: InputMaybe<Array<Scalars['String']['input']>>
  tailwindClassNames_SET?: InputMaybe<Array<Scalars['String']['input']>>
}

export type ElementUpdatedEvent = {
  event: EventType
  previousState: ElementEventPayload
  timestamp: Scalars['Float']['output']
  updatedElement: ElementEventPayload
}

export type ElementWhere = {
  AND?: InputMaybe<Array<ElementWhere>>
  NOT?: InputMaybe<ElementWhere>
  OR?: InputMaybe<Array<ElementWhere>>
  childMapperComponent?: InputMaybe<ComponentWhere>
  childMapperComponentAggregate?: InputMaybe<ElementChildMapperComponentAggregateInput>
  childMapperComponentConnection?: InputMaybe<ElementChildMapperComponentConnectionWhere>
  childMapperPreviousSibling?: InputMaybe<ElementWhere>
  childMapperPreviousSiblingAggregate?: InputMaybe<ElementChildMapperPreviousSiblingAggregateInput>
  childMapperPreviousSiblingConnection?: InputMaybe<ElementChildMapperPreviousSiblingConnectionWhere>
  /** @deprecated Please use the explicit _EQ version */
  childMapperPropKey?: InputMaybe<Scalars['String']['input']>
  childMapperPropKey_CONTAINS?: InputMaybe<Scalars['String']['input']>
  childMapperPropKey_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  childMapperPropKey_EQ?: InputMaybe<Scalars['String']['input']>
  childMapperPropKey_IN?: InputMaybe<
    Array<InputMaybe<Scalars['String']['input']>>
  >
  childMapperPropKey_MATCHES?: InputMaybe<Scalars['String']['input']>
  childMapperPropKey_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  compositeKey?: InputMaybe<Scalars['String']['input']>
  compositeKey_CONTAINS?: InputMaybe<Scalars['String']['input']>
  compositeKey_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  compositeKey_EQ?: InputMaybe<Scalars['String']['input']>
  compositeKey_IN?: InputMaybe<Array<Scalars['String']['input']>>
  compositeKey_MATCHES?: InputMaybe<Scalars['String']['input']>
  compositeKey_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  expanded?: InputMaybe<Scalars['Boolean']['input']>
  expanded_EQ?: InputMaybe<Scalars['Boolean']['input']>
  firstChild?: InputMaybe<ElementWhere>
  firstChildAggregate?: InputMaybe<ElementFirstChildAggregateInput>
  firstChildConnection?: InputMaybe<ElementFirstChildConnectionWhere>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  nextSibling?: InputMaybe<ElementWhere>
  nextSiblingAggregate?: InputMaybe<ElementNextSiblingAggregateInput>
  nextSiblingConnection?: InputMaybe<ElementNextSiblingConnectionWhere>
  page?: InputMaybe<PageWhere>
  pageAggregate?: InputMaybe<ElementPageAggregateInput>
  pageConnection?: InputMaybe<ElementPageConnectionWhere>
  parentComponent?: InputMaybe<ComponentWhere>
  parentComponentAggregate?: InputMaybe<ElementParentComponentAggregateInput>
  parentComponentConnection?: InputMaybe<ElementParentComponentConnectionWhere>
  parentElement?: InputMaybe<ElementWhere>
  parentElementAggregate?: InputMaybe<ElementParentElementAggregateInput>
  parentElementConnection?: InputMaybe<ElementParentElementConnectionWhere>
  postRenderActionsAggregate?: InputMaybe<ElementPostRenderActionsAggregateInput>
  /** Return Elements where all of the related ElementPostRenderActionsConnections match this filter */
  postRenderActionsConnection_ALL?: InputMaybe<ElementPostRenderActionsConnectionWhere>
  /** Return Elements where none of the related ElementPostRenderActionsConnections match this filter */
  postRenderActionsConnection_NONE?: InputMaybe<ElementPostRenderActionsConnectionWhere>
  /** Return Elements where one of the related ElementPostRenderActionsConnections match this filter */
  postRenderActionsConnection_SINGLE?: InputMaybe<ElementPostRenderActionsConnectionWhere>
  /** Return Elements where some of the related ElementPostRenderActionsConnections match this filter */
  postRenderActionsConnection_SOME?: InputMaybe<ElementPostRenderActionsConnectionWhere>
  /** Return Elements where all of the related BaseActions match this filter */
  postRenderActions_ALL?: InputMaybe<BaseActionWhere>
  /** Return Elements where none of the related BaseActions match this filter */
  postRenderActions_NONE?: InputMaybe<BaseActionWhere>
  /** Return Elements where one of the related BaseActions match this filter */
  postRenderActions_SINGLE?: InputMaybe<BaseActionWhere>
  /** Return Elements where some of the related BaseActions match this filter */
  postRenderActions_SOME?: InputMaybe<BaseActionWhere>
  preRenderActionsAggregate?: InputMaybe<ElementPreRenderActionsAggregateInput>
  /** Return Elements where all of the related ElementPreRenderActionsConnections match this filter */
  preRenderActionsConnection_ALL?: InputMaybe<ElementPreRenderActionsConnectionWhere>
  /** Return Elements where none of the related ElementPreRenderActionsConnections match this filter */
  preRenderActionsConnection_NONE?: InputMaybe<ElementPreRenderActionsConnectionWhere>
  /** Return Elements where one of the related ElementPreRenderActionsConnections match this filter */
  preRenderActionsConnection_SINGLE?: InputMaybe<ElementPreRenderActionsConnectionWhere>
  /** Return Elements where some of the related ElementPreRenderActionsConnections match this filter */
  preRenderActionsConnection_SOME?: InputMaybe<ElementPreRenderActionsConnectionWhere>
  /** Return Elements where all of the related BaseActions match this filter */
  preRenderActions_ALL?: InputMaybe<BaseActionWhere>
  /** Return Elements where none of the related BaseActions match this filter */
  preRenderActions_NONE?: InputMaybe<BaseActionWhere>
  /** Return Elements where one of the related BaseActions match this filter */
  preRenderActions_SINGLE?: InputMaybe<BaseActionWhere>
  /** Return Elements where some of the related BaseActions match this filter */
  preRenderActions_SOME?: InputMaybe<BaseActionWhere>
  prevSibling?: InputMaybe<ElementWhere>
  prevSiblingAggregate?: InputMaybe<ElementPrevSiblingAggregateInput>
  prevSiblingConnection?: InputMaybe<ElementPrevSiblingConnectionWhere>
  props?: InputMaybe<PropWhere>
  propsAggregate?: InputMaybe<ElementPropsAggregateInput>
  propsConnection?: InputMaybe<ElementPropsConnectionWhere>
  /** @deprecated Please use the explicit _EQ version */
  renderForEachPropKey?: InputMaybe<Scalars['String']['input']>
  renderForEachPropKey_CONTAINS?: InputMaybe<Scalars['String']['input']>
  renderForEachPropKey_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  renderForEachPropKey_EQ?: InputMaybe<Scalars['String']['input']>
  renderForEachPropKey_IN?: InputMaybe<
    Array<InputMaybe<Scalars['String']['input']>>
  >
  renderForEachPropKey_MATCHES?: InputMaybe<Scalars['String']['input']>
  renderForEachPropKey_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  renderIfExpression?: InputMaybe<Scalars['String']['input']>
  renderIfExpression_CONTAINS?: InputMaybe<Scalars['String']['input']>
  renderIfExpression_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  renderIfExpression_EQ?: InputMaybe<Scalars['String']['input']>
  renderIfExpression_IN?: InputMaybe<
    Array<InputMaybe<Scalars['String']['input']>>
  >
  renderIfExpression_MATCHES?: InputMaybe<Scalars['String']['input']>
  renderIfExpression_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  renderType?: InputMaybe<ElementRenderTypeWhere>
  renderTypeConnection?: InputMaybe<ElementRenderTypeConnectionWhere>
  /** @deprecated Please use the explicit _EQ version */
  style?: InputMaybe<Scalars['String']['input']>
  style_CONTAINS?: InputMaybe<Scalars['String']['input']>
  style_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  style_EQ?: InputMaybe<Scalars['String']['input']>
  style_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>
  style_MATCHES?: InputMaybe<Scalars['String']['input']>
  style_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  tailwindClassNames?: InputMaybe<Array<Scalars['String']['input']>>
  tailwindClassNames_EQ?: InputMaybe<Array<Scalars['String']['input']>>
  tailwindClassNames_INCLUDES?: InputMaybe<Scalars['String']['input']>
}

export type ElementsConnection = {
  edges: Array<ElementEdge>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

/**
 * Allows choosing one of a set of allowed values.
 * The value gets passed to the render pipe as a Enum Type Value id.
 * The actual value must be de-referenced by the id.
 */
export type EnumType = IBaseType & {
  allowedValues: Array<EnumTypeValue>
  allowedValuesAggregate?: Maybe<EnumTypeEnumTypeValueAllowedValuesAggregationSelection>
  allowedValuesConnection: EnumTypeAllowedValuesConnection
  fieldRefs: Array<Field>
  fieldRefsAggregate?: Maybe<EnumTypeFieldFieldRefsAggregationSelection>
  fieldRefsConnection: IBaseTypeFieldRefsConnection
  id: Scalars['ID']['output']
  kind: TypeKind
  name: Scalars['String']['output']
  owner: User
  ownerAggregate?: Maybe<EnumTypeUserOwnerAggregationSelection>
  ownerConnection: IBaseTypeOwnerConnection
}

/**
 * Allows choosing one of a set of allowed values.
 * The value gets passed to the render pipe as a Enum Type Value id.
 * The actual value must be de-referenced by the id.
 */
export type EnumTypeAllowedValuesArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<EnumTypeValueOptions>
  sort?: InputMaybe<Array<EnumTypeValueSort>>
  where?: InputMaybe<EnumTypeValueWhere>
}

/**
 * Allows choosing one of a set of allowed values.
 * The value gets passed to the render pipe as a Enum Type Value id.
 * The actual value must be de-referenced by the id.
 */
export type EnumTypeAllowedValuesAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<EnumTypeValueWhere>
}

/**
 * Allows choosing one of a set of allowed values.
 * The value gets passed to the render pipe as a Enum Type Value id.
 * The actual value must be de-referenced by the id.
 */
export type EnumTypeAllowedValuesConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<EnumTypeAllowedValuesConnectionSort>>
  where?: InputMaybe<EnumTypeAllowedValuesConnectionWhere>
}

/**
 * Allows choosing one of a set of allowed values.
 * The value gets passed to the render pipe as a Enum Type Value id.
 * The actual value must be de-referenced by the id.
 */
export type EnumTypeFieldRefsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<FieldOptions>
  sort?: InputMaybe<Array<FieldSort>>
  where?: InputMaybe<FieldWhere>
}

/**
 * Allows choosing one of a set of allowed values.
 * The value gets passed to the render pipe as a Enum Type Value id.
 * The actual value must be de-referenced by the id.
 */
export type EnumTypeFieldRefsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<FieldWhere>
}

/**
 * Allows choosing one of a set of allowed values.
 * The value gets passed to the render pipe as a Enum Type Value id.
 * The actual value must be de-referenced by the id.
 */
export type EnumTypeFieldRefsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<IBaseTypeFieldRefsConnectionSort>>
  where?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
}

/**
 * Allows choosing one of a set of allowed values.
 * The value gets passed to the render pipe as a Enum Type Value id.
 * The actual value must be de-referenced by the id.
 */
export type EnumTypeOwnerArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<UserOptions>
  sort?: InputMaybe<Array<UserSort>>
  where?: InputMaybe<UserWhere>
}

/**
 * Allows choosing one of a set of allowed values.
 * The value gets passed to the render pipe as a Enum Type Value id.
 * The actual value must be de-referenced by the id.
 */
export type EnumTypeOwnerAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<UserWhere>
}

/**
 * Allows choosing one of a set of allowed values.
 * The value gets passed to the render pipe as a Enum Type Value id.
 * The actual value must be de-referenced by the id.
 */
export type EnumTypeOwnerConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<IBaseTypeOwnerConnectionSort>>
  where?: InputMaybe<IBaseTypeOwnerConnectionWhere>
}

export type EnumTypeAggregateSelection = {
  count: Scalars['Int']['output']
  id: IdAggregateSelection
  name: StringAggregateSelection
}

export type EnumTypeAllowedValuesAggregateInput = {
  AND?: InputMaybe<Array<EnumTypeAllowedValuesAggregateInput>>
  NOT?: InputMaybe<EnumTypeAllowedValuesAggregateInput>
  OR?: InputMaybe<Array<EnumTypeAllowedValuesAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<EnumTypeAllowedValuesNodeAggregationWhereInput>
}

export type EnumTypeAllowedValuesConnectFieldInput = {
  connect?: InputMaybe<Array<EnumTypeValueConnectInput>>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<EnumTypeValueConnectWhere>
}

export type EnumTypeAllowedValuesConnection = {
  edges: Array<EnumTypeAllowedValuesRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type EnumTypeAllowedValuesConnectionSort = {
  node?: InputMaybe<EnumTypeValueSort>
}

export type EnumTypeAllowedValuesConnectionWhere = {
  AND?: InputMaybe<Array<EnumTypeAllowedValuesConnectionWhere>>
  NOT?: InputMaybe<EnumTypeAllowedValuesConnectionWhere>
  OR?: InputMaybe<Array<EnumTypeAllowedValuesConnectionWhere>>
  node?: InputMaybe<EnumTypeValueWhere>
}

export type EnumTypeAllowedValuesCreateFieldInput = {
  node: EnumTypeValueCreateInput
}

export type EnumTypeAllowedValuesDeleteFieldInput = {
  delete?: InputMaybe<EnumTypeValueDeleteInput>
  where?: InputMaybe<EnumTypeAllowedValuesConnectionWhere>
}

export type EnumTypeAllowedValuesDisconnectFieldInput = {
  disconnect?: InputMaybe<EnumTypeValueDisconnectInput>
  where?: InputMaybe<EnumTypeAllowedValuesConnectionWhere>
}

export type EnumTypeAllowedValuesFieldInput = {
  connect?: InputMaybe<Array<EnumTypeAllowedValuesConnectFieldInput>>
  create?: InputMaybe<Array<EnumTypeAllowedValuesCreateFieldInput>>
}

export type EnumTypeAllowedValuesNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<EnumTypeAllowedValuesNodeAggregationWhereInput>>
  NOT?: InputMaybe<EnumTypeAllowedValuesNodeAggregationWhereInput>
  OR?: InputMaybe<Array<EnumTypeAllowedValuesNodeAggregationWhereInput>>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  key_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  key_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  value_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  value_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  value_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  value_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  value_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  value_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  value_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  value_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  value_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  value_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  value_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  value_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  value_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  value_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  value_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type EnumTypeAllowedValuesRelationship = {
  cursor: Scalars['String']['output']
  node: EnumTypeValue
}

export type EnumTypeAllowedValuesUpdateConnectionInput = {
  node?: InputMaybe<EnumTypeValueUpdateInput>
}

export type EnumTypeAllowedValuesUpdateFieldInput = {
  connect?: InputMaybe<Array<EnumTypeAllowedValuesConnectFieldInput>>
  create?: InputMaybe<Array<EnumTypeAllowedValuesCreateFieldInput>>
  delete?: InputMaybe<Array<EnumTypeAllowedValuesDeleteFieldInput>>
  disconnect?: InputMaybe<Array<EnumTypeAllowedValuesDisconnectFieldInput>>
  update?: InputMaybe<EnumTypeAllowedValuesUpdateConnectionInput>
  where?: InputMaybe<EnumTypeAllowedValuesConnectionWhere>
}

export type EnumTypeConnectInput = {
  allowedValues?: InputMaybe<Array<EnumTypeAllowedValuesConnectFieldInput>>
  fieldRefs?: InputMaybe<Array<EnumTypeFieldRefsConnectFieldInput>>
  owner?: InputMaybe<EnumTypeOwnerConnectFieldInput>
}

export type EnumTypeConnectWhere = {
  node: EnumTypeWhere
}

export type EnumTypeCreateInput = {
  allowedValues?: InputMaybe<EnumTypeAllowedValuesFieldInput>
  fieldRefs?: InputMaybe<EnumTypeFieldRefsFieldInput>
  id: Scalars['ID']['input']
  kind?: TypeKind
  name: Scalars['String']['input']
  owner?: InputMaybe<EnumTypeOwnerFieldInput>
}

export type EnumTypeCreatedEvent = {
  createdEnumType: EnumTypeEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type EnumTypeDeleteInput = {
  allowedValues?: InputMaybe<Array<EnumTypeAllowedValuesDeleteFieldInput>>
  fieldRefs?: InputMaybe<Array<IBaseTypeFieldRefsDeleteFieldInput>>
  owner?: InputMaybe<IBaseTypeOwnerDeleteFieldInput>
}

export type EnumTypeDeletedEvent = {
  deletedEnumType: EnumTypeEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type EnumTypeDisconnectInput = {
  allowedValues?: InputMaybe<Array<EnumTypeAllowedValuesDisconnectFieldInput>>
  fieldRefs?: InputMaybe<Array<IBaseTypeFieldRefsDisconnectFieldInput>>
  owner?: InputMaybe<IBaseTypeOwnerDisconnectFieldInput>
}

export type EnumTypeEdge = {
  cursor: Scalars['String']['output']
  node: EnumType
}

export type EnumTypeEnumTypeValueAllowedValuesAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<EnumTypeEnumTypeValueAllowedValuesNodeAggregateSelection>
}

export type EnumTypeEnumTypeValueAllowedValuesNodeAggregateSelection = {
  id: IdAggregateSelection
  key: StringAggregateSelection
  value: StringAggregateSelection
}

export type EnumTypeEventPayload = {
  id: Scalars['ID']['output']
  kind: TypeKind
  name: Scalars['String']['output']
}

export type EnumTypeFieldFieldRefsAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<EnumTypeFieldFieldRefsNodeAggregateSelection>
}

export type EnumTypeFieldFieldRefsNodeAggregateSelection = {
  defaultValues: StringAggregateSelection
  description: StringAggregateSelection
  id: IdAggregateSelection
  key: StringAggregateSelection
  name: StringAggregateSelection
  validationRules: StringAggregateSelection
}

export type EnumTypeFieldRefsAggregateInput = {
  AND?: InputMaybe<Array<EnumTypeFieldRefsAggregateInput>>
  NOT?: InputMaybe<EnumTypeFieldRefsAggregateInput>
  OR?: InputMaybe<Array<EnumTypeFieldRefsAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<EnumTypeFieldRefsNodeAggregationWhereInput>
}

export type EnumTypeFieldRefsConnectFieldInput = {
  connect?: InputMaybe<Array<FieldConnectInput>>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<FieldConnectWhere>
}

export type EnumTypeFieldRefsConnectOrCreateFieldInput = {
  onCreate: EnumTypeFieldRefsConnectOrCreateFieldInputOnCreate
  where: FieldConnectOrCreateWhere
}

export type EnumTypeFieldRefsConnectOrCreateFieldInputOnCreate = {
  node: FieldOnCreateInput
}

export type EnumTypeFieldRefsCreateFieldInput = {
  node: FieldCreateInput
}

export type EnumTypeFieldRefsFieldInput = {
  connect?: InputMaybe<Array<EnumTypeFieldRefsConnectFieldInput>>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<
    Array<EnumTypeFieldRefsConnectOrCreateFieldInput>
  >
  create?: InputMaybe<Array<EnumTypeFieldRefsCreateFieldInput>>
}

export type EnumTypeFieldRefsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<EnumTypeFieldRefsNodeAggregationWhereInput>>
  NOT?: InputMaybe<EnumTypeFieldRefsNodeAggregationWhereInput>
  OR?: InputMaybe<Array<EnumTypeFieldRefsNodeAggregationWhereInput>>
  defaultValues_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  defaultValues_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  description_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  description_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  key_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  key_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  validationRules_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type EnumTypeFieldRefsUpdateConnectionInput = {
  node?: InputMaybe<FieldUpdateInput>
}

export type EnumTypeFieldRefsUpdateFieldInput = {
  connect?: InputMaybe<Array<EnumTypeFieldRefsConnectFieldInput>>
  connectOrCreate?: InputMaybe<
    Array<EnumTypeFieldRefsConnectOrCreateFieldInput>
  >
  create?: InputMaybe<Array<EnumTypeFieldRefsCreateFieldInput>>
  delete?: InputMaybe<Array<IBaseTypeFieldRefsDeleteFieldInput>>
  disconnect?: InputMaybe<Array<IBaseTypeFieldRefsDisconnectFieldInput>>
  update?: InputMaybe<EnumTypeFieldRefsUpdateConnectionInput>
  where?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
}

export type EnumTypeOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  /** Specify one or more EnumTypeSort objects to sort EnumTypes by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<EnumTypeSort>>
}

export type EnumTypeOwnerAggregateInput = {
  AND?: InputMaybe<Array<EnumTypeOwnerAggregateInput>>
  NOT?: InputMaybe<EnumTypeOwnerAggregateInput>
  OR?: InputMaybe<Array<EnumTypeOwnerAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<EnumTypeOwnerNodeAggregationWhereInput>
}

export type EnumTypeOwnerConnectFieldInput = {
  connect?: InputMaybe<UserConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<UserConnectWhere>
}

export type EnumTypeOwnerConnectOrCreateFieldInput = {
  onCreate: EnumTypeOwnerConnectOrCreateFieldInputOnCreate
  where: UserConnectOrCreateWhere
}

export type EnumTypeOwnerConnectOrCreateFieldInputOnCreate = {
  node: UserOnCreateInput
}

export type EnumTypeOwnerCreateFieldInput = {
  node: UserCreateInput
}

export type EnumTypeOwnerFieldInput = {
  connect?: InputMaybe<EnumTypeOwnerConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<EnumTypeOwnerConnectOrCreateFieldInput>
  create?: InputMaybe<EnumTypeOwnerCreateFieldInput>
}

export type EnumTypeOwnerNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<EnumTypeOwnerNodeAggregationWhereInput>>
  NOT?: InputMaybe<EnumTypeOwnerNodeAggregationWhereInput>
  OR?: InputMaybe<Array<EnumTypeOwnerNodeAggregationWhereInput>>
  auth0Id_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  auth0Id_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  email_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  email_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  username_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  username_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type EnumTypeOwnerUpdateConnectionInput = {
  node?: InputMaybe<UserUpdateInput>
}

export type EnumTypeOwnerUpdateFieldInput = {
  connect?: InputMaybe<EnumTypeOwnerConnectFieldInput>
  connectOrCreate?: InputMaybe<EnumTypeOwnerConnectOrCreateFieldInput>
  create?: InputMaybe<EnumTypeOwnerCreateFieldInput>
  delete?: InputMaybe<IBaseTypeOwnerDeleteFieldInput>
  disconnect?: InputMaybe<IBaseTypeOwnerDisconnectFieldInput>
  update?: InputMaybe<EnumTypeOwnerUpdateConnectionInput>
  where?: InputMaybe<IBaseTypeOwnerConnectionWhere>
}

/** Fields to sort EnumTypes by. The order in which sorts are applied is not guaranteed when specifying many fields in one EnumTypeSort object. */
export type EnumTypeSort = {
  id?: InputMaybe<SortDirection>
  kind?: InputMaybe<SortDirection>
  name?: InputMaybe<SortDirection>
}

export type EnumTypeSubscriptionWhere = {
  AND?: InputMaybe<Array<EnumTypeSubscriptionWhere>>
  NOT?: InputMaybe<EnumTypeSubscriptionWhere>
  OR?: InputMaybe<Array<EnumTypeSubscriptionWhere>>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  kind?: InputMaybe<TypeKind>
  kind_EQ?: InputMaybe<TypeKind>
  kind_IN?: InputMaybe<Array<TypeKind>>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>
  name_MATCHES?: InputMaybe<Scalars['String']['input']>
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
}

export type EnumTypeUpdateInput = {
  allowedValues?: InputMaybe<Array<EnumTypeAllowedValuesUpdateFieldInput>>
  fieldRefs?: InputMaybe<Array<EnumTypeFieldRefsUpdateFieldInput>>
  /** @deprecated Please use the explicit _SET field */
  id?: InputMaybe<Scalars['ID']['input']>
  id_SET?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _SET field */
  kind?: InputMaybe<TypeKind>
  kind_SET?: InputMaybe<TypeKind>
  /** @deprecated Please use the explicit _SET field */
  name?: InputMaybe<Scalars['String']['input']>
  name_SET?: InputMaybe<Scalars['String']['input']>
  owner?: InputMaybe<EnumTypeOwnerUpdateFieldInput>
}

export type EnumTypeUpdatedEvent = {
  event: EventType
  previousState: EnumTypeEventPayload
  timestamp: Scalars['Float']['output']
  updatedEnumType: EnumTypeEventPayload
}

export type EnumTypeUserOwnerAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<EnumTypeUserOwnerNodeAggregateSelection>
}

export type EnumTypeUserOwnerNodeAggregateSelection = {
  auth0Id: StringAggregateSelection
  email: StringAggregateSelection
  id: IdAggregateSelection
  username: StringAggregateSelection
}

export type EnumTypeValue = {
  enumType?: Maybe<EnumType>
  enumTypeAggregate?: Maybe<EnumTypeValueEnumTypeEnumTypeAggregationSelection>
  enumTypeConnection: EnumTypeValueEnumTypeConnection
  id: Scalars['ID']['output']
  key: Scalars['String']['output']
  value: Scalars['String']['output']
}

export type EnumTypeValueEnumTypeArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<EnumTypeOptions>
  sort?: InputMaybe<Array<EnumTypeSort>>
  where?: InputMaybe<EnumTypeWhere>
}

export type EnumTypeValueEnumTypeAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<EnumTypeWhere>
}

export type EnumTypeValueEnumTypeConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<EnumTypeValueEnumTypeConnectionSort>>
  where?: InputMaybe<EnumTypeValueEnumTypeConnectionWhere>
}

export type EnumTypeValueAggregateSelection = {
  count: Scalars['Int']['output']
  id: IdAggregateSelection
  key: StringAggregateSelection
  value: StringAggregateSelection
}

export type EnumTypeValueConnectInput = {
  enumType?: InputMaybe<EnumTypeValueEnumTypeConnectFieldInput>
}

export type EnumTypeValueConnectWhere = {
  node: EnumTypeValueWhere
}

export type EnumTypeValueCreateInput = {
  enumType?: InputMaybe<EnumTypeValueEnumTypeFieldInput>
  id: Scalars['ID']['input']
  key: Scalars['String']['input']
  value: Scalars['String']['input']
}

export type EnumTypeValueCreatedEvent = {
  createdEnumTypeValue: EnumTypeValueEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type EnumTypeValueDeleteInput = {
  enumType?: InputMaybe<EnumTypeValueEnumTypeDeleteFieldInput>
}

export type EnumTypeValueDeletedEvent = {
  deletedEnumTypeValue: EnumTypeValueEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type EnumTypeValueDisconnectInput = {
  enumType?: InputMaybe<EnumTypeValueEnumTypeDisconnectFieldInput>
}

export type EnumTypeValueEdge = {
  cursor: Scalars['String']['output']
  node: EnumTypeValue
}

export type EnumTypeValueEnumTypeAggregateInput = {
  AND?: InputMaybe<Array<EnumTypeValueEnumTypeAggregateInput>>
  NOT?: InputMaybe<EnumTypeValueEnumTypeAggregateInput>
  OR?: InputMaybe<Array<EnumTypeValueEnumTypeAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<EnumTypeValueEnumTypeNodeAggregationWhereInput>
}

export type EnumTypeValueEnumTypeConnectFieldInput = {
  connect?: InputMaybe<EnumTypeConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<EnumTypeConnectWhere>
}

export type EnumTypeValueEnumTypeConnection = {
  edges: Array<EnumTypeValueEnumTypeRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type EnumTypeValueEnumTypeConnectionSort = {
  node?: InputMaybe<EnumTypeSort>
}

export type EnumTypeValueEnumTypeConnectionWhere = {
  AND?: InputMaybe<Array<EnumTypeValueEnumTypeConnectionWhere>>
  NOT?: InputMaybe<EnumTypeValueEnumTypeConnectionWhere>
  OR?: InputMaybe<Array<EnumTypeValueEnumTypeConnectionWhere>>
  node?: InputMaybe<EnumTypeWhere>
}

export type EnumTypeValueEnumTypeCreateFieldInput = {
  node: EnumTypeCreateInput
}

export type EnumTypeValueEnumTypeDeleteFieldInput = {
  delete?: InputMaybe<EnumTypeDeleteInput>
  where?: InputMaybe<EnumTypeValueEnumTypeConnectionWhere>
}

export type EnumTypeValueEnumTypeDisconnectFieldInput = {
  disconnect?: InputMaybe<EnumTypeDisconnectInput>
  where?: InputMaybe<EnumTypeValueEnumTypeConnectionWhere>
}

export type EnumTypeValueEnumTypeEnumTypeAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<EnumTypeValueEnumTypeEnumTypeNodeAggregateSelection>
}

export type EnumTypeValueEnumTypeEnumTypeNodeAggregateSelection = {
  id: IdAggregateSelection
  name: StringAggregateSelection
}

export type EnumTypeValueEnumTypeFieldInput = {
  connect?: InputMaybe<EnumTypeValueEnumTypeConnectFieldInput>
  create?: InputMaybe<EnumTypeValueEnumTypeCreateFieldInput>
}

export type EnumTypeValueEnumTypeNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<EnumTypeValueEnumTypeNodeAggregationWhereInput>>
  NOT?: InputMaybe<EnumTypeValueEnumTypeNodeAggregationWhereInput>
  OR?: InputMaybe<Array<EnumTypeValueEnumTypeNodeAggregationWhereInput>>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type EnumTypeValueEnumTypeRelationship = {
  cursor: Scalars['String']['output']
  node: EnumType
}

export type EnumTypeValueEnumTypeUpdateConnectionInput = {
  node?: InputMaybe<EnumTypeUpdateInput>
}

export type EnumTypeValueEnumTypeUpdateFieldInput = {
  connect?: InputMaybe<EnumTypeValueEnumTypeConnectFieldInput>
  create?: InputMaybe<EnumTypeValueEnumTypeCreateFieldInput>
  delete?: InputMaybe<EnumTypeValueEnumTypeDeleteFieldInput>
  disconnect?: InputMaybe<EnumTypeValueEnumTypeDisconnectFieldInput>
  update?: InputMaybe<EnumTypeValueEnumTypeUpdateConnectionInput>
  where?: InputMaybe<EnumTypeValueEnumTypeConnectionWhere>
}

export type EnumTypeValueEventPayload = {
  id: Scalars['ID']['output']
  key: Scalars['String']['output']
  value: Scalars['String']['output']
}

export type EnumTypeValueOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  /** Specify one or more EnumTypeValueSort objects to sort EnumTypeValues by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<EnumTypeValueSort>>
}

/** Fields to sort EnumTypeValues by. The order in which sorts are applied is not guaranteed when specifying many fields in one EnumTypeValueSort object. */
export type EnumTypeValueSort = {
  id?: InputMaybe<SortDirection>
  key?: InputMaybe<SortDirection>
  value?: InputMaybe<SortDirection>
}

export type EnumTypeValueSubscriptionWhere = {
  AND?: InputMaybe<Array<EnumTypeValueSubscriptionWhere>>
  NOT?: InputMaybe<EnumTypeValueSubscriptionWhere>
  OR?: InputMaybe<Array<EnumTypeValueSubscriptionWhere>>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  key?: InputMaybe<Scalars['String']['input']>
  key_CONTAINS?: InputMaybe<Scalars['String']['input']>
  key_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  key_EQ?: InputMaybe<Scalars['String']['input']>
  key_IN?: InputMaybe<Array<Scalars['String']['input']>>
  key_MATCHES?: InputMaybe<Scalars['String']['input']>
  key_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  value?: InputMaybe<Scalars['String']['input']>
  value_CONTAINS?: InputMaybe<Scalars['String']['input']>
  value_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  value_EQ?: InputMaybe<Scalars['String']['input']>
  value_IN?: InputMaybe<Array<Scalars['String']['input']>>
  value_MATCHES?: InputMaybe<Scalars['String']['input']>
  value_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
}

export type EnumTypeValueUpdateInput = {
  enumType?: InputMaybe<EnumTypeValueEnumTypeUpdateFieldInput>
  /** @deprecated Please use the explicit _SET field */
  id?: InputMaybe<Scalars['ID']['input']>
  id_SET?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _SET field */
  key?: InputMaybe<Scalars['String']['input']>
  key_SET?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _SET field */
  value?: InputMaybe<Scalars['String']['input']>
  value_SET?: InputMaybe<Scalars['String']['input']>
}

export type EnumTypeValueUpdatedEvent = {
  event: EventType
  previousState: EnumTypeValueEventPayload
  timestamp: Scalars['Float']['output']
  updatedEnumTypeValue: EnumTypeValueEventPayload
}

export type EnumTypeValueWhere = {
  AND?: InputMaybe<Array<EnumTypeValueWhere>>
  NOT?: InputMaybe<EnumTypeValueWhere>
  OR?: InputMaybe<Array<EnumTypeValueWhere>>
  enumType?: InputMaybe<EnumTypeWhere>
  enumTypeAggregate?: InputMaybe<EnumTypeValueEnumTypeAggregateInput>
  enumTypeConnection?: InputMaybe<EnumTypeValueEnumTypeConnectionWhere>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  key?: InputMaybe<Scalars['String']['input']>
  key_CONTAINS?: InputMaybe<Scalars['String']['input']>
  key_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  key_EQ?: InputMaybe<Scalars['String']['input']>
  key_IN?: InputMaybe<Array<Scalars['String']['input']>>
  key_MATCHES?: InputMaybe<Scalars['String']['input']>
  key_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  value?: InputMaybe<Scalars['String']['input']>
  value_CONTAINS?: InputMaybe<Scalars['String']['input']>
  value_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  value_EQ?: InputMaybe<Scalars['String']['input']>
  value_IN?: InputMaybe<Array<Scalars['String']['input']>>
  value_MATCHES?: InputMaybe<Scalars['String']['input']>
  value_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
}

export type EnumTypeValuesConnection = {
  edges: Array<EnumTypeValueEdge>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type EnumTypeWhere = {
  AND?: InputMaybe<Array<EnumTypeWhere>>
  NOT?: InputMaybe<EnumTypeWhere>
  OR?: InputMaybe<Array<EnumTypeWhere>>
  allowedValuesAggregate?: InputMaybe<EnumTypeAllowedValuesAggregateInput>
  /** Return EnumTypes where all of the related EnumTypeAllowedValuesConnections match this filter */
  allowedValuesConnection_ALL?: InputMaybe<EnumTypeAllowedValuesConnectionWhere>
  /** Return EnumTypes where none of the related EnumTypeAllowedValuesConnections match this filter */
  allowedValuesConnection_NONE?: InputMaybe<EnumTypeAllowedValuesConnectionWhere>
  /** Return EnumTypes where one of the related EnumTypeAllowedValuesConnections match this filter */
  allowedValuesConnection_SINGLE?: InputMaybe<EnumTypeAllowedValuesConnectionWhere>
  /** Return EnumTypes where some of the related EnumTypeAllowedValuesConnections match this filter */
  allowedValuesConnection_SOME?: InputMaybe<EnumTypeAllowedValuesConnectionWhere>
  /** Return EnumTypes where all of the related EnumTypeValues match this filter */
  allowedValues_ALL?: InputMaybe<EnumTypeValueWhere>
  /** Return EnumTypes where none of the related EnumTypeValues match this filter */
  allowedValues_NONE?: InputMaybe<EnumTypeValueWhere>
  /** Return EnumTypes where one of the related EnumTypeValues match this filter */
  allowedValues_SINGLE?: InputMaybe<EnumTypeValueWhere>
  /** Return EnumTypes where some of the related EnumTypeValues match this filter */
  allowedValues_SOME?: InputMaybe<EnumTypeValueWhere>
  fieldRefsAggregate?: InputMaybe<EnumTypeFieldRefsAggregateInput>
  /** Return EnumTypes where all of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_ALL?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return EnumTypes where none of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_NONE?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return EnumTypes where one of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_SINGLE?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return EnumTypes where some of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_SOME?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return EnumTypes where all of the related Fields match this filter */
  fieldRefs_ALL?: InputMaybe<FieldWhere>
  /** Return EnumTypes where none of the related Fields match this filter */
  fieldRefs_NONE?: InputMaybe<FieldWhere>
  /** Return EnumTypes where one of the related Fields match this filter */
  fieldRefs_SINGLE?: InputMaybe<FieldWhere>
  /** Return EnumTypes where some of the related Fields match this filter */
  fieldRefs_SOME?: InputMaybe<FieldWhere>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  kind?: InputMaybe<TypeKind>
  kind_EQ?: InputMaybe<TypeKind>
  kind_IN?: InputMaybe<Array<TypeKind>>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>
  name_MATCHES?: InputMaybe<Scalars['String']['input']>
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  owner?: InputMaybe<UserWhere>
  ownerAggregate?: InputMaybe<EnumTypeOwnerAggregateInput>
  ownerConnection?: InputMaybe<IBaseTypeOwnerConnectionWhere>
}

export type EnumTypesConnection = {
  edges: Array<EnumTypeEdge>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export enum EventType {
  Create = 'CREATE',
  CreateRelationship = 'CREATE_RELATIONSHIP',
  Delete = 'DELETE',
  DeleteRelationship = 'DELETE_RELATIONSHIP',
  Update = 'UPDATE',
}

export type Field = {
  api: InterfaceType
  apiAggregate?: Maybe<FieldInterfaceTypeApiAggregationSelection>
  apiConnection: FieldApiConnection
  defaultValues?: Maybe<Scalars['String']['output']>
  description?: Maybe<Scalars['String']['output']>
  fieldType: IBaseType
  fieldTypeAggregate?: Maybe<FieldIBaseTypeFieldTypeAggregationSelection>
  fieldTypeConnection: FieldFieldTypeConnection
  id: Scalars['ID']['output']
  key: Scalars['String']['output']
  name?: Maybe<Scalars['String']['output']>
  nextSibling?: Maybe<Field>
  nextSiblingAggregate?: Maybe<FieldFieldNextSiblingAggregationSelection>
  nextSiblingConnection: FieldNextSiblingConnection
  prevSibling?: Maybe<Field>
  prevSiblingAggregate?: Maybe<FieldFieldPrevSiblingAggregationSelection>
  prevSiblingConnection: FieldPrevSiblingConnection
  validationRules?: Maybe<Scalars['String']['output']>
}

export type FieldApiArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<InterfaceTypeOptions>
  sort?: InputMaybe<Array<InterfaceTypeSort>>
  where?: InputMaybe<InterfaceTypeWhere>
}

export type FieldApiAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<InterfaceTypeWhere>
}

export type FieldApiConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<FieldApiConnectionSort>>
  where?: InputMaybe<FieldApiConnectionWhere>
}

export type FieldFieldTypeArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<IBaseTypeOptions>
  sort?: InputMaybe<Array<IBaseTypeSort>>
  where?: InputMaybe<IBaseTypeWhere>
}

export type FieldFieldTypeAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<IBaseTypeWhere>
}

export type FieldFieldTypeConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<FieldFieldTypeConnectionSort>>
  where?: InputMaybe<FieldFieldTypeConnectionWhere>
}

export type FieldNextSiblingArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<FieldOptions>
  sort?: InputMaybe<Array<FieldSort>>
  where?: InputMaybe<FieldWhere>
}

export type FieldNextSiblingAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<FieldWhere>
}

export type FieldNextSiblingConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<FieldNextSiblingConnectionSort>>
  where?: InputMaybe<FieldNextSiblingConnectionWhere>
}

export type FieldPrevSiblingArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<FieldOptions>
  sort?: InputMaybe<Array<FieldSort>>
  where?: InputMaybe<FieldWhere>
}

export type FieldPrevSiblingAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<FieldWhere>
}

export type FieldPrevSiblingConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<FieldPrevSiblingConnectionSort>>
  where?: InputMaybe<FieldPrevSiblingConnectionWhere>
}

export type FieldAggregateSelection = {
  count: Scalars['Int']['output']
  defaultValues: StringAggregateSelection
  description: StringAggregateSelection
  id: IdAggregateSelection
  key: StringAggregateSelection
  name: StringAggregateSelection
  validationRules: StringAggregateSelection
}

export type FieldApiAggregateInput = {
  AND?: InputMaybe<Array<FieldApiAggregateInput>>
  NOT?: InputMaybe<FieldApiAggregateInput>
  OR?: InputMaybe<Array<FieldApiAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<FieldApiNodeAggregationWhereInput>
}

export type FieldApiConnectFieldInput = {
  connect?: InputMaybe<InterfaceTypeConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<InterfaceTypeConnectWhere>
}

export type FieldApiConnection = {
  edges: Array<FieldApiRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type FieldApiConnectionSort = {
  node?: InputMaybe<InterfaceTypeSort>
}

export type FieldApiConnectionWhere = {
  AND?: InputMaybe<Array<FieldApiConnectionWhere>>
  NOT?: InputMaybe<FieldApiConnectionWhere>
  OR?: InputMaybe<Array<FieldApiConnectionWhere>>
  node?: InputMaybe<InterfaceTypeWhere>
}

export type FieldApiCreateFieldInput = {
  node: InterfaceTypeCreateInput
}

export type FieldApiDeleteFieldInput = {
  delete?: InputMaybe<InterfaceTypeDeleteInput>
  where?: InputMaybe<FieldApiConnectionWhere>
}

export type FieldApiDisconnectFieldInput = {
  disconnect?: InputMaybe<InterfaceTypeDisconnectInput>
  where?: InputMaybe<FieldApiConnectionWhere>
}

export type FieldApiFieldInput = {
  connect?: InputMaybe<FieldApiConnectFieldInput>
  create?: InputMaybe<FieldApiCreateFieldInput>
}

export type FieldApiNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<FieldApiNodeAggregationWhereInput>>
  NOT?: InputMaybe<FieldApiNodeAggregationWhereInput>
  OR?: InputMaybe<Array<FieldApiNodeAggregationWhereInput>>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type FieldApiRelationship = {
  cursor: Scalars['String']['output']
  node: InterfaceType
}

export type FieldApiUpdateConnectionInput = {
  node?: InputMaybe<InterfaceTypeUpdateInput>
}

export type FieldApiUpdateFieldInput = {
  connect?: InputMaybe<FieldApiConnectFieldInput>
  create?: InputMaybe<FieldApiCreateFieldInput>
  delete?: InputMaybe<FieldApiDeleteFieldInput>
  disconnect?: InputMaybe<FieldApiDisconnectFieldInput>
  update?: InputMaybe<FieldApiUpdateConnectionInput>
  where?: InputMaybe<FieldApiConnectionWhere>
}

export type FieldConnectInput = {
  api?: InputMaybe<FieldApiConnectFieldInput>
  fieldType?: InputMaybe<FieldFieldTypeConnectFieldInput>
  nextSibling?: InputMaybe<FieldNextSiblingConnectFieldInput>
  prevSibling?: InputMaybe<FieldPrevSiblingConnectFieldInput>
}

export type FieldConnectOrCreateWhere = {
  node: FieldUniqueWhere
}

export type FieldConnectWhere = {
  node: FieldWhere
}

export type FieldCreateInput = {
  api?: InputMaybe<FieldApiFieldInput>
  defaultValues?: InputMaybe<Scalars['String']['input']>
  description?: InputMaybe<Scalars['String']['input']>
  fieldType?: InputMaybe<FieldFieldTypeFieldInput>
  id: Scalars['ID']['input']
  key: Scalars['String']['input']
  name?: InputMaybe<Scalars['String']['input']>
  nextSibling?: InputMaybe<FieldNextSiblingFieldInput>
  prevSibling?: InputMaybe<FieldPrevSiblingFieldInput>
  validationRules?: InputMaybe<Scalars['String']['input']>
}

export type FieldCreatedEvent = {
  createdField: FieldEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type FieldDeleteInput = {
  api?: InputMaybe<FieldApiDeleteFieldInput>
  fieldType?: InputMaybe<FieldFieldTypeDeleteFieldInput>
  nextSibling?: InputMaybe<FieldNextSiblingDeleteFieldInput>
  prevSibling?: InputMaybe<FieldPrevSiblingDeleteFieldInput>
}

export type FieldDeletedEvent = {
  deletedField: FieldEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type FieldDisconnectInput = {
  api?: InputMaybe<FieldApiDisconnectFieldInput>
  fieldType?: InputMaybe<FieldFieldTypeDisconnectFieldInput>
  nextSibling?: InputMaybe<FieldNextSiblingDisconnectFieldInput>
  prevSibling?: InputMaybe<FieldPrevSiblingDisconnectFieldInput>
}

export type FieldEdge = {
  cursor: Scalars['String']['output']
  node: Field
}

export type FieldEventPayload = {
  defaultValues?: Maybe<Scalars['String']['output']>
  description?: Maybe<Scalars['String']['output']>
  id: Scalars['ID']['output']
  key: Scalars['String']['output']
  name?: Maybe<Scalars['String']['output']>
  validationRules?: Maybe<Scalars['String']['output']>
}

export type FieldFieldNextSiblingAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<FieldFieldNextSiblingNodeAggregateSelection>
}

export type FieldFieldNextSiblingNodeAggregateSelection = {
  defaultValues: StringAggregateSelection
  description: StringAggregateSelection
  id: IdAggregateSelection
  key: StringAggregateSelection
  name: StringAggregateSelection
  validationRules: StringAggregateSelection
}

export type FieldFieldPrevSiblingAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<FieldFieldPrevSiblingNodeAggregateSelection>
}

export type FieldFieldPrevSiblingNodeAggregateSelection = {
  defaultValues: StringAggregateSelection
  description: StringAggregateSelection
  id: IdAggregateSelection
  key: StringAggregateSelection
  name: StringAggregateSelection
  validationRules: StringAggregateSelection
}

export type FieldFieldTypeAggregateInput = {
  AND?: InputMaybe<Array<FieldFieldTypeAggregateInput>>
  NOT?: InputMaybe<FieldFieldTypeAggregateInput>
  OR?: InputMaybe<Array<FieldFieldTypeAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<FieldFieldTypeNodeAggregationWhereInput>
}

export type FieldFieldTypeConnectFieldInput = {
  connect?: InputMaybe<IBaseTypeConnectInput>
  where?: InputMaybe<IBaseTypeConnectWhere>
}

export type FieldFieldTypeConnection = {
  edges: Array<FieldFieldTypeRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type FieldFieldTypeConnectionSort = {
  node?: InputMaybe<IBaseTypeSort>
}

export type FieldFieldTypeConnectionWhere = {
  AND?: InputMaybe<Array<FieldFieldTypeConnectionWhere>>
  NOT?: InputMaybe<FieldFieldTypeConnectionWhere>
  OR?: InputMaybe<Array<FieldFieldTypeConnectionWhere>>
  node?: InputMaybe<IBaseTypeWhere>
}

export type FieldFieldTypeCreateFieldInput = {
  node: IBaseTypeCreateInput
}

export type FieldFieldTypeDeleteFieldInput = {
  delete?: InputMaybe<IBaseTypeDeleteInput>
  where?: InputMaybe<FieldFieldTypeConnectionWhere>
}

export type FieldFieldTypeDisconnectFieldInput = {
  disconnect?: InputMaybe<IBaseTypeDisconnectInput>
  where?: InputMaybe<FieldFieldTypeConnectionWhere>
}

export type FieldFieldTypeFieldInput = {
  connect?: InputMaybe<FieldFieldTypeConnectFieldInput>
  create?: InputMaybe<FieldFieldTypeCreateFieldInput>
}

export type FieldFieldTypeNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<FieldFieldTypeNodeAggregationWhereInput>>
  NOT?: InputMaybe<FieldFieldTypeNodeAggregationWhereInput>
  OR?: InputMaybe<Array<FieldFieldTypeNodeAggregationWhereInput>>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type FieldFieldTypeRelationship = {
  cursor: Scalars['String']['output']
  node: IBaseType
}

export type FieldFieldTypeUpdateConnectionInput = {
  node?: InputMaybe<IBaseTypeUpdateInput>
}

export type FieldFieldTypeUpdateFieldInput = {
  connect?: InputMaybe<FieldFieldTypeConnectFieldInput>
  create?: InputMaybe<FieldFieldTypeCreateFieldInput>
  delete?: InputMaybe<FieldFieldTypeDeleteFieldInput>
  disconnect?: InputMaybe<FieldFieldTypeDisconnectFieldInput>
  update?: InputMaybe<FieldFieldTypeUpdateConnectionInput>
  where?: InputMaybe<FieldFieldTypeConnectionWhere>
}

export type FieldIBaseTypeFieldTypeAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<FieldIBaseTypeFieldTypeNodeAggregateSelection>
}

export type FieldIBaseTypeFieldTypeNodeAggregateSelection = {
  id: IdAggregateSelection
  name: StringAggregateSelection
}

export type FieldInterfaceTypeApiAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<FieldInterfaceTypeApiNodeAggregateSelection>
}

export type FieldInterfaceTypeApiNodeAggregateSelection = {
  id: IdAggregateSelection
  name: StringAggregateSelection
}

export type FieldNextSiblingAggregateInput = {
  AND?: InputMaybe<Array<FieldNextSiblingAggregateInput>>
  NOT?: InputMaybe<FieldNextSiblingAggregateInput>
  OR?: InputMaybe<Array<FieldNextSiblingAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<FieldNextSiblingNodeAggregationWhereInput>
}

export type FieldNextSiblingConnectFieldInput = {
  connect?: InputMaybe<FieldConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<FieldConnectWhere>
}

export type FieldNextSiblingConnectOrCreateFieldInput = {
  onCreate: FieldNextSiblingConnectOrCreateFieldInputOnCreate
  where: FieldConnectOrCreateWhere
}

export type FieldNextSiblingConnectOrCreateFieldInputOnCreate = {
  node: FieldOnCreateInput
}

export type FieldNextSiblingConnection = {
  edges: Array<FieldNextSiblingRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type FieldNextSiblingConnectionSort = {
  node?: InputMaybe<FieldSort>
}

export type FieldNextSiblingConnectionWhere = {
  AND?: InputMaybe<Array<FieldNextSiblingConnectionWhere>>
  NOT?: InputMaybe<FieldNextSiblingConnectionWhere>
  OR?: InputMaybe<Array<FieldNextSiblingConnectionWhere>>
  node?: InputMaybe<FieldWhere>
}

export type FieldNextSiblingCreateFieldInput = {
  node: FieldCreateInput
}

export type FieldNextSiblingDeleteFieldInput = {
  delete?: InputMaybe<FieldDeleteInput>
  where?: InputMaybe<FieldNextSiblingConnectionWhere>
}

export type FieldNextSiblingDisconnectFieldInput = {
  disconnect?: InputMaybe<FieldDisconnectInput>
  where?: InputMaybe<FieldNextSiblingConnectionWhere>
}

export type FieldNextSiblingFieldInput = {
  connect?: InputMaybe<FieldNextSiblingConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<FieldNextSiblingConnectOrCreateFieldInput>
  create?: InputMaybe<FieldNextSiblingCreateFieldInput>
}

export type FieldNextSiblingNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<FieldNextSiblingNodeAggregationWhereInput>>
  NOT?: InputMaybe<FieldNextSiblingNodeAggregationWhereInput>
  OR?: InputMaybe<Array<FieldNextSiblingNodeAggregationWhereInput>>
  defaultValues_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  defaultValues_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  description_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  description_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  key_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  key_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  validationRules_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type FieldNextSiblingRelationship = {
  cursor: Scalars['String']['output']
  node: Field
}

export type FieldNextSiblingUpdateConnectionInput = {
  node?: InputMaybe<FieldUpdateInput>
}

export type FieldNextSiblingUpdateFieldInput = {
  connect?: InputMaybe<FieldNextSiblingConnectFieldInput>
  connectOrCreate?: InputMaybe<FieldNextSiblingConnectOrCreateFieldInput>
  create?: InputMaybe<FieldNextSiblingCreateFieldInput>
  delete?: InputMaybe<FieldNextSiblingDeleteFieldInput>
  disconnect?: InputMaybe<FieldNextSiblingDisconnectFieldInput>
  update?: InputMaybe<FieldNextSiblingUpdateConnectionInput>
  where?: InputMaybe<FieldNextSiblingConnectionWhere>
}

export type FieldOnCreateInput = {
  defaultValues?: InputMaybe<Scalars['String']['input']>
  description?: InputMaybe<Scalars['String']['input']>
  id: Scalars['ID']['input']
  key: Scalars['String']['input']
  name?: InputMaybe<Scalars['String']['input']>
  validationRules?: InputMaybe<Scalars['String']['input']>
}

export type FieldOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  /** Specify one or more FieldSort objects to sort Fields by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<FieldSort>>
}

export type FieldPrevSiblingAggregateInput = {
  AND?: InputMaybe<Array<FieldPrevSiblingAggregateInput>>
  NOT?: InputMaybe<FieldPrevSiblingAggregateInput>
  OR?: InputMaybe<Array<FieldPrevSiblingAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<FieldPrevSiblingNodeAggregationWhereInput>
}

export type FieldPrevSiblingConnectFieldInput = {
  connect?: InputMaybe<FieldConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<FieldConnectWhere>
}

export type FieldPrevSiblingConnectOrCreateFieldInput = {
  onCreate: FieldPrevSiblingConnectOrCreateFieldInputOnCreate
  where: FieldConnectOrCreateWhere
}

export type FieldPrevSiblingConnectOrCreateFieldInputOnCreate = {
  node: FieldOnCreateInput
}

export type FieldPrevSiblingConnection = {
  edges: Array<FieldPrevSiblingRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type FieldPrevSiblingConnectionSort = {
  node?: InputMaybe<FieldSort>
}

export type FieldPrevSiblingConnectionWhere = {
  AND?: InputMaybe<Array<FieldPrevSiblingConnectionWhere>>
  NOT?: InputMaybe<FieldPrevSiblingConnectionWhere>
  OR?: InputMaybe<Array<FieldPrevSiblingConnectionWhere>>
  node?: InputMaybe<FieldWhere>
}

export type FieldPrevSiblingCreateFieldInput = {
  node: FieldCreateInput
}

export type FieldPrevSiblingDeleteFieldInput = {
  delete?: InputMaybe<FieldDeleteInput>
  where?: InputMaybe<FieldPrevSiblingConnectionWhere>
}

export type FieldPrevSiblingDisconnectFieldInput = {
  disconnect?: InputMaybe<FieldDisconnectInput>
  where?: InputMaybe<FieldPrevSiblingConnectionWhere>
}

export type FieldPrevSiblingFieldInput = {
  connect?: InputMaybe<FieldPrevSiblingConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<FieldPrevSiblingConnectOrCreateFieldInput>
  create?: InputMaybe<FieldPrevSiblingCreateFieldInput>
}

export type FieldPrevSiblingNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<FieldPrevSiblingNodeAggregationWhereInput>>
  NOT?: InputMaybe<FieldPrevSiblingNodeAggregationWhereInput>
  OR?: InputMaybe<Array<FieldPrevSiblingNodeAggregationWhereInput>>
  defaultValues_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  defaultValues_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  description_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  description_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  key_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  key_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  validationRules_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type FieldPrevSiblingRelationship = {
  cursor: Scalars['String']['output']
  node: Field
}

export type FieldPrevSiblingUpdateConnectionInput = {
  node?: InputMaybe<FieldUpdateInput>
}

export type FieldPrevSiblingUpdateFieldInput = {
  connect?: InputMaybe<FieldPrevSiblingConnectFieldInput>
  connectOrCreate?: InputMaybe<FieldPrevSiblingConnectOrCreateFieldInput>
  create?: InputMaybe<FieldPrevSiblingCreateFieldInput>
  delete?: InputMaybe<FieldPrevSiblingDeleteFieldInput>
  disconnect?: InputMaybe<FieldPrevSiblingDisconnectFieldInput>
  update?: InputMaybe<FieldPrevSiblingUpdateConnectionInput>
  where?: InputMaybe<FieldPrevSiblingConnectionWhere>
}

/** Fields to sort Fields by. The order in which sorts are applied is not guaranteed when specifying many fields in one FieldSort object. */
export type FieldSort = {
  defaultValues?: InputMaybe<SortDirection>
  description?: InputMaybe<SortDirection>
  id?: InputMaybe<SortDirection>
  key?: InputMaybe<SortDirection>
  name?: InputMaybe<SortDirection>
  validationRules?: InputMaybe<SortDirection>
}

export type FieldSubscriptionWhere = {
  AND?: InputMaybe<Array<FieldSubscriptionWhere>>
  NOT?: InputMaybe<FieldSubscriptionWhere>
  OR?: InputMaybe<Array<FieldSubscriptionWhere>>
  /** @deprecated Please use the explicit _EQ version */
  defaultValues?: InputMaybe<Scalars['String']['input']>
  defaultValues_CONTAINS?: InputMaybe<Scalars['String']['input']>
  defaultValues_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  defaultValues_EQ?: InputMaybe<Scalars['String']['input']>
  defaultValues_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>
  defaultValues_MATCHES?: InputMaybe<Scalars['String']['input']>
  defaultValues_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  description?: InputMaybe<Scalars['String']['input']>
  description_CONTAINS?: InputMaybe<Scalars['String']['input']>
  description_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  description_EQ?: InputMaybe<Scalars['String']['input']>
  description_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>
  description_MATCHES?: InputMaybe<Scalars['String']['input']>
  description_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  key?: InputMaybe<Scalars['String']['input']>
  key_CONTAINS?: InputMaybe<Scalars['String']['input']>
  key_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  key_EQ?: InputMaybe<Scalars['String']['input']>
  key_IN?: InputMaybe<Array<Scalars['String']['input']>>
  key_MATCHES?: InputMaybe<Scalars['String']['input']>
  key_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  name_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>
  name_MATCHES?: InputMaybe<Scalars['String']['input']>
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  validationRules?: InputMaybe<Scalars['String']['input']>
  validationRules_CONTAINS?: InputMaybe<Scalars['String']['input']>
  validationRules_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  validationRules_EQ?: InputMaybe<Scalars['String']['input']>
  validationRules_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>
  validationRules_MATCHES?: InputMaybe<Scalars['String']['input']>
  validationRules_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
}

export type FieldUniqueWhere = {
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
}

export type FieldUpdateInput = {
  api?: InputMaybe<FieldApiUpdateFieldInput>
  /** @deprecated Please use the explicit _SET field */
  defaultValues?: InputMaybe<Scalars['String']['input']>
  defaultValues_SET?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _SET field */
  description?: InputMaybe<Scalars['String']['input']>
  description_SET?: InputMaybe<Scalars['String']['input']>
  fieldType?: InputMaybe<FieldFieldTypeUpdateFieldInput>
  /** @deprecated Please use the explicit _SET field */
  key?: InputMaybe<Scalars['String']['input']>
  key_SET?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _SET field */
  name?: InputMaybe<Scalars['String']['input']>
  name_SET?: InputMaybe<Scalars['String']['input']>
  nextSibling?: InputMaybe<FieldNextSiblingUpdateFieldInput>
  prevSibling?: InputMaybe<FieldPrevSiblingUpdateFieldInput>
  /** @deprecated Please use the explicit _SET field */
  validationRules?: InputMaybe<Scalars['String']['input']>
  validationRules_SET?: InputMaybe<Scalars['String']['input']>
}

export type FieldUpdatedEvent = {
  event: EventType
  previousState: FieldEventPayload
  timestamp: Scalars['Float']['output']
  updatedField: FieldEventPayload
}

export type FieldWhere = {
  AND?: InputMaybe<Array<FieldWhere>>
  NOT?: InputMaybe<FieldWhere>
  OR?: InputMaybe<Array<FieldWhere>>
  api?: InputMaybe<InterfaceTypeWhere>
  apiAggregate?: InputMaybe<FieldApiAggregateInput>
  apiConnection?: InputMaybe<FieldApiConnectionWhere>
  /** @deprecated Please use the explicit _EQ version */
  defaultValues?: InputMaybe<Scalars['String']['input']>
  defaultValues_CONTAINS?: InputMaybe<Scalars['String']['input']>
  defaultValues_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  defaultValues_EQ?: InputMaybe<Scalars['String']['input']>
  defaultValues_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>
  defaultValues_MATCHES?: InputMaybe<Scalars['String']['input']>
  defaultValues_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  description?: InputMaybe<Scalars['String']['input']>
  description_CONTAINS?: InputMaybe<Scalars['String']['input']>
  description_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  description_EQ?: InputMaybe<Scalars['String']['input']>
  description_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>
  description_MATCHES?: InputMaybe<Scalars['String']['input']>
  description_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  fieldType?: InputMaybe<IBaseTypeWhere>
  fieldTypeAggregate?: InputMaybe<FieldFieldTypeAggregateInput>
  fieldTypeConnection?: InputMaybe<FieldFieldTypeConnectionWhere>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  key?: InputMaybe<Scalars['String']['input']>
  key_CONTAINS?: InputMaybe<Scalars['String']['input']>
  key_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  key_EQ?: InputMaybe<Scalars['String']['input']>
  key_IN?: InputMaybe<Array<Scalars['String']['input']>>
  key_MATCHES?: InputMaybe<Scalars['String']['input']>
  key_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  name_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>
  name_MATCHES?: InputMaybe<Scalars['String']['input']>
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  nextSibling?: InputMaybe<FieldWhere>
  nextSiblingAggregate?: InputMaybe<FieldNextSiblingAggregateInput>
  nextSiblingConnection?: InputMaybe<FieldNextSiblingConnectionWhere>
  prevSibling?: InputMaybe<FieldWhere>
  prevSiblingAggregate?: InputMaybe<FieldPrevSiblingAggregateInput>
  prevSiblingConnection?: InputMaybe<FieldPrevSiblingConnectionWhere>
  /** @deprecated Please use the explicit _EQ version */
  validationRules?: InputMaybe<Scalars['String']['input']>
  validationRules_CONTAINS?: InputMaybe<Scalars['String']['input']>
  validationRules_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  validationRules_EQ?: InputMaybe<Scalars['String']['input']>
  validationRules_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>
  validationRules_MATCHES?: InputMaybe<Scalars['String']['input']>
  validationRules_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
}

export type FieldsConnection = {
  edges: Array<FieldEdge>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type FloatAggregateSelection = {
  average?: Maybe<Scalars['Float']['output']>
  max?: Maybe<Scalars['Float']['output']>
  min?: Maybe<Scalars['Float']['output']>
  sum?: Maybe<Scalars['Float']['output']>
}

export type Hook = {
  config: Prop
  configAggregate?: Maybe<HookPropConfigAggregationSelection>
  configConnection: HookConfigConnection
  element: Element
  elementAggregate?: Maybe<HookElementElementAggregationSelection>
  elementConnection: HookElementConnection
  id: Scalars['ID']['output']
  type: AtomType
}

export type HookConfigArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<PropOptions>
  sort?: InputMaybe<Array<PropSort>>
  where?: InputMaybe<PropWhere>
}

export type HookConfigAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<PropWhere>
}

export type HookConfigConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<HookConfigConnectionSort>>
  where?: InputMaybe<HookConfigConnectionWhere>
}

export type HookElementArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<ElementOptions>
  sort?: InputMaybe<Array<ElementSort>>
  where?: InputMaybe<ElementWhere>
}

export type HookElementAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<ElementWhere>
}

export type HookElementConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<HookElementConnectionSort>>
  where?: InputMaybe<HookElementConnectionWhere>
}

export type HookAggregateSelection = {
  count: Scalars['Int']['output']
  id: IdAggregateSelection
}

export type HookConfigAggregateInput = {
  AND?: InputMaybe<Array<HookConfigAggregateInput>>
  NOT?: InputMaybe<HookConfigAggregateInput>
  OR?: InputMaybe<Array<HookConfigAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<HookConfigNodeAggregationWhereInput>
}

export type HookConfigConnectFieldInput = {
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<PropConnectWhere>
}

export type HookConfigConnectOrCreateFieldInput = {
  onCreate: HookConfigConnectOrCreateFieldInputOnCreate
  where: PropConnectOrCreateWhere
}

export type HookConfigConnectOrCreateFieldInputOnCreate = {
  node: PropOnCreateInput
}

export type HookConfigConnection = {
  edges: Array<HookConfigRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type HookConfigConnectionSort = {
  node?: InputMaybe<PropSort>
}

export type HookConfigConnectionWhere = {
  AND?: InputMaybe<Array<HookConfigConnectionWhere>>
  NOT?: InputMaybe<HookConfigConnectionWhere>
  OR?: InputMaybe<Array<HookConfigConnectionWhere>>
  node?: InputMaybe<PropWhere>
}

export type HookConfigCreateFieldInput = {
  node: PropCreateInput
}

export type HookConfigDeleteFieldInput = {
  where?: InputMaybe<HookConfigConnectionWhere>
}

export type HookConfigDisconnectFieldInput = {
  where?: InputMaybe<HookConfigConnectionWhere>
}

export type HookConfigFieldInput = {
  connect?: InputMaybe<HookConfigConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<HookConfigConnectOrCreateFieldInput>
  create?: InputMaybe<HookConfigCreateFieldInput>
}

export type HookConfigNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<HookConfigNodeAggregationWhereInput>>
  NOT?: InputMaybe<HookConfigNodeAggregationWhereInput>
  OR?: InputMaybe<Array<HookConfigNodeAggregationWhereInput>>
  data_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  data_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  data_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  data_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  data_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  data_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  data_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  data_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  data_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  data_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  data_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  data_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  data_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  data_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  data_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
}

export type HookConfigRelationship = {
  cursor: Scalars['String']['output']
  node: Prop
}

export type HookConfigUpdateConnectionInput = {
  node?: InputMaybe<PropUpdateInput>
}

export type HookConfigUpdateFieldInput = {
  connect?: InputMaybe<HookConfigConnectFieldInput>
  connectOrCreate?: InputMaybe<HookConfigConnectOrCreateFieldInput>
  create?: InputMaybe<HookConfigCreateFieldInput>
  delete?: InputMaybe<HookConfigDeleteFieldInput>
  disconnect?: InputMaybe<HookConfigDisconnectFieldInput>
  update?: InputMaybe<HookConfigUpdateConnectionInput>
  where?: InputMaybe<HookConfigConnectionWhere>
}

export type HookCreateInput = {
  config?: InputMaybe<HookConfigFieldInput>
  element?: InputMaybe<HookElementFieldInput>
  id: Scalars['ID']['input']
  type: AtomType
}

export type HookCreatedEvent = {
  createdHook: HookEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type HookDeleteInput = {
  config?: InputMaybe<HookConfigDeleteFieldInput>
  element?: InputMaybe<HookElementDeleteFieldInput>
}

export type HookDeletedEvent = {
  deletedHook: HookEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type HookEdge = {
  cursor: Scalars['String']['output']
  node: Hook
}

export type HookElementAggregateInput = {
  AND?: InputMaybe<Array<HookElementAggregateInput>>
  NOT?: InputMaybe<HookElementAggregateInput>
  OR?: InputMaybe<Array<HookElementAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<HookElementNodeAggregationWhereInput>
}

export type HookElementConnectFieldInput = {
  connect?: InputMaybe<ElementConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<ElementConnectWhere>
}

export type HookElementConnectOrCreateFieldInput = {
  onCreate: HookElementConnectOrCreateFieldInputOnCreate
  where: ElementConnectOrCreateWhere
}

export type HookElementConnectOrCreateFieldInputOnCreate = {
  node: ElementOnCreateInput
}

export type HookElementConnection = {
  edges: Array<HookElementRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type HookElementConnectionSort = {
  node?: InputMaybe<ElementSort>
}

export type HookElementConnectionWhere = {
  AND?: InputMaybe<Array<HookElementConnectionWhere>>
  NOT?: InputMaybe<HookElementConnectionWhere>
  OR?: InputMaybe<Array<HookElementConnectionWhere>>
  node?: InputMaybe<ElementWhere>
}

export type HookElementCreateFieldInput = {
  node: ElementCreateInput
}

export type HookElementDeleteFieldInput = {
  delete?: InputMaybe<ElementDeleteInput>
  where?: InputMaybe<HookElementConnectionWhere>
}

export type HookElementDisconnectFieldInput = {
  disconnect?: InputMaybe<ElementDisconnectInput>
  where?: InputMaybe<HookElementConnectionWhere>
}

export type HookElementElementAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<HookElementElementNodeAggregateSelection>
}

export type HookElementElementNodeAggregateSelection = {
  childMapperPropKey: StringAggregateSelection
  compositeKey: StringAggregateSelection
  id: IdAggregateSelection
  renderForEachPropKey: StringAggregateSelection
  renderIfExpression: StringAggregateSelection
  style: StringAggregateSelection
}

export type HookElementFieldInput = {
  connect?: InputMaybe<HookElementConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<HookElementConnectOrCreateFieldInput>
  create?: InputMaybe<HookElementCreateFieldInput>
}

export type HookElementNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<HookElementNodeAggregationWhereInput>>
  NOT?: InputMaybe<HookElementNodeAggregationWhereInput>
  OR?: InputMaybe<Array<HookElementNodeAggregationWhereInput>>
  childMapperPropKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  childMapperPropKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_GTE?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_LTE?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_LONGEST_LENGTH_EQUAL?: InputMaybe<
    Scalars['Int']['input']
  >
  renderForEachPropKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<
    Scalars['Int']['input']
  >
  renderForEachPropKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  renderIfExpression_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  style_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  style_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type HookElementRelationship = {
  cursor: Scalars['String']['output']
  node: Element
}

export type HookElementUpdateConnectionInput = {
  node?: InputMaybe<ElementUpdateInput>
}

export type HookElementUpdateFieldInput = {
  connect?: InputMaybe<HookElementConnectFieldInput>
  connectOrCreate?: InputMaybe<HookElementConnectOrCreateFieldInput>
  create?: InputMaybe<HookElementCreateFieldInput>
  delete?: InputMaybe<HookElementDeleteFieldInput>
  disconnect?: InputMaybe<HookElementDisconnectFieldInput>
  update?: InputMaybe<HookElementUpdateConnectionInput>
  where?: InputMaybe<HookElementConnectionWhere>
}

export type HookEventPayload = {
  id: Scalars['ID']['output']
  type: AtomType
}

export type HookOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  /** Specify one or more HookSort objects to sort Hooks by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<HookSort>>
}

export type HookPropConfigAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<HookPropConfigNodeAggregateSelection>
}

export type HookPropConfigNodeAggregateSelection = {
  data: StringAggregateSelection
  id: IdAggregateSelection
}

/** Fields to sort Hooks by. The order in which sorts are applied is not guaranteed when specifying many fields in one HookSort object. */
export type HookSort = {
  id?: InputMaybe<SortDirection>
  type?: InputMaybe<SortDirection>
}

export type HookSubscriptionWhere = {
  AND?: InputMaybe<Array<HookSubscriptionWhere>>
  NOT?: InputMaybe<HookSubscriptionWhere>
  OR?: InputMaybe<Array<HookSubscriptionWhere>>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  type?: InputMaybe<AtomType>
  type_EQ?: InputMaybe<AtomType>
  type_IN?: InputMaybe<Array<AtomType>>
}

export type HookUpdateInput = {
  config?: InputMaybe<HookConfigUpdateFieldInput>
  element?: InputMaybe<HookElementUpdateFieldInput>
  /** @deprecated Please use the explicit _SET field */
  type?: InputMaybe<AtomType>
  type_SET?: InputMaybe<AtomType>
}

export type HookUpdatedEvent = {
  event: EventType
  previousState: HookEventPayload
  timestamp: Scalars['Float']['output']
  updatedHook: HookEventPayload
}

export type HookWhere = {
  AND?: InputMaybe<Array<HookWhere>>
  NOT?: InputMaybe<HookWhere>
  OR?: InputMaybe<Array<HookWhere>>
  config?: InputMaybe<PropWhere>
  configAggregate?: InputMaybe<HookConfigAggregateInput>
  configConnection?: InputMaybe<HookConfigConnectionWhere>
  element?: InputMaybe<ElementWhere>
  elementAggregate?: InputMaybe<HookElementAggregateInput>
  elementConnection?: InputMaybe<HookElementConnectionWhere>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  type?: InputMaybe<AtomType>
  type_EQ?: InputMaybe<AtomType>
  type_IN?: InputMaybe<Array<AtomType>>
}

export type HooksConnection = {
  edges: Array<HookEdge>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type IBaseType = {
  fieldRefs: Array<Field>
  fieldRefsConnection: IBaseTypeFieldRefsConnection
  id: Scalars['ID']['output']
  kind: TypeKind
  name: Scalars['String']['output']
  owner: User
  ownerConnection: IBaseTypeOwnerConnection
}

export type IBaseTypeFieldRefsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<FieldOptions>
  sort?: InputMaybe<Array<FieldSort>>
  where?: InputMaybe<FieldWhere>
}

export type IBaseTypeFieldRefsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<IBaseTypeFieldRefsConnectionSort>>
  where?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
}

export type IBaseTypeOwnerArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<UserOptions>
  sort?: InputMaybe<Array<UserSort>>
  where?: InputMaybe<UserWhere>
}

export type IBaseTypeOwnerConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<IBaseTypeOwnerConnectionSort>>
  where?: InputMaybe<IBaseTypeOwnerConnectionWhere>
}

export type IBaseTypeAggregateSelection = {
  count: Scalars['Int']['output']
  id: IdAggregateSelection
  name: StringAggregateSelection
}

export type IBaseTypeConnectInput = {
  fieldRefs?: InputMaybe<Array<IBaseTypeFieldRefsConnectFieldInput>>
  owner?: InputMaybe<IBaseTypeOwnerConnectFieldInput>
}

export type IBaseTypeConnectWhere = {
  node: IBaseTypeWhere
}

export type IBaseTypeCreateInput = {
  ActionType?: InputMaybe<ActionTypeCreateInput>
  AppType?: InputMaybe<AppTypeCreateInput>
  ArrayType?: InputMaybe<ArrayTypeCreateInput>
  CodeMirrorType?: InputMaybe<CodeMirrorTypeCreateInput>
  ElementType?: InputMaybe<ElementTypeCreateInput>
  EnumType?: InputMaybe<EnumTypeCreateInput>
  InterfaceType?: InputMaybe<InterfaceTypeCreateInput>
  LambdaType?: InputMaybe<LambdaTypeCreateInput>
  PageType?: InputMaybe<PageTypeCreateInput>
  PrimitiveType?: InputMaybe<PrimitiveTypeCreateInput>
  ReactNodeType?: InputMaybe<ReactNodeTypeCreateInput>
  RenderPropType?: InputMaybe<RenderPropTypeCreateInput>
  RichTextType?: InputMaybe<RichTextTypeCreateInput>
  UnionType?: InputMaybe<UnionTypeCreateInput>
}

export type IBaseTypeDeleteInput = {
  fieldRefs?: InputMaybe<Array<IBaseTypeFieldRefsDeleteFieldInput>>
  owner?: InputMaybe<IBaseTypeOwnerDeleteFieldInput>
}

export type IBaseTypeDisconnectInput = {
  fieldRefs?: InputMaybe<Array<IBaseTypeFieldRefsDisconnectFieldInput>>
  owner?: InputMaybe<IBaseTypeOwnerDisconnectFieldInput>
}

export type IBaseTypeEdge = {
  cursor: Scalars['String']['output']
  node: IBaseType
}

export type IBaseTypeFieldRefsAggregateInput = {
  AND?: InputMaybe<Array<IBaseTypeFieldRefsAggregateInput>>
  NOT?: InputMaybe<IBaseTypeFieldRefsAggregateInput>
  OR?: InputMaybe<Array<IBaseTypeFieldRefsAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<IBaseTypeFieldRefsNodeAggregationWhereInput>
}

export type IBaseTypeFieldRefsConnectFieldInput = {
  connect?: InputMaybe<Array<FieldConnectInput>>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<FieldConnectWhere>
}

export type IBaseTypeFieldRefsConnectOrCreateFieldInput = {
  onCreate: IBaseTypeFieldRefsConnectOrCreateFieldInputOnCreate
  where: FieldConnectOrCreateWhere
}

export type IBaseTypeFieldRefsConnectOrCreateFieldInputOnCreate = {
  node: FieldOnCreateInput
}

export type IBaseTypeFieldRefsConnection = {
  edges: Array<IBaseTypeFieldRefsRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type IBaseTypeFieldRefsConnectionSort = {
  node?: InputMaybe<FieldSort>
}

export type IBaseTypeFieldRefsConnectionWhere = {
  AND?: InputMaybe<Array<IBaseTypeFieldRefsConnectionWhere>>
  NOT?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  OR?: InputMaybe<Array<IBaseTypeFieldRefsConnectionWhere>>
  node?: InputMaybe<FieldWhere>
}

export type IBaseTypeFieldRefsCreateFieldInput = {
  node: FieldCreateInput
}

export type IBaseTypeFieldRefsDeleteFieldInput = {
  delete?: InputMaybe<FieldDeleteInput>
  where?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
}

export type IBaseTypeFieldRefsDisconnectFieldInput = {
  disconnect?: InputMaybe<FieldDisconnectInput>
  where?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
}

export type IBaseTypeFieldRefsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<IBaseTypeFieldRefsNodeAggregationWhereInput>>
  NOT?: InputMaybe<IBaseTypeFieldRefsNodeAggregationWhereInput>
  OR?: InputMaybe<Array<IBaseTypeFieldRefsNodeAggregationWhereInput>>
  defaultValues_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  defaultValues_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  description_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  description_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  key_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  key_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  validationRules_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type IBaseTypeFieldRefsRelationship = {
  cursor: Scalars['String']['output']
  node: Field
}

export type IBaseTypeFieldRefsUpdateConnectionInput = {
  node?: InputMaybe<FieldUpdateInput>
}

export type IBaseTypeFieldRefsUpdateFieldInput = {
  connect?: InputMaybe<Array<IBaseTypeFieldRefsConnectFieldInput>>
  connectOrCreate?: InputMaybe<
    Array<IBaseTypeFieldRefsConnectOrCreateFieldInput>
  >
  create?: InputMaybe<Array<IBaseTypeFieldRefsCreateFieldInput>>
  delete?: InputMaybe<Array<IBaseTypeFieldRefsDeleteFieldInput>>
  disconnect?: InputMaybe<Array<IBaseTypeFieldRefsDisconnectFieldInput>>
  update?: InputMaybe<IBaseTypeFieldRefsUpdateConnectionInput>
  where?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
}

export enum IBaseTypeImplementation {
  ActionType = 'ActionType',
  AppType = 'AppType',
  ArrayType = 'ArrayType',
  CodeMirrorType = 'CodeMirrorType',
  ElementType = 'ElementType',
  EnumType = 'EnumType',
  InterfaceType = 'InterfaceType',
  LambdaType = 'LambdaType',
  PageType = 'PageType',
  PrimitiveType = 'PrimitiveType',
  ReactNodeType = 'ReactNodeType',
  RenderPropType = 'RenderPropType',
  RichTextType = 'RichTextType',
  UnionType = 'UnionType',
}

export type IBaseTypeOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  /** Specify one or more IBaseTypeSort objects to sort IBaseTypes by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<IBaseTypeSort>>
}

export type IBaseTypeOwnerAggregateInput = {
  AND?: InputMaybe<Array<IBaseTypeOwnerAggregateInput>>
  NOT?: InputMaybe<IBaseTypeOwnerAggregateInput>
  OR?: InputMaybe<Array<IBaseTypeOwnerAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<IBaseTypeOwnerNodeAggregationWhereInput>
}

export type IBaseTypeOwnerConnectFieldInput = {
  connect?: InputMaybe<UserConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<UserConnectWhere>
}

export type IBaseTypeOwnerConnectOrCreateFieldInput = {
  onCreate: IBaseTypeOwnerConnectOrCreateFieldInputOnCreate
  where: UserConnectOrCreateWhere
}

export type IBaseTypeOwnerConnectOrCreateFieldInputOnCreate = {
  node: UserOnCreateInput
}

export type IBaseTypeOwnerConnection = {
  edges: Array<IBaseTypeOwnerRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type IBaseTypeOwnerConnectionSort = {
  node?: InputMaybe<UserSort>
}

export type IBaseTypeOwnerConnectionWhere = {
  AND?: InputMaybe<Array<IBaseTypeOwnerConnectionWhere>>
  NOT?: InputMaybe<IBaseTypeOwnerConnectionWhere>
  OR?: InputMaybe<Array<IBaseTypeOwnerConnectionWhere>>
  node?: InputMaybe<UserWhere>
}

export type IBaseTypeOwnerCreateFieldInput = {
  node: UserCreateInput
}

export type IBaseTypeOwnerDeleteFieldInput = {
  delete?: InputMaybe<UserDeleteInput>
  where?: InputMaybe<IBaseTypeOwnerConnectionWhere>
}

export type IBaseTypeOwnerDisconnectFieldInput = {
  disconnect?: InputMaybe<UserDisconnectInput>
  where?: InputMaybe<IBaseTypeOwnerConnectionWhere>
}

export type IBaseTypeOwnerNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<IBaseTypeOwnerNodeAggregationWhereInput>>
  NOT?: InputMaybe<IBaseTypeOwnerNodeAggregationWhereInput>
  OR?: InputMaybe<Array<IBaseTypeOwnerNodeAggregationWhereInput>>
  auth0Id_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  auth0Id_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  email_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  email_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  username_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  username_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type IBaseTypeOwnerRelationship = {
  cursor: Scalars['String']['output']
  node: User
}

export type IBaseTypeOwnerUpdateConnectionInput = {
  node?: InputMaybe<UserUpdateInput>
}

export type IBaseTypeOwnerUpdateFieldInput = {
  connect?: InputMaybe<IBaseTypeOwnerConnectFieldInput>
  connectOrCreate?: InputMaybe<IBaseTypeOwnerConnectOrCreateFieldInput>
  create?: InputMaybe<IBaseTypeOwnerCreateFieldInput>
  delete?: InputMaybe<IBaseTypeOwnerDeleteFieldInput>
  disconnect?: InputMaybe<IBaseTypeOwnerDisconnectFieldInput>
  update?: InputMaybe<IBaseTypeOwnerUpdateConnectionInput>
  where?: InputMaybe<IBaseTypeOwnerConnectionWhere>
}

/** Fields to sort IBaseTypes by. The order in which sorts are applied is not guaranteed when specifying many fields in one IBaseTypeSort object. */
export type IBaseTypeSort = {
  id?: InputMaybe<SortDirection>
  kind?: InputMaybe<SortDirection>
  name?: InputMaybe<SortDirection>
}

export type IBaseTypeUpdateInput = {
  fieldRefs?: InputMaybe<Array<IBaseTypeFieldRefsUpdateFieldInput>>
  /** @deprecated Please use the explicit _SET field */
  id?: InputMaybe<Scalars['ID']['input']>
  id_SET?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _SET field */
  kind?: InputMaybe<TypeKind>
  kind_SET?: InputMaybe<TypeKind>
  /** @deprecated Please use the explicit _SET field */
  name?: InputMaybe<Scalars['String']['input']>
  name_SET?: InputMaybe<Scalars['String']['input']>
  owner?: InputMaybe<IBaseTypeOwnerUpdateFieldInput>
}

export type IBaseTypeWhere = {
  AND?: InputMaybe<Array<IBaseTypeWhere>>
  NOT?: InputMaybe<IBaseTypeWhere>
  OR?: InputMaybe<Array<IBaseTypeWhere>>
  fieldRefsAggregate?: InputMaybe<IBaseTypeFieldRefsAggregateInput>
  /** Return IBaseTypes where all of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_ALL?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return IBaseTypes where none of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_NONE?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return IBaseTypes where one of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_SINGLE?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return IBaseTypes where some of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_SOME?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return IBaseTypes where all of the related Fields match this filter */
  fieldRefs_ALL?: InputMaybe<FieldWhere>
  /** Return IBaseTypes where none of the related Fields match this filter */
  fieldRefs_NONE?: InputMaybe<FieldWhere>
  /** Return IBaseTypes where one of the related Fields match this filter */
  fieldRefs_SINGLE?: InputMaybe<FieldWhere>
  /** Return IBaseTypes where some of the related Fields match this filter */
  fieldRefs_SOME?: InputMaybe<FieldWhere>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  kind?: InputMaybe<TypeKind>
  kind_EQ?: InputMaybe<TypeKind>
  kind_IN?: InputMaybe<Array<TypeKind>>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>
  name_MATCHES?: InputMaybe<Scalars['String']['input']>
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  owner?: InputMaybe<UserWhere>
  ownerAggregate?: InputMaybe<IBaseTypeOwnerAggregateInput>
  ownerConnection?: InputMaybe<IBaseTypeOwnerConnectionWhere>
  typename_IN?: InputMaybe<Array<IBaseTypeImplementation>>
}

export type IBaseTypesConnection = {
  edges: Array<IBaseTypeEdge>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type IdAggregateSelection = {
  longest?: Maybe<Scalars['ID']['output']>
  shortest?: Maybe<Scalars['ID']['output']>
}

/** Represents an object type with multiple fields */
export type InterfaceType = IBaseType &
  WithDescendants & {
    apiOfAtoms: Array<Atom>
    apiOfAtomsAggregate?: Maybe<InterfaceTypeAtomApiOfAtomsAggregationSelection>
    apiOfAtomsConnection: InterfaceTypeApiOfAtomsConnection
    descendantTypesIds: Array<Scalars['ID']['output']>
    fieldRefs: Array<Field>
    fieldRefsAggregate?: Maybe<InterfaceTypeFieldFieldRefsAggregationSelection>
    fieldRefsConnection: IBaseTypeFieldRefsConnection
    fields: Array<Field>
    fieldsAggregate?: Maybe<InterfaceTypeFieldFieldsAggregationSelection>
    fieldsConnection: InterfaceTypeFieldsConnection
    id: Scalars['ID']['output']
    kind: TypeKind
    name: Scalars['String']['output']
    owner: User
    ownerAggregate?: Maybe<InterfaceTypeUserOwnerAggregationSelection>
    ownerConnection: IBaseTypeOwnerConnection
  }

/** Represents an object type with multiple fields */
export type InterfaceTypeApiOfAtomsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<AtomOptions>
  sort?: InputMaybe<Array<AtomSort>>
  where?: InputMaybe<AtomWhere>
}

/** Represents an object type with multiple fields */
export type InterfaceTypeApiOfAtomsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<AtomWhere>
}

/** Represents an object type with multiple fields */
export type InterfaceTypeApiOfAtomsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<InterfaceTypeApiOfAtomsConnectionSort>>
  where?: InputMaybe<InterfaceTypeApiOfAtomsConnectionWhere>
}

/** Represents an object type with multiple fields */
export type InterfaceTypeFieldRefsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<FieldOptions>
  sort?: InputMaybe<Array<FieldSort>>
  where?: InputMaybe<FieldWhere>
}

/** Represents an object type with multiple fields */
export type InterfaceTypeFieldRefsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<FieldWhere>
}

/** Represents an object type with multiple fields */
export type InterfaceTypeFieldRefsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<IBaseTypeFieldRefsConnectionSort>>
  where?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
}

/** Represents an object type with multiple fields */
export type InterfaceTypeFieldsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<FieldOptions>
  sort?: InputMaybe<Array<FieldSort>>
  where?: InputMaybe<FieldWhere>
}

/** Represents an object type with multiple fields */
export type InterfaceTypeFieldsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<FieldWhere>
}

/** Represents an object type with multiple fields */
export type InterfaceTypeFieldsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<InterfaceTypeFieldsConnectionSort>>
  where?: InputMaybe<InterfaceTypeFieldsConnectionWhere>
}

/** Represents an object type with multiple fields */
export type InterfaceTypeOwnerArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<UserOptions>
  sort?: InputMaybe<Array<UserSort>>
  where?: InputMaybe<UserWhere>
}

/** Represents an object type with multiple fields */
export type InterfaceTypeOwnerAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<UserWhere>
}

/** Represents an object type with multiple fields */
export type InterfaceTypeOwnerConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<IBaseTypeOwnerConnectionSort>>
  where?: InputMaybe<IBaseTypeOwnerConnectionWhere>
}

export type InterfaceTypeAggregateSelection = {
  count: Scalars['Int']['output']
  id: IdAggregateSelection
  name: StringAggregateSelection
}

export type InterfaceTypeApiOfAtomsAggregateInput = {
  AND?: InputMaybe<Array<InterfaceTypeApiOfAtomsAggregateInput>>
  NOT?: InputMaybe<InterfaceTypeApiOfAtomsAggregateInput>
  OR?: InputMaybe<Array<InterfaceTypeApiOfAtomsAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<InterfaceTypeApiOfAtomsNodeAggregationWhereInput>
}

export type InterfaceTypeApiOfAtomsConnectFieldInput = {
  connect?: InputMaybe<Array<AtomConnectInput>>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<AtomConnectWhere>
}

export type InterfaceTypeApiOfAtomsConnectOrCreateFieldInput = {
  onCreate: InterfaceTypeApiOfAtomsConnectOrCreateFieldInputOnCreate
  where: AtomConnectOrCreateWhere
}

export type InterfaceTypeApiOfAtomsConnectOrCreateFieldInputOnCreate = {
  node: AtomOnCreateInput
}

export type InterfaceTypeApiOfAtomsConnection = {
  edges: Array<InterfaceTypeApiOfAtomsRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type InterfaceTypeApiOfAtomsConnectionSort = {
  node?: InputMaybe<AtomSort>
}

export type InterfaceTypeApiOfAtomsConnectionWhere = {
  AND?: InputMaybe<Array<InterfaceTypeApiOfAtomsConnectionWhere>>
  NOT?: InputMaybe<InterfaceTypeApiOfAtomsConnectionWhere>
  OR?: InputMaybe<Array<InterfaceTypeApiOfAtomsConnectionWhere>>
  node?: InputMaybe<AtomWhere>
}

export type InterfaceTypeApiOfAtomsCreateFieldInput = {
  node: AtomCreateInput
}

export type InterfaceTypeApiOfAtomsDeleteFieldInput = {
  delete?: InputMaybe<AtomDeleteInput>
  where?: InputMaybe<InterfaceTypeApiOfAtomsConnectionWhere>
}

export type InterfaceTypeApiOfAtomsDisconnectFieldInput = {
  disconnect?: InputMaybe<AtomDisconnectInput>
  where?: InputMaybe<InterfaceTypeApiOfAtomsConnectionWhere>
}

export type InterfaceTypeApiOfAtomsFieldInput = {
  connect?: InputMaybe<Array<InterfaceTypeApiOfAtomsConnectFieldInput>>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<
    Array<InterfaceTypeApiOfAtomsConnectOrCreateFieldInput>
  >
  create?: InputMaybe<Array<InterfaceTypeApiOfAtomsCreateFieldInput>>
}

export type InterfaceTypeApiOfAtomsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<InterfaceTypeApiOfAtomsNodeAggregationWhereInput>>
  NOT?: InputMaybe<InterfaceTypeApiOfAtomsNodeAggregationWhereInput>
  OR?: InputMaybe<Array<InterfaceTypeApiOfAtomsNodeAggregationWhereInput>>
  externalCssSource_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  externalCssSource_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  externalCssSource_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  externalCssSource_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  externalCssSource_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  externalCssSource_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  externalCssSource_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  externalCssSource_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  externalCssSource_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  externalCssSource_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  externalCssSource_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  externalCssSource_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  externalCssSource_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  externalCssSource_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  externalCssSource_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  externalJsSource_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  externalJsSource_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  externalJsSource_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  externalJsSource_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  externalJsSource_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  externalJsSource_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  externalJsSource_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  externalJsSource_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  externalJsSource_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  externalJsSource_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  externalJsSource_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  externalJsSource_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  externalJsSource_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  externalJsSource_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  externalJsSource_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  externalSourceType_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  externalSourceType_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  externalSourceType_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  externalSourceType_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  externalSourceType_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  externalSourceType_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  externalSourceType_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  externalSourceType_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  externalSourceType_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  externalSourceType_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  externalSourceType_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  externalSourceType_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  externalSourceType_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  externalSourceType_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  externalSourceType_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  icon_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  icon_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  icon_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  icon_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  icon_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  icon_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  icon_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  icon_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  icon_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  icon_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  icon_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  icon_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  icon_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  icon_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  icon_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type InterfaceTypeApiOfAtomsRelationship = {
  cursor: Scalars['String']['output']
  node: Atom
}

export type InterfaceTypeApiOfAtomsUpdateConnectionInput = {
  node?: InputMaybe<AtomUpdateInput>
}

export type InterfaceTypeApiOfAtomsUpdateFieldInput = {
  connect?: InputMaybe<Array<InterfaceTypeApiOfAtomsConnectFieldInput>>
  connectOrCreate?: InputMaybe<
    Array<InterfaceTypeApiOfAtomsConnectOrCreateFieldInput>
  >
  create?: InputMaybe<Array<InterfaceTypeApiOfAtomsCreateFieldInput>>
  delete?: InputMaybe<Array<InterfaceTypeApiOfAtomsDeleteFieldInput>>
  disconnect?: InputMaybe<Array<InterfaceTypeApiOfAtomsDisconnectFieldInput>>
  update?: InputMaybe<InterfaceTypeApiOfAtomsUpdateConnectionInput>
  where?: InputMaybe<InterfaceTypeApiOfAtomsConnectionWhere>
}

export type InterfaceTypeAtomApiOfAtomsAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<InterfaceTypeAtomApiOfAtomsNodeAggregateSelection>
}

export type InterfaceTypeAtomApiOfAtomsNodeAggregateSelection = {
  externalCssSource: StringAggregateSelection
  externalJsSource: StringAggregateSelection
  externalSourceType: StringAggregateSelection
  icon: StringAggregateSelection
  id: IdAggregateSelection
  name: StringAggregateSelection
}

export type InterfaceTypeConnectInput = {
  apiOfAtoms?: InputMaybe<Array<InterfaceTypeApiOfAtomsConnectFieldInput>>
  fieldRefs?: InputMaybe<Array<InterfaceTypeFieldRefsConnectFieldInput>>
  fields?: InputMaybe<Array<InterfaceTypeFieldsConnectFieldInput>>
  owner?: InputMaybe<InterfaceTypeOwnerConnectFieldInput>
}

export type InterfaceTypeConnectWhere = {
  node: InterfaceTypeWhere
}

export type InterfaceTypeCreateInput = {
  apiOfAtoms?: InputMaybe<InterfaceTypeApiOfAtomsFieldInput>
  fieldRefs?: InputMaybe<InterfaceTypeFieldRefsFieldInput>
  fields?: InputMaybe<InterfaceTypeFieldsFieldInput>
  id: Scalars['ID']['input']
  kind?: TypeKind
  name: Scalars['String']['input']
  owner?: InputMaybe<InterfaceTypeOwnerFieldInput>
}

export type InterfaceTypeCreatedEvent = {
  createdInterfaceType: InterfaceTypeEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type InterfaceTypeDeleteInput = {
  apiOfAtoms?: InputMaybe<Array<InterfaceTypeApiOfAtomsDeleteFieldInput>>
  fieldRefs?: InputMaybe<Array<IBaseTypeFieldRefsDeleteFieldInput>>
  fields?: InputMaybe<Array<InterfaceTypeFieldsDeleteFieldInput>>
  owner?: InputMaybe<IBaseTypeOwnerDeleteFieldInput>
}

export type InterfaceTypeDeletedEvent = {
  deletedInterfaceType: InterfaceTypeEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type InterfaceTypeDisconnectInput = {
  apiOfAtoms?: InputMaybe<Array<InterfaceTypeApiOfAtomsDisconnectFieldInput>>
  fieldRefs?: InputMaybe<Array<IBaseTypeFieldRefsDisconnectFieldInput>>
  fields?: InputMaybe<Array<InterfaceTypeFieldsDisconnectFieldInput>>
  owner?: InputMaybe<IBaseTypeOwnerDisconnectFieldInput>
}

export type InterfaceTypeEdge = {
  cursor: Scalars['String']['output']
  node: InterfaceType
}

export type InterfaceTypeEventPayload = {
  id: Scalars['ID']['output']
  kind: TypeKind
  name: Scalars['String']['output']
}

export type InterfaceTypeFieldFieldRefsAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<InterfaceTypeFieldFieldRefsNodeAggregateSelection>
}

export type InterfaceTypeFieldFieldRefsNodeAggregateSelection = {
  defaultValues: StringAggregateSelection
  description: StringAggregateSelection
  id: IdAggregateSelection
  key: StringAggregateSelection
  name: StringAggregateSelection
  validationRules: StringAggregateSelection
}

export type InterfaceTypeFieldFieldsAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<InterfaceTypeFieldFieldsNodeAggregateSelection>
}

export type InterfaceTypeFieldFieldsNodeAggregateSelection = {
  defaultValues: StringAggregateSelection
  description: StringAggregateSelection
  id: IdAggregateSelection
  key: StringAggregateSelection
  name: StringAggregateSelection
  validationRules: StringAggregateSelection
}

export type InterfaceTypeFieldRefsAggregateInput = {
  AND?: InputMaybe<Array<InterfaceTypeFieldRefsAggregateInput>>
  NOT?: InputMaybe<InterfaceTypeFieldRefsAggregateInput>
  OR?: InputMaybe<Array<InterfaceTypeFieldRefsAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<InterfaceTypeFieldRefsNodeAggregationWhereInput>
}

export type InterfaceTypeFieldRefsConnectFieldInput = {
  connect?: InputMaybe<Array<FieldConnectInput>>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<FieldConnectWhere>
}

export type InterfaceTypeFieldRefsConnectOrCreateFieldInput = {
  onCreate: InterfaceTypeFieldRefsConnectOrCreateFieldInputOnCreate
  where: FieldConnectOrCreateWhere
}

export type InterfaceTypeFieldRefsConnectOrCreateFieldInputOnCreate = {
  node: FieldOnCreateInput
}

export type InterfaceTypeFieldRefsCreateFieldInput = {
  node: FieldCreateInput
}

export type InterfaceTypeFieldRefsFieldInput = {
  connect?: InputMaybe<Array<InterfaceTypeFieldRefsConnectFieldInput>>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<
    Array<InterfaceTypeFieldRefsConnectOrCreateFieldInput>
  >
  create?: InputMaybe<Array<InterfaceTypeFieldRefsCreateFieldInput>>
}

export type InterfaceTypeFieldRefsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<InterfaceTypeFieldRefsNodeAggregationWhereInput>>
  NOT?: InputMaybe<InterfaceTypeFieldRefsNodeAggregationWhereInput>
  OR?: InputMaybe<Array<InterfaceTypeFieldRefsNodeAggregationWhereInput>>
  defaultValues_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  defaultValues_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  description_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  description_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  key_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  key_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  validationRules_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type InterfaceTypeFieldRefsUpdateConnectionInput = {
  node?: InputMaybe<FieldUpdateInput>
}

export type InterfaceTypeFieldRefsUpdateFieldInput = {
  connect?: InputMaybe<Array<InterfaceTypeFieldRefsConnectFieldInput>>
  connectOrCreate?: InputMaybe<
    Array<InterfaceTypeFieldRefsConnectOrCreateFieldInput>
  >
  create?: InputMaybe<Array<InterfaceTypeFieldRefsCreateFieldInput>>
  delete?: InputMaybe<Array<IBaseTypeFieldRefsDeleteFieldInput>>
  disconnect?: InputMaybe<Array<IBaseTypeFieldRefsDisconnectFieldInput>>
  update?: InputMaybe<InterfaceTypeFieldRefsUpdateConnectionInput>
  where?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
}

export type InterfaceTypeFieldsAggregateInput = {
  AND?: InputMaybe<Array<InterfaceTypeFieldsAggregateInput>>
  NOT?: InputMaybe<InterfaceTypeFieldsAggregateInput>
  OR?: InputMaybe<Array<InterfaceTypeFieldsAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<InterfaceTypeFieldsNodeAggregationWhereInput>
}

export type InterfaceTypeFieldsConnectFieldInput = {
  connect?: InputMaybe<Array<FieldConnectInput>>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<FieldConnectWhere>
}

export type InterfaceTypeFieldsConnectOrCreateFieldInput = {
  onCreate: InterfaceTypeFieldsConnectOrCreateFieldInputOnCreate
  where: FieldConnectOrCreateWhere
}

export type InterfaceTypeFieldsConnectOrCreateFieldInputOnCreate = {
  node: FieldOnCreateInput
}

export type InterfaceTypeFieldsConnection = {
  edges: Array<InterfaceTypeFieldsRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type InterfaceTypeFieldsConnectionSort = {
  node?: InputMaybe<FieldSort>
}

export type InterfaceTypeFieldsConnectionWhere = {
  AND?: InputMaybe<Array<InterfaceTypeFieldsConnectionWhere>>
  NOT?: InputMaybe<InterfaceTypeFieldsConnectionWhere>
  OR?: InputMaybe<Array<InterfaceTypeFieldsConnectionWhere>>
  node?: InputMaybe<FieldWhere>
}

export type InterfaceTypeFieldsCreateFieldInput = {
  node: FieldCreateInput
}

export type InterfaceTypeFieldsDeleteFieldInput = {
  delete?: InputMaybe<FieldDeleteInput>
  where?: InputMaybe<InterfaceTypeFieldsConnectionWhere>
}

export type InterfaceTypeFieldsDisconnectFieldInput = {
  disconnect?: InputMaybe<FieldDisconnectInput>
  where?: InputMaybe<InterfaceTypeFieldsConnectionWhere>
}

export type InterfaceTypeFieldsFieldInput = {
  connect?: InputMaybe<Array<InterfaceTypeFieldsConnectFieldInput>>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<
    Array<InterfaceTypeFieldsConnectOrCreateFieldInput>
  >
  create?: InputMaybe<Array<InterfaceTypeFieldsCreateFieldInput>>
}

export type InterfaceTypeFieldsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<InterfaceTypeFieldsNodeAggregationWhereInput>>
  NOT?: InputMaybe<InterfaceTypeFieldsNodeAggregationWhereInput>
  OR?: InputMaybe<Array<InterfaceTypeFieldsNodeAggregationWhereInput>>
  defaultValues_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  defaultValues_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  description_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  description_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  key_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  key_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  validationRules_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type InterfaceTypeFieldsRelationship = {
  cursor: Scalars['String']['output']
  node: Field
}

export type InterfaceTypeFieldsUpdateConnectionInput = {
  node?: InputMaybe<FieldUpdateInput>
}

export type InterfaceTypeFieldsUpdateFieldInput = {
  connect?: InputMaybe<Array<InterfaceTypeFieldsConnectFieldInput>>
  connectOrCreate?: InputMaybe<
    Array<InterfaceTypeFieldsConnectOrCreateFieldInput>
  >
  create?: InputMaybe<Array<InterfaceTypeFieldsCreateFieldInput>>
  delete?: InputMaybe<Array<InterfaceTypeFieldsDeleteFieldInput>>
  disconnect?: InputMaybe<Array<InterfaceTypeFieldsDisconnectFieldInput>>
  update?: InputMaybe<InterfaceTypeFieldsUpdateConnectionInput>
  where?: InputMaybe<InterfaceTypeFieldsConnectionWhere>
}

export type InterfaceTypeOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  /** Specify one or more InterfaceTypeSort objects to sort InterfaceTypes by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<InterfaceTypeSort>>
}

export type InterfaceTypeOwnerAggregateInput = {
  AND?: InputMaybe<Array<InterfaceTypeOwnerAggregateInput>>
  NOT?: InputMaybe<InterfaceTypeOwnerAggregateInput>
  OR?: InputMaybe<Array<InterfaceTypeOwnerAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<InterfaceTypeOwnerNodeAggregationWhereInput>
}

export type InterfaceTypeOwnerConnectFieldInput = {
  connect?: InputMaybe<UserConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<UserConnectWhere>
}

export type InterfaceTypeOwnerConnectOrCreateFieldInput = {
  onCreate: InterfaceTypeOwnerConnectOrCreateFieldInputOnCreate
  where: UserConnectOrCreateWhere
}

export type InterfaceTypeOwnerConnectOrCreateFieldInputOnCreate = {
  node: UserOnCreateInput
}

export type InterfaceTypeOwnerCreateFieldInput = {
  node: UserCreateInput
}

export type InterfaceTypeOwnerFieldInput = {
  connect?: InputMaybe<InterfaceTypeOwnerConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<InterfaceTypeOwnerConnectOrCreateFieldInput>
  create?: InputMaybe<InterfaceTypeOwnerCreateFieldInput>
}

export type InterfaceTypeOwnerNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<InterfaceTypeOwnerNodeAggregationWhereInput>>
  NOT?: InputMaybe<InterfaceTypeOwnerNodeAggregationWhereInput>
  OR?: InputMaybe<Array<InterfaceTypeOwnerNodeAggregationWhereInput>>
  auth0Id_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  auth0Id_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  email_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  email_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  username_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  username_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type InterfaceTypeOwnerUpdateConnectionInput = {
  node?: InputMaybe<UserUpdateInput>
}

export type InterfaceTypeOwnerUpdateFieldInput = {
  connect?: InputMaybe<InterfaceTypeOwnerConnectFieldInput>
  connectOrCreate?: InputMaybe<InterfaceTypeOwnerConnectOrCreateFieldInput>
  create?: InputMaybe<InterfaceTypeOwnerCreateFieldInput>
  delete?: InputMaybe<IBaseTypeOwnerDeleteFieldInput>
  disconnect?: InputMaybe<IBaseTypeOwnerDisconnectFieldInput>
  update?: InputMaybe<InterfaceTypeOwnerUpdateConnectionInput>
  where?: InputMaybe<IBaseTypeOwnerConnectionWhere>
}

/** Fields to sort InterfaceTypes by. The order in which sorts are applied is not guaranteed when specifying many fields in one InterfaceTypeSort object. */
export type InterfaceTypeSort = {
  id?: InputMaybe<SortDirection>
  kind?: InputMaybe<SortDirection>
  name?: InputMaybe<SortDirection>
}

export type InterfaceTypeSubscriptionWhere = {
  AND?: InputMaybe<Array<InterfaceTypeSubscriptionWhere>>
  NOT?: InputMaybe<InterfaceTypeSubscriptionWhere>
  OR?: InputMaybe<Array<InterfaceTypeSubscriptionWhere>>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  kind?: InputMaybe<TypeKind>
  kind_EQ?: InputMaybe<TypeKind>
  kind_IN?: InputMaybe<Array<TypeKind>>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>
  name_MATCHES?: InputMaybe<Scalars['String']['input']>
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
}

export type InterfaceTypeUpdateInput = {
  apiOfAtoms?: InputMaybe<Array<InterfaceTypeApiOfAtomsUpdateFieldInput>>
  fieldRefs?: InputMaybe<Array<InterfaceTypeFieldRefsUpdateFieldInput>>
  fields?: InputMaybe<Array<InterfaceTypeFieldsUpdateFieldInput>>
  /** @deprecated Please use the explicit _SET field */
  id?: InputMaybe<Scalars['ID']['input']>
  id_SET?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _SET field */
  kind?: InputMaybe<TypeKind>
  kind_SET?: InputMaybe<TypeKind>
  /** @deprecated Please use the explicit _SET field */
  name?: InputMaybe<Scalars['String']['input']>
  name_SET?: InputMaybe<Scalars['String']['input']>
  owner?: InputMaybe<InterfaceTypeOwnerUpdateFieldInput>
}

export type InterfaceTypeUpdatedEvent = {
  event: EventType
  previousState: InterfaceTypeEventPayload
  timestamp: Scalars['Float']['output']
  updatedInterfaceType: InterfaceTypeEventPayload
}

export type InterfaceTypeUserOwnerAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<InterfaceTypeUserOwnerNodeAggregateSelection>
}

export type InterfaceTypeUserOwnerNodeAggregateSelection = {
  auth0Id: StringAggregateSelection
  email: StringAggregateSelection
  id: IdAggregateSelection
  username: StringAggregateSelection
}

export type InterfaceTypeWhere = {
  AND?: InputMaybe<Array<InterfaceTypeWhere>>
  NOT?: InputMaybe<InterfaceTypeWhere>
  OR?: InputMaybe<Array<InterfaceTypeWhere>>
  apiOfAtomsAggregate?: InputMaybe<InterfaceTypeApiOfAtomsAggregateInput>
  /** Return InterfaceTypes where all of the related InterfaceTypeApiOfAtomsConnections match this filter */
  apiOfAtomsConnection_ALL?: InputMaybe<InterfaceTypeApiOfAtomsConnectionWhere>
  /** Return InterfaceTypes where none of the related InterfaceTypeApiOfAtomsConnections match this filter */
  apiOfAtomsConnection_NONE?: InputMaybe<InterfaceTypeApiOfAtomsConnectionWhere>
  /** Return InterfaceTypes where one of the related InterfaceTypeApiOfAtomsConnections match this filter */
  apiOfAtomsConnection_SINGLE?: InputMaybe<InterfaceTypeApiOfAtomsConnectionWhere>
  /** Return InterfaceTypes where some of the related InterfaceTypeApiOfAtomsConnections match this filter */
  apiOfAtomsConnection_SOME?: InputMaybe<InterfaceTypeApiOfAtomsConnectionWhere>
  /** Return InterfaceTypes where all of the related Atoms match this filter */
  apiOfAtoms_ALL?: InputMaybe<AtomWhere>
  /** Return InterfaceTypes where none of the related Atoms match this filter */
  apiOfAtoms_NONE?: InputMaybe<AtomWhere>
  /** Return InterfaceTypes where one of the related Atoms match this filter */
  apiOfAtoms_SINGLE?: InputMaybe<AtomWhere>
  /** Return InterfaceTypes where some of the related Atoms match this filter */
  apiOfAtoms_SOME?: InputMaybe<AtomWhere>
  fieldRefsAggregate?: InputMaybe<InterfaceTypeFieldRefsAggregateInput>
  /** Return InterfaceTypes where all of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_ALL?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return InterfaceTypes where none of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_NONE?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return InterfaceTypes where one of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_SINGLE?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return InterfaceTypes where some of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_SOME?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return InterfaceTypes where all of the related Fields match this filter */
  fieldRefs_ALL?: InputMaybe<FieldWhere>
  /** Return InterfaceTypes where none of the related Fields match this filter */
  fieldRefs_NONE?: InputMaybe<FieldWhere>
  /** Return InterfaceTypes where one of the related Fields match this filter */
  fieldRefs_SINGLE?: InputMaybe<FieldWhere>
  /** Return InterfaceTypes where some of the related Fields match this filter */
  fieldRefs_SOME?: InputMaybe<FieldWhere>
  fieldsAggregate?: InputMaybe<InterfaceTypeFieldsAggregateInput>
  /** Return InterfaceTypes where all of the related InterfaceTypeFieldsConnections match this filter */
  fieldsConnection_ALL?: InputMaybe<InterfaceTypeFieldsConnectionWhere>
  /** Return InterfaceTypes where none of the related InterfaceTypeFieldsConnections match this filter */
  fieldsConnection_NONE?: InputMaybe<InterfaceTypeFieldsConnectionWhere>
  /** Return InterfaceTypes where one of the related InterfaceTypeFieldsConnections match this filter */
  fieldsConnection_SINGLE?: InputMaybe<InterfaceTypeFieldsConnectionWhere>
  /** Return InterfaceTypes where some of the related InterfaceTypeFieldsConnections match this filter */
  fieldsConnection_SOME?: InputMaybe<InterfaceTypeFieldsConnectionWhere>
  /** Return InterfaceTypes where all of the related Fields match this filter */
  fields_ALL?: InputMaybe<FieldWhere>
  /** Return InterfaceTypes where none of the related Fields match this filter */
  fields_NONE?: InputMaybe<FieldWhere>
  /** Return InterfaceTypes where one of the related Fields match this filter */
  fields_SINGLE?: InputMaybe<FieldWhere>
  /** Return InterfaceTypes where some of the related Fields match this filter */
  fields_SOME?: InputMaybe<FieldWhere>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  kind?: InputMaybe<TypeKind>
  kind_EQ?: InputMaybe<TypeKind>
  kind_IN?: InputMaybe<Array<TypeKind>>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>
  name_MATCHES?: InputMaybe<Scalars['String']['input']>
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  owner?: InputMaybe<UserWhere>
  ownerAggregate?: InputMaybe<InterfaceTypeOwnerAggregateInput>
  ownerConnection?: InputMaybe<IBaseTypeOwnerConnectionWhere>
}

export type InterfaceTypesConnection = {
  edges: Array<InterfaceTypeEdge>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

/** Allows picking a lambda */
export type LambdaType = IBaseType & {
  fieldRefs: Array<Field>
  fieldRefsAggregate?: Maybe<LambdaTypeFieldFieldRefsAggregationSelection>
  fieldRefsConnection: IBaseTypeFieldRefsConnection
  id: Scalars['ID']['output']
  kind: TypeKind
  name: Scalars['String']['output']
  owner: User
  ownerAggregate?: Maybe<LambdaTypeUserOwnerAggregationSelection>
  ownerConnection: IBaseTypeOwnerConnection
}

/** Allows picking a lambda */
export type LambdaTypeFieldRefsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<FieldOptions>
  sort?: InputMaybe<Array<FieldSort>>
  where?: InputMaybe<FieldWhere>
}

/** Allows picking a lambda */
export type LambdaTypeFieldRefsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<FieldWhere>
}

/** Allows picking a lambda */
export type LambdaTypeFieldRefsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<IBaseTypeFieldRefsConnectionSort>>
  where?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
}

/** Allows picking a lambda */
export type LambdaTypeOwnerArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<UserOptions>
  sort?: InputMaybe<Array<UserSort>>
  where?: InputMaybe<UserWhere>
}

/** Allows picking a lambda */
export type LambdaTypeOwnerAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<UserWhere>
}

/** Allows picking a lambda */
export type LambdaTypeOwnerConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<IBaseTypeOwnerConnectionSort>>
  where?: InputMaybe<IBaseTypeOwnerConnectionWhere>
}

export type LambdaTypeAggregateSelection = {
  count: Scalars['Int']['output']
  id: IdAggregateSelection
  name: StringAggregateSelection
}

export type LambdaTypeConnectInput = {
  fieldRefs?: InputMaybe<Array<LambdaTypeFieldRefsConnectFieldInput>>
  owner?: InputMaybe<LambdaTypeOwnerConnectFieldInput>
}

export type LambdaTypeConnectWhere = {
  node: LambdaTypeWhere
}

export type LambdaTypeCreateInput = {
  fieldRefs?: InputMaybe<LambdaTypeFieldRefsFieldInput>
  id: Scalars['ID']['input']
  kind?: TypeKind
  name: Scalars['String']['input']
  owner?: InputMaybe<LambdaTypeOwnerFieldInput>
}

export type LambdaTypeCreatedEvent = {
  createdLambdaType: LambdaTypeEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type LambdaTypeDeleteInput = {
  fieldRefs?: InputMaybe<Array<IBaseTypeFieldRefsDeleteFieldInput>>
  owner?: InputMaybe<IBaseTypeOwnerDeleteFieldInput>
}

export type LambdaTypeDeletedEvent = {
  deletedLambdaType: LambdaTypeEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type LambdaTypeDisconnectInput = {
  fieldRefs?: InputMaybe<Array<IBaseTypeFieldRefsDisconnectFieldInput>>
  owner?: InputMaybe<IBaseTypeOwnerDisconnectFieldInput>
}

export type LambdaTypeEdge = {
  cursor: Scalars['String']['output']
  node: LambdaType
}

export type LambdaTypeEventPayload = {
  id: Scalars['ID']['output']
  kind: TypeKind
  name: Scalars['String']['output']
}

export type LambdaTypeFieldFieldRefsAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<LambdaTypeFieldFieldRefsNodeAggregateSelection>
}

export type LambdaTypeFieldFieldRefsNodeAggregateSelection = {
  defaultValues: StringAggregateSelection
  description: StringAggregateSelection
  id: IdAggregateSelection
  key: StringAggregateSelection
  name: StringAggregateSelection
  validationRules: StringAggregateSelection
}

export type LambdaTypeFieldRefsAggregateInput = {
  AND?: InputMaybe<Array<LambdaTypeFieldRefsAggregateInput>>
  NOT?: InputMaybe<LambdaTypeFieldRefsAggregateInput>
  OR?: InputMaybe<Array<LambdaTypeFieldRefsAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<LambdaTypeFieldRefsNodeAggregationWhereInput>
}

export type LambdaTypeFieldRefsConnectFieldInput = {
  connect?: InputMaybe<Array<FieldConnectInput>>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<FieldConnectWhere>
}

export type LambdaTypeFieldRefsConnectOrCreateFieldInput = {
  onCreate: LambdaTypeFieldRefsConnectOrCreateFieldInputOnCreate
  where: FieldConnectOrCreateWhere
}

export type LambdaTypeFieldRefsConnectOrCreateFieldInputOnCreate = {
  node: FieldOnCreateInput
}

export type LambdaTypeFieldRefsCreateFieldInput = {
  node: FieldCreateInput
}

export type LambdaTypeFieldRefsFieldInput = {
  connect?: InputMaybe<Array<LambdaTypeFieldRefsConnectFieldInput>>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<
    Array<LambdaTypeFieldRefsConnectOrCreateFieldInput>
  >
  create?: InputMaybe<Array<LambdaTypeFieldRefsCreateFieldInput>>
}

export type LambdaTypeFieldRefsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<LambdaTypeFieldRefsNodeAggregationWhereInput>>
  NOT?: InputMaybe<LambdaTypeFieldRefsNodeAggregationWhereInput>
  OR?: InputMaybe<Array<LambdaTypeFieldRefsNodeAggregationWhereInput>>
  defaultValues_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  defaultValues_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  description_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  description_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  key_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  key_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  validationRules_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type LambdaTypeFieldRefsUpdateConnectionInput = {
  node?: InputMaybe<FieldUpdateInput>
}

export type LambdaTypeFieldRefsUpdateFieldInput = {
  connect?: InputMaybe<Array<LambdaTypeFieldRefsConnectFieldInput>>
  connectOrCreate?: InputMaybe<
    Array<LambdaTypeFieldRefsConnectOrCreateFieldInput>
  >
  create?: InputMaybe<Array<LambdaTypeFieldRefsCreateFieldInput>>
  delete?: InputMaybe<Array<IBaseTypeFieldRefsDeleteFieldInput>>
  disconnect?: InputMaybe<Array<IBaseTypeFieldRefsDisconnectFieldInput>>
  update?: InputMaybe<LambdaTypeFieldRefsUpdateConnectionInput>
  where?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
}

export type LambdaTypeOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  /** Specify one or more LambdaTypeSort objects to sort LambdaTypes by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<LambdaTypeSort>>
}

export type LambdaTypeOwnerAggregateInput = {
  AND?: InputMaybe<Array<LambdaTypeOwnerAggregateInput>>
  NOT?: InputMaybe<LambdaTypeOwnerAggregateInput>
  OR?: InputMaybe<Array<LambdaTypeOwnerAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<LambdaTypeOwnerNodeAggregationWhereInput>
}

export type LambdaTypeOwnerConnectFieldInput = {
  connect?: InputMaybe<UserConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<UserConnectWhere>
}

export type LambdaTypeOwnerConnectOrCreateFieldInput = {
  onCreate: LambdaTypeOwnerConnectOrCreateFieldInputOnCreate
  where: UserConnectOrCreateWhere
}

export type LambdaTypeOwnerConnectOrCreateFieldInputOnCreate = {
  node: UserOnCreateInput
}

export type LambdaTypeOwnerCreateFieldInput = {
  node: UserCreateInput
}

export type LambdaTypeOwnerFieldInput = {
  connect?: InputMaybe<LambdaTypeOwnerConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<LambdaTypeOwnerConnectOrCreateFieldInput>
  create?: InputMaybe<LambdaTypeOwnerCreateFieldInput>
}

export type LambdaTypeOwnerNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<LambdaTypeOwnerNodeAggregationWhereInput>>
  NOT?: InputMaybe<LambdaTypeOwnerNodeAggregationWhereInput>
  OR?: InputMaybe<Array<LambdaTypeOwnerNodeAggregationWhereInput>>
  auth0Id_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  auth0Id_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  email_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  email_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  username_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  username_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type LambdaTypeOwnerUpdateConnectionInput = {
  node?: InputMaybe<UserUpdateInput>
}

export type LambdaTypeOwnerUpdateFieldInput = {
  connect?: InputMaybe<LambdaTypeOwnerConnectFieldInput>
  connectOrCreate?: InputMaybe<LambdaTypeOwnerConnectOrCreateFieldInput>
  create?: InputMaybe<LambdaTypeOwnerCreateFieldInput>
  delete?: InputMaybe<IBaseTypeOwnerDeleteFieldInput>
  disconnect?: InputMaybe<IBaseTypeOwnerDisconnectFieldInput>
  update?: InputMaybe<LambdaTypeOwnerUpdateConnectionInput>
  where?: InputMaybe<IBaseTypeOwnerConnectionWhere>
}

/** Fields to sort LambdaTypes by. The order in which sorts are applied is not guaranteed when specifying many fields in one LambdaTypeSort object. */
export type LambdaTypeSort = {
  id?: InputMaybe<SortDirection>
  kind?: InputMaybe<SortDirection>
  name?: InputMaybe<SortDirection>
}

export type LambdaTypeSubscriptionWhere = {
  AND?: InputMaybe<Array<LambdaTypeSubscriptionWhere>>
  NOT?: InputMaybe<LambdaTypeSubscriptionWhere>
  OR?: InputMaybe<Array<LambdaTypeSubscriptionWhere>>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  kind?: InputMaybe<TypeKind>
  kind_EQ?: InputMaybe<TypeKind>
  kind_IN?: InputMaybe<Array<TypeKind>>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>
  name_MATCHES?: InputMaybe<Scalars['String']['input']>
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
}

export type LambdaTypeUpdateInput = {
  fieldRefs?: InputMaybe<Array<LambdaTypeFieldRefsUpdateFieldInput>>
  /** @deprecated Please use the explicit _SET field */
  id?: InputMaybe<Scalars['ID']['input']>
  id_SET?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _SET field */
  kind?: InputMaybe<TypeKind>
  kind_SET?: InputMaybe<TypeKind>
  /** @deprecated Please use the explicit _SET field */
  name?: InputMaybe<Scalars['String']['input']>
  name_SET?: InputMaybe<Scalars['String']['input']>
  owner?: InputMaybe<LambdaTypeOwnerUpdateFieldInput>
}

export type LambdaTypeUpdatedEvent = {
  event: EventType
  previousState: LambdaTypeEventPayload
  timestamp: Scalars['Float']['output']
  updatedLambdaType: LambdaTypeEventPayload
}

export type LambdaTypeUserOwnerAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<LambdaTypeUserOwnerNodeAggregateSelection>
}

export type LambdaTypeUserOwnerNodeAggregateSelection = {
  auth0Id: StringAggregateSelection
  email: StringAggregateSelection
  id: IdAggregateSelection
  username: StringAggregateSelection
}

export type LambdaTypeWhere = {
  AND?: InputMaybe<Array<LambdaTypeWhere>>
  NOT?: InputMaybe<LambdaTypeWhere>
  OR?: InputMaybe<Array<LambdaTypeWhere>>
  fieldRefsAggregate?: InputMaybe<LambdaTypeFieldRefsAggregateInput>
  /** Return LambdaTypes where all of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_ALL?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return LambdaTypes where none of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_NONE?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return LambdaTypes where one of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_SINGLE?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return LambdaTypes where some of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_SOME?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return LambdaTypes where all of the related Fields match this filter */
  fieldRefs_ALL?: InputMaybe<FieldWhere>
  /** Return LambdaTypes where none of the related Fields match this filter */
  fieldRefs_NONE?: InputMaybe<FieldWhere>
  /** Return LambdaTypes where one of the related Fields match this filter */
  fieldRefs_SINGLE?: InputMaybe<FieldWhere>
  /** Return LambdaTypes where some of the related Fields match this filter */
  fieldRefs_SOME?: InputMaybe<FieldWhere>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  kind?: InputMaybe<TypeKind>
  kind_EQ?: InputMaybe<TypeKind>
  kind_IN?: InputMaybe<Array<TypeKind>>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>
  name_MATCHES?: InputMaybe<Scalars['String']['input']>
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  owner?: InputMaybe<UserWhere>
  ownerAggregate?: InputMaybe<LambdaTypeOwnerAggregateInput>
  ownerConnection?: InputMaybe<IBaseTypeOwnerConnectionWhere>
}

export type LambdaTypesConnection = {
  edges: Array<LambdaTypeEdge>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type Mutation = {
  createActionTypes: CreateActionTypesMutationResponse
  createApiActions: CreateApiActionsMutationResponse
  createAppTypes: CreateAppTypesMutationResponse
  createApps: CreateAppsMutationResponse
  createArrayTypes: CreateArrayTypesMutationResponse
  createAtoms: CreateAtomsMutationResponse
  createAuthGuards: CreateAuthGuardsMutationResponse
  createCodeActions: CreateCodeActionsMutationResponse
  createCodeMirrorTypes: CreateCodeMirrorTypesMutationResponse
  createComponents: CreateComponentsMutationResponse
  createDomains: CreateDomainsMutationResponse
  createElementTypes: CreateElementTypesMutationResponse
  createElements: CreateElementsMutationResponse
  createEnumTypeValues: CreateEnumTypeValuesMutationResponse
  createEnumTypes: CreateEnumTypesMutationResponse
  createFields: CreateFieldsMutationResponse
  createHooks: CreateHooksMutationResponse
  createInterfaceTypes: CreateInterfaceTypesMutationResponse
  createLambdaTypes: CreateLambdaTypesMutationResponse
  createPageTypes: CreatePageTypesMutationResponse
  createPages: CreatePagesMutationResponse
  createPreferences: CreatePreferencesMutationResponse
  createPrimitiveTypes: CreatePrimitiveTypesMutationResponse
  createProps: CreatePropsMutationResponse
  createReactNodeTypes: CreateReactNodeTypesMutationResponse
  createRedirects: CreateRedirectsMutationResponse
  createRenderPropTypes: CreateRenderPropTypesMutationResponse
  createResources: CreateResourcesMutationResponse
  createRichTextTypes: CreateRichTextTypesMutationResponse
  createStores: CreateStoresMutationResponse
  createTags: CreateTagsMutationResponse
  createTypeReferences: CreateTypeReferencesMutationResponse
  createUnionTypes: CreateUnionTypesMutationResponse
  createUsers: CreateUsersMutationResponse
  deleteActionTypes: DeleteInfo
  deleteApiActions: DeleteInfo
  deleteAppTypes: DeleteInfo
  deleteApps: DeleteInfo
  deleteArrayTypes: DeleteInfo
  deleteAtoms: DeleteInfo
  deleteAuthGuards: DeleteInfo
  deleteCodeActions: DeleteInfo
  deleteCodeMirrorTypes: DeleteInfo
  deleteComponents: DeleteInfo
  deleteDomains: DeleteInfo
  deleteElementTypes: DeleteInfo
  deleteElements: DeleteInfo
  deleteEnumTypeValues: DeleteInfo
  deleteEnumTypes: DeleteInfo
  deleteFields: DeleteInfo
  deleteHooks: DeleteInfo
  deleteInterfaceTypes: DeleteInfo
  deleteLambdaTypes: DeleteInfo
  deletePageTypes: DeleteInfo
  deletePages: DeleteInfo
  deletePreferences: DeleteInfo
  deletePrimitiveTypes: DeleteInfo
  deleteProps: DeleteInfo
  deleteReactNodeTypes: DeleteInfo
  deleteRedirects: DeleteInfo
  deleteRenderPropTypes: DeleteInfo
  deleteResources: DeleteInfo
  deleteRichTextTypes: DeleteInfo
  deleteStores: DeleteInfo
  deleteTags: DeleteInfo
  deleteTypeReferences: DeleteInfo
  deleteUnionTypes: DeleteInfo
  deleteUsers: DeleteInfo
  updateActionTypes: UpdateActionTypesMutationResponse
  updateApiActions: UpdateApiActionsMutationResponse
  updateAppTypes: UpdateAppTypesMutationResponse
  updateApps: UpdateAppsMutationResponse
  updateArrayTypes: UpdateArrayTypesMutationResponse
  updateAtoms: UpdateAtomsMutationResponse
  updateAuthGuards: UpdateAuthGuardsMutationResponse
  updateCodeActions: UpdateCodeActionsMutationResponse
  updateCodeMirrorTypes: UpdateCodeMirrorTypesMutationResponse
  updateComponents: UpdateComponentsMutationResponse
  updateDomains: UpdateDomainsMutationResponse
  updateElementTypes: UpdateElementTypesMutationResponse
  updateElements: UpdateElementsMutationResponse
  updateEnumTypeValues: UpdateEnumTypeValuesMutationResponse
  updateEnumTypes: UpdateEnumTypesMutationResponse
  updateFields: UpdateFieldsMutationResponse
  updateHooks: UpdateHooksMutationResponse
  updateInterfaceTypes: UpdateInterfaceTypesMutationResponse
  updateLambdaTypes: UpdateLambdaTypesMutationResponse
  updatePageTypes: UpdatePageTypesMutationResponse
  updatePages: UpdatePagesMutationResponse
  updatePreferences: UpdatePreferencesMutationResponse
  updatePrimitiveTypes: UpdatePrimitiveTypesMutationResponse
  updateProps: UpdatePropsMutationResponse
  updateReactNodeTypes: UpdateReactNodeTypesMutationResponse
  updateRedirects: UpdateRedirectsMutationResponse
  updateRenderPropTypes: UpdateRenderPropTypesMutationResponse
  updateResources: UpdateResourcesMutationResponse
  updateRichTextTypes: UpdateRichTextTypesMutationResponse
  updateStores: UpdateStoresMutationResponse
  updateTags: UpdateTagsMutationResponse
  updateTypeReferences: UpdateTypeReferencesMutationResponse
  updateUnionTypes: UpdateUnionTypesMutationResponse
  updateUsers: UpdateUsersMutationResponse
}

export type MutationCreateActionTypesArgs = {
  input: Array<ActionTypeCreateInput>
}

export type MutationCreateApiActionsArgs = {
  input: Array<ApiActionCreateInput>
}

export type MutationCreateAppTypesArgs = {
  input: Array<AppTypeCreateInput>
}

export type MutationCreateAppsArgs = {
  input: Array<AppCreateInput>
}

export type MutationCreateArrayTypesArgs = {
  input: Array<ArrayTypeCreateInput>
}

export type MutationCreateAtomsArgs = {
  input: Array<AtomCreateInput>
}

export type MutationCreateAuthGuardsArgs = {
  input: Array<AuthGuardCreateInput>
}

export type MutationCreateCodeActionsArgs = {
  input: Array<CodeActionCreateInput>
}

export type MutationCreateCodeMirrorTypesArgs = {
  input: Array<CodeMirrorTypeCreateInput>
}

export type MutationCreateComponentsArgs = {
  input: Array<ComponentCreateInput>
}

export type MutationCreateDomainsArgs = {
  input: Array<DomainCreateInput>
}

export type MutationCreateElementTypesArgs = {
  input: Array<ElementTypeCreateInput>
}

export type MutationCreateElementsArgs = {
  input: Array<ElementCreateInput>
}

export type MutationCreateEnumTypeValuesArgs = {
  input: Array<EnumTypeValueCreateInput>
}

export type MutationCreateEnumTypesArgs = {
  input: Array<EnumTypeCreateInput>
}

export type MutationCreateFieldsArgs = {
  input: Array<FieldCreateInput>
}

export type MutationCreateHooksArgs = {
  input: Array<HookCreateInput>
}

export type MutationCreateInterfaceTypesArgs = {
  input: Array<InterfaceTypeCreateInput>
}

export type MutationCreateLambdaTypesArgs = {
  input: Array<LambdaTypeCreateInput>
}

export type MutationCreatePageTypesArgs = {
  input: Array<PageTypeCreateInput>
}

export type MutationCreatePagesArgs = {
  input: Array<PageCreateInput>
}

export type MutationCreatePreferencesArgs = {
  input: Array<PreferenceCreateInput>
}

export type MutationCreatePrimitiveTypesArgs = {
  input: Array<PrimitiveTypeCreateInput>
}

export type MutationCreatePropsArgs = {
  input: Array<PropCreateInput>
}

export type MutationCreateReactNodeTypesArgs = {
  input: Array<ReactNodeTypeCreateInput>
}

export type MutationCreateRedirectsArgs = {
  input: Array<RedirectCreateInput>
}

export type MutationCreateRenderPropTypesArgs = {
  input: Array<RenderPropTypeCreateInput>
}

export type MutationCreateResourcesArgs = {
  input: Array<ResourceCreateInput>
}

export type MutationCreateRichTextTypesArgs = {
  input: Array<RichTextTypeCreateInput>
}

export type MutationCreateStoresArgs = {
  input: Array<StoreCreateInput>
}

export type MutationCreateTagsArgs = {
  input: Array<TagCreateInput>
}

export type MutationCreateTypeReferencesArgs = {
  input: Array<TypeReferenceCreateInput>
}

export type MutationCreateUnionTypesArgs = {
  input: Array<UnionTypeCreateInput>
}

export type MutationCreateUsersArgs = {
  input: Array<UserCreateInput>
}

export type MutationDeleteActionTypesArgs = {
  delete?: InputMaybe<ActionTypeDeleteInput>
  where?: InputMaybe<ActionTypeWhere>
}

export type MutationDeleteApiActionsArgs = {
  delete?: InputMaybe<ApiActionDeleteInput>
  where?: InputMaybe<ApiActionWhere>
}

export type MutationDeleteAppTypesArgs = {
  delete?: InputMaybe<AppTypeDeleteInput>
  where?: InputMaybe<AppTypeWhere>
}

export type MutationDeleteAppsArgs = {
  delete?: InputMaybe<AppDeleteInput>
  where?: InputMaybe<AppWhere>
}

export type MutationDeleteArrayTypesArgs = {
  delete?: InputMaybe<ArrayTypeDeleteInput>
  where?: InputMaybe<ArrayTypeWhere>
}

export type MutationDeleteAtomsArgs = {
  delete?: InputMaybe<AtomDeleteInput>
  where?: InputMaybe<AtomWhere>
}

export type MutationDeleteAuthGuardsArgs = {
  delete?: InputMaybe<AuthGuardDeleteInput>
  where?: InputMaybe<AuthGuardWhere>
}

export type MutationDeleteCodeActionsArgs = {
  delete?: InputMaybe<CodeActionDeleteInput>
  where?: InputMaybe<CodeActionWhere>
}

export type MutationDeleteCodeMirrorTypesArgs = {
  delete?: InputMaybe<CodeMirrorTypeDeleteInput>
  where?: InputMaybe<CodeMirrorTypeWhere>
}

export type MutationDeleteComponentsArgs = {
  delete?: InputMaybe<ComponentDeleteInput>
  where?: InputMaybe<ComponentWhere>
}

export type MutationDeleteDomainsArgs = {
  delete?: InputMaybe<DomainDeleteInput>
  where?: InputMaybe<DomainWhere>
}

export type MutationDeleteElementTypesArgs = {
  delete?: InputMaybe<ElementTypeDeleteInput>
  where?: InputMaybe<ElementTypeWhere>
}

export type MutationDeleteElementsArgs = {
  delete?: InputMaybe<ElementDeleteInput>
  where?: InputMaybe<ElementWhere>
}

export type MutationDeleteEnumTypeValuesArgs = {
  delete?: InputMaybe<EnumTypeValueDeleteInput>
  where?: InputMaybe<EnumTypeValueWhere>
}

export type MutationDeleteEnumTypesArgs = {
  delete?: InputMaybe<EnumTypeDeleteInput>
  where?: InputMaybe<EnumTypeWhere>
}

export type MutationDeleteFieldsArgs = {
  delete?: InputMaybe<FieldDeleteInput>
  where?: InputMaybe<FieldWhere>
}

export type MutationDeleteHooksArgs = {
  delete?: InputMaybe<HookDeleteInput>
  where?: InputMaybe<HookWhere>
}

export type MutationDeleteInterfaceTypesArgs = {
  delete?: InputMaybe<InterfaceTypeDeleteInput>
  where?: InputMaybe<InterfaceTypeWhere>
}

export type MutationDeleteLambdaTypesArgs = {
  delete?: InputMaybe<LambdaTypeDeleteInput>
  where?: InputMaybe<LambdaTypeWhere>
}

export type MutationDeletePageTypesArgs = {
  delete?: InputMaybe<PageTypeDeleteInput>
  where?: InputMaybe<PageTypeWhere>
}

export type MutationDeletePagesArgs = {
  delete?: InputMaybe<PageDeleteInput>
  where?: InputMaybe<PageWhere>
}

export type MutationDeletePreferencesArgs = {
  delete?: InputMaybe<PreferenceDeleteInput>
  where?: InputMaybe<PreferenceWhere>
}

export type MutationDeletePrimitiveTypesArgs = {
  delete?: InputMaybe<PrimitiveTypeDeleteInput>
  where?: InputMaybe<PrimitiveTypeWhere>
}

export type MutationDeletePropsArgs = {
  where?: InputMaybe<PropWhere>
}

export type MutationDeleteReactNodeTypesArgs = {
  delete?: InputMaybe<ReactNodeTypeDeleteInput>
  where?: InputMaybe<ReactNodeTypeWhere>
}

export type MutationDeleteRedirectsArgs = {
  delete?: InputMaybe<RedirectDeleteInput>
  where?: InputMaybe<RedirectWhere>
}

export type MutationDeleteRenderPropTypesArgs = {
  delete?: InputMaybe<RenderPropTypeDeleteInput>
  where?: InputMaybe<RenderPropTypeWhere>
}

export type MutationDeleteResourcesArgs = {
  delete?: InputMaybe<ResourceDeleteInput>
  where?: InputMaybe<ResourceWhere>
}

export type MutationDeleteRichTextTypesArgs = {
  delete?: InputMaybe<RichTextTypeDeleteInput>
  where?: InputMaybe<RichTextTypeWhere>
}

export type MutationDeleteStoresArgs = {
  delete?: InputMaybe<StoreDeleteInput>
  where?: InputMaybe<StoreWhere>
}

export type MutationDeleteTagsArgs = {
  delete?: InputMaybe<TagDeleteInput>
  where?: InputMaybe<TagWhere>
}

export type MutationDeleteTypeReferencesArgs = {
  where?: InputMaybe<TypeReferenceWhere>
}

export type MutationDeleteUnionTypesArgs = {
  delete?: InputMaybe<UnionTypeDeleteInput>
  where?: InputMaybe<UnionTypeWhere>
}

export type MutationDeleteUsersArgs = {
  delete?: InputMaybe<UserDeleteInput>
  where?: InputMaybe<UserWhere>
}

export type MutationUpdateActionTypesArgs = {
  update?: InputMaybe<ActionTypeUpdateInput>
  where?: InputMaybe<ActionTypeWhere>
}

export type MutationUpdateApiActionsArgs = {
  update?: InputMaybe<ApiActionUpdateInput>
  where?: InputMaybe<ApiActionWhere>
}

export type MutationUpdateAppTypesArgs = {
  update?: InputMaybe<AppTypeUpdateInput>
  where?: InputMaybe<AppTypeWhere>
}

export type MutationUpdateAppsArgs = {
  update?: InputMaybe<AppUpdateInput>
  where?: InputMaybe<AppWhere>
}

export type MutationUpdateArrayTypesArgs = {
  update?: InputMaybe<ArrayTypeUpdateInput>
  where?: InputMaybe<ArrayTypeWhere>
}

export type MutationUpdateAtomsArgs = {
  update?: InputMaybe<AtomUpdateInput>
  where?: InputMaybe<AtomWhere>
}

export type MutationUpdateAuthGuardsArgs = {
  update?: InputMaybe<AuthGuardUpdateInput>
  where?: InputMaybe<AuthGuardWhere>
}

export type MutationUpdateCodeActionsArgs = {
  update?: InputMaybe<CodeActionUpdateInput>
  where?: InputMaybe<CodeActionWhere>
}

export type MutationUpdateCodeMirrorTypesArgs = {
  update?: InputMaybe<CodeMirrorTypeUpdateInput>
  where?: InputMaybe<CodeMirrorTypeWhere>
}

export type MutationUpdateComponentsArgs = {
  update?: InputMaybe<ComponentUpdateInput>
  where?: InputMaybe<ComponentWhere>
}

export type MutationUpdateDomainsArgs = {
  update?: InputMaybe<DomainUpdateInput>
  where?: InputMaybe<DomainWhere>
}

export type MutationUpdateElementTypesArgs = {
  update?: InputMaybe<ElementTypeUpdateInput>
  where?: InputMaybe<ElementTypeWhere>
}

export type MutationUpdateElementsArgs = {
  update?: InputMaybe<ElementUpdateInput>
  where?: InputMaybe<ElementWhere>
}

export type MutationUpdateEnumTypeValuesArgs = {
  update?: InputMaybe<EnumTypeValueUpdateInput>
  where?: InputMaybe<EnumTypeValueWhere>
}

export type MutationUpdateEnumTypesArgs = {
  update?: InputMaybe<EnumTypeUpdateInput>
  where?: InputMaybe<EnumTypeWhere>
}

export type MutationUpdateFieldsArgs = {
  update?: InputMaybe<FieldUpdateInput>
  where?: InputMaybe<FieldWhere>
}

export type MutationUpdateHooksArgs = {
  update?: InputMaybe<HookUpdateInput>
  where?: InputMaybe<HookWhere>
}

export type MutationUpdateInterfaceTypesArgs = {
  update?: InputMaybe<InterfaceTypeUpdateInput>
  where?: InputMaybe<InterfaceTypeWhere>
}

export type MutationUpdateLambdaTypesArgs = {
  update?: InputMaybe<LambdaTypeUpdateInput>
  where?: InputMaybe<LambdaTypeWhere>
}

export type MutationUpdatePageTypesArgs = {
  update?: InputMaybe<PageTypeUpdateInput>
  where?: InputMaybe<PageTypeWhere>
}

export type MutationUpdatePagesArgs = {
  update?: InputMaybe<PageUpdateInput>
  where?: InputMaybe<PageWhere>
}

export type MutationUpdatePreferencesArgs = {
  update?: InputMaybe<PreferenceUpdateInput>
  where?: InputMaybe<PreferenceWhere>
}

export type MutationUpdatePrimitiveTypesArgs = {
  update?: InputMaybe<PrimitiveTypeUpdateInput>
  where?: InputMaybe<PrimitiveTypeWhere>
}

export type MutationUpdatePropsArgs = {
  update?: InputMaybe<PropUpdateInput>
  where?: InputMaybe<PropWhere>
}

export type MutationUpdateReactNodeTypesArgs = {
  update?: InputMaybe<ReactNodeTypeUpdateInput>
  where?: InputMaybe<ReactNodeTypeWhere>
}

export type MutationUpdateRedirectsArgs = {
  update?: InputMaybe<RedirectUpdateInput>
  where?: InputMaybe<RedirectWhere>
}

export type MutationUpdateRenderPropTypesArgs = {
  update?: InputMaybe<RenderPropTypeUpdateInput>
  where?: InputMaybe<RenderPropTypeWhere>
}

export type MutationUpdateResourcesArgs = {
  update?: InputMaybe<ResourceUpdateInput>
  where?: InputMaybe<ResourceWhere>
}

export type MutationUpdateRichTextTypesArgs = {
  update?: InputMaybe<RichTextTypeUpdateInput>
  where?: InputMaybe<RichTextTypeWhere>
}

export type MutationUpdateStoresArgs = {
  update?: InputMaybe<StoreUpdateInput>
  where?: InputMaybe<StoreWhere>
}

export type MutationUpdateTagsArgs = {
  update?: InputMaybe<TagUpdateInput>
  where?: InputMaybe<TagWhere>
}

export type MutationUpdateTypeReferencesArgs = {
  update?: InputMaybe<TypeReferenceUpdateInput>
  where?: InputMaybe<TypeReferenceWhere>
}

export type MutationUpdateUnionTypesArgs = {
  update?: InputMaybe<UnionTypeUpdateInput>
  where?: InputMaybe<UnionTypeWhere>
}

export type MutationUpdateUsersArgs = {
  update?: InputMaybe<UserUpdateInput>
  where?: InputMaybe<UserWhere>
}

export type Page = {
  app: App
  appAggregate?: Maybe<PageAppAppAggregationSelection>
  appConnection: PageAppConnection
  compositeKey: Scalars['String']['output']
  elements: Array<Element>
  elementsAggregate?: Maybe<PageElementElementsAggregationSelection>
  elementsConnection: PageElementsConnection
  id: Scalars['ID']['output']
  kind: PageKind
  name: Scalars['String']['output']
  pageContentContainer?: Maybe<Element>
  pageContentContainerAggregate?: Maybe<PageElementPageContentContainerAggregationSelection>
  pageContentContainerConnection: PagePageContentContainerConnection
  redirect?: Maybe<Redirect>
  redirectAggregate?: Maybe<PageRedirectRedirectAggregationSelection>
  redirectConnection: PageRedirectConnection
  rootElement: Element
  rootElementAggregate?: Maybe<PageElementRootElementAggregationSelection>
  rootElementConnection: PageRootElementConnection
  slug: Scalars['String']['output']
  store: Store
  storeAggregate?: Maybe<PageStoreStoreAggregationSelection>
  storeConnection: PageStoreConnection
  urlPattern: Scalars['String']['output']
}

export type PageAppArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<AppOptions>
  sort?: InputMaybe<Array<AppSort>>
  where?: InputMaybe<AppWhere>
}

export type PageAppAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<AppWhere>
}

export type PageAppConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<PageAppConnectionSort>>
  where?: InputMaybe<PageAppConnectionWhere>
}

export type PageElementsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<ElementOptions>
  sort?: InputMaybe<Array<ElementSort>>
  where?: InputMaybe<ElementWhere>
}

export type PageElementsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<ElementWhere>
}

export type PageElementsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<PageElementsConnectionSort>>
  where?: InputMaybe<PageElementsConnectionWhere>
}

export type PagePageContentContainerArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<ElementOptions>
  sort?: InputMaybe<Array<ElementSort>>
  where?: InputMaybe<ElementWhere>
}

export type PagePageContentContainerAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<ElementWhere>
}

export type PagePageContentContainerConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<PagePageContentContainerConnectionSort>>
  where?: InputMaybe<PagePageContentContainerConnectionWhere>
}

export type PageRedirectArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<RedirectOptions>
  sort?: InputMaybe<Array<RedirectSort>>
  where?: InputMaybe<RedirectWhere>
}

export type PageRedirectAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<RedirectWhere>
}

export type PageRedirectConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<PageRedirectConnectionSort>>
  where?: InputMaybe<PageRedirectConnectionWhere>
}

export type PageRootElementArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<ElementOptions>
  sort?: InputMaybe<Array<ElementSort>>
  where?: InputMaybe<ElementWhere>
}

export type PageRootElementAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<ElementWhere>
}

export type PageRootElementConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<PageRootElementConnectionSort>>
  where?: InputMaybe<PageRootElementConnectionWhere>
}

export type PageStoreArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<StoreOptions>
  sort?: InputMaybe<Array<StoreSort>>
  where?: InputMaybe<StoreWhere>
}

export type PageStoreAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<StoreWhere>
}

export type PageStoreConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<PageStoreConnectionSort>>
  where?: InputMaybe<PageStoreConnectionWhere>
}

export type PageAggregateSelection = {
  compositeKey: StringAggregateSelection
  count: Scalars['Int']['output']
  id: IdAggregateSelection
  urlPattern: StringAggregateSelection
}

export type PageAppAggregateInput = {
  AND?: InputMaybe<Array<PageAppAggregateInput>>
  NOT?: InputMaybe<PageAppAggregateInput>
  OR?: InputMaybe<Array<PageAppAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<PageAppNodeAggregationWhereInput>
}

export type PageAppAppAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<PageAppAppNodeAggregateSelection>
}

export type PageAppAppNodeAggregateSelection = {
  compositeKey: StringAggregateSelection
  id: IdAggregateSelection
}

export type PageAppConnectFieldInput = {
  connect?: InputMaybe<AppConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<AppConnectWhere>
}

export type PageAppConnectOrCreateFieldInput = {
  onCreate: PageAppConnectOrCreateFieldInputOnCreate
  where: AppConnectOrCreateWhere
}

export type PageAppConnectOrCreateFieldInputOnCreate = {
  node: AppOnCreateInput
}

export type PageAppConnection = {
  edges: Array<PageAppRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type PageAppConnectionSort = {
  node?: InputMaybe<AppSort>
}

export type PageAppConnectionWhere = {
  AND?: InputMaybe<Array<PageAppConnectionWhere>>
  NOT?: InputMaybe<PageAppConnectionWhere>
  OR?: InputMaybe<Array<PageAppConnectionWhere>>
  node?: InputMaybe<AppWhere>
}

export type PageAppCreateFieldInput = {
  node: AppCreateInput
}

export type PageAppDeleteFieldInput = {
  delete?: InputMaybe<AppDeleteInput>
  where?: InputMaybe<PageAppConnectionWhere>
}

export type PageAppDisconnectFieldInput = {
  disconnect?: InputMaybe<AppDisconnectInput>
  where?: InputMaybe<PageAppConnectionWhere>
}

export type PageAppFieldInput = {
  connect?: InputMaybe<PageAppConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<PageAppConnectOrCreateFieldInput>
  create?: InputMaybe<PageAppCreateFieldInput>
}

export type PageAppNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<PageAppNodeAggregationWhereInput>>
  NOT?: InputMaybe<PageAppNodeAggregationWhereInput>
  OR?: InputMaybe<Array<PageAppNodeAggregationWhereInput>>
  compositeKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
}

export type PageAppRelationship = {
  cursor: Scalars['String']['output']
  node: App
}

export type PageAppUpdateConnectionInput = {
  node?: InputMaybe<AppUpdateInput>
}

export type PageAppUpdateFieldInput = {
  connect?: InputMaybe<PageAppConnectFieldInput>
  connectOrCreate?: InputMaybe<PageAppConnectOrCreateFieldInput>
  create?: InputMaybe<PageAppCreateFieldInput>
  delete?: InputMaybe<PageAppDeleteFieldInput>
  disconnect?: InputMaybe<PageAppDisconnectFieldInput>
  update?: InputMaybe<PageAppUpdateConnectionInput>
  where?: InputMaybe<PageAppConnectionWhere>
}

export type PageConnectInput = {
  app?: InputMaybe<PageAppConnectFieldInput>
  elements?: InputMaybe<Array<PageElementsConnectFieldInput>>
  pageContentContainer?: InputMaybe<PagePageContentContainerConnectFieldInput>
  redirect?: InputMaybe<PageRedirectConnectFieldInput>
  rootElement?: InputMaybe<PageRootElementConnectFieldInput>
  store?: InputMaybe<PageStoreConnectFieldInput>
}

export type PageConnectOrCreateWhere = {
  node: PageUniqueWhere
}

export type PageConnectWhere = {
  node: PageWhere
}

export type PageCreateInput = {
  app?: InputMaybe<PageAppFieldInput>
  compositeKey: Scalars['String']['input']
  elements?: InputMaybe<PageElementsFieldInput>
  id: Scalars['ID']['input']
  kind: PageKind
  pageContentContainer?: InputMaybe<PagePageContentContainerFieldInput>
  redirect?: InputMaybe<PageRedirectFieldInput>
  rootElement?: InputMaybe<PageRootElementFieldInput>
  store?: InputMaybe<PageStoreFieldInput>
  urlPattern: Scalars['String']['input']
}

export type PageCreatedEvent = {
  createdPage: PageEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type PageDeleteInput = {
  app?: InputMaybe<PageAppDeleteFieldInput>
  elements?: InputMaybe<Array<PageElementsDeleteFieldInput>>
  pageContentContainer?: InputMaybe<PagePageContentContainerDeleteFieldInput>
  redirect?: InputMaybe<PageRedirectDeleteFieldInput>
  rootElement?: InputMaybe<PageRootElementDeleteFieldInput>
  store?: InputMaybe<PageStoreDeleteFieldInput>
}

export type PageDeletedEvent = {
  deletedPage: PageEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type PageDisconnectInput = {
  app?: InputMaybe<PageAppDisconnectFieldInput>
  elements?: InputMaybe<Array<PageElementsDisconnectFieldInput>>
  pageContentContainer?: InputMaybe<PagePageContentContainerDisconnectFieldInput>
  redirect?: InputMaybe<PageRedirectDisconnectFieldInput>
  rootElement?: InputMaybe<PageRootElementDisconnectFieldInput>
  store?: InputMaybe<PageStoreDisconnectFieldInput>
}

export type PageEdge = {
  cursor: Scalars['String']['output']
  node: Page
}

export type PageElementElementsAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<PageElementElementsNodeAggregateSelection>
}

export type PageElementElementsNodeAggregateSelection = {
  childMapperPropKey: StringAggregateSelection
  compositeKey: StringAggregateSelection
  id: IdAggregateSelection
  renderForEachPropKey: StringAggregateSelection
  renderIfExpression: StringAggregateSelection
  style: StringAggregateSelection
}

export type PageElementPageContentContainerAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<PageElementPageContentContainerNodeAggregateSelection>
}

export type PageElementPageContentContainerNodeAggregateSelection = {
  childMapperPropKey: StringAggregateSelection
  compositeKey: StringAggregateSelection
  id: IdAggregateSelection
  renderForEachPropKey: StringAggregateSelection
  renderIfExpression: StringAggregateSelection
  style: StringAggregateSelection
}

export type PageElementRootElementAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<PageElementRootElementNodeAggregateSelection>
}

export type PageElementRootElementNodeAggregateSelection = {
  childMapperPropKey: StringAggregateSelection
  compositeKey: StringAggregateSelection
  id: IdAggregateSelection
  renderForEachPropKey: StringAggregateSelection
  renderIfExpression: StringAggregateSelection
  style: StringAggregateSelection
}

export type PageElementsAggregateInput = {
  AND?: InputMaybe<Array<PageElementsAggregateInput>>
  NOT?: InputMaybe<PageElementsAggregateInput>
  OR?: InputMaybe<Array<PageElementsAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<PageElementsNodeAggregationWhereInput>
}

export type PageElementsConnectFieldInput = {
  connect?: InputMaybe<Array<ElementConnectInput>>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<ElementConnectWhere>
}

export type PageElementsConnectOrCreateFieldInput = {
  onCreate: PageElementsConnectOrCreateFieldInputOnCreate
  where: ElementConnectOrCreateWhere
}

export type PageElementsConnectOrCreateFieldInputOnCreate = {
  node: ElementOnCreateInput
}

export type PageElementsConnection = {
  edges: Array<PageElementsRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type PageElementsConnectionSort = {
  node?: InputMaybe<ElementSort>
}

export type PageElementsConnectionWhere = {
  AND?: InputMaybe<Array<PageElementsConnectionWhere>>
  NOT?: InputMaybe<PageElementsConnectionWhere>
  OR?: InputMaybe<Array<PageElementsConnectionWhere>>
  node?: InputMaybe<ElementWhere>
}

export type PageElementsCreateFieldInput = {
  node: ElementCreateInput
}

export type PageElementsDeleteFieldInput = {
  delete?: InputMaybe<ElementDeleteInput>
  where?: InputMaybe<PageElementsConnectionWhere>
}

export type PageElementsDisconnectFieldInput = {
  disconnect?: InputMaybe<ElementDisconnectInput>
  where?: InputMaybe<PageElementsConnectionWhere>
}

export type PageElementsFieldInput = {
  connect?: InputMaybe<Array<PageElementsConnectFieldInput>>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<Array<PageElementsConnectOrCreateFieldInput>>
  create?: InputMaybe<Array<PageElementsCreateFieldInput>>
}

export type PageElementsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<PageElementsNodeAggregationWhereInput>>
  NOT?: InputMaybe<PageElementsNodeAggregationWhereInput>
  OR?: InputMaybe<Array<PageElementsNodeAggregationWhereInput>>
  childMapperPropKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  childMapperPropKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_GTE?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_LTE?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_LONGEST_LENGTH_EQUAL?: InputMaybe<
    Scalars['Int']['input']
  >
  renderForEachPropKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<
    Scalars['Int']['input']
  >
  renderForEachPropKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  renderIfExpression_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  style_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  style_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type PageElementsRelationship = {
  cursor: Scalars['String']['output']
  node: Element
}

export type PageElementsUpdateConnectionInput = {
  node?: InputMaybe<ElementUpdateInput>
}

export type PageElementsUpdateFieldInput = {
  connect?: InputMaybe<Array<PageElementsConnectFieldInput>>
  connectOrCreate?: InputMaybe<Array<PageElementsConnectOrCreateFieldInput>>
  create?: InputMaybe<Array<PageElementsCreateFieldInput>>
  delete?: InputMaybe<Array<PageElementsDeleteFieldInput>>
  disconnect?: InputMaybe<Array<PageElementsDisconnectFieldInput>>
  update?: InputMaybe<PageElementsUpdateConnectionInput>
  where?: InputMaybe<PageElementsConnectionWhere>
}

export type PageEventPayload = {
  compositeKey: Scalars['String']['output']
  id: Scalars['ID']['output']
  kind: PageKind
  urlPattern: Scalars['String']['output']
}

/** Pagination information (Relay) */
export type PageInfo = {
  endCursor?: Maybe<Scalars['String']['output']>
  hasNextPage: Scalars['Boolean']['output']
  hasPreviousPage: Scalars['Boolean']['output']
  startCursor?: Maybe<Scalars['String']['output']>
}

export enum PageKind {
  InternalServerError = 'InternalServerError',
  NotFound = 'NotFound',
  Provider = 'Provider',
  Regular = 'Regular',
}

export type PageOnCreateInput = {
  compositeKey: Scalars['String']['input']
  id: Scalars['ID']['input']
  kind: PageKind
  urlPattern: Scalars['String']['input']
}

export type PageOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  /** Specify one or more PageSort objects to sort Pages by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<PageSort>>
}

export type PagePageContentContainerAggregateInput = {
  AND?: InputMaybe<Array<PagePageContentContainerAggregateInput>>
  NOT?: InputMaybe<PagePageContentContainerAggregateInput>
  OR?: InputMaybe<Array<PagePageContentContainerAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<PagePageContentContainerNodeAggregationWhereInput>
}

export type PagePageContentContainerConnectFieldInput = {
  connect?: InputMaybe<ElementConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<ElementConnectWhere>
}

export type PagePageContentContainerConnectOrCreateFieldInput = {
  onCreate: PagePageContentContainerConnectOrCreateFieldInputOnCreate
  where: ElementConnectOrCreateWhere
}

export type PagePageContentContainerConnectOrCreateFieldInputOnCreate = {
  node: ElementOnCreateInput
}

export type PagePageContentContainerConnection = {
  edges: Array<PagePageContentContainerRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type PagePageContentContainerConnectionSort = {
  node?: InputMaybe<ElementSort>
}

export type PagePageContentContainerConnectionWhere = {
  AND?: InputMaybe<Array<PagePageContentContainerConnectionWhere>>
  NOT?: InputMaybe<PagePageContentContainerConnectionWhere>
  OR?: InputMaybe<Array<PagePageContentContainerConnectionWhere>>
  node?: InputMaybe<ElementWhere>
}

export type PagePageContentContainerCreateFieldInput = {
  node: ElementCreateInput
}

export type PagePageContentContainerDeleteFieldInput = {
  delete?: InputMaybe<ElementDeleteInput>
  where?: InputMaybe<PagePageContentContainerConnectionWhere>
}

export type PagePageContentContainerDisconnectFieldInput = {
  disconnect?: InputMaybe<ElementDisconnectInput>
  where?: InputMaybe<PagePageContentContainerConnectionWhere>
}

export type PagePageContentContainerFieldInput = {
  connect?: InputMaybe<PagePageContentContainerConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<PagePageContentContainerConnectOrCreateFieldInput>
  create?: InputMaybe<PagePageContentContainerCreateFieldInput>
}

export type PagePageContentContainerNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<PagePageContentContainerNodeAggregationWhereInput>>
  NOT?: InputMaybe<PagePageContentContainerNodeAggregationWhereInput>
  OR?: InputMaybe<Array<PagePageContentContainerNodeAggregationWhereInput>>
  childMapperPropKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  childMapperPropKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_GTE?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_LTE?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_LONGEST_LENGTH_EQUAL?: InputMaybe<
    Scalars['Int']['input']
  >
  renderForEachPropKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<
    Scalars['Int']['input']
  >
  renderForEachPropKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  renderIfExpression_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  style_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  style_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type PagePageContentContainerRelationship = {
  cursor: Scalars['String']['output']
  node: Element
}

export type PagePageContentContainerUpdateConnectionInput = {
  node?: InputMaybe<ElementUpdateInput>
}

export type PagePageContentContainerUpdateFieldInput = {
  connect?: InputMaybe<PagePageContentContainerConnectFieldInput>
  connectOrCreate?: InputMaybe<PagePageContentContainerConnectOrCreateFieldInput>
  create?: InputMaybe<PagePageContentContainerCreateFieldInput>
  delete?: InputMaybe<PagePageContentContainerDeleteFieldInput>
  disconnect?: InputMaybe<PagePageContentContainerDisconnectFieldInput>
  update?: InputMaybe<PagePageContentContainerUpdateConnectionInput>
  where?: InputMaybe<PagePageContentContainerConnectionWhere>
}

export type PageRedirectAggregateInput = {
  AND?: InputMaybe<Array<PageRedirectAggregateInput>>
  NOT?: InputMaybe<PageRedirectAggregateInput>
  OR?: InputMaybe<Array<PageRedirectAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<PageRedirectNodeAggregationWhereInput>
}

export type PageRedirectConnectFieldInput = {
  connect?: InputMaybe<RedirectConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<RedirectConnectWhere>
}

export type PageRedirectConnectOrCreateFieldInput = {
  onCreate: PageRedirectConnectOrCreateFieldInputOnCreate
  where: RedirectConnectOrCreateWhere
}

export type PageRedirectConnectOrCreateFieldInputOnCreate = {
  node: RedirectOnCreateInput
}

export type PageRedirectConnection = {
  edges: Array<PageRedirectRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type PageRedirectConnectionSort = {
  node?: InputMaybe<RedirectSort>
}

export type PageRedirectConnectionWhere = {
  AND?: InputMaybe<Array<PageRedirectConnectionWhere>>
  NOT?: InputMaybe<PageRedirectConnectionWhere>
  OR?: InputMaybe<Array<PageRedirectConnectionWhere>>
  node?: InputMaybe<RedirectWhere>
}

export type PageRedirectCreateFieldInput = {
  node: RedirectCreateInput
}

export type PageRedirectDeleteFieldInput = {
  delete?: InputMaybe<RedirectDeleteInput>
  where?: InputMaybe<PageRedirectConnectionWhere>
}

export type PageRedirectDisconnectFieldInput = {
  disconnect?: InputMaybe<RedirectDisconnectInput>
  where?: InputMaybe<PageRedirectConnectionWhere>
}

export type PageRedirectFieldInput = {
  connect?: InputMaybe<PageRedirectConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<PageRedirectConnectOrCreateFieldInput>
  create?: InputMaybe<PageRedirectCreateFieldInput>
}

export type PageRedirectNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<PageRedirectNodeAggregationWhereInput>>
  NOT?: InputMaybe<PageRedirectNodeAggregationWhereInput>
  OR?: InputMaybe<Array<PageRedirectNodeAggregationWhereInput>>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  targetUrl_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  targetUrl_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  targetUrl_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  targetUrl_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  targetUrl_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  targetUrl_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  targetUrl_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  targetUrl_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  targetUrl_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  targetUrl_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  targetUrl_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  targetUrl_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  targetUrl_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  targetUrl_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  targetUrl_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type PageRedirectRedirectAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<PageRedirectRedirectNodeAggregateSelection>
}

export type PageRedirectRedirectNodeAggregateSelection = {
  id: IdAggregateSelection
  targetUrl: StringAggregateSelection
}

export type PageRedirectRelationship = {
  cursor: Scalars['String']['output']
  node: Redirect
}

export type PageRedirectUpdateConnectionInput = {
  node?: InputMaybe<RedirectUpdateInput>
}

export type PageRedirectUpdateFieldInput = {
  connect?: InputMaybe<PageRedirectConnectFieldInput>
  connectOrCreate?: InputMaybe<PageRedirectConnectOrCreateFieldInput>
  create?: InputMaybe<PageRedirectCreateFieldInput>
  delete?: InputMaybe<PageRedirectDeleteFieldInput>
  disconnect?: InputMaybe<PageRedirectDisconnectFieldInput>
  update?: InputMaybe<PageRedirectUpdateConnectionInput>
  where?: InputMaybe<PageRedirectConnectionWhere>
}

export type PageRootElementAggregateInput = {
  AND?: InputMaybe<Array<PageRootElementAggregateInput>>
  NOT?: InputMaybe<PageRootElementAggregateInput>
  OR?: InputMaybe<Array<PageRootElementAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<PageRootElementNodeAggregationWhereInput>
}

export type PageRootElementConnectFieldInput = {
  connect?: InputMaybe<ElementConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<ElementConnectWhere>
}

export type PageRootElementConnectOrCreateFieldInput = {
  onCreate: PageRootElementConnectOrCreateFieldInputOnCreate
  where: ElementConnectOrCreateWhere
}

export type PageRootElementConnectOrCreateFieldInputOnCreate = {
  node: ElementOnCreateInput
}

export type PageRootElementConnection = {
  edges: Array<PageRootElementRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type PageRootElementConnectionSort = {
  node?: InputMaybe<ElementSort>
}

export type PageRootElementConnectionWhere = {
  AND?: InputMaybe<Array<PageRootElementConnectionWhere>>
  NOT?: InputMaybe<PageRootElementConnectionWhere>
  OR?: InputMaybe<Array<PageRootElementConnectionWhere>>
  node?: InputMaybe<ElementWhere>
}

export type PageRootElementCreateFieldInput = {
  node: ElementCreateInput
}

export type PageRootElementDeleteFieldInput = {
  delete?: InputMaybe<ElementDeleteInput>
  where?: InputMaybe<PageRootElementConnectionWhere>
}

export type PageRootElementDisconnectFieldInput = {
  disconnect?: InputMaybe<ElementDisconnectInput>
  where?: InputMaybe<PageRootElementConnectionWhere>
}

export type PageRootElementFieldInput = {
  connect?: InputMaybe<PageRootElementConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<PageRootElementConnectOrCreateFieldInput>
  create?: InputMaybe<PageRootElementCreateFieldInput>
}

export type PageRootElementNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<PageRootElementNodeAggregationWhereInput>>
  NOT?: InputMaybe<PageRootElementNodeAggregationWhereInput>
  OR?: InputMaybe<Array<PageRootElementNodeAggregationWhereInput>>
  childMapperPropKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  childMapperPropKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_GTE?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_LTE?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_LONGEST_LENGTH_EQUAL?: InputMaybe<
    Scalars['Int']['input']
  >
  renderForEachPropKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<
    Scalars['Int']['input']
  >
  renderForEachPropKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  renderIfExpression_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  style_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  style_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type PageRootElementRelationship = {
  cursor: Scalars['String']['output']
  node: Element
}

export type PageRootElementUpdateConnectionInput = {
  node?: InputMaybe<ElementUpdateInput>
}

export type PageRootElementUpdateFieldInput = {
  connect?: InputMaybe<PageRootElementConnectFieldInput>
  connectOrCreate?: InputMaybe<PageRootElementConnectOrCreateFieldInput>
  create?: InputMaybe<PageRootElementCreateFieldInput>
  delete?: InputMaybe<PageRootElementDeleteFieldInput>
  disconnect?: InputMaybe<PageRootElementDisconnectFieldInput>
  update?: InputMaybe<PageRootElementUpdateConnectionInput>
  where?: InputMaybe<PageRootElementConnectionWhere>
}

/** Fields to sort Pages by. The order in which sorts are applied is not guaranteed when specifying many fields in one PageSort object. */
export type PageSort = {
  compositeKey?: InputMaybe<SortDirection>
  id?: InputMaybe<SortDirection>
  kind?: InputMaybe<SortDirection>
  urlPattern?: InputMaybe<SortDirection>
}

export type PageStoreAggregateInput = {
  AND?: InputMaybe<Array<PageStoreAggregateInput>>
  NOT?: InputMaybe<PageStoreAggregateInput>
  OR?: InputMaybe<Array<PageStoreAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<PageStoreNodeAggregationWhereInput>
}

export type PageStoreConnectFieldInput = {
  connect?: InputMaybe<StoreConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<StoreConnectWhere>
}

export type PageStoreConnectOrCreateFieldInput = {
  onCreate: PageStoreConnectOrCreateFieldInputOnCreate
  where: StoreConnectOrCreateWhere
}

export type PageStoreConnectOrCreateFieldInputOnCreate = {
  node: StoreOnCreateInput
}

export type PageStoreConnection = {
  edges: Array<PageStoreRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type PageStoreConnectionSort = {
  node?: InputMaybe<StoreSort>
}

export type PageStoreConnectionWhere = {
  AND?: InputMaybe<Array<PageStoreConnectionWhere>>
  NOT?: InputMaybe<PageStoreConnectionWhere>
  OR?: InputMaybe<Array<PageStoreConnectionWhere>>
  node?: InputMaybe<StoreWhere>
}

export type PageStoreCreateFieldInput = {
  node: StoreCreateInput
}

export type PageStoreDeleteFieldInput = {
  delete?: InputMaybe<StoreDeleteInput>
  where?: InputMaybe<PageStoreConnectionWhere>
}

export type PageStoreDisconnectFieldInput = {
  disconnect?: InputMaybe<StoreDisconnectInput>
  where?: InputMaybe<PageStoreConnectionWhere>
}

export type PageStoreFieldInput = {
  connect?: InputMaybe<PageStoreConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<PageStoreConnectOrCreateFieldInput>
  create?: InputMaybe<PageStoreCreateFieldInput>
}

export type PageStoreNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<PageStoreNodeAggregationWhereInput>>
  NOT?: InputMaybe<PageStoreNodeAggregationWhereInput>
  OR?: InputMaybe<Array<PageStoreNodeAggregationWhereInput>>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type PageStoreRelationship = {
  cursor: Scalars['String']['output']
  node: Store
}

export type PageStoreStoreAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<PageStoreStoreNodeAggregateSelection>
}

export type PageStoreStoreNodeAggregateSelection = {
  id: IdAggregateSelection
  name: StringAggregateSelection
}

export type PageStoreUpdateConnectionInput = {
  node?: InputMaybe<StoreUpdateInput>
}

export type PageStoreUpdateFieldInput = {
  connect?: InputMaybe<PageStoreConnectFieldInput>
  connectOrCreate?: InputMaybe<PageStoreConnectOrCreateFieldInput>
  create?: InputMaybe<PageStoreCreateFieldInput>
  delete?: InputMaybe<PageStoreDeleteFieldInput>
  disconnect?: InputMaybe<PageStoreDisconnectFieldInput>
  update?: InputMaybe<PageStoreUpdateConnectionInput>
  where?: InputMaybe<PageStoreConnectionWhere>
}

export type PageSubscriptionWhere = {
  AND?: InputMaybe<Array<PageSubscriptionWhere>>
  NOT?: InputMaybe<PageSubscriptionWhere>
  OR?: InputMaybe<Array<PageSubscriptionWhere>>
  /** @deprecated Please use the explicit _EQ version */
  compositeKey?: InputMaybe<Scalars['String']['input']>
  compositeKey_CONTAINS?: InputMaybe<Scalars['String']['input']>
  compositeKey_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  compositeKey_EQ?: InputMaybe<Scalars['String']['input']>
  compositeKey_IN?: InputMaybe<Array<Scalars['String']['input']>>
  compositeKey_MATCHES?: InputMaybe<Scalars['String']['input']>
  compositeKey_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  kind?: InputMaybe<PageKind>
  kind_EQ?: InputMaybe<PageKind>
  kind_IN?: InputMaybe<Array<PageKind>>
  /** @deprecated Please use the explicit _EQ version */
  urlPattern?: InputMaybe<Scalars['String']['input']>
  urlPattern_CONTAINS?: InputMaybe<Scalars['String']['input']>
  urlPattern_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  urlPattern_EQ?: InputMaybe<Scalars['String']['input']>
  urlPattern_IN?: InputMaybe<Array<Scalars['String']['input']>>
  urlPattern_MATCHES?: InputMaybe<Scalars['String']['input']>
  urlPattern_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
}

/** Allows picking a page from the list of pages */
export type PageType = IBaseType & {
  fieldRefs: Array<Field>
  fieldRefsAggregate?: Maybe<PageTypeFieldFieldRefsAggregationSelection>
  fieldRefsConnection: IBaseTypeFieldRefsConnection
  id: Scalars['ID']['output']
  kind: TypeKind
  name: Scalars['String']['output']
  owner: User
  ownerAggregate?: Maybe<PageTypeUserOwnerAggregationSelection>
  ownerConnection: IBaseTypeOwnerConnection
}

/** Allows picking a page from the list of pages */
export type PageTypeFieldRefsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<FieldOptions>
  sort?: InputMaybe<Array<FieldSort>>
  where?: InputMaybe<FieldWhere>
}

/** Allows picking a page from the list of pages */
export type PageTypeFieldRefsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<FieldWhere>
}

/** Allows picking a page from the list of pages */
export type PageTypeFieldRefsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<IBaseTypeFieldRefsConnectionSort>>
  where?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
}

/** Allows picking a page from the list of pages */
export type PageTypeOwnerArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<UserOptions>
  sort?: InputMaybe<Array<UserSort>>
  where?: InputMaybe<UserWhere>
}

/** Allows picking a page from the list of pages */
export type PageTypeOwnerAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<UserWhere>
}

/** Allows picking a page from the list of pages */
export type PageTypeOwnerConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<IBaseTypeOwnerConnectionSort>>
  where?: InputMaybe<IBaseTypeOwnerConnectionWhere>
}

export type PageTypeAggregateSelection = {
  count: Scalars['Int']['output']
  id: IdAggregateSelection
  name: StringAggregateSelection
}

export type PageTypeConnectInput = {
  fieldRefs?: InputMaybe<Array<PageTypeFieldRefsConnectFieldInput>>
  owner?: InputMaybe<PageTypeOwnerConnectFieldInput>
}

export type PageTypeConnectWhere = {
  node: PageTypeWhere
}

export type PageTypeCreateInput = {
  fieldRefs?: InputMaybe<PageTypeFieldRefsFieldInput>
  id: Scalars['ID']['input']
  kind?: TypeKind
  name: Scalars['String']['input']
  owner?: InputMaybe<PageTypeOwnerFieldInput>
}

export type PageTypeCreatedEvent = {
  createdPageType: PageTypeEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type PageTypeDeleteInput = {
  fieldRefs?: InputMaybe<Array<IBaseTypeFieldRefsDeleteFieldInput>>
  owner?: InputMaybe<IBaseTypeOwnerDeleteFieldInput>
}

export type PageTypeDeletedEvent = {
  deletedPageType: PageTypeEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type PageTypeDisconnectInput = {
  fieldRefs?: InputMaybe<Array<IBaseTypeFieldRefsDisconnectFieldInput>>
  owner?: InputMaybe<IBaseTypeOwnerDisconnectFieldInput>
}

export type PageTypeEdge = {
  cursor: Scalars['String']['output']
  node: PageType
}

export type PageTypeEventPayload = {
  id: Scalars['ID']['output']
  kind: TypeKind
  name: Scalars['String']['output']
}

export type PageTypeFieldFieldRefsAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<PageTypeFieldFieldRefsNodeAggregateSelection>
}

export type PageTypeFieldFieldRefsNodeAggregateSelection = {
  defaultValues: StringAggregateSelection
  description: StringAggregateSelection
  id: IdAggregateSelection
  key: StringAggregateSelection
  name: StringAggregateSelection
  validationRules: StringAggregateSelection
}

export type PageTypeFieldRefsAggregateInput = {
  AND?: InputMaybe<Array<PageTypeFieldRefsAggregateInput>>
  NOT?: InputMaybe<PageTypeFieldRefsAggregateInput>
  OR?: InputMaybe<Array<PageTypeFieldRefsAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<PageTypeFieldRefsNodeAggregationWhereInput>
}

export type PageTypeFieldRefsConnectFieldInput = {
  connect?: InputMaybe<Array<FieldConnectInput>>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<FieldConnectWhere>
}

export type PageTypeFieldRefsConnectOrCreateFieldInput = {
  onCreate: PageTypeFieldRefsConnectOrCreateFieldInputOnCreate
  where: FieldConnectOrCreateWhere
}

export type PageTypeFieldRefsConnectOrCreateFieldInputOnCreate = {
  node: FieldOnCreateInput
}

export type PageTypeFieldRefsCreateFieldInput = {
  node: FieldCreateInput
}

export type PageTypeFieldRefsFieldInput = {
  connect?: InputMaybe<Array<PageTypeFieldRefsConnectFieldInput>>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<
    Array<PageTypeFieldRefsConnectOrCreateFieldInput>
  >
  create?: InputMaybe<Array<PageTypeFieldRefsCreateFieldInput>>
}

export type PageTypeFieldRefsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<PageTypeFieldRefsNodeAggregationWhereInput>>
  NOT?: InputMaybe<PageTypeFieldRefsNodeAggregationWhereInput>
  OR?: InputMaybe<Array<PageTypeFieldRefsNodeAggregationWhereInput>>
  defaultValues_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  defaultValues_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  description_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  description_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  key_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  key_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  validationRules_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type PageTypeFieldRefsUpdateConnectionInput = {
  node?: InputMaybe<FieldUpdateInput>
}

export type PageTypeFieldRefsUpdateFieldInput = {
  connect?: InputMaybe<Array<PageTypeFieldRefsConnectFieldInput>>
  connectOrCreate?: InputMaybe<
    Array<PageTypeFieldRefsConnectOrCreateFieldInput>
  >
  create?: InputMaybe<Array<PageTypeFieldRefsCreateFieldInput>>
  delete?: InputMaybe<Array<IBaseTypeFieldRefsDeleteFieldInput>>
  disconnect?: InputMaybe<Array<IBaseTypeFieldRefsDisconnectFieldInput>>
  update?: InputMaybe<PageTypeFieldRefsUpdateConnectionInput>
  where?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
}

export type PageTypeOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  /** Specify one or more PageTypeSort objects to sort PageTypes by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<PageTypeSort>>
}

export type PageTypeOwnerAggregateInput = {
  AND?: InputMaybe<Array<PageTypeOwnerAggregateInput>>
  NOT?: InputMaybe<PageTypeOwnerAggregateInput>
  OR?: InputMaybe<Array<PageTypeOwnerAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<PageTypeOwnerNodeAggregationWhereInput>
}

export type PageTypeOwnerConnectFieldInput = {
  connect?: InputMaybe<UserConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<UserConnectWhere>
}

export type PageTypeOwnerConnectOrCreateFieldInput = {
  onCreate: PageTypeOwnerConnectOrCreateFieldInputOnCreate
  where: UserConnectOrCreateWhere
}

export type PageTypeOwnerConnectOrCreateFieldInputOnCreate = {
  node: UserOnCreateInput
}

export type PageTypeOwnerCreateFieldInput = {
  node: UserCreateInput
}

export type PageTypeOwnerFieldInput = {
  connect?: InputMaybe<PageTypeOwnerConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<PageTypeOwnerConnectOrCreateFieldInput>
  create?: InputMaybe<PageTypeOwnerCreateFieldInput>
}

export type PageTypeOwnerNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<PageTypeOwnerNodeAggregationWhereInput>>
  NOT?: InputMaybe<PageTypeOwnerNodeAggregationWhereInput>
  OR?: InputMaybe<Array<PageTypeOwnerNodeAggregationWhereInput>>
  auth0Id_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  auth0Id_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  email_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  email_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  username_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  username_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type PageTypeOwnerUpdateConnectionInput = {
  node?: InputMaybe<UserUpdateInput>
}

export type PageTypeOwnerUpdateFieldInput = {
  connect?: InputMaybe<PageTypeOwnerConnectFieldInput>
  connectOrCreate?: InputMaybe<PageTypeOwnerConnectOrCreateFieldInput>
  create?: InputMaybe<PageTypeOwnerCreateFieldInput>
  delete?: InputMaybe<IBaseTypeOwnerDeleteFieldInput>
  disconnect?: InputMaybe<IBaseTypeOwnerDisconnectFieldInput>
  update?: InputMaybe<PageTypeOwnerUpdateConnectionInput>
  where?: InputMaybe<IBaseTypeOwnerConnectionWhere>
}

/** Fields to sort PageTypes by. The order in which sorts are applied is not guaranteed when specifying many fields in one PageTypeSort object. */
export type PageTypeSort = {
  id?: InputMaybe<SortDirection>
  kind?: InputMaybe<SortDirection>
  name?: InputMaybe<SortDirection>
}

export type PageTypeSubscriptionWhere = {
  AND?: InputMaybe<Array<PageTypeSubscriptionWhere>>
  NOT?: InputMaybe<PageTypeSubscriptionWhere>
  OR?: InputMaybe<Array<PageTypeSubscriptionWhere>>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  kind?: InputMaybe<TypeKind>
  kind_EQ?: InputMaybe<TypeKind>
  kind_IN?: InputMaybe<Array<TypeKind>>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>
  name_MATCHES?: InputMaybe<Scalars['String']['input']>
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
}

export type PageTypeUpdateInput = {
  fieldRefs?: InputMaybe<Array<PageTypeFieldRefsUpdateFieldInput>>
  /** @deprecated Please use the explicit _SET field */
  id?: InputMaybe<Scalars['ID']['input']>
  id_SET?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _SET field */
  kind?: InputMaybe<TypeKind>
  kind_SET?: InputMaybe<TypeKind>
  /** @deprecated Please use the explicit _SET field */
  name?: InputMaybe<Scalars['String']['input']>
  name_SET?: InputMaybe<Scalars['String']['input']>
  owner?: InputMaybe<PageTypeOwnerUpdateFieldInput>
}

export type PageTypeUpdatedEvent = {
  event: EventType
  previousState: PageTypeEventPayload
  timestamp: Scalars['Float']['output']
  updatedPageType: PageTypeEventPayload
}

export type PageTypeUserOwnerAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<PageTypeUserOwnerNodeAggregateSelection>
}

export type PageTypeUserOwnerNodeAggregateSelection = {
  auth0Id: StringAggregateSelection
  email: StringAggregateSelection
  id: IdAggregateSelection
  username: StringAggregateSelection
}

export type PageTypeWhere = {
  AND?: InputMaybe<Array<PageTypeWhere>>
  NOT?: InputMaybe<PageTypeWhere>
  OR?: InputMaybe<Array<PageTypeWhere>>
  fieldRefsAggregate?: InputMaybe<PageTypeFieldRefsAggregateInput>
  /** Return PageTypes where all of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_ALL?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return PageTypes where none of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_NONE?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return PageTypes where one of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_SINGLE?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return PageTypes where some of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_SOME?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return PageTypes where all of the related Fields match this filter */
  fieldRefs_ALL?: InputMaybe<FieldWhere>
  /** Return PageTypes where none of the related Fields match this filter */
  fieldRefs_NONE?: InputMaybe<FieldWhere>
  /** Return PageTypes where one of the related Fields match this filter */
  fieldRefs_SINGLE?: InputMaybe<FieldWhere>
  /** Return PageTypes where some of the related Fields match this filter */
  fieldRefs_SOME?: InputMaybe<FieldWhere>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  kind?: InputMaybe<TypeKind>
  kind_EQ?: InputMaybe<TypeKind>
  kind_IN?: InputMaybe<Array<TypeKind>>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>
  name_MATCHES?: InputMaybe<Scalars['String']['input']>
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  owner?: InputMaybe<UserWhere>
  ownerAggregate?: InputMaybe<PageTypeOwnerAggregateInput>
  ownerConnection?: InputMaybe<IBaseTypeOwnerConnectionWhere>
}

export type PageTypesConnection = {
  edges: Array<PageTypeEdge>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type PageUniqueWhere = {
  /** @deprecated Please use the explicit _EQ version */
  compositeKey?: InputMaybe<Scalars['String']['input']>
  compositeKey_EQ?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
}

export type PageUpdateInput = {
  app?: InputMaybe<PageAppUpdateFieldInput>
  /** @deprecated Please use the explicit _SET field */
  compositeKey?: InputMaybe<Scalars['String']['input']>
  compositeKey_SET?: InputMaybe<Scalars['String']['input']>
  elements?: InputMaybe<Array<PageElementsUpdateFieldInput>>
  /** @deprecated Please use the explicit _SET field */
  kind?: InputMaybe<PageKind>
  kind_SET?: InputMaybe<PageKind>
  pageContentContainer?: InputMaybe<PagePageContentContainerUpdateFieldInput>
  redirect?: InputMaybe<PageRedirectUpdateFieldInput>
  rootElement?: InputMaybe<PageRootElementUpdateFieldInput>
  store?: InputMaybe<PageStoreUpdateFieldInput>
  /** @deprecated Please use the explicit _SET field */
  urlPattern?: InputMaybe<Scalars['String']['input']>
  urlPattern_SET?: InputMaybe<Scalars['String']['input']>
}

export type PageUpdatedEvent = {
  event: EventType
  previousState: PageEventPayload
  timestamp: Scalars['Float']['output']
  updatedPage: PageEventPayload
}

export type PageWhere = {
  AND?: InputMaybe<Array<PageWhere>>
  NOT?: InputMaybe<PageWhere>
  OR?: InputMaybe<Array<PageWhere>>
  app?: InputMaybe<AppWhere>
  appAggregate?: InputMaybe<PageAppAggregateInput>
  appConnection?: InputMaybe<PageAppConnectionWhere>
  /** @deprecated Please use the explicit _EQ version */
  compositeKey?: InputMaybe<Scalars['String']['input']>
  compositeKey_CONTAINS?: InputMaybe<Scalars['String']['input']>
  compositeKey_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  compositeKey_EQ?: InputMaybe<Scalars['String']['input']>
  compositeKey_IN?: InputMaybe<Array<Scalars['String']['input']>>
  compositeKey_MATCHES?: InputMaybe<Scalars['String']['input']>
  compositeKey_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  elementsAggregate?: InputMaybe<PageElementsAggregateInput>
  /** Return Pages where all of the related PageElementsConnections match this filter */
  elementsConnection_ALL?: InputMaybe<PageElementsConnectionWhere>
  /** Return Pages where none of the related PageElementsConnections match this filter */
  elementsConnection_NONE?: InputMaybe<PageElementsConnectionWhere>
  /** Return Pages where one of the related PageElementsConnections match this filter */
  elementsConnection_SINGLE?: InputMaybe<PageElementsConnectionWhere>
  /** Return Pages where some of the related PageElementsConnections match this filter */
  elementsConnection_SOME?: InputMaybe<PageElementsConnectionWhere>
  /** Return Pages where all of the related Elements match this filter */
  elements_ALL?: InputMaybe<ElementWhere>
  /** Return Pages where none of the related Elements match this filter */
  elements_NONE?: InputMaybe<ElementWhere>
  /** Return Pages where one of the related Elements match this filter */
  elements_SINGLE?: InputMaybe<ElementWhere>
  /** Return Pages where some of the related Elements match this filter */
  elements_SOME?: InputMaybe<ElementWhere>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  kind?: InputMaybe<PageKind>
  kind_EQ?: InputMaybe<PageKind>
  kind_IN?: InputMaybe<Array<PageKind>>
  pageContentContainer?: InputMaybe<ElementWhere>
  pageContentContainerAggregate?: InputMaybe<PagePageContentContainerAggregateInput>
  pageContentContainerConnection?: InputMaybe<PagePageContentContainerConnectionWhere>
  redirect?: InputMaybe<RedirectWhere>
  redirectAggregate?: InputMaybe<PageRedirectAggregateInput>
  redirectConnection?: InputMaybe<PageRedirectConnectionWhere>
  rootElement?: InputMaybe<ElementWhere>
  rootElementAggregate?: InputMaybe<PageRootElementAggregateInput>
  rootElementConnection?: InputMaybe<PageRootElementConnectionWhere>
  store?: InputMaybe<StoreWhere>
  storeAggregate?: InputMaybe<PageStoreAggregateInput>
  storeConnection?: InputMaybe<PageStoreConnectionWhere>
  /** @deprecated Please use the explicit _EQ version */
  urlPattern?: InputMaybe<Scalars['String']['input']>
  urlPattern_CONTAINS?: InputMaybe<Scalars['String']['input']>
  urlPattern_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  urlPattern_EQ?: InputMaybe<Scalars['String']['input']>
  urlPattern_IN?: InputMaybe<Array<Scalars['String']['input']>>
  urlPattern_MATCHES?: InputMaybe<Scalars['String']['input']>
  urlPattern_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
}

export type PagesConnection = {
  edges: Array<PageEdge>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type Preference = WithOwner & {
  builderBreakpointType: BreakpointType
  builderWidth: Scalars['Float']['output']
  id: Scalars['ID']['output']
  owner: User
  ownerAggregate?: Maybe<PreferenceUserOwnerAggregationSelection>
  ownerConnection: WithOwnerOwnerConnection
}

export type PreferenceOwnerArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<UserOptions>
  sort?: InputMaybe<Array<UserSort>>
  where?: InputMaybe<UserWhere>
}

export type PreferenceOwnerAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<UserWhere>
}

export type PreferenceOwnerConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<WithOwnerOwnerConnectionSort>>
  where?: InputMaybe<WithOwnerOwnerConnectionWhere>
}

export type PreferenceAggregateSelection = {
  builderWidth: FloatAggregateSelection
  count: Scalars['Int']['output']
  id: IdAggregateSelection
}

export type PreferenceConnectInput = {
  owner?: InputMaybe<PreferenceOwnerConnectFieldInput>
}

export type PreferenceConnectOrCreateWhere = {
  node: PreferenceUniqueWhere
}

export type PreferenceConnectWhere = {
  node: PreferenceWhere
}

export type PreferenceCreateInput = {
  builderBreakpointType: BreakpointType
  builderWidth: Scalars['Float']['input']
  id: Scalars['ID']['input']
  owner?: InputMaybe<PreferenceOwnerFieldInput>
}

export type PreferenceCreatedEvent = {
  createdPreference: PreferenceEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type PreferenceDeleteInput = {
  owner?: InputMaybe<WithOwnerOwnerDeleteFieldInput>
}

export type PreferenceDeletedEvent = {
  deletedPreference: PreferenceEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type PreferenceDisconnectInput = {
  owner?: InputMaybe<WithOwnerOwnerDisconnectFieldInput>
}

export type PreferenceEdge = {
  cursor: Scalars['String']['output']
  node: Preference
}

export type PreferenceEventPayload = {
  builderBreakpointType: BreakpointType
  builderWidth: Scalars['Float']['output']
  id: Scalars['ID']['output']
}

export type PreferenceOnCreateInput = {
  builderBreakpointType: BreakpointType
  builderWidth: Scalars['Float']['input']
  id: Scalars['ID']['input']
}

export type PreferenceOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  /** Specify one or more PreferenceSort objects to sort Preferences by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<PreferenceSort>>
}

export type PreferenceOwnerAggregateInput = {
  AND?: InputMaybe<Array<PreferenceOwnerAggregateInput>>
  NOT?: InputMaybe<PreferenceOwnerAggregateInput>
  OR?: InputMaybe<Array<PreferenceOwnerAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<PreferenceOwnerNodeAggregationWhereInput>
}

export type PreferenceOwnerConnectFieldInput = {
  connect?: InputMaybe<UserConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<UserConnectWhere>
}

export type PreferenceOwnerConnectOrCreateFieldInput = {
  onCreate: PreferenceOwnerConnectOrCreateFieldInputOnCreate
  where: UserConnectOrCreateWhere
}

export type PreferenceOwnerConnectOrCreateFieldInputOnCreate = {
  node: UserOnCreateInput
}

export type PreferenceOwnerCreateFieldInput = {
  node: UserCreateInput
}

export type PreferenceOwnerFieldInput = {
  connect?: InputMaybe<PreferenceOwnerConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<PreferenceOwnerConnectOrCreateFieldInput>
  create?: InputMaybe<PreferenceOwnerCreateFieldInput>
}

export type PreferenceOwnerNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<PreferenceOwnerNodeAggregationWhereInput>>
  NOT?: InputMaybe<PreferenceOwnerNodeAggregationWhereInput>
  OR?: InputMaybe<Array<PreferenceOwnerNodeAggregationWhereInput>>
  auth0Id_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  auth0Id_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  email_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  email_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  username_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  username_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type PreferenceOwnerUpdateConnectionInput = {
  node?: InputMaybe<UserUpdateInput>
}

export type PreferenceOwnerUpdateFieldInput = {
  connect?: InputMaybe<PreferenceOwnerConnectFieldInput>
  connectOrCreate?: InputMaybe<PreferenceOwnerConnectOrCreateFieldInput>
  create?: InputMaybe<PreferenceOwnerCreateFieldInput>
  delete?: InputMaybe<WithOwnerOwnerDeleteFieldInput>
  disconnect?: InputMaybe<WithOwnerOwnerDisconnectFieldInput>
  update?: InputMaybe<PreferenceOwnerUpdateConnectionInput>
  where?: InputMaybe<WithOwnerOwnerConnectionWhere>
}

/** Fields to sort Preferences by. The order in which sorts are applied is not guaranteed when specifying many fields in one PreferenceSort object. */
export type PreferenceSort = {
  builderBreakpointType?: InputMaybe<SortDirection>
  builderWidth?: InputMaybe<SortDirection>
  id?: InputMaybe<SortDirection>
}

export type PreferenceSubscriptionWhere = {
  AND?: InputMaybe<Array<PreferenceSubscriptionWhere>>
  NOT?: InputMaybe<PreferenceSubscriptionWhere>
  OR?: InputMaybe<Array<PreferenceSubscriptionWhere>>
  /** @deprecated Please use the explicit _EQ version */
  builderBreakpointType?: InputMaybe<BreakpointType>
  builderBreakpointType_EQ?: InputMaybe<BreakpointType>
  builderBreakpointType_IN?: InputMaybe<Array<BreakpointType>>
  /** @deprecated Please use the explicit _EQ version */
  builderWidth?: InputMaybe<Scalars['Float']['input']>
  builderWidth_EQ?: InputMaybe<Scalars['Float']['input']>
  builderWidth_GT?: InputMaybe<Scalars['Float']['input']>
  builderWidth_GTE?: InputMaybe<Scalars['Float']['input']>
  builderWidth_IN?: InputMaybe<Array<Scalars['Float']['input']>>
  builderWidth_LT?: InputMaybe<Scalars['Float']['input']>
  builderWidth_LTE?: InputMaybe<Scalars['Float']['input']>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
}

export type PreferenceUniqueWhere = {
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
}

export type PreferenceUpdateInput = {
  /** @deprecated Please use the explicit _SET field */
  builderBreakpointType?: InputMaybe<BreakpointType>
  builderBreakpointType_SET?: InputMaybe<BreakpointType>
  /** @deprecated Please use the explicit _SET field */
  builderWidth?: InputMaybe<Scalars['Float']['input']>
  builderWidth_ADD?: InputMaybe<Scalars['Float']['input']>
  builderWidth_DIVIDE?: InputMaybe<Scalars['Float']['input']>
  builderWidth_MULTIPLY?: InputMaybe<Scalars['Float']['input']>
  builderWidth_SET?: InputMaybe<Scalars['Float']['input']>
  builderWidth_SUBTRACT?: InputMaybe<Scalars['Float']['input']>
  owner?: InputMaybe<PreferenceOwnerUpdateFieldInput>
}

export type PreferenceUpdatedEvent = {
  event: EventType
  previousState: PreferenceEventPayload
  timestamp: Scalars['Float']['output']
  updatedPreference: PreferenceEventPayload
}

export type PreferenceUserOwnerAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<PreferenceUserOwnerNodeAggregateSelection>
}

export type PreferenceUserOwnerNodeAggregateSelection = {
  auth0Id: StringAggregateSelection
  email: StringAggregateSelection
  id: IdAggregateSelection
  username: StringAggregateSelection
}

export type PreferenceWhere = {
  AND?: InputMaybe<Array<PreferenceWhere>>
  NOT?: InputMaybe<PreferenceWhere>
  OR?: InputMaybe<Array<PreferenceWhere>>
  /** @deprecated Please use the explicit _EQ version */
  builderBreakpointType?: InputMaybe<BreakpointType>
  builderBreakpointType_EQ?: InputMaybe<BreakpointType>
  builderBreakpointType_IN?: InputMaybe<Array<BreakpointType>>
  /** @deprecated Please use the explicit _EQ version */
  builderWidth?: InputMaybe<Scalars['Float']['input']>
  builderWidth_EQ?: InputMaybe<Scalars['Float']['input']>
  builderWidth_GT?: InputMaybe<Scalars['Float']['input']>
  builderWidth_GTE?: InputMaybe<Scalars['Float']['input']>
  builderWidth_IN?: InputMaybe<Array<Scalars['Float']['input']>>
  builderWidth_LT?: InputMaybe<Scalars['Float']['input']>
  builderWidth_LTE?: InputMaybe<Scalars['Float']['input']>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  owner?: InputMaybe<UserWhere>
  ownerAggregate?: InputMaybe<PreferenceOwnerAggregateInput>
  ownerConnection?: InputMaybe<WithOwnerOwnerConnectionWhere>
}

export type PreferencesConnection = {
  edges: Array<PreferenceEdge>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

/** Base atomic building block of the type system. Represents primitive types - String, Integer, Float, Boolean */
export type PrimitiveType = IBaseType & {
  fieldRefs: Array<Field>
  fieldRefsAggregate?: Maybe<PrimitiveTypeFieldFieldRefsAggregationSelection>
  fieldRefsConnection: IBaseTypeFieldRefsConnection
  id: Scalars['ID']['output']
  kind: TypeKind
  name: Scalars['String']['output']
  owner: User
  ownerAggregate?: Maybe<PrimitiveTypeUserOwnerAggregationSelection>
  ownerConnection: IBaseTypeOwnerConnection
  primitiveKind: PrimitiveTypeKind
}

/** Base atomic building block of the type system. Represents primitive types - String, Integer, Float, Boolean */
export type PrimitiveTypeFieldRefsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<FieldOptions>
  sort?: InputMaybe<Array<FieldSort>>
  where?: InputMaybe<FieldWhere>
}

/** Base atomic building block of the type system. Represents primitive types - String, Integer, Float, Boolean */
export type PrimitiveTypeFieldRefsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<FieldWhere>
}

/** Base atomic building block of the type system. Represents primitive types - String, Integer, Float, Boolean */
export type PrimitiveTypeFieldRefsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<IBaseTypeFieldRefsConnectionSort>>
  where?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
}

/** Base atomic building block of the type system. Represents primitive types - String, Integer, Float, Boolean */
export type PrimitiveTypeOwnerArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<UserOptions>
  sort?: InputMaybe<Array<UserSort>>
  where?: InputMaybe<UserWhere>
}

/** Base atomic building block of the type system. Represents primitive types - String, Integer, Float, Boolean */
export type PrimitiveTypeOwnerAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<UserWhere>
}

/** Base atomic building block of the type system. Represents primitive types - String, Integer, Float, Boolean */
export type PrimitiveTypeOwnerConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<IBaseTypeOwnerConnectionSort>>
  where?: InputMaybe<IBaseTypeOwnerConnectionWhere>
}

export type PrimitiveTypeAggregateSelection = {
  count: Scalars['Int']['output']
  id: IdAggregateSelection
  name: StringAggregateSelection
}

export type PrimitiveTypeConnectInput = {
  fieldRefs?: InputMaybe<Array<PrimitiveTypeFieldRefsConnectFieldInput>>
  owner?: InputMaybe<PrimitiveTypeOwnerConnectFieldInput>
}

export type PrimitiveTypeConnectOrCreateWhere = {
  node: PrimitiveTypeUniqueWhere
}

export type PrimitiveTypeConnectWhere = {
  node: PrimitiveTypeWhere
}

export type PrimitiveTypeCreateInput = {
  fieldRefs?: InputMaybe<PrimitiveTypeFieldRefsFieldInput>
  id: Scalars['ID']['input']
  kind?: TypeKind
  name: Scalars['String']['input']
  owner?: InputMaybe<PrimitiveTypeOwnerFieldInput>
  primitiveKind: PrimitiveTypeKind
}

export type PrimitiveTypeCreatedEvent = {
  createdPrimitiveType: PrimitiveTypeEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type PrimitiveTypeDeleteInput = {
  fieldRefs?: InputMaybe<Array<IBaseTypeFieldRefsDeleteFieldInput>>
  owner?: InputMaybe<IBaseTypeOwnerDeleteFieldInput>
}

export type PrimitiveTypeDeletedEvent = {
  deletedPrimitiveType: PrimitiveTypeEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type PrimitiveTypeDisconnectInput = {
  fieldRefs?: InputMaybe<Array<IBaseTypeFieldRefsDisconnectFieldInput>>
  owner?: InputMaybe<IBaseTypeOwnerDisconnectFieldInput>
}

export type PrimitiveTypeEdge = {
  cursor: Scalars['String']['output']
  node: PrimitiveType
}

export type PrimitiveTypeEventPayload = {
  id: Scalars['ID']['output']
  kind: TypeKind
  name: Scalars['String']['output']
  primitiveKind: PrimitiveTypeKind
}

export type PrimitiveTypeFieldFieldRefsAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<PrimitiveTypeFieldFieldRefsNodeAggregateSelection>
}

export type PrimitiveTypeFieldFieldRefsNodeAggregateSelection = {
  defaultValues: StringAggregateSelection
  description: StringAggregateSelection
  id: IdAggregateSelection
  key: StringAggregateSelection
  name: StringAggregateSelection
  validationRules: StringAggregateSelection
}

export type PrimitiveTypeFieldRefsAggregateInput = {
  AND?: InputMaybe<Array<PrimitiveTypeFieldRefsAggregateInput>>
  NOT?: InputMaybe<PrimitiveTypeFieldRefsAggregateInput>
  OR?: InputMaybe<Array<PrimitiveTypeFieldRefsAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<PrimitiveTypeFieldRefsNodeAggregationWhereInput>
}

export type PrimitiveTypeFieldRefsConnectFieldInput = {
  connect?: InputMaybe<Array<FieldConnectInput>>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<FieldConnectWhere>
}

export type PrimitiveTypeFieldRefsConnectOrCreateFieldInput = {
  onCreate: PrimitiveTypeFieldRefsConnectOrCreateFieldInputOnCreate
  where: FieldConnectOrCreateWhere
}

export type PrimitiveTypeFieldRefsConnectOrCreateFieldInputOnCreate = {
  node: FieldOnCreateInput
}

export type PrimitiveTypeFieldRefsCreateFieldInput = {
  node: FieldCreateInput
}

export type PrimitiveTypeFieldRefsFieldInput = {
  connect?: InputMaybe<Array<PrimitiveTypeFieldRefsConnectFieldInput>>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<
    Array<PrimitiveTypeFieldRefsConnectOrCreateFieldInput>
  >
  create?: InputMaybe<Array<PrimitiveTypeFieldRefsCreateFieldInput>>
}

export type PrimitiveTypeFieldRefsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<PrimitiveTypeFieldRefsNodeAggregationWhereInput>>
  NOT?: InputMaybe<PrimitiveTypeFieldRefsNodeAggregationWhereInput>
  OR?: InputMaybe<Array<PrimitiveTypeFieldRefsNodeAggregationWhereInput>>
  defaultValues_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  defaultValues_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  description_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  description_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  key_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  key_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  validationRules_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type PrimitiveTypeFieldRefsUpdateConnectionInput = {
  node?: InputMaybe<FieldUpdateInput>
}

export type PrimitiveTypeFieldRefsUpdateFieldInput = {
  connect?: InputMaybe<Array<PrimitiveTypeFieldRefsConnectFieldInput>>
  connectOrCreate?: InputMaybe<
    Array<PrimitiveTypeFieldRefsConnectOrCreateFieldInput>
  >
  create?: InputMaybe<Array<PrimitiveTypeFieldRefsCreateFieldInput>>
  delete?: InputMaybe<Array<IBaseTypeFieldRefsDeleteFieldInput>>
  disconnect?: InputMaybe<Array<IBaseTypeFieldRefsDisconnectFieldInput>>
  update?: InputMaybe<PrimitiveTypeFieldRefsUpdateConnectionInput>
  where?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
}

export enum PrimitiveTypeKind {
  Boolean = 'Boolean',
  Integer = 'Integer',
  Number = 'Number',
  String = 'String',
}

export type PrimitiveTypeOnCreateInput = {
  id: Scalars['ID']['input']
  kind?: TypeKind
  name: Scalars['String']['input']
  primitiveKind: PrimitiveTypeKind
}

export type PrimitiveTypeOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  /** Specify one or more PrimitiveTypeSort objects to sort PrimitiveTypes by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<PrimitiveTypeSort>>
}

export type PrimitiveTypeOwnerAggregateInput = {
  AND?: InputMaybe<Array<PrimitiveTypeOwnerAggregateInput>>
  NOT?: InputMaybe<PrimitiveTypeOwnerAggregateInput>
  OR?: InputMaybe<Array<PrimitiveTypeOwnerAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<PrimitiveTypeOwnerNodeAggregationWhereInput>
}

export type PrimitiveTypeOwnerConnectFieldInput = {
  connect?: InputMaybe<UserConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<UserConnectWhere>
}

export type PrimitiveTypeOwnerConnectOrCreateFieldInput = {
  onCreate: PrimitiveTypeOwnerConnectOrCreateFieldInputOnCreate
  where: UserConnectOrCreateWhere
}

export type PrimitiveTypeOwnerConnectOrCreateFieldInputOnCreate = {
  node: UserOnCreateInput
}

export type PrimitiveTypeOwnerCreateFieldInput = {
  node: UserCreateInput
}

export type PrimitiveTypeOwnerFieldInput = {
  connect?: InputMaybe<PrimitiveTypeOwnerConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<PrimitiveTypeOwnerConnectOrCreateFieldInput>
  create?: InputMaybe<PrimitiveTypeOwnerCreateFieldInput>
}

export type PrimitiveTypeOwnerNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<PrimitiveTypeOwnerNodeAggregationWhereInput>>
  NOT?: InputMaybe<PrimitiveTypeOwnerNodeAggregationWhereInput>
  OR?: InputMaybe<Array<PrimitiveTypeOwnerNodeAggregationWhereInput>>
  auth0Id_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  auth0Id_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  email_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  email_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  username_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  username_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type PrimitiveTypeOwnerUpdateConnectionInput = {
  node?: InputMaybe<UserUpdateInput>
}

export type PrimitiveTypeOwnerUpdateFieldInput = {
  connect?: InputMaybe<PrimitiveTypeOwnerConnectFieldInput>
  connectOrCreate?: InputMaybe<PrimitiveTypeOwnerConnectOrCreateFieldInput>
  create?: InputMaybe<PrimitiveTypeOwnerCreateFieldInput>
  delete?: InputMaybe<IBaseTypeOwnerDeleteFieldInput>
  disconnect?: InputMaybe<IBaseTypeOwnerDisconnectFieldInput>
  update?: InputMaybe<PrimitiveTypeOwnerUpdateConnectionInput>
  where?: InputMaybe<IBaseTypeOwnerConnectionWhere>
}

/** Fields to sort PrimitiveTypes by. The order in which sorts are applied is not guaranteed when specifying many fields in one PrimitiveTypeSort object. */
export type PrimitiveTypeSort = {
  id?: InputMaybe<SortDirection>
  kind?: InputMaybe<SortDirection>
  name?: InputMaybe<SortDirection>
  primitiveKind?: InputMaybe<SortDirection>
}

export type PrimitiveTypeSubscriptionWhere = {
  AND?: InputMaybe<Array<PrimitiveTypeSubscriptionWhere>>
  NOT?: InputMaybe<PrimitiveTypeSubscriptionWhere>
  OR?: InputMaybe<Array<PrimitiveTypeSubscriptionWhere>>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  kind?: InputMaybe<TypeKind>
  kind_EQ?: InputMaybe<TypeKind>
  kind_IN?: InputMaybe<Array<TypeKind>>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>
  name_MATCHES?: InputMaybe<Scalars['String']['input']>
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  primitiveKind?: InputMaybe<PrimitiveTypeKind>
  primitiveKind_EQ?: InputMaybe<PrimitiveTypeKind>
  primitiveKind_IN?: InputMaybe<Array<PrimitiveTypeKind>>
}

export type PrimitiveTypeUniqueWhere = {
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  primitiveKind?: InputMaybe<PrimitiveTypeKind>
  primitiveKind_EQ?: InputMaybe<PrimitiveTypeKind>
}

export type PrimitiveTypeUpdateInput = {
  fieldRefs?: InputMaybe<Array<PrimitiveTypeFieldRefsUpdateFieldInput>>
  /** @deprecated Please use the explicit _SET field */
  id?: InputMaybe<Scalars['ID']['input']>
  id_SET?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _SET field */
  kind?: InputMaybe<TypeKind>
  kind_SET?: InputMaybe<TypeKind>
  /** @deprecated Please use the explicit _SET field */
  name?: InputMaybe<Scalars['String']['input']>
  name_SET?: InputMaybe<Scalars['String']['input']>
  owner?: InputMaybe<PrimitiveTypeOwnerUpdateFieldInput>
  /** @deprecated Please use the explicit _SET field */
  primitiveKind?: InputMaybe<PrimitiveTypeKind>
  primitiveKind_SET?: InputMaybe<PrimitiveTypeKind>
}

export type PrimitiveTypeUpdatedEvent = {
  event: EventType
  previousState: PrimitiveTypeEventPayload
  timestamp: Scalars['Float']['output']
  updatedPrimitiveType: PrimitiveTypeEventPayload
}

export type PrimitiveTypeUserOwnerAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<PrimitiveTypeUserOwnerNodeAggregateSelection>
}

export type PrimitiveTypeUserOwnerNodeAggregateSelection = {
  auth0Id: StringAggregateSelection
  email: StringAggregateSelection
  id: IdAggregateSelection
  username: StringAggregateSelection
}

export type PrimitiveTypeWhere = {
  AND?: InputMaybe<Array<PrimitiveTypeWhere>>
  NOT?: InputMaybe<PrimitiveTypeWhere>
  OR?: InputMaybe<Array<PrimitiveTypeWhere>>
  fieldRefsAggregate?: InputMaybe<PrimitiveTypeFieldRefsAggregateInput>
  /** Return PrimitiveTypes where all of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_ALL?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return PrimitiveTypes where none of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_NONE?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return PrimitiveTypes where one of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_SINGLE?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return PrimitiveTypes where some of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_SOME?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return PrimitiveTypes where all of the related Fields match this filter */
  fieldRefs_ALL?: InputMaybe<FieldWhere>
  /** Return PrimitiveTypes where none of the related Fields match this filter */
  fieldRefs_NONE?: InputMaybe<FieldWhere>
  /** Return PrimitiveTypes where one of the related Fields match this filter */
  fieldRefs_SINGLE?: InputMaybe<FieldWhere>
  /** Return PrimitiveTypes where some of the related Fields match this filter */
  fieldRefs_SOME?: InputMaybe<FieldWhere>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  kind?: InputMaybe<TypeKind>
  kind_EQ?: InputMaybe<TypeKind>
  kind_IN?: InputMaybe<Array<TypeKind>>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>
  name_MATCHES?: InputMaybe<Scalars['String']['input']>
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  owner?: InputMaybe<UserWhere>
  ownerAggregate?: InputMaybe<PrimitiveTypeOwnerAggregateInput>
  ownerConnection?: InputMaybe<IBaseTypeOwnerConnectionWhere>
  /** @deprecated Please use the explicit _EQ version */
  primitiveKind?: InputMaybe<PrimitiveTypeKind>
  primitiveKind_EQ?: InputMaybe<PrimitiveTypeKind>
  primitiveKind_IN?: InputMaybe<Array<PrimitiveTypeKind>>
}

export type PrimitiveTypesConnection = {
  edges: Array<PrimitiveTypeEdge>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type ProductionDomainConfig = {
  misconfigured: Scalars['Boolean']['output']
}

export type ProductionDomainConfigCreatedEvent = {
  createdProductionDomainConfig: ProductionDomainConfigEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type ProductionDomainConfigDeletedEvent = {
  deletedProductionDomainConfig: ProductionDomainConfigEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type ProductionDomainConfigEventPayload = {
  misconfigured: Scalars['Boolean']['output']
}

export type ProductionDomainConfigSubscriptionWhere = {
  AND?: InputMaybe<Array<ProductionDomainConfigSubscriptionWhere>>
  NOT?: InputMaybe<ProductionDomainConfigSubscriptionWhere>
  OR?: InputMaybe<Array<ProductionDomainConfigSubscriptionWhere>>
  /** @deprecated Please use the explicit _EQ version */
  misconfigured?: InputMaybe<Scalars['Boolean']['input']>
  misconfigured_EQ?: InputMaybe<Scalars['Boolean']['input']>
}

export type ProductionDomainConfigUpdatedEvent = {
  event: EventType
  previousState: ProductionDomainConfigEventPayload
  timestamp: Scalars['Float']['output']
  updatedProductionDomainConfig: ProductionDomainConfigEventPayload
}

export type Prop = {
  data: Scalars['String']['output']
  id: Scalars['ID']['output']
}

export type PropAggregateSelection = {
  count: Scalars['Int']['output']
  data: StringAggregateSelection
  id: IdAggregateSelection
}

export type PropConnectOrCreateWhere = {
  node: PropUniqueWhere
}

export type PropConnectWhere = {
  node: PropWhere
}

export type PropCreateInput = {
  data: Scalars['String']['input']
  id: Scalars['ID']['input']
}

export type PropCreatedEvent = {
  createdProp: PropEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type PropDeletedEvent = {
  deletedProp: PropEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type PropEdge = {
  cursor: Scalars['String']['output']
  node: Prop
}

export type PropEventPayload = {
  data: Scalars['String']['output']
  id: Scalars['ID']['output']
}

export type PropOnCreateInput = {
  data: Scalars['String']['input']
  id: Scalars['ID']['input']
}

export type PropOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  /** Specify one or more PropSort objects to sort Props by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<PropSort>>
}

/** Fields to sort Props by. The order in which sorts are applied is not guaranteed when specifying many fields in one PropSort object. */
export type PropSort = {
  data?: InputMaybe<SortDirection>
  id?: InputMaybe<SortDirection>
}

export type PropSubscriptionWhere = {
  AND?: InputMaybe<Array<PropSubscriptionWhere>>
  NOT?: InputMaybe<PropSubscriptionWhere>
  OR?: InputMaybe<Array<PropSubscriptionWhere>>
  /** @deprecated Please use the explicit _EQ version */
  data?: InputMaybe<Scalars['String']['input']>
  data_CONTAINS?: InputMaybe<Scalars['String']['input']>
  data_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  data_EQ?: InputMaybe<Scalars['String']['input']>
  data_IN?: InputMaybe<Array<Scalars['String']['input']>>
  data_MATCHES?: InputMaybe<Scalars['String']['input']>
  data_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
}

export type PropUniqueWhere = {
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
}

export type PropUpdateInput = {
  /** @deprecated Please use the explicit _SET field */
  data?: InputMaybe<Scalars['String']['input']>
  data_SET?: InputMaybe<Scalars['String']['input']>
}

export type PropUpdatedEvent = {
  event: EventType
  previousState: PropEventPayload
  timestamp: Scalars['Float']['output']
  updatedProp: PropEventPayload
}

export type PropWhere = {
  AND?: InputMaybe<Array<PropWhere>>
  NOT?: InputMaybe<PropWhere>
  OR?: InputMaybe<Array<PropWhere>>
  /** @deprecated Please use the explicit _EQ version */
  data?: InputMaybe<Scalars['String']['input']>
  data_CONTAINS?: InputMaybe<Scalars['String']['input']>
  data_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  data_EQ?: InputMaybe<Scalars['String']['input']>
  data_IN?: InputMaybe<Array<Scalars['String']['input']>>
  data_MATCHES?: InputMaybe<Scalars['String']['input']>
  data_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
}

export type PropsConnection = {
  edges: Array<PropEdge>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type Query = {
  actionTypes: Array<ActionType>
  actionTypesAggregate: ActionTypeAggregateSelection
  actionTypesConnection: ActionTypesConnection
  anyActions: Array<AnyAction>
  anyTypes: Array<AnyType>
  apiActions: Array<ApiAction>
  apiActionsAggregate: ApiActionAggregateSelection
  apiActionsConnection: ApiActionsConnection
  appTypes: Array<AppType>
  appTypesAggregate: AppTypeAggregateSelection
  appTypesConnection: AppTypesConnection
  apps: Array<App>
  appsAggregate: AppAggregateSelection
  appsConnection: AppsConnection
  arrayTypes: Array<ArrayType>
  arrayTypesAggregate: ArrayTypeAggregateSelection
  arrayTypesConnection: ArrayTypesConnection
  atoms: Array<Atom>
  atomsAggregate: AtomAggregateSelection
  atomsConnection: AtomsConnection
  authGuards: Array<AuthGuard>
  authGuardsAggregate: AuthGuardAggregateSelection
  authGuardsConnection: AuthGuardsConnection
  baseActions: Array<BaseAction>
  baseActionsAggregate: BaseActionAggregateSelection
  baseActionsConnection: BaseActionsConnection
  codeActions: Array<CodeAction>
  codeActionsAggregate: CodeActionAggregateSelection
  codeActionsConnection: CodeActionsConnection
  codeMirrorTypes: Array<CodeMirrorType>
  codeMirrorTypesAggregate: CodeMirrorTypeAggregateSelection
  codeMirrorTypesConnection: CodeMirrorTypesConnection
  components: Array<Component>
  componentsAggregate: ComponentAggregateSelection
  componentsConnection: ComponentsConnection
  containerNodes: Array<ContainerNode>
  domains: Array<Domain>
  domainsAggregate: DomainAggregateSelection
  domainsConnection: DomainsConnection
  elementRenderTypes: Array<ElementRenderType>
  elementTypes: Array<ElementType>
  elementTypesAggregate: ElementTypeAggregateSelection
  elementTypesConnection: ElementTypesConnection
  elements: Array<Element>
  elementsAggregate: ElementAggregateSelection
  elementsConnection: ElementsConnection
  enumTypeValues: Array<EnumTypeValue>
  enumTypeValuesAggregate: EnumTypeValueAggregateSelection
  enumTypeValuesConnection: EnumTypeValuesConnection
  enumTypes: Array<EnumType>
  enumTypesAggregate: EnumTypeAggregateSelection
  enumTypesConnection: EnumTypesConnection
  fields: Array<Field>
  fieldsAggregate: FieldAggregateSelection
  fieldsConnection: FieldsConnection
  /**
   * Returns a list of all Type and Atom entities that reference the type with the given id
   * This could be different types of relationships like Atom-Api, ArrayType-itemType, InterfaceType-field, UnionType-unionTypeChild
   */
  getTypeReferences?: Maybe<Array<TypeReference>>
  hooks: Array<Hook>
  hooksAggregate: HookAggregateSelection
  hooksConnection: HooksConnection
  iBaseTypes: Array<IBaseType>
  iBaseTypesAggregate: IBaseTypeAggregateSelection
  iBaseTypesConnection: IBaseTypesConnection
  interfaceTypes: Array<InterfaceType>
  interfaceTypesAggregate: InterfaceTypeAggregateSelection
  interfaceTypesConnection: InterfaceTypesConnection
  /** Does a recursive check to see if the parent type (parentTypeId) contains the descendant type (descendantTypeId) at any level of nesting. Useful for checking for recursion */
  isTypeDescendantOf?: Maybe<Scalars['Boolean']['output']>
  lambdaTypes: Array<LambdaType>
  lambdaTypesAggregate: LambdaTypeAggregateSelection
  lambdaTypesConnection: LambdaTypesConnection
  pageTypes: Array<PageType>
  pageTypesAggregate: PageTypeAggregateSelection
  pageTypesConnection: PageTypesConnection
  pages: Array<Page>
  pagesAggregate: PageAggregateSelection
  pagesConnection: PagesConnection
  preferences: Array<Preference>
  preferencesAggregate: PreferenceAggregateSelection
  preferencesConnection: PreferencesConnection
  primitiveTypes: Array<PrimitiveType>
  primitiveTypesAggregate: PrimitiveTypeAggregateSelection
  primitiveTypesConnection: PrimitiveTypesConnection
  props: Array<Prop>
  propsAggregate: PropAggregateSelection
  propsConnection: PropsConnection
  reactNodeTypes: Array<ReactNodeType>
  reactNodeTypesAggregate: ReactNodeTypeAggregateSelection
  reactNodeTypesConnection: ReactNodeTypesConnection
  redirects: Array<Redirect>
  redirectsAggregate: RedirectAggregateSelection
  redirectsConnection: RedirectsConnection
  renderPropTypes: Array<RenderPropType>
  renderPropTypesAggregate: RenderPropTypeAggregateSelection
  renderPropTypesConnection: RenderPropTypesConnection
  resources: Array<Resource>
  resourcesAggregate: ResourceAggregateSelection
  resourcesConnection: ResourcesConnection
  richTextTypes: Array<RichTextType>
  richTextTypesAggregate: RichTextTypeAggregateSelection
  richTextTypesConnection: RichTextTypesConnection
  stores: Array<Store>
  storesAggregate: StoreAggregateSelection
  storesConnection: StoresConnection
  tags: Array<Tag>
  tagsAggregate: TagAggregateSelection
  tagsConnection: TagsConnection
  typeReferences: Array<TypeReference>
  typeReferencesAggregate: TypeReferenceAggregateSelection
  typeReferencesConnection: TypeReferencesConnection
  unionTypes: Array<UnionType>
  unionTypesAggregate: UnionTypeAggregateSelection
  unionTypesConnection: UnionTypesConnection
  users: Array<User>
  usersAggregate: UserAggregateSelection
  usersConnection: UsersConnection
  withDescendants: Array<WithDescendants>
  withDescendantsAggregate: WithDescendantsAggregateSelection
  withDescendantsConnection: WithDescendantsConnection
  withOwners: Array<WithOwner>
  withOwnersAggregate: WithOwnerAggregateSelection
  withOwnersConnection: WithOwnersConnection
}

export type QueryActionTypesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<ActionTypeOptions>
  sort?: InputMaybe<Array<ActionTypeSort>>
  where?: InputMaybe<ActionTypeWhere>
}

export type QueryActionTypesAggregateArgs = {
  where?: InputMaybe<ActionTypeWhere>
}

export type QueryActionTypesConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<ActionTypeSort>>
  where?: InputMaybe<ActionTypeWhere>
}

export type QueryAnyActionsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<QueryOptions>
  where?: InputMaybe<AnyActionWhere>
}

export type QueryAnyTypesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<QueryOptions>
  where?: InputMaybe<AnyTypeWhere>
}

export type QueryApiActionsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<ApiActionOptions>
  sort?: InputMaybe<Array<ApiActionSort>>
  where?: InputMaybe<ApiActionWhere>
}

export type QueryApiActionsAggregateArgs = {
  where?: InputMaybe<ApiActionWhere>
}

export type QueryApiActionsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<ApiActionSort>>
  where?: InputMaybe<ApiActionWhere>
}

export type QueryAppTypesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<AppTypeOptions>
  sort?: InputMaybe<Array<AppTypeSort>>
  where?: InputMaybe<AppTypeWhere>
}

export type QueryAppTypesAggregateArgs = {
  where?: InputMaybe<AppTypeWhere>
}

export type QueryAppTypesConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<AppTypeSort>>
  where?: InputMaybe<AppTypeWhere>
}

export type QueryAppsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<AppOptions>
  sort?: InputMaybe<Array<AppSort>>
  where?: InputMaybe<AppWhere>
}

export type QueryAppsAggregateArgs = {
  where?: InputMaybe<AppWhere>
}

export type QueryAppsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<AppSort>>
  where?: InputMaybe<AppWhere>
}

export type QueryArrayTypesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<ArrayTypeOptions>
  sort?: InputMaybe<Array<ArrayTypeSort>>
  where?: InputMaybe<ArrayTypeWhere>
}

export type QueryArrayTypesAggregateArgs = {
  where?: InputMaybe<ArrayTypeWhere>
}

export type QueryArrayTypesConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<ArrayTypeSort>>
  where?: InputMaybe<ArrayTypeWhere>
}

export type QueryAtomsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<AtomOptions>
  sort?: InputMaybe<Array<AtomSort>>
  where?: InputMaybe<AtomWhere>
}

export type QueryAtomsAggregateArgs = {
  where?: InputMaybe<AtomWhere>
}

export type QueryAtomsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<AtomSort>>
  where?: InputMaybe<AtomWhere>
}

export type QueryAuthGuardsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<AuthGuardOptions>
  sort?: InputMaybe<Array<AuthGuardSort>>
  where?: InputMaybe<AuthGuardWhere>
}

export type QueryAuthGuardsAggregateArgs = {
  where?: InputMaybe<AuthGuardWhere>
}

export type QueryAuthGuardsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<AuthGuardSort>>
  where?: InputMaybe<AuthGuardWhere>
}

export type QueryBaseActionsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<BaseActionOptions>
  sort?: InputMaybe<Array<BaseActionSort>>
  where?: InputMaybe<BaseActionWhere>
}

export type QueryBaseActionsAggregateArgs = {
  where?: InputMaybe<BaseActionWhere>
}

export type QueryBaseActionsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<BaseActionSort>>
  where?: InputMaybe<BaseActionWhere>
}

export type QueryCodeActionsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<CodeActionOptions>
  sort?: InputMaybe<Array<CodeActionSort>>
  where?: InputMaybe<CodeActionWhere>
}

export type QueryCodeActionsAggregateArgs = {
  where?: InputMaybe<CodeActionWhere>
}

export type QueryCodeActionsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<CodeActionSort>>
  where?: InputMaybe<CodeActionWhere>
}

export type QueryCodeMirrorTypesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<CodeMirrorTypeOptions>
  sort?: InputMaybe<Array<CodeMirrorTypeSort>>
  where?: InputMaybe<CodeMirrorTypeWhere>
}

export type QueryCodeMirrorTypesAggregateArgs = {
  where?: InputMaybe<CodeMirrorTypeWhere>
}

export type QueryCodeMirrorTypesConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<CodeMirrorTypeSort>>
  where?: InputMaybe<CodeMirrorTypeWhere>
}

export type QueryComponentsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<ComponentOptions>
  sort?: InputMaybe<Array<ComponentSort>>
  where?: InputMaybe<ComponentWhere>
}

export type QueryComponentsAggregateArgs = {
  where?: InputMaybe<ComponentWhere>
}

export type QueryComponentsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<ComponentSort>>
  where?: InputMaybe<ComponentWhere>
}

export type QueryContainerNodesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<QueryOptions>
  where?: InputMaybe<ContainerNodeWhere>
}

export type QueryDomainsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<DomainOptions>
  sort?: InputMaybe<Array<DomainSort>>
  where?: InputMaybe<DomainWhere>
}

export type QueryDomainsAggregateArgs = {
  where?: InputMaybe<DomainWhere>
}

export type QueryDomainsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<DomainSort>>
  where?: InputMaybe<DomainWhere>
}

export type QueryElementRenderTypesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<QueryOptions>
  where?: InputMaybe<ElementRenderTypeWhere>
}

export type QueryElementTypesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<ElementTypeOptions>
  sort?: InputMaybe<Array<ElementTypeSort>>
  where?: InputMaybe<ElementTypeWhere>
}

export type QueryElementTypesAggregateArgs = {
  where?: InputMaybe<ElementTypeWhere>
}

export type QueryElementTypesConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<ElementTypeSort>>
  where?: InputMaybe<ElementTypeWhere>
}

export type QueryElementsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<ElementOptions>
  sort?: InputMaybe<Array<ElementSort>>
  where?: InputMaybe<ElementWhere>
}

export type QueryElementsAggregateArgs = {
  where?: InputMaybe<ElementWhere>
}

export type QueryElementsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<ElementSort>>
  where?: InputMaybe<ElementWhere>
}

export type QueryEnumTypeValuesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<EnumTypeValueOptions>
  sort?: InputMaybe<Array<EnumTypeValueSort>>
  where?: InputMaybe<EnumTypeValueWhere>
}

export type QueryEnumTypeValuesAggregateArgs = {
  where?: InputMaybe<EnumTypeValueWhere>
}

export type QueryEnumTypeValuesConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<EnumTypeValueSort>>
  where?: InputMaybe<EnumTypeValueWhere>
}

export type QueryEnumTypesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<EnumTypeOptions>
  sort?: InputMaybe<Array<EnumTypeSort>>
  where?: InputMaybe<EnumTypeWhere>
}

export type QueryEnumTypesAggregateArgs = {
  where?: InputMaybe<EnumTypeWhere>
}

export type QueryEnumTypesConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<EnumTypeSort>>
  where?: InputMaybe<EnumTypeWhere>
}

export type QueryFieldsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<FieldOptions>
  sort?: InputMaybe<Array<FieldSort>>
  where?: InputMaybe<FieldWhere>
}

export type QueryFieldsAggregateArgs = {
  where?: InputMaybe<FieldWhere>
}

export type QueryFieldsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<FieldSort>>
  where?: InputMaybe<FieldWhere>
}

export type QueryGetTypeReferencesArgs = {
  typeId: Scalars['ID']['input']
}

export type QueryHooksArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<HookOptions>
  sort?: InputMaybe<Array<HookSort>>
  where?: InputMaybe<HookWhere>
}

export type QueryHooksAggregateArgs = {
  where?: InputMaybe<HookWhere>
}

export type QueryHooksConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<HookSort>>
  where?: InputMaybe<HookWhere>
}

export type QueryIBaseTypesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<IBaseTypeOptions>
  sort?: InputMaybe<Array<IBaseTypeSort>>
  where?: InputMaybe<IBaseTypeWhere>
}

export type QueryIBaseTypesAggregateArgs = {
  where?: InputMaybe<IBaseTypeWhere>
}

export type QueryIBaseTypesConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<IBaseTypeSort>>
  where?: InputMaybe<IBaseTypeWhere>
}

export type QueryInterfaceTypesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<InterfaceTypeOptions>
  sort?: InputMaybe<Array<InterfaceTypeSort>>
  where?: InputMaybe<InterfaceTypeWhere>
}

export type QueryInterfaceTypesAggregateArgs = {
  where?: InputMaybe<InterfaceTypeWhere>
}

export type QueryInterfaceTypesConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<InterfaceTypeSort>>
  where?: InputMaybe<InterfaceTypeWhere>
}

export type QueryIsTypeDescendantOfArgs = {
  descendantTypeId: Scalars['ID']['input']
  parentTypeId: Scalars['ID']['input']
}

export type QueryLambdaTypesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<LambdaTypeOptions>
  sort?: InputMaybe<Array<LambdaTypeSort>>
  where?: InputMaybe<LambdaTypeWhere>
}

export type QueryLambdaTypesAggregateArgs = {
  where?: InputMaybe<LambdaTypeWhere>
}

export type QueryLambdaTypesConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<LambdaTypeSort>>
  where?: InputMaybe<LambdaTypeWhere>
}

export type QueryPageTypesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<PageTypeOptions>
  sort?: InputMaybe<Array<PageTypeSort>>
  where?: InputMaybe<PageTypeWhere>
}

export type QueryPageTypesAggregateArgs = {
  where?: InputMaybe<PageTypeWhere>
}

export type QueryPageTypesConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<PageTypeSort>>
  where?: InputMaybe<PageTypeWhere>
}

export type QueryPagesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<PageOptions>
  sort?: InputMaybe<Array<PageSort>>
  where?: InputMaybe<PageWhere>
}

export type QueryPagesAggregateArgs = {
  where?: InputMaybe<PageWhere>
}

export type QueryPagesConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<PageSort>>
  where?: InputMaybe<PageWhere>
}

export type QueryPreferencesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<PreferenceOptions>
  sort?: InputMaybe<Array<PreferenceSort>>
  where?: InputMaybe<PreferenceWhere>
}

export type QueryPreferencesAggregateArgs = {
  where?: InputMaybe<PreferenceWhere>
}

export type QueryPreferencesConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<PreferenceSort>>
  where?: InputMaybe<PreferenceWhere>
}

export type QueryPrimitiveTypesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<PrimitiveTypeOptions>
  sort?: InputMaybe<Array<PrimitiveTypeSort>>
  where?: InputMaybe<PrimitiveTypeWhere>
}

export type QueryPrimitiveTypesAggregateArgs = {
  where?: InputMaybe<PrimitiveTypeWhere>
}

export type QueryPrimitiveTypesConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<PrimitiveTypeSort>>
  where?: InputMaybe<PrimitiveTypeWhere>
}

export type QueryPropsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<PropOptions>
  sort?: InputMaybe<Array<PropSort>>
  where?: InputMaybe<PropWhere>
}

export type QueryPropsAggregateArgs = {
  where?: InputMaybe<PropWhere>
}

export type QueryPropsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<PropSort>>
  where?: InputMaybe<PropWhere>
}

export type QueryReactNodeTypesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<ReactNodeTypeOptions>
  sort?: InputMaybe<Array<ReactNodeTypeSort>>
  where?: InputMaybe<ReactNodeTypeWhere>
}

export type QueryReactNodeTypesAggregateArgs = {
  where?: InputMaybe<ReactNodeTypeWhere>
}

export type QueryReactNodeTypesConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<ReactNodeTypeSort>>
  where?: InputMaybe<ReactNodeTypeWhere>
}

export type QueryRedirectsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<RedirectOptions>
  sort?: InputMaybe<Array<RedirectSort>>
  where?: InputMaybe<RedirectWhere>
}

export type QueryRedirectsAggregateArgs = {
  where?: InputMaybe<RedirectWhere>
}

export type QueryRedirectsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<RedirectSort>>
  where?: InputMaybe<RedirectWhere>
}

export type QueryRenderPropTypesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<RenderPropTypeOptions>
  sort?: InputMaybe<Array<RenderPropTypeSort>>
  where?: InputMaybe<RenderPropTypeWhere>
}

export type QueryRenderPropTypesAggregateArgs = {
  where?: InputMaybe<RenderPropTypeWhere>
}

export type QueryRenderPropTypesConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<RenderPropTypeSort>>
  where?: InputMaybe<RenderPropTypeWhere>
}

export type QueryResourcesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<ResourceOptions>
  sort?: InputMaybe<Array<ResourceSort>>
  where?: InputMaybe<ResourceWhere>
}

export type QueryResourcesAggregateArgs = {
  where?: InputMaybe<ResourceWhere>
}

export type QueryResourcesConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<ResourceSort>>
  where?: InputMaybe<ResourceWhere>
}

export type QueryRichTextTypesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<RichTextTypeOptions>
  sort?: InputMaybe<Array<RichTextTypeSort>>
  where?: InputMaybe<RichTextTypeWhere>
}

export type QueryRichTextTypesAggregateArgs = {
  where?: InputMaybe<RichTextTypeWhere>
}

export type QueryRichTextTypesConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<RichTextTypeSort>>
  where?: InputMaybe<RichTextTypeWhere>
}

export type QueryStoresArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<StoreOptions>
  sort?: InputMaybe<Array<StoreSort>>
  where?: InputMaybe<StoreWhere>
}

export type QueryStoresAggregateArgs = {
  where?: InputMaybe<StoreWhere>
}

export type QueryStoresConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<StoreSort>>
  where?: InputMaybe<StoreWhere>
}

export type QueryTagsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<TagOptions>
  sort?: InputMaybe<Array<TagSort>>
  where?: InputMaybe<TagWhere>
}

export type QueryTagsAggregateArgs = {
  where?: InputMaybe<TagWhere>
}

export type QueryTagsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<TagSort>>
  where?: InputMaybe<TagWhere>
}

export type QueryTypeReferencesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<TypeReferenceOptions>
  sort?: InputMaybe<Array<TypeReferenceSort>>
  where?: InputMaybe<TypeReferenceWhere>
}

export type QueryTypeReferencesAggregateArgs = {
  where?: InputMaybe<TypeReferenceWhere>
}

export type QueryTypeReferencesConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<TypeReferenceSort>>
  where?: InputMaybe<TypeReferenceWhere>
}

export type QueryUnionTypesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<UnionTypeOptions>
  sort?: InputMaybe<Array<UnionTypeSort>>
  where?: InputMaybe<UnionTypeWhere>
}

export type QueryUnionTypesAggregateArgs = {
  where?: InputMaybe<UnionTypeWhere>
}

export type QueryUnionTypesConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<UnionTypeSort>>
  where?: InputMaybe<UnionTypeWhere>
}

export type QueryUsersArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<UserOptions>
  sort?: InputMaybe<Array<UserSort>>
  where?: InputMaybe<UserWhere>
}

export type QueryUsersAggregateArgs = {
  where?: InputMaybe<UserWhere>
}

export type QueryUsersConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<UserSort>>
  where?: InputMaybe<UserWhere>
}

export type QueryWithDescendantsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<WithDescendantsOptions>
  where?: InputMaybe<WithDescendantsWhere>
}

export type QueryWithDescendantsAggregateArgs = {
  where?: InputMaybe<WithDescendantsWhere>
}

export type QueryWithDescendantsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  where?: InputMaybe<WithDescendantsWhere>
}

export type QueryWithOwnersArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<WithOwnerOptions>
  where?: InputMaybe<WithOwnerWhere>
}

export type QueryWithOwnersAggregateArgs = {
  where?: InputMaybe<WithOwnerWhere>
}

export type QueryWithOwnersConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  where?: InputMaybe<WithOwnerWhere>
}

/** Input type for options that can be specified on a query operation. */
export type QueryOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
}

/**
 * Allows picking a Component from the list of components.
 * It is passed to the rendered element as a React node: `ReactNode`
 * Prop values for this type have the shape of TypedProp in order to
 * be distinguished from other element types.
 * Comparison between different element types:
 * - RenderPropType: Component select box, results it '(props) => ReactNode' value
 * - ReactNodeType: Component select box, results it 'ReactNode' value
 * - ElementType: Current tree element select box, results it 'ReactNode' value
 */
export type ReactNodeType = IBaseType & {
  fieldRefs: Array<Field>
  fieldRefsAggregate?: Maybe<ReactNodeTypeFieldFieldRefsAggregationSelection>
  fieldRefsConnection: IBaseTypeFieldRefsConnection
  id: Scalars['ID']['output']
  kind: TypeKind
  name: Scalars['String']['output']
  owner: User
  ownerAggregate?: Maybe<ReactNodeTypeUserOwnerAggregationSelection>
  ownerConnection: IBaseTypeOwnerConnection
}

/**
 * Allows picking a Component from the list of components.
 * It is passed to the rendered element as a React node: `ReactNode`
 * Prop values for this type have the shape of TypedProp in order to
 * be distinguished from other element types.
 * Comparison between different element types:
 * - RenderPropType: Component select box, results it '(props) => ReactNode' value
 * - ReactNodeType: Component select box, results it 'ReactNode' value
 * - ElementType: Current tree element select box, results it 'ReactNode' value
 */
export type ReactNodeTypeFieldRefsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<FieldOptions>
  sort?: InputMaybe<Array<FieldSort>>
  where?: InputMaybe<FieldWhere>
}

/**
 * Allows picking a Component from the list of components.
 * It is passed to the rendered element as a React node: `ReactNode`
 * Prop values for this type have the shape of TypedProp in order to
 * be distinguished from other element types.
 * Comparison between different element types:
 * - RenderPropType: Component select box, results it '(props) => ReactNode' value
 * - ReactNodeType: Component select box, results it 'ReactNode' value
 * - ElementType: Current tree element select box, results it 'ReactNode' value
 */
export type ReactNodeTypeFieldRefsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<FieldWhere>
}

/**
 * Allows picking a Component from the list of components.
 * It is passed to the rendered element as a React node: `ReactNode`
 * Prop values for this type have the shape of TypedProp in order to
 * be distinguished from other element types.
 * Comparison between different element types:
 * - RenderPropType: Component select box, results it '(props) => ReactNode' value
 * - ReactNodeType: Component select box, results it 'ReactNode' value
 * - ElementType: Current tree element select box, results it 'ReactNode' value
 */
export type ReactNodeTypeFieldRefsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<IBaseTypeFieldRefsConnectionSort>>
  where?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
}

/**
 * Allows picking a Component from the list of components.
 * It is passed to the rendered element as a React node: `ReactNode`
 * Prop values for this type have the shape of TypedProp in order to
 * be distinguished from other element types.
 * Comparison between different element types:
 * - RenderPropType: Component select box, results it '(props) => ReactNode' value
 * - ReactNodeType: Component select box, results it 'ReactNode' value
 * - ElementType: Current tree element select box, results it 'ReactNode' value
 */
export type ReactNodeTypeOwnerArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<UserOptions>
  sort?: InputMaybe<Array<UserSort>>
  where?: InputMaybe<UserWhere>
}

/**
 * Allows picking a Component from the list of components.
 * It is passed to the rendered element as a React node: `ReactNode`
 * Prop values for this type have the shape of TypedProp in order to
 * be distinguished from other element types.
 * Comparison between different element types:
 * - RenderPropType: Component select box, results it '(props) => ReactNode' value
 * - ReactNodeType: Component select box, results it 'ReactNode' value
 * - ElementType: Current tree element select box, results it 'ReactNode' value
 */
export type ReactNodeTypeOwnerAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<UserWhere>
}

/**
 * Allows picking a Component from the list of components.
 * It is passed to the rendered element as a React node: `ReactNode`
 * Prop values for this type have the shape of TypedProp in order to
 * be distinguished from other element types.
 * Comparison between different element types:
 * - RenderPropType: Component select box, results it '(props) => ReactNode' value
 * - ReactNodeType: Component select box, results it 'ReactNode' value
 * - ElementType: Current tree element select box, results it 'ReactNode' value
 */
export type ReactNodeTypeOwnerConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<IBaseTypeOwnerConnectionSort>>
  where?: InputMaybe<IBaseTypeOwnerConnectionWhere>
}

export type ReactNodeTypeAggregateSelection = {
  count: Scalars['Int']['output']
  id: IdAggregateSelection
  name: StringAggregateSelection
}

export type ReactNodeTypeConnectInput = {
  fieldRefs?: InputMaybe<Array<ReactNodeTypeFieldRefsConnectFieldInput>>
  owner?: InputMaybe<ReactNodeTypeOwnerConnectFieldInput>
}

export type ReactNodeTypeConnectOrCreateWhere = {
  node: ReactNodeTypeUniqueWhere
}

export type ReactNodeTypeConnectWhere = {
  node: ReactNodeTypeWhere
}

export type ReactNodeTypeCreateInput = {
  fieldRefs?: InputMaybe<ReactNodeTypeFieldRefsFieldInput>
  id: Scalars['ID']['input']
  kind?: TypeKind
  name: Scalars['String']['input']
  owner?: InputMaybe<ReactNodeTypeOwnerFieldInput>
}

export type ReactNodeTypeCreatedEvent = {
  createdReactNodeType: ReactNodeTypeEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type ReactNodeTypeDeleteInput = {
  fieldRefs?: InputMaybe<Array<IBaseTypeFieldRefsDeleteFieldInput>>
  owner?: InputMaybe<IBaseTypeOwnerDeleteFieldInput>
}

export type ReactNodeTypeDeletedEvent = {
  deletedReactNodeType: ReactNodeTypeEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type ReactNodeTypeDisconnectInput = {
  fieldRefs?: InputMaybe<Array<IBaseTypeFieldRefsDisconnectFieldInput>>
  owner?: InputMaybe<IBaseTypeOwnerDisconnectFieldInput>
}

export type ReactNodeTypeEdge = {
  cursor: Scalars['String']['output']
  node: ReactNodeType
}

export type ReactNodeTypeEventPayload = {
  id: Scalars['ID']['output']
  kind: TypeKind
  name: Scalars['String']['output']
}

export type ReactNodeTypeFieldFieldRefsAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<ReactNodeTypeFieldFieldRefsNodeAggregateSelection>
}

export type ReactNodeTypeFieldFieldRefsNodeAggregateSelection = {
  defaultValues: StringAggregateSelection
  description: StringAggregateSelection
  id: IdAggregateSelection
  key: StringAggregateSelection
  name: StringAggregateSelection
  validationRules: StringAggregateSelection
}

export type ReactNodeTypeFieldRefsAggregateInput = {
  AND?: InputMaybe<Array<ReactNodeTypeFieldRefsAggregateInput>>
  NOT?: InputMaybe<ReactNodeTypeFieldRefsAggregateInput>
  OR?: InputMaybe<Array<ReactNodeTypeFieldRefsAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<ReactNodeTypeFieldRefsNodeAggregationWhereInput>
}

export type ReactNodeTypeFieldRefsConnectFieldInput = {
  connect?: InputMaybe<Array<FieldConnectInput>>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<FieldConnectWhere>
}

export type ReactNodeTypeFieldRefsConnectOrCreateFieldInput = {
  onCreate: ReactNodeTypeFieldRefsConnectOrCreateFieldInputOnCreate
  where: FieldConnectOrCreateWhere
}

export type ReactNodeTypeFieldRefsConnectOrCreateFieldInputOnCreate = {
  node: FieldOnCreateInput
}

export type ReactNodeTypeFieldRefsCreateFieldInput = {
  node: FieldCreateInput
}

export type ReactNodeTypeFieldRefsFieldInput = {
  connect?: InputMaybe<Array<ReactNodeTypeFieldRefsConnectFieldInput>>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<
    Array<ReactNodeTypeFieldRefsConnectOrCreateFieldInput>
  >
  create?: InputMaybe<Array<ReactNodeTypeFieldRefsCreateFieldInput>>
}

export type ReactNodeTypeFieldRefsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<ReactNodeTypeFieldRefsNodeAggregationWhereInput>>
  NOT?: InputMaybe<ReactNodeTypeFieldRefsNodeAggregationWhereInput>
  OR?: InputMaybe<Array<ReactNodeTypeFieldRefsNodeAggregationWhereInput>>
  defaultValues_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  defaultValues_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  description_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  description_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  key_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  key_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  validationRules_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type ReactNodeTypeFieldRefsUpdateConnectionInput = {
  node?: InputMaybe<FieldUpdateInput>
}

export type ReactNodeTypeFieldRefsUpdateFieldInput = {
  connect?: InputMaybe<Array<ReactNodeTypeFieldRefsConnectFieldInput>>
  connectOrCreate?: InputMaybe<
    Array<ReactNodeTypeFieldRefsConnectOrCreateFieldInput>
  >
  create?: InputMaybe<Array<ReactNodeTypeFieldRefsCreateFieldInput>>
  delete?: InputMaybe<Array<IBaseTypeFieldRefsDeleteFieldInput>>
  disconnect?: InputMaybe<Array<IBaseTypeFieldRefsDisconnectFieldInput>>
  update?: InputMaybe<ReactNodeTypeFieldRefsUpdateConnectionInput>
  where?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
}

export type ReactNodeTypeOnCreateInput = {
  id: Scalars['ID']['input']
  kind?: TypeKind
  name: Scalars['String']['input']
}

export type ReactNodeTypeOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  /** Specify one or more ReactNodeTypeSort objects to sort ReactNodeTypes by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<ReactNodeTypeSort>>
}

export type ReactNodeTypeOwnerAggregateInput = {
  AND?: InputMaybe<Array<ReactNodeTypeOwnerAggregateInput>>
  NOT?: InputMaybe<ReactNodeTypeOwnerAggregateInput>
  OR?: InputMaybe<Array<ReactNodeTypeOwnerAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<ReactNodeTypeOwnerNodeAggregationWhereInput>
}

export type ReactNodeTypeOwnerConnectFieldInput = {
  connect?: InputMaybe<UserConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<UserConnectWhere>
}

export type ReactNodeTypeOwnerConnectOrCreateFieldInput = {
  onCreate: ReactNodeTypeOwnerConnectOrCreateFieldInputOnCreate
  where: UserConnectOrCreateWhere
}

export type ReactNodeTypeOwnerConnectOrCreateFieldInputOnCreate = {
  node: UserOnCreateInput
}

export type ReactNodeTypeOwnerCreateFieldInput = {
  node: UserCreateInput
}

export type ReactNodeTypeOwnerFieldInput = {
  connect?: InputMaybe<ReactNodeTypeOwnerConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<ReactNodeTypeOwnerConnectOrCreateFieldInput>
  create?: InputMaybe<ReactNodeTypeOwnerCreateFieldInput>
}

export type ReactNodeTypeOwnerNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<ReactNodeTypeOwnerNodeAggregationWhereInput>>
  NOT?: InputMaybe<ReactNodeTypeOwnerNodeAggregationWhereInput>
  OR?: InputMaybe<Array<ReactNodeTypeOwnerNodeAggregationWhereInput>>
  auth0Id_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  auth0Id_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  email_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  email_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  username_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  username_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type ReactNodeTypeOwnerUpdateConnectionInput = {
  node?: InputMaybe<UserUpdateInput>
}

export type ReactNodeTypeOwnerUpdateFieldInput = {
  connect?: InputMaybe<ReactNodeTypeOwnerConnectFieldInput>
  connectOrCreate?: InputMaybe<ReactNodeTypeOwnerConnectOrCreateFieldInput>
  create?: InputMaybe<ReactNodeTypeOwnerCreateFieldInput>
  delete?: InputMaybe<IBaseTypeOwnerDeleteFieldInput>
  disconnect?: InputMaybe<IBaseTypeOwnerDisconnectFieldInput>
  update?: InputMaybe<ReactNodeTypeOwnerUpdateConnectionInput>
  where?: InputMaybe<IBaseTypeOwnerConnectionWhere>
}

/** Fields to sort ReactNodeTypes by. The order in which sorts are applied is not guaranteed when specifying many fields in one ReactNodeTypeSort object. */
export type ReactNodeTypeSort = {
  id?: InputMaybe<SortDirection>
  kind?: InputMaybe<SortDirection>
  name?: InputMaybe<SortDirection>
}

export type ReactNodeTypeSubscriptionWhere = {
  AND?: InputMaybe<Array<ReactNodeTypeSubscriptionWhere>>
  NOT?: InputMaybe<ReactNodeTypeSubscriptionWhere>
  OR?: InputMaybe<Array<ReactNodeTypeSubscriptionWhere>>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  kind?: InputMaybe<TypeKind>
  kind_EQ?: InputMaybe<TypeKind>
  kind_IN?: InputMaybe<Array<TypeKind>>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>
  name_MATCHES?: InputMaybe<Scalars['String']['input']>
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
}

export type ReactNodeTypeUniqueWhere = {
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
}

export type ReactNodeTypeUpdateInput = {
  fieldRefs?: InputMaybe<Array<ReactNodeTypeFieldRefsUpdateFieldInput>>
  /** @deprecated Please use the explicit _SET field */
  id?: InputMaybe<Scalars['ID']['input']>
  id_SET?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _SET field */
  kind?: InputMaybe<TypeKind>
  kind_SET?: InputMaybe<TypeKind>
  /** @deprecated Please use the explicit _SET field */
  name?: InputMaybe<Scalars['String']['input']>
  name_SET?: InputMaybe<Scalars['String']['input']>
  owner?: InputMaybe<ReactNodeTypeOwnerUpdateFieldInput>
}

export type ReactNodeTypeUpdatedEvent = {
  event: EventType
  previousState: ReactNodeTypeEventPayload
  timestamp: Scalars['Float']['output']
  updatedReactNodeType: ReactNodeTypeEventPayload
}

export type ReactNodeTypeUserOwnerAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<ReactNodeTypeUserOwnerNodeAggregateSelection>
}

export type ReactNodeTypeUserOwnerNodeAggregateSelection = {
  auth0Id: StringAggregateSelection
  email: StringAggregateSelection
  id: IdAggregateSelection
  username: StringAggregateSelection
}

export type ReactNodeTypeWhere = {
  AND?: InputMaybe<Array<ReactNodeTypeWhere>>
  NOT?: InputMaybe<ReactNodeTypeWhere>
  OR?: InputMaybe<Array<ReactNodeTypeWhere>>
  fieldRefsAggregate?: InputMaybe<ReactNodeTypeFieldRefsAggregateInput>
  /** Return ReactNodeTypes where all of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_ALL?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return ReactNodeTypes where none of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_NONE?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return ReactNodeTypes where one of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_SINGLE?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return ReactNodeTypes where some of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_SOME?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return ReactNodeTypes where all of the related Fields match this filter */
  fieldRefs_ALL?: InputMaybe<FieldWhere>
  /** Return ReactNodeTypes where none of the related Fields match this filter */
  fieldRefs_NONE?: InputMaybe<FieldWhere>
  /** Return ReactNodeTypes where one of the related Fields match this filter */
  fieldRefs_SINGLE?: InputMaybe<FieldWhere>
  /** Return ReactNodeTypes where some of the related Fields match this filter */
  fieldRefs_SOME?: InputMaybe<FieldWhere>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  kind?: InputMaybe<TypeKind>
  kind_EQ?: InputMaybe<TypeKind>
  kind_IN?: InputMaybe<Array<TypeKind>>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>
  name_MATCHES?: InputMaybe<Scalars['String']['input']>
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  owner?: InputMaybe<UserWhere>
  ownerAggregate?: InputMaybe<ReactNodeTypeOwnerAggregateInput>
  ownerConnection?: InputMaybe<IBaseTypeOwnerConnectionWhere>
}

export type ReactNodeTypesConnection = {
  edges: Array<ReactNodeTypeEdge>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type Redirect = {
  authGuard: AuthGuard
  authGuardAggregate?: Maybe<RedirectAuthGuardAuthGuardAggregationSelection>
  authGuardConnection: RedirectAuthGuardConnection
  id: Scalars['ID']['output']
  source: Page
  sourceAggregate?: Maybe<RedirectPageSourceAggregationSelection>
  sourceConnection: RedirectSourceConnection
  targetPage?: Maybe<Page>
  targetPageAggregate?: Maybe<RedirectPageTargetPageAggregationSelection>
  targetPageConnection: RedirectTargetPageConnection
  targetType: RedirectTargetType
  targetUrl?: Maybe<Scalars['String']['output']>
}

export type RedirectAuthGuardArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<AuthGuardOptions>
  sort?: InputMaybe<Array<AuthGuardSort>>
  where?: InputMaybe<AuthGuardWhere>
}

export type RedirectAuthGuardAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<AuthGuardWhere>
}

export type RedirectAuthGuardConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<RedirectAuthGuardConnectionSort>>
  where?: InputMaybe<RedirectAuthGuardConnectionWhere>
}

export type RedirectSourceArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<PageOptions>
  sort?: InputMaybe<Array<PageSort>>
  where?: InputMaybe<PageWhere>
}

export type RedirectSourceAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<PageWhere>
}

export type RedirectSourceConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<RedirectSourceConnectionSort>>
  where?: InputMaybe<RedirectSourceConnectionWhere>
}

export type RedirectTargetPageArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<PageOptions>
  sort?: InputMaybe<Array<PageSort>>
  where?: InputMaybe<PageWhere>
}

export type RedirectTargetPageAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<PageWhere>
}

export type RedirectTargetPageConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<RedirectTargetPageConnectionSort>>
  where?: InputMaybe<RedirectTargetPageConnectionWhere>
}

export type RedirectAggregateSelection = {
  count: Scalars['Int']['output']
  id: IdAggregateSelection
  targetUrl: StringAggregateSelection
}

export type RedirectAuthGuardAggregateInput = {
  AND?: InputMaybe<Array<RedirectAuthGuardAggregateInput>>
  NOT?: InputMaybe<RedirectAuthGuardAggregateInput>
  OR?: InputMaybe<Array<RedirectAuthGuardAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<RedirectAuthGuardNodeAggregationWhereInput>
}

export type RedirectAuthGuardAuthGuardAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<RedirectAuthGuardAuthGuardNodeAggregateSelection>
}

export type RedirectAuthGuardAuthGuardNodeAggregateSelection = {
  id: IdAggregateSelection
  name: StringAggregateSelection
  responseTransformer: StringAggregateSelection
}

export type RedirectAuthGuardConnectFieldInput = {
  connect?: InputMaybe<AuthGuardConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<AuthGuardConnectWhere>
}

export type RedirectAuthGuardConnectOrCreateFieldInput = {
  onCreate: RedirectAuthGuardConnectOrCreateFieldInputOnCreate
  where: AuthGuardConnectOrCreateWhere
}

export type RedirectAuthGuardConnectOrCreateFieldInputOnCreate = {
  node: AuthGuardOnCreateInput
}

export type RedirectAuthGuardConnection = {
  edges: Array<RedirectAuthGuardRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type RedirectAuthGuardConnectionSort = {
  node?: InputMaybe<AuthGuardSort>
}

export type RedirectAuthGuardConnectionWhere = {
  AND?: InputMaybe<Array<RedirectAuthGuardConnectionWhere>>
  NOT?: InputMaybe<RedirectAuthGuardConnectionWhere>
  OR?: InputMaybe<Array<RedirectAuthGuardConnectionWhere>>
  node?: InputMaybe<AuthGuardWhere>
}

export type RedirectAuthGuardCreateFieldInput = {
  node: AuthGuardCreateInput
}

export type RedirectAuthGuardDeleteFieldInput = {
  delete?: InputMaybe<AuthGuardDeleteInput>
  where?: InputMaybe<RedirectAuthGuardConnectionWhere>
}

export type RedirectAuthGuardDisconnectFieldInput = {
  disconnect?: InputMaybe<AuthGuardDisconnectInput>
  where?: InputMaybe<RedirectAuthGuardConnectionWhere>
}

export type RedirectAuthGuardFieldInput = {
  connect?: InputMaybe<RedirectAuthGuardConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<RedirectAuthGuardConnectOrCreateFieldInput>
  create?: InputMaybe<RedirectAuthGuardCreateFieldInput>
}

export type RedirectAuthGuardNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<RedirectAuthGuardNodeAggregationWhereInput>>
  NOT?: InputMaybe<RedirectAuthGuardNodeAggregationWhereInput>
  OR?: InputMaybe<Array<RedirectAuthGuardNodeAggregationWhereInput>>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  responseTransformer_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  responseTransformer_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  responseTransformer_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  responseTransformer_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  responseTransformer_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  responseTransformer_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  responseTransformer_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  responseTransformer_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  responseTransformer_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  responseTransformer_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  responseTransformer_SHORTEST_LENGTH_EQUAL?: InputMaybe<
    Scalars['Int']['input']
  >
  responseTransformer_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  responseTransformer_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  responseTransformer_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  responseTransformer_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type RedirectAuthGuardRelationship = {
  cursor: Scalars['String']['output']
  node: AuthGuard
}

export type RedirectAuthGuardUpdateConnectionInput = {
  node?: InputMaybe<AuthGuardUpdateInput>
}

export type RedirectAuthGuardUpdateFieldInput = {
  connect?: InputMaybe<RedirectAuthGuardConnectFieldInput>
  connectOrCreate?: InputMaybe<RedirectAuthGuardConnectOrCreateFieldInput>
  create?: InputMaybe<RedirectAuthGuardCreateFieldInput>
  delete?: InputMaybe<RedirectAuthGuardDeleteFieldInput>
  disconnect?: InputMaybe<RedirectAuthGuardDisconnectFieldInput>
  update?: InputMaybe<RedirectAuthGuardUpdateConnectionInput>
  where?: InputMaybe<RedirectAuthGuardConnectionWhere>
}

export type RedirectConnectInput = {
  authGuard?: InputMaybe<RedirectAuthGuardConnectFieldInput>
  source?: InputMaybe<RedirectSourceConnectFieldInput>
  targetPage?: InputMaybe<RedirectTargetPageConnectFieldInput>
}

export type RedirectConnectOrCreateWhere = {
  node: RedirectUniqueWhere
}

export type RedirectConnectWhere = {
  node: RedirectWhere
}

export type RedirectCreateInput = {
  authGuard?: InputMaybe<RedirectAuthGuardFieldInput>
  id: Scalars['ID']['input']
  source?: InputMaybe<RedirectSourceFieldInput>
  targetPage?: InputMaybe<RedirectTargetPageFieldInput>
  targetType: RedirectTargetType
  targetUrl?: InputMaybe<Scalars['String']['input']>
}

export type RedirectCreatedEvent = {
  createdRedirect: RedirectEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type RedirectDeleteInput = {
  authGuard?: InputMaybe<RedirectAuthGuardDeleteFieldInput>
  source?: InputMaybe<RedirectSourceDeleteFieldInput>
  targetPage?: InputMaybe<RedirectTargetPageDeleteFieldInput>
}

export type RedirectDeletedEvent = {
  deletedRedirect: RedirectEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type RedirectDisconnectInput = {
  authGuard?: InputMaybe<RedirectAuthGuardDisconnectFieldInput>
  source?: InputMaybe<RedirectSourceDisconnectFieldInput>
  targetPage?: InputMaybe<RedirectTargetPageDisconnectFieldInput>
}

export type RedirectEdge = {
  cursor: Scalars['String']['output']
  node: Redirect
}

export type RedirectEventPayload = {
  id: Scalars['ID']['output']
  targetType: RedirectTargetType
  targetUrl?: Maybe<Scalars['String']['output']>
}

export type RedirectOnCreateInput = {
  id: Scalars['ID']['input']
  targetType: RedirectTargetType
  targetUrl?: InputMaybe<Scalars['String']['input']>
}

export type RedirectOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  /** Specify one or more RedirectSort objects to sort Redirects by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<RedirectSort>>
}

export type RedirectPageSourceAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<RedirectPageSourceNodeAggregateSelection>
}

export type RedirectPageSourceNodeAggregateSelection = {
  compositeKey: StringAggregateSelection
  id: IdAggregateSelection
  urlPattern: StringAggregateSelection
}

export type RedirectPageTargetPageAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<RedirectPageTargetPageNodeAggregateSelection>
}

export type RedirectPageTargetPageNodeAggregateSelection = {
  compositeKey: StringAggregateSelection
  id: IdAggregateSelection
  urlPattern: StringAggregateSelection
}

/** Fields to sort Redirects by. The order in which sorts are applied is not guaranteed when specifying many fields in one RedirectSort object. */
export type RedirectSort = {
  id?: InputMaybe<SortDirection>
  targetType?: InputMaybe<SortDirection>
  targetUrl?: InputMaybe<SortDirection>
}

export type RedirectSourceAggregateInput = {
  AND?: InputMaybe<Array<RedirectSourceAggregateInput>>
  NOT?: InputMaybe<RedirectSourceAggregateInput>
  OR?: InputMaybe<Array<RedirectSourceAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<RedirectSourceNodeAggregationWhereInput>
}

export type RedirectSourceConnectFieldInput = {
  connect?: InputMaybe<PageConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<PageConnectWhere>
}

export type RedirectSourceConnectOrCreateFieldInput = {
  onCreate: RedirectSourceConnectOrCreateFieldInputOnCreate
  where: PageConnectOrCreateWhere
}

export type RedirectSourceConnectOrCreateFieldInputOnCreate = {
  node: PageOnCreateInput
}

export type RedirectSourceConnection = {
  edges: Array<RedirectSourceRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type RedirectSourceConnectionSort = {
  node?: InputMaybe<PageSort>
}

export type RedirectSourceConnectionWhere = {
  AND?: InputMaybe<Array<RedirectSourceConnectionWhere>>
  NOT?: InputMaybe<RedirectSourceConnectionWhere>
  OR?: InputMaybe<Array<RedirectSourceConnectionWhere>>
  node?: InputMaybe<PageWhere>
}

export type RedirectSourceCreateFieldInput = {
  node: PageCreateInput
}

export type RedirectSourceDeleteFieldInput = {
  delete?: InputMaybe<PageDeleteInput>
  where?: InputMaybe<RedirectSourceConnectionWhere>
}

export type RedirectSourceDisconnectFieldInput = {
  disconnect?: InputMaybe<PageDisconnectInput>
  where?: InputMaybe<RedirectSourceConnectionWhere>
}

export type RedirectSourceFieldInput = {
  connect?: InputMaybe<RedirectSourceConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<RedirectSourceConnectOrCreateFieldInput>
  create?: InputMaybe<RedirectSourceCreateFieldInput>
}

export type RedirectSourceNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<RedirectSourceNodeAggregationWhereInput>>
  NOT?: InputMaybe<RedirectSourceNodeAggregationWhereInput>
  OR?: InputMaybe<Array<RedirectSourceNodeAggregationWhereInput>>
  compositeKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  urlPattern_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  urlPattern_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  urlPattern_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  urlPattern_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  urlPattern_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  urlPattern_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  urlPattern_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  urlPattern_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  urlPattern_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  urlPattern_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  urlPattern_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  urlPattern_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  urlPattern_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  urlPattern_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  urlPattern_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type RedirectSourceRelationship = {
  cursor: Scalars['String']['output']
  node: Page
}

export type RedirectSourceUpdateConnectionInput = {
  node?: InputMaybe<PageUpdateInput>
}

export type RedirectSourceUpdateFieldInput = {
  connect?: InputMaybe<RedirectSourceConnectFieldInput>
  connectOrCreate?: InputMaybe<RedirectSourceConnectOrCreateFieldInput>
  create?: InputMaybe<RedirectSourceCreateFieldInput>
  delete?: InputMaybe<RedirectSourceDeleteFieldInput>
  disconnect?: InputMaybe<RedirectSourceDisconnectFieldInput>
  update?: InputMaybe<RedirectSourceUpdateConnectionInput>
  where?: InputMaybe<RedirectSourceConnectionWhere>
}

export type RedirectSubscriptionWhere = {
  AND?: InputMaybe<Array<RedirectSubscriptionWhere>>
  NOT?: InputMaybe<RedirectSubscriptionWhere>
  OR?: InputMaybe<Array<RedirectSubscriptionWhere>>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  targetType?: InputMaybe<RedirectTargetType>
  targetType_EQ?: InputMaybe<RedirectTargetType>
  targetType_IN?: InputMaybe<Array<RedirectTargetType>>
  /** @deprecated Please use the explicit _EQ version */
  targetUrl?: InputMaybe<Scalars['String']['input']>
  targetUrl_CONTAINS?: InputMaybe<Scalars['String']['input']>
  targetUrl_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  targetUrl_EQ?: InputMaybe<Scalars['String']['input']>
  targetUrl_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>
  targetUrl_MATCHES?: InputMaybe<Scalars['String']['input']>
  targetUrl_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
}

export type RedirectTargetPageAggregateInput = {
  AND?: InputMaybe<Array<RedirectTargetPageAggregateInput>>
  NOT?: InputMaybe<RedirectTargetPageAggregateInput>
  OR?: InputMaybe<Array<RedirectTargetPageAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<RedirectTargetPageNodeAggregationWhereInput>
}

export type RedirectTargetPageConnectFieldInput = {
  connect?: InputMaybe<PageConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<PageConnectWhere>
}

export type RedirectTargetPageConnectOrCreateFieldInput = {
  onCreate: RedirectTargetPageConnectOrCreateFieldInputOnCreate
  where: PageConnectOrCreateWhere
}

export type RedirectTargetPageConnectOrCreateFieldInputOnCreate = {
  node: PageOnCreateInput
}

export type RedirectTargetPageConnection = {
  edges: Array<RedirectTargetPageRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type RedirectTargetPageConnectionSort = {
  node?: InputMaybe<PageSort>
}

export type RedirectTargetPageConnectionWhere = {
  AND?: InputMaybe<Array<RedirectTargetPageConnectionWhere>>
  NOT?: InputMaybe<RedirectTargetPageConnectionWhere>
  OR?: InputMaybe<Array<RedirectTargetPageConnectionWhere>>
  node?: InputMaybe<PageWhere>
}

export type RedirectTargetPageCreateFieldInput = {
  node: PageCreateInput
}

export type RedirectTargetPageDeleteFieldInput = {
  delete?: InputMaybe<PageDeleteInput>
  where?: InputMaybe<RedirectTargetPageConnectionWhere>
}

export type RedirectTargetPageDisconnectFieldInput = {
  disconnect?: InputMaybe<PageDisconnectInput>
  where?: InputMaybe<RedirectTargetPageConnectionWhere>
}

export type RedirectTargetPageFieldInput = {
  connect?: InputMaybe<RedirectTargetPageConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<RedirectTargetPageConnectOrCreateFieldInput>
  create?: InputMaybe<RedirectTargetPageCreateFieldInput>
}

export type RedirectTargetPageNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<RedirectTargetPageNodeAggregationWhereInput>>
  NOT?: InputMaybe<RedirectTargetPageNodeAggregationWhereInput>
  OR?: InputMaybe<Array<RedirectTargetPageNodeAggregationWhereInput>>
  compositeKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  urlPattern_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  urlPattern_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  urlPattern_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  urlPattern_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  urlPattern_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  urlPattern_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  urlPattern_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  urlPattern_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  urlPattern_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  urlPattern_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  urlPattern_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  urlPattern_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  urlPattern_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  urlPattern_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  urlPattern_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type RedirectTargetPageRelationship = {
  cursor: Scalars['String']['output']
  node: Page
}

export type RedirectTargetPageUpdateConnectionInput = {
  node?: InputMaybe<PageUpdateInput>
}

export type RedirectTargetPageUpdateFieldInput = {
  connect?: InputMaybe<RedirectTargetPageConnectFieldInput>
  connectOrCreate?: InputMaybe<RedirectTargetPageConnectOrCreateFieldInput>
  create?: InputMaybe<RedirectTargetPageCreateFieldInput>
  delete?: InputMaybe<RedirectTargetPageDeleteFieldInput>
  disconnect?: InputMaybe<RedirectTargetPageDisconnectFieldInput>
  update?: InputMaybe<RedirectTargetPageUpdateConnectionInput>
  where?: InputMaybe<RedirectTargetPageConnectionWhere>
}

export enum RedirectTargetType {
  /** Redirect to a page in the same app */
  Page = 'Page',
  /** Redirect responsible for fetching data from a resource */
  Url = 'Url',
}

export type RedirectUniqueWhere = {
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
}

export type RedirectUpdateInput = {
  authGuard?: InputMaybe<RedirectAuthGuardUpdateFieldInput>
  source?: InputMaybe<RedirectSourceUpdateFieldInput>
  targetPage?: InputMaybe<RedirectTargetPageUpdateFieldInput>
  /** @deprecated Please use the explicit _SET field */
  targetType?: InputMaybe<RedirectTargetType>
  targetType_SET?: InputMaybe<RedirectTargetType>
  /** @deprecated Please use the explicit _SET field */
  targetUrl?: InputMaybe<Scalars['String']['input']>
  targetUrl_SET?: InputMaybe<Scalars['String']['input']>
}

export type RedirectUpdatedEvent = {
  event: EventType
  previousState: RedirectEventPayload
  timestamp: Scalars['Float']['output']
  updatedRedirect: RedirectEventPayload
}

export type RedirectWhere = {
  AND?: InputMaybe<Array<RedirectWhere>>
  NOT?: InputMaybe<RedirectWhere>
  OR?: InputMaybe<Array<RedirectWhere>>
  authGuard?: InputMaybe<AuthGuardWhere>
  authGuardAggregate?: InputMaybe<RedirectAuthGuardAggregateInput>
  authGuardConnection?: InputMaybe<RedirectAuthGuardConnectionWhere>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  source?: InputMaybe<PageWhere>
  sourceAggregate?: InputMaybe<RedirectSourceAggregateInput>
  sourceConnection?: InputMaybe<RedirectSourceConnectionWhere>
  targetPage?: InputMaybe<PageWhere>
  targetPageAggregate?: InputMaybe<RedirectTargetPageAggregateInput>
  targetPageConnection?: InputMaybe<RedirectTargetPageConnectionWhere>
  /** @deprecated Please use the explicit _EQ version */
  targetType?: InputMaybe<RedirectTargetType>
  targetType_EQ?: InputMaybe<RedirectTargetType>
  targetType_IN?: InputMaybe<Array<RedirectTargetType>>
  /** @deprecated Please use the explicit _EQ version */
  targetUrl?: InputMaybe<Scalars['String']['input']>
  targetUrl_CONTAINS?: InputMaybe<Scalars['String']['input']>
  targetUrl_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  targetUrl_EQ?: InputMaybe<Scalars['String']['input']>
  targetUrl_IN?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>
  targetUrl_MATCHES?: InputMaybe<Scalars['String']['input']>
  targetUrl_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
}

export type RedirectsConnection = {
  edges: Array<RedirectEdge>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

/**
 * Allows picking a Component from the list of components.
 * It is passed to the rendered element as a function that takes props as input
 * and returns a React element: '(props) => ReactNode'
 * Prop values for this type have the shape of TypedProp in order to
 * be distinguished from other element types.
 * Comparison between different element types:
 * - RenderPropType: Component select box, results it '(props) => ReactNode' value
 * - ReactNodeType: Component select box, results it 'ReactNode' value
 * - ElementType: Current tree element select box, results it 'ReactNode' value
 */
export type RenderPropType = IBaseType & {
  fieldRefs: Array<Field>
  fieldRefsAggregate?: Maybe<RenderPropTypeFieldFieldRefsAggregationSelection>
  fieldRefsConnection: IBaseTypeFieldRefsConnection
  id: Scalars['ID']['output']
  kind: TypeKind
  name: Scalars['String']['output']
  owner: User
  ownerAggregate?: Maybe<RenderPropTypeUserOwnerAggregationSelection>
  ownerConnection: IBaseTypeOwnerConnection
}

/**
 * Allows picking a Component from the list of components.
 * It is passed to the rendered element as a function that takes props as input
 * and returns a React element: '(props) => ReactNode'
 * Prop values for this type have the shape of TypedProp in order to
 * be distinguished from other element types.
 * Comparison between different element types:
 * - RenderPropType: Component select box, results it '(props) => ReactNode' value
 * - ReactNodeType: Component select box, results it 'ReactNode' value
 * - ElementType: Current tree element select box, results it 'ReactNode' value
 */
export type RenderPropTypeFieldRefsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<FieldOptions>
  sort?: InputMaybe<Array<FieldSort>>
  where?: InputMaybe<FieldWhere>
}

/**
 * Allows picking a Component from the list of components.
 * It is passed to the rendered element as a function that takes props as input
 * and returns a React element: '(props) => ReactNode'
 * Prop values for this type have the shape of TypedProp in order to
 * be distinguished from other element types.
 * Comparison between different element types:
 * - RenderPropType: Component select box, results it '(props) => ReactNode' value
 * - ReactNodeType: Component select box, results it 'ReactNode' value
 * - ElementType: Current tree element select box, results it 'ReactNode' value
 */
export type RenderPropTypeFieldRefsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<FieldWhere>
}

/**
 * Allows picking a Component from the list of components.
 * It is passed to the rendered element as a function that takes props as input
 * and returns a React element: '(props) => ReactNode'
 * Prop values for this type have the shape of TypedProp in order to
 * be distinguished from other element types.
 * Comparison between different element types:
 * - RenderPropType: Component select box, results it '(props) => ReactNode' value
 * - ReactNodeType: Component select box, results it 'ReactNode' value
 * - ElementType: Current tree element select box, results it 'ReactNode' value
 */
export type RenderPropTypeFieldRefsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<IBaseTypeFieldRefsConnectionSort>>
  where?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
}

/**
 * Allows picking a Component from the list of components.
 * It is passed to the rendered element as a function that takes props as input
 * and returns a React element: '(props) => ReactNode'
 * Prop values for this type have the shape of TypedProp in order to
 * be distinguished from other element types.
 * Comparison between different element types:
 * - RenderPropType: Component select box, results it '(props) => ReactNode' value
 * - ReactNodeType: Component select box, results it 'ReactNode' value
 * - ElementType: Current tree element select box, results it 'ReactNode' value
 */
export type RenderPropTypeOwnerArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<UserOptions>
  sort?: InputMaybe<Array<UserSort>>
  where?: InputMaybe<UserWhere>
}

/**
 * Allows picking a Component from the list of components.
 * It is passed to the rendered element as a function that takes props as input
 * and returns a React element: '(props) => ReactNode'
 * Prop values for this type have the shape of TypedProp in order to
 * be distinguished from other element types.
 * Comparison between different element types:
 * - RenderPropType: Component select box, results it '(props) => ReactNode' value
 * - ReactNodeType: Component select box, results it 'ReactNode' value
 * - ElementType: Current tree element select box, results it 'ReactNode' value
 */
export type RenderPropTypeOwnerAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<UserWhere>
}

/**
 * Allows picking a Component from the list of components.
 * It is passed to the rendered element as a function that takes props as input
 * and returns a React element: '(props) => ReactNode'
 * Prop values for this type have the shape of TypedProp in order to
 * be distinguished from other element types.
 * Comparison between different element types:
 * - RenderPropType: Component select box, results it '(props) => ReactNode' value
 * - ReactNodeType: Component select box, results it 'ReactNode' value
 * - ElementType: Current tree element select box, results it 'ReactNode' value
 */
export type RenderPropTypeOwnerConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<IBaseTypeOwnerConnectionSort>>
  where?: InputMaybe<IBaseTypeOwnerConnectionWhere>
}

export type RenderPropTypeAggregateSelection = {
  count: Scalars['Int']['output']
  id: IdAggregateSelection
  name: StringAggregateSelection
}

export type RenderPropTypeConnectInput = {
  fieldRefs?: InputMaybe<Array<RenderPropTypeFieldRefsConnectFieldInput>>
  owner?: InputMaybe<RenderPropTypeOwnerConnectFieldInput>
}

export type RenderPropTypeConnectOrCreateWhere = {
  node: RenderPropTypeUniqueWhere
}

export type RenderPropTypeConnectWhere = {
  node: RenderPropTypeWhere
}

export type RenderPropTypeCreateInput = {
  fieldRefs?: InputMaybe<RenderPropTypeFieldRefsFieldInput>
  id: Scalars['ID']['input']
  kind?: TypeKind
  name: Scalars['String']['input']
  owner?: InputMaybe<RenderPropTypeOwnerFieldInput>
}

export type RenderPropTypeCreatedEvent = {
  createdRenderPropType: RenderPropTypeEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type RenderPropTypeDeleteInput = {
  fieldRefs?: InputMaybe<Array<IBaseTypeFieldRefsDeleteFieldInput>>
  owner?: InputMaybe<IBaseTypeOwnerDeleteFieldInput>
}

export type RenderPropTypeDeletedEvent = {
  deletedRenderPropType: RenderPropTypeEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type RenderPropTypeDisconnectInput = {
  fieldRefs?: InputMaybe<Array<IBaseTypeFieldRefsDisconnectFieldInput>>
  owner?: InputMaybe<IBaseTypeOwnerDisconnectFieldInput>
}

export type RenderPropTypeEdge = {
  cursor: Scalars['String']['output']
  node: RenderPropType
}

export type RenderPropTypeEventPayload = {
  id: Scalars['ID']['output']
  kind: TypeKind
  name: Scalars['String']['output']
}

export type RenderPropTypeFieldFieldRefsAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<RenderPropTypeFieldFieldRefsNodeAggregateSelection>
}

export type RenderPropTypeFieldFieldRefsNodeAggregateSelection = {
  defaultValues: StringAggregateSelection
  description: StringAggregateSelection
  id: IdAggregateSelection
  key: StringAggregateSelection
  name: StringAggregateSelection
  validationRules: StringAggregateSelection
}

export type RenderPropTypeFieldRefsAggregateInput = {
  AND?: InputMaybe<Array<RenderPropTypeFieldRefsAggregateInput>>
  NOT?: InputMaybe<RenderPropTypeFieldRefsAggregateInput>
  OR?: InputMaybe<Array<RenderPropTypeFieldRefsAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<RenderPropTypeFieldRefsNodeAggregationWhereInput>
}

export type RenderPropTypeFieldRefsConnectFieldInput = {
  connect?: InputMaybe<Array<FieldConnectInput>>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<FieldConnectWhere>
}

export type RenderPropTypeFieldRefsConnectOrCreateFieldInput = {
  onCreate: RenderPropTypeFieldRefsConnectOrCreateFieldInputOnCreate
  where: FieldConnectOrCreateWhere
}

export type RenderPropTypeFieldRefsConnectOrCreateFieldInputOnCreate = {
  node: FieldOnCreateInput
}

export type RenderPropTypeFieldRefsCreateFieldInput = {
  node: FieldCreateInput
}

export type RenderPropTypeFieldRefsFieldInput = {
  connect?: InputMaybe<Array<RenderPropTypeFieldRefsConnectFieldInput>>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<
    Array<RenderPropTypeFieldRefsConnectOrCreateFieldInput>
  >
  create?: InputMaybe<Array<RenderPropTypeFieldRefsCreateFieldInput>>
}

export type RenderPropTypeFieldRefsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<RenderPropTypeFieldRefsNodeAggregationWhereInput>>
  NOT?: InputMaybe<RenderPropTypeFieldRefsNodeAggregationWhereInput>
  OR?: InputMaybe<Array<RenderPropTypeFieldRefsNodeAggregationWhereInput>>
  defaultValues_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  defaultValues_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  description_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  description_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  key_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  key_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  validationRules_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type RenderPropTypeFieldRefsUpdateConnectionInput = {
  node?: InputMaybe<FieldUpdateInput>
}

export type RenderPropTypeFieldRefsUpdateFieldInput = {
  connect?: InputMaybe<Array<RenderPropTypeFieldRefsConnectFieldInput>>
  connectOrCreate?: InputMaybe<
    Array<RenderPropTypeFieldRefsConnectOrCreateFieldInput>
  >
  create?: InputMaybe<Array<RenderPropTypeFieldRefsCreateFieldInput>>
  delete?: InputMaybe<Array<IBaseTypeFieldRefsDeleteFieldInput>>
  disconnect?: InputMaybe<Array<IBaseTypeFieldRefsDisconnectFieldInput>>
  update?: InputMaybe<RenderPropTypeFieldRefsUpdateConnectionInput>
  where?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
}

export type RenderPropTypeOnCreateInput = {
  id: Scalars['ID']['input']
  kind?: TypeKind
  name: Scalars['String']['input']
}

export type RenderPropTypeOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  /** Specify one or more RenderPropTypeSort objects to sort RenderPropTypes by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<RenderPropTypeSort>>
}

export type RenderPropTypeOwnerAggregateInput = {
  AND?: InputMaybe<Array<RenderPropTypeOwnerAggregateInput>>
  NOT?: InputMaybe<RenderPropTypeOwnerAggregateInput>
  OR?: InputMaybe<Array<RenderPropTypeOwnerAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<RenderPropTypeOwnerNodeAggregationWhereInput>
}

export type RenderPropTypeOwnerConnectFieldInput = {
  connect?: InputMaybe<UserConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<UserConnectWhere>
}

export type RenderPropTypeOwnerConnectOrCreateFieldInput = {
  onCreate: RenderPropTypeOwnerConnectOrCreateFieldInputOnCreate
  where: UserConnectOrCreateWhere
}

export type RenderPropTypeOwnerConnectOrCreateFieldInputOnCreate = {
  node: UserOnCreateInput
}

export type RenderPropTypeOwnerCreateFieldInput = {
  node: UserCreateInput
}

export type RenderPropTypeOwnerFieldInput = {
  connect?: InputMaybe<RenderPropTypeOwnerConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<RenderPropTypeOwnerConnectOrCreateFieldInput>
  create?: InputMaybe<RenderPropTypeOwnerCreateFieldInput>
}

export type RenderPropTypeOwnerNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<RenderPropTypeOwnerNodeAggregationWhereInput>>
  NOT?: InputMaybe<RenderPropTypeOwnerNodeAggregationWhereInput>
  OR?: InputMaybe<Array<RenderPropTypeOwnerNodeAggregationWhereInput>>
  auth0Id_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  auth0Id_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  email_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  email_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  username_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  username_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type RenderPropTypeOwnerUpdateConnectionInput = {
  node?: InputMaybe<UserUpdateInput>
}

export type RenderPropTypeOwnerUpdateFieldInput = {
  connect?: InputMaybe<RenderPropTypeOwnerConnectFieldInput>
  connectOrCreate?: InputMaybe<RenderPropTypeOwnerConnectOrCreateFieldInput>
  create?: InputMaybe<RenderPropTypeOwnerCreateFieldInput>
  delete?: InputMaybe<IBaseTypeOwnerDeleteFieldInput>
  disconnect?: InputMaybe<IBaseTypeOwnerDisconnectFieldInput>
  update?: InputMaybe<RenderPropTypeOwnerUpdateConnectionInput>
  where?: InputMaybe<IBaseTypeOwnerConnectionWhere>
}

/** Fields to sort RenderPropTypes by. The order in which sorts are applied is not guaranteed when specifying many fields in one RenderPropTypeSort object. */
export type RenderPropTypeSort = {
  id?: InputMaybe<SortDirection>
  kind?: InputMaybe<SortDirection>
  name?: InputMaybe<SortDirection>
}

export type RenderPropTypeSubscriptionWhere = {
  AND?: InputMaybe<Array<RenderPropTypeSubscriptionWhere>>
  NOT?: InputMaybe<RenderPropTypeSubscriptionWhere>
  OR?: InputMaybe<Array<RenderPropTypeSubscriptionWhere>>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  kind?: InputMaybe<TypeKind>
  kind_EQ?: InputMaybe<TypeKind>
  kind_IN?: InputMaybe<Array<TypeKind>>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>
  name_MATCHES?: InputMaybe<Scalars['String']['input']>
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
}

export type RenderPropTypeUniqueWhere = {
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
}

export type RenderPropTypeUpdateInput = {
  fieldRefs?: InputMaybe<Array<RenderPropTypeFieldRefsUpdateFieldInput>>
  /** @deprecated Please use the explicit _SET field */
  id?: InputMaybe<Scalars['ID']['input']>
  id_SET?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _SET field */
  kind?: InputMaybe<TypeKind>
  kind_SET?: InputMaybe<TypeKind>
  /** @deprecated Please use the explicit _SET field */
  name?: InputMaybe<Scalars['String']['input']>
  name_SET?: InputMaybe<Scalars['String']['input']>
  owner?: InputMaybe<RenderPropTypeOwnerUpdateFieldInput>
}

export type RenderPropTypeUpdatedEvent = {
  event: EventType
  previousState: RenderPropTypeEventPayload
  timestamp: Scalars['Float']['output']
  updatedRenderPropType: RenderPropTypeEventPayload
}

export type RenderPropTypeUserOwnerAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<RenderPropTypeUserOwnerNodeAggregateSelection>
}

export type RenderPropTypeUserOwnerNodeAggregateSelection = {
  auth0Id: StringAggregateSelection
  email: StringAggregateSelection
  id: IdAggregateSelection
  username: StringAggregateSelection
}

export type RenderPropTypeWhere = {
  AND?: InputMaybe<Array<RenderPropTypeWhere>>
  NOT?: InputMaybe<RenderPropTypeWhere>
  OR?: InputMaybe<Array<RenderPropTypeWhere>>
  fieldRefsAggregate?: InputMaybe<RenderPropTypeFieldRefsAggregateInput>
  /** Return RenderPropTypes where all of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_ALL?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return RenderPropTypes where none of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_NONE?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return RenderPropTypes where one of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_SINGLE?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return RenderPropTypes where some of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_SOME?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return RenderPropTypes where all of the related Fields match this filter */
  fieldRefs_ALL?: InputMaybe<FieldWhere>
  /** Return RenderPropTypes where none of the related Fields match this filter */
  fieldRefs_NONE?: InputMaybe<FieldWhere>
  /** Return RenderPropTypes where one of the related Fields match this filter */
  fieldRefs_SINGLE?: InputMaybe<FieldWhere>
  /** Return RenderPropTypes where some of the related Fields match this filter */
  fieldRefs_SOME?: InputMaybe<FieldWhere>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  kind?: InputMaybe<TypeKind>
  kind_EQ?: InputMaybe<TypeKind>
  kind_IN?: InputMaybe<Array<TypeKind>>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>
  name_MATCHES?: InputMaybe<Scalars['String']['input']>
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  owner?: InputMaybe<UserWhere>
  ownerAggregate?: InputMaybe<RenderPropTypeOwnerAggregateInput>
  ownerConnection?: InputMaybe<IBaseTypeOwnerConnectionWhere>
}

export type RenderPropTypesConnection = {
  edges: Array<RenderPropTypeEdge>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type Resource = WithOwner & {
  config: Prop
  configAggregate?: Maybe<ResourcePropConfigAggregationSelection>
  configConnection: ResourceConfigConnection
  id: Scalars['ID']['output']
  name: Scalars['String']['output']
  owner: User
  ownerAggregate?: Maybe<ResourceUserOwnerAggregationSelection>
  ownerConnection: WithOwnerOwnerConnection
  type: ResourceType
}

export type ResourceConfigArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<PropOptions>
  sort?: InputMaybe<Array<PropSort>>
  where?: InputMaybe<PropWhere>
}

export type ResourceConfigAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<PropWhere>
}

export type ResourceConfigConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<ResourceConfigConnectionSort>>
  where?: InputMaybe<ResourceConfigConnectionWhere>
}

export type ResourceOwnerArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<UserOptions>
  sort?: InputMaybe<Array<UserSort>>
  where?: InputMaybe<UserWhere>
}

export type ResourceOwnerAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<UserWhere>
}

export type ResourceOwnerConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<WithOwnerOwnerConnectionSort>>
  where?: InputMaybe<WithOwnerOwnerConnectionWhere>
}

export type ResourceAggregateSelection = {
  count: Scalars['Int']['output']
  id: IdAggregateSelection
  name: StringAggregateSelection
}

export type ResourceConfigAggregateInput = {
  AND?: InputMaybe<Array<ResourceConfigAggregateInput>>
  NOT?: InputMaybe<ResourceConfigAggregateInput>
  OR?: InputMaybe<Array<ResourceConfigAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<ResourceConfigNodeAggregationWhereInput>
}

export type ResourceConfigConnectFieldInput = {
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<PropConnectWhere>
}

export type ResourceConfigConnectOrCreateFieldInput = {
  onCreate: ResourceConfigConnectOrCreateFieldInputOnCreate
  where: PropConnectOrCreateWhere
}

export type ResourceConfigConnectOrCreateFieldInputOnCreate = {
  node: PropOnCreateInput
}

export type ResourceConfigConnection = {
  edges: Array<ResourceConfigRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type ResourceConfigConnectionSort = {
  node?: InputMaybe<PropSort>
}

export type ResourceConfigConnectionWhere = {
  AND?: InputMaybe<Array<ResourceConfigConnectionWhere>>
  NOT?: InputMaybe<ResourceConfigConnectionWhere>
  OR?: InputMaybe<Array<ResourceConfigConnectionWhere>>
  node?: InputMaybe<PropWhere>
}

export type ResourceConfigCreateFieldInput = {
  node: PropCreateInput
}

export type ResourceConfigDeleteFieldInput = {
  where?: InputMaybe<ResourceConfigConnectionWhere>
}

export type ResourceConfigDisconnectFieldInput = {
  where?: InputMaybe<ResourceConfigConnectionWhere>
}

export type ResourceConfigFieldInput = {
  connect?: InputMaybe<ResourceConfigConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<ResourceConfigConnectOrCreateFieldInput>
  create?: InputMaybe<ResourceConfigCreateFieldInput>
}

export type ResourceConfigNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<ResourceConfigNodeAggregationWhereInput>>
  NOT?: InputMaybe<ResourceConfigNodeAggregationWhereInput>
  OR?: InputMaybe<Array<ResourceConfigNodeAggregationWhereInput>>
  data_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  data_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  data_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  data_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  data_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  data_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  data_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  data_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  data_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  data_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  data_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  data_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  data_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  data_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  data_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
}

export type ResourceConfigRelationship = {
  cursor: Scalars['String']['output']
  node: Prop
}

export type ResourceConfigUpdateConnectionInput = {
  node?: InputMaybe<PropUpdateInput>
}

export type ResourceConfigUpdateFieldInput = {
  connect?: InputMaybe<ResourceConfigConnectFieldInput>
  connectOrCreate?: InputMaybe<ResourceConfigConnectOrCreateFieldInput>
  create?: InputMaybe<ResourceConfigCreateFieldInput>
  delete?: InputMaybe<ResourceConfigDeleteFieldInput>
  disconnect?: InputMaybe<ResourceConfigDisconnectFieldInput>
  update?: InputMaybe<ResourceConfigUpdateConnectionInput>
  where?: InputMaybe<ResourceConfigConnectionWhere>
}

export type ResourceConnectInput = {
  config?: InputMaybe<ResourceConfigConnectFieldInput>
  owner?: InputMaybe<ResourceOwnerConnectFieldInput>
}

export type ResourceConnectOrCreateWhere = {
  node: ResourceUniqueWhere
}

export type ResourceConnectWhere = {
  node: ResourceWhere
}

export type ResourceCreateInput = {
  config?: InputMaybe<ResourceConfigFieldInput>
  id: Scalars['ID']['input']
  name: Scalars['String']['input']
  owner?: InputMaybe<ResourceOwnerFieldInput>
  type: ResourceType
}

export type ResourceCreatedEvent = {
  createdResource: ResourceEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type ResourceDeleteInput = {
  config?: InputMaybe<ResourceConfigDeleteFieldInput>
  owner?: InputMaybe<WithOwnerOwnerDeleteFieldInput>
}

export type ResourceDeletedEvent = {
  deletedResource: ResourceEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type ResourceDisconnectInput = {
  config?: InputMaybe<ResourceConfigDisconnectFieldInput>
  owner?: InputMaybe<WithOwnerOwnerDisconnectFieldInput>
}

export type ResourceEdge = {
  cursor: Scalars['String']['output']
  node: Resource
}

export type ResourceEventPayload = {
  id: Scalars['ID']['output']
  name: Scalars['String']['output']
  type: ResourceType
}

export type ResourceOnCreateInput = {
  id: Scalars['ID']['input']
  name: Scalars['String']['input']
  type: ResourceType
}

export type ResourceOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  /** Specify one or more ResourceSort objects to sort Resources by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<ResourceSort>>
}

export type ResourceOwnerAggregateInput = {
  AND?: InputMaybe<Array<ResourceOwnerAggregateInput>>
  NOT?: InputMaybe<ResourceOwnerAggregateInput>
  OR?: InputMaybe<Array<ResourceOwnerAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<ResourceOwnerNodeAggregationWhereInput>
}

export type ResourceOwnerConnectFieldInput = {
  connect?: InputMaybe<UserConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<UserConnectWhere>
}

export type ResourceOwnerConnectOrCreateFieldInput = {
  onCreate: ResourceOwnerConnectOrCreateFieldInputOnCreate
  where: UserConnectOrCreateWhere
}

export type ResourceOwnerConnectOrCreateFieldInputOnCreate = {
  node: UserOnCreateInput
}

export type ResourceOwnerCreateFieldInput = {
  node: UserCreateInput
}

export type ResourceOwnerFieldInput = {
  connect?: InputMaybe<ResourceOwnerConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<ResourceOwnerConnectOrCreateFieldInput>
  create?: InputMaybe<ResourceOwnerCreateFieldInput>
}

export type ResourceOwnerNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<ResourceOwnerNodeAggregationWhereInput>>
  NOT?: InputMaybe<ResourceOwnerNodeAggregationWhereInput>
  OR?: InputMaybe<Array<ResourceOwnerNodeAggregationWhereInput>>
  auth0Id_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  auth0Id_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  email_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  email_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  username_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  username_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type ResourceOwnerUpdateConnectionInput = {
  node?: InputMaybe<UserUpdateInput>
}

export type ResourceOwnerUpdateFieldInput = {
  connect?: InputMaybe<ResourceOwnerConnectFieldInput>
  connectOrCreate?: InputMaybe<ResourceOwnerConnectOrCreateFieldInput>
  create?: InputMaybe<ResourceOwnerCreateFieldInput>
  delete?: InputMaybe<WithOwnerOwnerDeleteFieldInput>
  disconnect?: InputMaybe<WithOwnerOwnerDisconnectFieldInput>
  update?: InputMaybe<ResourceOwnerUpdateConnectionInput>
  where?: InputMaybe<WithOwnerOwnerConnectionWhere>
}

export type ResourcePropConfigAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<ResourcePropConfigNodeAggregateSelection>
}

export type ResourcePropConfigNodeAggregateSelection = {
  data: StringAggregateSelection
  id: IdAggregateSelection
}

/** Fields to sort Resources by. The order in which sorts are applied is not guaranteed when specifying many fields in one ResourceSort object. */
export type ResourceSort = {
  id?: InputMaybe<SortDirection>
  name?: InputMaybe<SortDirection>
  type?: InputMaybe<SortDirection>
}

export type ResourceSubscriptionWhere = {
  AND?: InputMaybe<Array<ResourceSubscriptionWhere>>
  NOT?: InputMaybe<ResourceSubscriptionWhere>
  OR?: InputMaybe<Array<ResourceSubscriptionWhere>>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>
  name_MATCHES?: InputMaybe<Scalars['String']['input']>
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  type?: InputMaybe<ResourceType>
  type_EQ?: InputMaybe<ResourceType>
  type_IN?: InputMaybe<Array<ResourceType>>
}

export enum ResourceType {
  GraphQl = 'GraphQl',
  Rest = 'Rest',
}

export type ResourceUniqueWhere = {
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
}

export type ResourceUpdateInput = {
  config?: InputMaybe<ResourceConfigUpdateFieldInput>
  /** @deprecated Please use the explicit _SET field */
  name?: InputMaybe<Scalars['String']['input']>
  name_SET?: InputMaybe<Scalars['String']['input']>
  owner?: InputMaybe<ResourceOwnerUpdateFieldInput>
  /** @deprecated Please use the explicit _SET field */
  type?: InputMaybe<ResourceType>
  type_SET?: InputMaybe<ResourceType>
}

export type ResourceUpdatedEvent = {
  event: EventType
  previousState: ResourceEventPayload
  timestamp: Scalars['Float']['output']
  updatedResource: ResourceEventPayload
}

export type ResourceUserOwnerAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<ResourceUserOwnerNodeAggregateSelection>
}

export type ResourceUserOwnerNodeAggregateSelection = {
  auth0Id: StringAggregateSelection
  email: StringAggregateSelection
  id: IdAggregateSelection
  username: StringAggregateSelection
}

export type ResourceWhere = {
  AND?: InputMaybe<Array<ResourceWhere>>
  NOT?: InputMaybe<ResourceWhere>
  OR?: InputMaybe<Array<ResourceWhere>>
  config?: InputMaybe<PropWhere>
  configAggregate?: InputMaybe<ResourceConfigAggregateInput>
  configConnection?: InputMaybe<ResourceConfigConnectionWhere>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>
  name_MATCHES?: InputMaybe<Scalars['String']['input']>
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  owner?: InputMaybe<UserWhere>
  ownerAggregate?: InputMaybe<ResourceOwnerAggregateInput>
  ownerConnection?: InputMaybe<WithOwnerOwnerConnectionWhere>
  /** @deprecated Please use the explicit _EQ version */
  type?: InputMaybe<ResourceType>
  type_EQ?: InputMaybe<ResourceType>
  type_IN?: InputMaybe<Array<ResourceType>>
}

export type ResourcesConnection = {
  edges: Array<ResourceEdge>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

/** Allows picking a app from the list of apps */
export type RichTextType = IBaseType & {
  fieldRefs: Array<Field>
  fieldRefsAggregate?: Maybe<RichTextTypeFieldFieldRefsAggregationSelection>
  fieldRefsConnection: IBaseTypeFieldRefsConnection
  id: Scalars['ID']['output']
  kind: TypeKind
  name: Scalars['String']['output']
  owner: User
  ownerAggregate?: Maybe<RichTextTypeUserOwnerAggregationSelection>
  ownerConnection: IBaseTypeOwnerConnection
}

/** Allows picking a app from the list of apps */
export type RichTextTypeFieldRefsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<FieldOptions>
  sort?: InputMaybe<Array<FieldSort>>
  where?: InputMaybe<FieldWhere>
}

/** Allows picking a app from the list of apps */
export type RichTextTypeFieldRefsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<FieldWhere>
}

/** Allows picking a app from the list of apps */
export type RichTextTypeFieldRefsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<IBaseTypeFieldRefsConnectionSort>>
  where?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
}

/** Allows picking a app from the list of apps */
export type RichTextTypeOwnerArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<UserOptions>
  sort?: InputMaybe<Array<UserSort>>
  where?: InputMaybe<UserWhere>
}

/** Allows picking a app from the list of apps */
export type RichTextTypeOwnerAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<UserWhere>
}

/** Allows picking a app from the list of apps */
export type RichTextTypeOwnerConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<IBaseTypeOwnerConnectionSort>>
  where?: InputMaybe<IBaseTypeOwnerConnectionWhere>
}

export type RichTextTypeAggregateSelection = {
  count: Scalars['Int']['output']
  id: IdAggregateSelection
  name: StringAggregateSelection
}

export type RichTextTypeConnectInput = {
  fieldRefs?: InputMaybe<Array<RichTextTypeFieldRefsConnectFieldInput>>
  owner?: InputMaybe<RichTextTypeOwnerConnectFieldInput>
}

export type RichTextTypeConnectWhere = {
  node: RichTextTypeWhere
}

export type RichTextTypeCreateInput = {
  fieldRefs?: InputMaybe<RichTextTypeFieldRefsFieldInput>
  id: Scalars['ID']['input']
  kind?: TypeKind
  name: Scalars['String']['input']
  owner?: InputMaybe<RichTextTypeOwnerFieldInput>
}

export type RichTextTypeCreatedEvent = {
  createdRichTextType: RichTextTypeEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type RichTextTypeDeleteInput = {
  fieldRefs?: InputMaybe<Array<IBaseTypeFieldRefsDeleteFieldInput>>
  owner?: InputMaybe<IBaseTypeOwnerDeleteFieldInput>
}

export type RichTextTypeDeletedEvent = {
  deletedRichTextType: RichTextTypeEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type RichTextTypeDisconnectInput = {
  fieldRefs?: InputMaybe<Array<IBaseTypeFieldRefsDisconnectFieldInput>>
  owner?: InputMaybe<IBaseTypeOwnerDisconnectFieldInput>
}

export type RichTextTypeEdge = {
  cursor: Scalars['String']['output']
  node: RichTextType
}

export type RichTextTypeEventPayload = {
  id: Scalars['ID']['output']
  kind: TypeKind
  name: Scalars['String']['output']
}

export type RichTextTypeFieldFieldRefsAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<RichTextTypeFieldFieldRefsNodeAggregateSelection>
}

export type RichTextTypeFieldFieldRefsNodeAggregateSelection = {
  defaultValues: StringAggregateSelection
  description: StringAggregateSelection
  id: IdAggregateSelection
  key: StringAggregateSelection
  name: StringAggregateSelection
  validationRules: StringAggregateSelection
}

export type RichTextTypeFieldRefsAggregateInput = {
  AND?: InputMaybe<Array<RichTextTypeFieldRefsAggregateInput>>
  NOT?: InputMaybe<RichTextTypeFieldRefsAggregateInput>
  OR?: InputMaybe<Array<RichTextTypeFieldRefsAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<RichTextTypeFieldRefsNodeAggregationWhereInput>
}

export type RichTextTypeFieldRefsConnectFieldInput = {
  connect?: InputMaybe<Array<FieldConnectInput>>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<FieldConnectWhere>
}

export type RichTextTypeFieldRefsConnectOrCreateFieldInput = {
  onCreate: RichTextTypeFieldRefsConnectOrCreateFieldInputOnCreate
  where: FieldConnectOrCreateWhere
}

export type RichTextTypeFieldRefsConnectOrCreateFieldInputOnCreate = {
  node: FieldOnCreateInput
}

export type RichTextTypeFieldRefsCreateFieldInput = {
  node: FieldCreateInput
}

export type RichTextTypeFieldRefsFieldInput = {
  connect?: InputMaybe<Array<RichTextTypeFieldRefsConnectFieldInput>>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<
    Array<RichTextTypeFieldRefsConnectOrCreateFieldInput>
  >
  create?: InputMaybe<Array<RichTextTypeFieldRefsCreateFieldInput>>
}

export type RichTextTypeFieldRefsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<RichTextTypeFieldRefsNodeAggregationWhereInput>>
  NOT?: InputMaybe<RichTextTypeFieldRefsNodeAggregationWhereInput>
  OR?: InputMaybe<Array<RichTextTypeFieldRefsNodeAggregationWhereInput>>
  defaultValues_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  defaultValues_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  description_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  description_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  key_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  key_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  validationRules_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type RichTextTypeFieldRefsUpdateConnectionInput = {
  node?: InputMaybe<FieldUpdateInput>
}

export type RichTextTypeFieldRefsUpdateFieldInput = {
  connect?: InputMaybe<Array<RichTextTypeFieldRefsConnectFieldInput>>
  connectOrCreate?: InputMaybe<
    Array<RichTextTypeFieldRefsConnectOrCreateFieldInput>
  >
  create?: InputMaybe<Array<RichTextTypeFieldRefsCreateFieldInput>>
  delete?: InputMaybe<Array<IBaseTypeFieldRefsDeleteFieldInput>>
  disconnect?: InputMaybe<Array<IBaseTypeFieldRefsDisconnectFieldInput>>
  update?: InputMaybe<RichTextTypeFieldRefsUpdateConnectionInput>
  where?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
}

export type RichTextTypeOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  /** Specify one or more RichTextTypeSort objects to sort RichTextTypes by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<RichTextTypeSort>>
}

export type RichTextTypeOwnerAggregateInput = {
  AND?: InputMaybe<Array<RichTextTypeOwnerAggregateInput>>
  NOT?: InputMaybe<RichTextTypeOwnerAggregateInput>
  OR?: InputMaybe<Array<RichTextTypeOwnerAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<RichTextTypeOwnerNodeAggregationWhereInput>
}

export type RichTextTypeOwnerConnectFieldInput = {
  connect?: InputMaybe<UserConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<UserConnectWhere>
}

export type RichTextTypeOwnerConnectOrCreateFieldInput = {
  onCreate: RichTextTypeOwnerConnectOrCreateFieldInputOnCreate
  where: UserConnectOrCreateWhere
}

export type RichTextTypeOwnerConnectOrCreateFieldInputOnCreate = {
  node: UserOnCreateInput
}

export type RichTextTypeOwnerCreateFieldInput = {
  node: UserCreateInput
}

export type RichTextTypeOwnerFieldInput = {
  connect?: InputMaybe<RichTextTypeOwnerConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<RichTextTypeOwnerConnectOrCreateFieldInput>
  create?: InputMaybe<RichTextTypeOwnerCreateFieldInput>
}

export type RichTextTypeOwnerNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<RichTextTypeOwnerNodeAggregationWhereInput>>
  NOT?: InputMaybe<RichTextTypeOwnerNodeAggregationWhereInput>
  OR?: InputMaybe<Array<RichTextTypeOwnerNodeAggregationWhereInput>>
  auth0Id_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  auth0Id_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  email_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  email_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  username_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  username_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type RichTextTypeOwnerUpdateConnectionInput = {
  node?: InputMaybe<UserUpdateInput>
}

export type RichTextTypeOwnerUpdateFieldInput = {
  connect?: InputMaybe<RichTextTypeOwnerConnectFieldInput>
  connectOrCreate?: InputMaybe<RichTextTypeOwnerConnectOrCreateFieldInput>
  create?: InputMaybe<RichTextTypeOwnerCreateFieldInput>
  delete?: InputMaybe<IBaseTypeOwnerDeleteFieldInput>
  disconnect?: InputMaybe<IBaseTypeOwnerDisconnectFieldInput>
  update?: InputMaybe<RichTextTypeOwnerUpdateConnectionInput>
  where?: InputMaybe<IBaseTypeOwnerConnectionWhere>
}

/** Fields to sort RichTextTypes by. The order in which sorts are applied is not guaranteed when specifying many fields in one RichTextTypeSort object. */
export type RichTextTypeSort = {
  id?: InputMaybe<SortDirection>
  kind?: InputMaybe<SortDirection>
  name?: InputMaybe<SortDirection>
}

export type RichTextTypeSubscriptionWhere = {
  AND?: InputMaybe<Array<RichTextTypeSubscriptionWhere>>
  NOT?: InputMaybe<RichTextTypeSubscriptionWhere>
  OR?: InputMaybe<Array<RichTextTypeSubscriptionWhere>>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  kind?: InputMaybe<TypeKind>
  kind_EQ?: InputMaybe<TypeKind>
  kind_IN?: InputMaybe<Array<TypeKind>>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>
  name_MATCHES?: InputMaybe<Scalars['String']['input']>
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
}

export type RichTextTypeUpdateInput = {
  fieldRefs?: InputMaybe<Array<RichTextTypeFieldRefsUpdateFieldInput>>
  /** @deprecated Please use the explicit _SET field */
  id?: InputMaybe<Scalars['ID']['input']>
  id_SET?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _SET field */
  kind?: InputMaybe<TypeKind>
  kind_SET?: InputMaybe<TypeKind>
  /** @deprecated Please use the explicit _SET field */
  name?: InputMaybe<Scalars['String']['input']>
  name_SET?: InputMaybe<Scalars['String']['input']>
  owner?: InputMaybe<RichTextTypeOwnerUpdateFieldInput>
}

export type RichTextTypeUpdatedEvent = {
  event: EventType
  previousState: RichTextTypeEventPayload
  timestamp: Scalars['Float']['output']
  updatedRichTextType: RichTextTypeEventPayload
}

export type RichTextTypeUserOwnerAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<RichTextTypeUserOwnerNodeAggregateSelection>
}

export type RichTextTypeUserOwnerNodeAggregateSelection = {
  auth0Id: StringAggregateSelection
  email: StringAggregateSelection
  id: IdAggregateSelection
  username: StringAggregateSelection
}

export type RichTextTypeWhere = {
  AND?: InputMaybe<Array<RichTextTypeWhere>>
  NOT?: InputMaybe<RichTextTypeWhere>
  OR?: InputMaybe<Array<RichTextTypeWhere>>
  fieldRefsAggregate?: InputMaybe<RichTextTypeFieldRefsAggregateInput>
  /** Return RichTextTypes where all of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_ALL?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return RichTextTypes where none of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_NONE?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return RichTextTypes where one of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_SINGLE?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return RichTextTypes where some of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_SOME?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return RichTextTypes where all of the related Fields match this filter */
  fieldRefs_ALL?: InputMaybe<FieldWhere>
  /** Return RichTextTypes where none of the related Fields match this filter */
  fieldRefs_NONE?: InputMaybe<FieldWhere>
  /** Return RichTextTypes where one of the related Fields match this filter */
  fieldRefs_SINGLE?: InputMaybe<FieldWhere>
  /** Return RichTextTypes where some of the related Fields match this filter */
  fieldRefs_SOME?: InputMaybe<FieldWhere>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  kind?: InputMaybe<TypeKind>
  kind_EQ?: InputMaybe<TypeKind>
  kind_IN?: InputMaybe<Array<TypeKind>>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>
  name_MATCHES?: InputMaybe<Scalars['String']['input']>
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  owner?: InputMaybe<UserWhere>
  ownerAggregate?: InputMaybe<RichTextTypeOwnerAggregateInput>
  ownerConnection?: InputMaybe<IBaseTypeOwnerConnectionWhere>
}

export type RichTextTypesConnection = {
  edges: Array<RichTextTypeEdge>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export enum Role {
  Admin = 'Admin',
  User = 'User',
}

/** An enum for sorting in either ascending or descending order. */
export enum SortDirection {
  /** Sort by field values in ascending order. */
  Asc = 'ASC',
  /** Sort by field values in descending order. */
  Desc = 'DESC',
}

export type Store = {
  actions: Array<AnyAction>
  actionsConnection: StoreActionsConnection
  api: InterfaceType
  apiAggregate?: Maybe<StoreInterfaceTypeApiAggregationSelection>
  apiConnection: StoreApiConnection
  id: Scalars['ID']['output']
  name: Scalars['String']['output']
}

export type StoreActionsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<QueryOptions>
  where?: InputMaybe<AnyActionWhere>
}

export type StoreActionsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  where?: InputMaybe<StoreActionsConnectionWhere>
}

export type StoreApiArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<InterfaceTypeOptions>
  sort?: InputMaybe<Array<InterfaceTypeSort>>
  where?: InputMaybe<InterfaceTypeWhere>
}

export type StoreApiAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<InterfaceTypeWhere>
}

export type StoreApiConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<StoreApiConnectionSort>>
  where?: InputMaybe<StoreApiConnectionWhere>
}

export type StoreActionsApiActionConnectFieldInput = {
  connect?: InputMaybe<Array<ApiActionConnectInput>>
  where?: InputMaybe<ApiActionConnectWhere>
}

export type StoreActionsApiActionConnectionWhere = {
  AND?: InputMaybe<Array<StoreActionsApiActionConnectionWhere>>
  NOT?: InputMaybe<StoreActionsApiActionConnectionWhere>
  OR?: InputMaybe<Array<StoreActionsApiActionConnectionWhere>>
  node?: InputMaybe<ApiActionWhere>
}

export type StoreActionsApiActionCreateFieldInput = {
  node: ApiActionCreateInput
}

export type StoreActionsApiActionDeleteFieldInput = {
  delete?: InputMaybe<ApiActionDeleteInput>
  where?: InputMaybe<StoreActionsApiActionConnectionWhere>
}

export type StoreActionsApiActionDisconnectFieldInput = {
  disconnect?: InputMaybe<ApiActionDisconnectInput>
  where?: InputMaybe<StoreActionsApiActionConnectionWhere>
}

export type StoreActionsApiActionFieldInput = {
  connect?: InputMaybe<Array<StoreActionsApiActionConnectFieldInput>>
  create?: InputMaybe<Array<StoreActionsApiActionCreateFieldInput>>
}

export type StoreActionsApiActionUpdateConnectionInput = {
  node?: InputMaybe<ApiActionUpdateInput>
}

export type StoreActionsApiActionUpdateFieldInput = {
  connect?: InputMaybe<Array<StoreActionsApiActionConnectFieldInput>>
  create?: InputMaybe<Array<StoreActionsApiActionCreateFieldInput>>
  delete?: InputMaybe<Array<StoreActionsApiActionDeleteFieldInput>>
  disconnect?: InputMaybe<Array<StoreActionsApiActionDisconnectFieldInput>>
  update?: InputMaybe<StoreActionsApiActionUpdateConnectionInput>
  where?: InputMaybe<StoreActionsApiActionConnectionWhere>
}

export type StoreActionsCodeActionConnectFieldInput = {
  connect?: InputMaybe<Array<CodeActionConnectInput>>
  where?: InputMaybe<CodeActionConnectWhere>
}

export type StoreActionsCodeActionConnectionWhere = {
  AND?: InputMaybe<Array<StoreActionsCodeActionConnectionWhere>>
  NOT?: InputMaybe<StoreActionsCodeActionConnectionWhere>
  OR?: InputMaybe<Array<StoreActionsCodeActionConnectionWhere>>
  node?: InputMaybe<CodeActionWhere>
}

export type StoreActionsCodeActionCreateFieldInput = {
  node: CodeActionCreateInput
}

export type StoreActionsCodeActionDeleteFieldInput = {
  delete?: InputMaybe<CodeActionDeleteInput>
  where?: InputMaybe<StoreActionsCodeActionConnectionWhere>
}

export type StoreActionsCodeActionDisconnectFieldInput = {
  disconnect?: InputMaybe<CodeActionDisconnectInput>
  where?: InputMaybe<StoreActionsCodeActionConnectionWhere>
}

export type StoreActionsCodeActionFieldInput = {
  connect?: InputMaybe<Array<StoreActionsCodeActionConnectFieldInput>>
  create?: InputMaybe<Array<StoreActionsCodeActionCreateFieldInput>>
}

export type StoreActionsCodeActionUpdateConnectionInput = {
  node?: InputMaybe<CodeActionUpdateInput>
}

export type StoreActionsCodeActionUpdateFieldInput = {
  connect?: InputMaybe<Array<StoreActionsCodeActionConnectFieldInput>>
  create?: InputMaybe<Array<StoreActionsCodeActionCreateFieldInput>>
  delete?: InputMaybe<Array<StoreActionsCodeActionDeleteFieldInput>>
  disconnect?: InputMaybe<Array<StoreActionsCodeActionDisconnectFieldInput>>
  update?: InputMaybe<StoreActionsCodeActionUpdateConnectionInput>
  where?: InputMaybe<StoreActionsCodeActionConnectionWhere>
}

export type StoreActionsConnectInput = {
  ApiAction?: InputMaybe<Array<StoreActionsApiActionConnectFieldInput>>
  CodeAction?: InputMaybe<Array<StoreActionsCodeActionConnectFieldInput>>
}

export type StoreActionsConnection = {
  edges: Array<StoreActionsRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type StoreActionsConnectionWhere = {
  ApiAction?: InputMaybe<StoreActionsApiActionConnectionWhere>
  CodeAction?: InputMaybe<StoreActionsCodeActionConnectionWhere>
}

export type StoreActionsCreateInput = {
  ApiAction?: InputMaybe<StoreActionsApiActionFieldInput>
  CodeAction?: InputMaybe<StoreActionsCodeActionFieldInput>
}

export type StoreActionsDeleteInput = {
  ApiAction?: InputMaybe<Array<StoreActionsApiActionDeleteFieldInput>>
  CodeAction?: InputMaybe<Array<StoreActionsCodeActionDeleteFieldInput>>
}

export type StoreActionsDisconnectInput = {
  ApiAction?: InputMaybe<Array<StoreActionsApiActionDisconnectFieldInput>>
  CodeAction?: InputMaybe<Array<StoreActionsCodeActionDisconnectFieldInput>>
}

export type StoreActionsRelationship = {
  cursor: Scalars['String']['output']
  node: AnyAction
}

export type StoreActionsUpdateInput = {
  ApiAction?: InputMaybe<Array<StoreActionsApiActionUpdateFieldInput>>
  CodeAction?: InputMaybe<Array<StoreActionsCodeActionUpdateFieldInput>>
}

export type StoreAggregateSelection = {
  count: Scalars['Int']['output']
  id: IdAggregateSelection
  name: StringAggregateSelection
}

export type StoreApiAggregateInput = {
  AND?: InputMaybe<Array<StoreApiAggregateInput>>
  NOT?: InputMaybe<StoreApiAggregateInput>
  OR?: InputMaybe<Array<StoreApiAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<StoreApiNodeAggregationWhereInput>
}

export type StoreApiConnectFieldInput = {
  connect?: InputMaybe<InterfaceTypeConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<InterfaceTypeConnectWhere>
}

export type StoreApiConnection = {
  edges: Array<StoreApiRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type StoreApiConnectionSort = {
  node?: InputMaybe<InterfaceTypeSort>
}

export type StoreApiConnectionWhere = {
  AND?: InputMaybe<Array<StoreApiConnectionWhere>>
  NOT?: InputMaybe<StoreApiConnectionWhere>
  OR?: InputMaybe<Array<StoreApiConnectionWhere>>
  node?: InputMaybe<InterfaceTypeWhere>
}

export type StoreApiCreateFieldInput = {
  node: InterfaceTypeCreateInput
}

export type StoreApiDeleteFieldInput = {
  delete?: InputMaybe<InterfaceTypeDeleteInput>
  where?: InputMaybe<StoreApiConnectionWhere>
}

export type StoreApiDisconnectFieldInput = {
  disconnect?: InputMaybe<InterfaceTypeDisconnectInput>
  where?: InputMaybe<StoreApiConnectionWhere>
}

export type StoreApiFieldInput = {
  connect?: InputMaybe<StoreApiConnectFieldInput>
  create?: InputMaybe<StoreApiCreateFieldInput>
}

export type StoreApiNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<StoreApiNodeAggregationWhereInput>>
  NOT?: InputMaybe<StoreApiNodeAggregationWhereInput>
  OR?: InputMaybe<Array<StoreApiNodeAggregationWhereInput>>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type StoreApiRelationship = {
  cursor: Scalars['String']['output']
  node: InterfaceType
}

export type StoreApiUpdateConnectionInput = {
  node?: InputMaybe<InterfaceTypeUpdateInput>
}

export type StoreApiUpdateFieldInput = {
  connect?: InputMaybe<StoreApiConnectFieldInput>
  create?: InputMaybe<StoreApiCreateFieldInput>
  delete?: InputMaybe<StoreApiDeleteFieldInput>
  disconnect?: InputMaybe<StoreApiDisconnectFieldInput>
  update?: InputMaybe<StoreApiUpdateConnectionInput>
  where?: InputMaybe<StoreApiConnectionWhere>
}

export type StoreConnectInput = {
  actions?: InputMaybe<StoreActionsConnectInput>
  api?: InputMaybe<StoreApiConnectFieldInput>
}

export type StoreConnectOrCreateWhere = {
  node: StoreUniqueWhere
}

export type StoreConnectWhere = {
  node: StoreWhere
}

export type StoreCreateInput = {
  actions?: InputMaybe<StoreActionsCreateInput>
  api?: InputMaybe<StoreApiFieldInput>
  id: Scalars['ID']['input']
  name: Scalars['String']['input']
}

export type StoreCreatedEvent = {
  createdStore: StoreEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type StoreDeleteInput = {
  actions?: InputMaybe<StoreActionsDeleteInput>
  api?: InputMaybe<StoreApiDeleteFieldInput>
}

export type StoreDeletedEvent = {
  deletedStore: StoreEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type StoreDisconnectInput = {
  actions?: InputMaybe<StoreActionsDisconnectInput>
  api?: InputMaybe<StoreApiDisconnectFieldInput>
}

export type StoreEdge = {
  cursor: Scalars['String']['output']
  node: Store
}

export type StoreEventPayload = {
  id: Scalars['ID']['output']
  name: Scalars['String']['output']
}

export type StoreInterfaceTypeApiAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<StoreInterfaceTypeApiNodeAggregateSelection>
}

export type StoreInterfaceTypeApiNodeAggregateSelection = {
  id: IdAggregateSelection
  name: StringAggregateSelection
}

export type StoreOnCreateInput = {
  id: Scalars['ID']['input']
  name: Scalars['String']['input']
}

export type StoreOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  /** Specify one or more StoreSort objects to sort Stores by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<StoreSort>>
}

/** Fields to sort Stores by. The order in which sorts are applied is not guaranteed when specifying many fields in one StoreSort object. */
export type StoreSort = {
  id?: InputMaybe<SortDirection>
  name?: InputMaybe<SortDirection>
}

export type StoreSubscriptionWhere = {
  AND?: InputMaybe<Array<StoreSubscriptionWhere>>
  NOT?: InputMaybe<StoreSubscriptionWhere>
  OR?: InputMaybe<Array<StoreSubscriptionWhere>>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>
  name_MATCHES?: InputMaybe<Scalars['String']['input']>
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
}

export type StoreUniqueWhere = {
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
}

export type StoreUpdateInput = {
  actions?: InputMaybe<StoreActionsUpdateInput>
  api?: InputMaybe<StoreApiUpdateFieldInput>
  /** @deprecated Please use the explicit _SET field */
  name?: InputMaybe<Scalars['String']['input']>
  name_SET?: InputMaybe<Scalars['String']['input']>
}

export type StoreUpdatedEvent = {
  event: EventType
  previousState: StoreEventPayload
  timestamp: Scalars['Float']['output']
  updatedStore: StoreEventPayload
}

export type StoreWhere = {
  AND?: InputMaybe<Array<StoreWhere>>
  NOT?: InputMaybe<StoreWhere>
  OR?: InputMaybe<Array<StoreWhere>>
  /** Return Stores where all of the related StoreActionsConnections match this filter */
  actionsConnection_ALL?: InputMaybe<StoreActionsConnectionWhere>
  /** Return Stores where none of the related StoreActionsConnections match this filter */
  actionsConnection_NONE?: InputMaybe<StoreActionsConnectionWhere>
  /** Return Stores where one of the related StoreActionsConnections match this filter */
  actionsConnection_SINGLE?: InputMaybe<StoreActionsConnectionWhere>
  /** Return Stores where some of the related StoreActionsConnections match this filter */
  actionsConnection_SOME?: InputMaybe<StoreActionsConnectionWhere>
  /** Return Stores where all of the related AnyActions match this filter */
  actions_ALL?: InputMaybe<AnyActionWhere>
  /** Return Stores where none of the related AnyActions match this filter */
  actions_NONE?: InputMaybe<AnyActionWhere>
  /** Return Stores where one of the related AnyActions match this filter */
  actions_SINGLE?: InputMaybe<AnyActionWhere>
  /** Return Stores where some of the related AnyActions match this filter */
  actions_SOME?: InputMaybe<AnyActionWhere>
  api?: InputMaybe<InterfaceTypeWhere>
  apiAggregate?: InputMaybe<StoreApiAggregateInput>
  apiConnection?: InputMaybe<StoreApiConnectionWhere>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>
  name_MATCHES?: InputMaybe<Scalars['String']['input']>
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
}

export type StoresConnection = {
  edges: Array<StoreEdge>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type StringAggregateSelection = {
  longest?: Maybe<Scalars['String']['output']>
  shortest?: Maybe<Scalars['String']['output']>
}

export type Subscription = {
  actionTypeCreated: ActionTypeCreatedEvent
  actionTypeDeleted: ActionTypeDeletedEvent
  actionTypeUpdated: ActionTypeUpdatedEvent
  apiActionCreated: ApiActionCreatedEvent
  apiActionDeleted: ApiActionDeletedEvent
  apiActionUpdated: ApiActionUpdatedEvent
  appCreated: AppCreatedEvent
  appDeleted: AppDeletedEvent
  appTypeCreated: AppTypeCreatedEvent
  appTypeDeleted: AppTypeDeletedEvent
  appTypeUpdated: AppTypeUpdatedEvent
  appUpdated: AppUpdatedEvent
  arrayTypeCreated: ArrayTypeCreatedEvent
  arrayTypeDeleted: ArrayTypeDeletedEvent
  arrayTypeUpdated: ArrayTypeUpdatedEvent
  atomCreated: AtomCreatedEvent
  atomDeleted: AtomDeletedEvent
  atomUpdated: AtomUpdatedEvent
  authGuardCreated: AuthGuardCreatedEvent
  authGuardDeleted: AuthGuardDeletedEvent
  authGuardUpdated: AuthGuardUpdatedEvent
  codeActionCreated: CodeActionCreatedEvent
  codeActionDeleted: CodeActionDeletedEvent
  codeActionUpdated: CodeActionUpdatedEvent
  codeMirrorTypeCreated: CodeMirrorTypeCreatedEvent
  codeMirrorTypeDeleted: CodeMirrorTypeDeletedEvent
  codeMirrorTypeUpdated: CodeMirrorTypeUpdatedEvent
  componentCreated: ComponentCreatedEvent
  componentDeleted: ComponentDeletedEvent
  componentUpdated: ComponentUpdatedEvent
  domainCreated: DomainCreatedEvent
  domainDeleted: DomainDeletedEvent
  domainUpdated: DomainUpdatedEvent
  elementCreated: ElementCreatedEvent
  elementDeleted: ElementDeletedEvent
  elementTypeCreated: ElementTypeCreatedEvent
  elementTypeDeleted: ElementTypeDeletedEvent
  elementTypeUpdated: ElementTypeUpdatedEvent
  elementUpdated: ElementUpdatedEvent
  enumTypeCreated: EnumTypeCreatedEvent
  enumTypeDeleted: EnumTypeDeletedEvent
  enumTypeUpdated: EnumTypeUpdatedEvent
  enumTypeValueCreated: EnumTypeValueCreatedEvent
  enumTypeValueDeleted: EnumTypeValueDeletedEvent
  enumTypeValueUpdated: EnumTypeValueUpdatedEvent
  fieldCreated: FieldCreatedEvent
  fieldDeleted: FieldDeletedEvent
  fieldUpdated: FieldUpdatedEvent
  hookCreated: HookCreatedEvent
  hookDeleted: HookDeletedEvent
  hookUpdated: HookUpdatedEvent
  interfaceTypeCreated: InterfaceTypeCreatedEvent
  interfaceTypeDeleted: InterfaceTypeDeletedEvent
  interfaceTypeUpdated: InterfaceTypeUpdatedEvent
  lambdaTypeCreated: LambdaTypeCreatedEvent
  lambdaTypeDeleted: LambdaTypeDeletedEvent
  lambdaTypeUpdated: LambdaTypeUpdatedEvent
  pageCreated: PageCreatedEvent
  pageDeleted: PageDeletedEvent
  pageTypeCreated: PageTypeCreatedEvent
  pageTypeDeleted: PageTypeDeletedEvent
  pageTypeUpdated: PageTypeUpdatedEvent
  pageUpdated: PageUpdatedEvent
  preferenceCreated: PreferenceCreatedEvent
  preferenceDeleted: PreferenceDeletedEvent
  preferenceUpdated: PreferenceUpdatedEvent
  primitiveTypeCreated: PrimitiveTypeCreatedEvent
  primitiveTypeDeleted: PrimitiveTypeDeletedEvent
  primitiveTypeUpdated: PrimitiveTypeUpdatedEvent
  productionDomainConfigCreated: ProductionDomainConfigCreatedEvent
  productionDomainConfigDeleted: ProductionDomainConfigDeletedEvent
  productionDomainConfigUpdated: ProductionDomainConfigUpdatedEvent
  propCreated: PropCreatedEvent
  propDeleted: PropDeletedEvent
  propUpdated: PropUpdatedEvent
  reactNodeTypeCreated: ReactNodeTypeCreatedEvent
  reactNodeTypeDeleted: ReactNodeTypeDeletedEvent
  reactNodeTypeUpdated: ReactNodeTypeUpdatedEvent
  redirectCreated: RedirectCreatedEvent
  redirectDeleted: RedirectDeletedEvent
  redirectUpdated: RedirectUpdatedEvent
  renderPropTypeCreated: RenderPropTypeCreatedEvent
  renderPropTypeDeleted: RenderPropTypeDeletedEvent
  renderPropTypeUpdated: RenderPropTypeUpdatedEvent
  resourceCreated: ResourceCreatedEvent
  resourceDeleted: ResourceDeletedEvent
  resourceUpdated: ResourceUpdatedEvent
  richTextTypeCreated: RichTextTypeCreatedEvent
  richTextTypeDeleted: RichTextTypeDeletedEvent
  richTextTypeUpdated: RichTextTypeUpdatedEvent
  storeCreated: StoreCreatedEvent
  storeDeleted: StoreDeletedEvent
  storeUpdated: StoreUpdatedEvent
  tagCreated: TagCreatedEvent
  tagDeleted: TagDeletedEvent
  tagUpdated: TagUpdatedEvent
  typeReferenceCreated: TypeReferenceCreatedEvent
  typeReferenceDeleted: TypeReferenceDeletedEvent
  typeReferenceUpdated: TypeReferenceUpdatedEvent
  unionTypeCreated: UnionTypeCreatedEvent
  unionTypeDeleted: UnionTypeDeletedEvent
  unionTypeUpdated: UnionTypeUpdatedEvent
  userCreated: UserCreatedEvent
  userDeleted: UserDeletedEvent
  userUpdated: UserUpdatedEvent
}

export type SubscriptionActionTypeCreatedArgs = {
  where?: InputMaybe<ActionTypeSubscriptionWhere>
}

export type SubscriptionActionTypeDeletedArgs = {
  where?: InputMaybe<ActionTypeSubscriptionWhere>
}

export type SubscriptionActionTypeUpdatedArgs = {
  where?: InputMaybe<ActionTypeSubscriptionWhere>
}

export type SubscriptionApiActionCreatedArgs = {
  where?: InputMaybe<ApiActionSubscriptionWhere>
}

export type SubscriptionApiActionDeletedArgs = {
  where?: InputMaybe<ApiActionSubscriptionWhere>
}

export type SubscriptionApiActionUpdatedArgs = {
  where?: InputMaybe<ApiActionSubscriptionWhere>
}

export type SubscriptionAppCreatedArgs = {
  where?: InputMaybe<AppSubscriptionWhere>
}

export type SubscriptionAppDeletedArgs = {
  where?: InputMaybe<AppSubscriptionWhere>
}

export type SubscriptionAppTypeCreatedArgs = {
  where?: InputMaybe<AppTypeSubscriptionWhere>
}

export type SubscriptionAppTypeDeletedArgs = {
  where?: InputMaybe<AppTypeSubscriptionWhere>
}

export type SubscriptionAppTypeUpdatedArgs = {
  where?: InputMaybe<AppTypeSubscriptionWhere>
}

export type SubscriptionAppUpdatedArgs = {
  where?: InputMaybe<AppSubscriptionWhere>
}

export type SubscriptionArrayTypeCreatedArgs = {
  where?: InputMaybe<ArrayTypeSubscriptionWhere>
}

export type SubscriptionArrayTypeDeletedArgs = {
  where?: InputMaybe<ArrayTypeSubscriptionWhere>
}

export type SubscriptionArrayTypeUpdatedArgs = {
  where?: InputMaybe<ArrayTypeSubscriptionWhere>
}

export type SubscriptionAtomCreatedArgs = {
  where?: InputMaybe<AtomSubscriptionWhere>
}

export type SubscriptionAtomDeletedArgs = {
  where?: InputMaybe<AtomSubscriptionWhere>
}

export type SubscriptionAtomUpdatedArgs = {
  where?: InputMaybe<AtomSubscriptionWhere>
}

export type SubscriptionAuthGuardCreatedArgs = {
  where?: InputMaybe<AuthGuardSubscriptionWhere>
}

export type SubscriptionAuthGuardDeletedArgs = {
  where?: InputMaybe<AuthGuardSubscriptionWhere>
}

export type SubscriptionAuthGuardUpdatedArgs = {
  where?: InputMaybe<AuthGuardSubscriptionWhere>
}

export type SubscriptionCodeActionCreatedArgs = {
  where?: InputMaybe<CodeActionSubscriptionWhere>
}

export type SubscriptionCodeActionDeletedArgs = {
  where?: InputMaybe<CodeActionSubscriptionWhere>
}

export type SubscriptionCodeActionUpdatedArgs = {
  where?: InputMaybe<CodeActionSubscriptionWhere>
}

export type SubscriptionCodeMirrorTypeCreatedArgs = {
  where?: InputMaybe<CodeMirrorTypeSubscriptionWhere>
}

export type SubscriptionCodeMirrorTypeDeletedArgs = {
  where?: InputMaybe<CodeMirrorTypeSubscriptionWhere>
}

export type SubscriptionCodeMirrorTypeUpdatedArgs = {
  where?: InputMaybe<CodeMirrorTypeSubscriptionWhere>
}

export type SubscriptionComponentCreatedArgs = {
  where?: InputMaybe<ComponentSubscriptionWhere>
}

export type SubscriptionComponentDeletedArgs = {
  where?: InputMaybe<ComponentSubscriptionWhere>
}

export type SubscriptionComponentUpdatedArgs = {
  where?: InputMaybe<ComponentSubscriptionWhere>
}

export type SubscriptionDomainCreatedArgs = {
  where?: InputMaybe<DomainSubscriptionWhere>
}

export type SubscriptionDomainDeletedArgs = {
  where?: InputMaybe<DomainSubscriptionWhere>
}

export type SubscriptionDomainUpdatedArgs = {
  where?: InputMaybe<DomainSubscriptionWhere>
}

export type SubscriptionElementCreatedArgs = {
  where?: InputMaybe<ElementSubscriptionWhere>
}

export type SubscriptionElementDeletedArgs = {
  where?: InputMaybe<ElementSubscriptionWhere>
}

export type SubscriptionElementTypeCreatedArgs = {
  where?: InputMaybe<ElementTypeSubscriptionWhere>
}

export type SubscriptionElementTypeDeletedArgs = {
  where?: InputMaybe<ElementTypeSubscriptionWhere>
}

export type SubscriptionElementTypeUpdatedArgs = {
  where?: InputMaybe<ElementTypeSubscriptionWhere>
}

export type SubscriptionElementUpdatedArgs = {
  where?: InputMaybe<ElementSubscriptionWhere>
}

export type SubscriptionEnumTypeCreatedArgs = {
  where?: InputMaybe<EnumTypeSubscriptionWhere>
}

export type SubscriptionEnumTypeDeletedArgs = {
  where?: InputMaybe<EnumTypeSubscriptionWhere>
}

export type SubscriptionEnumTypeUpdatedArgs = {
  where?: InputMaybe<EnumTypeSubscriptionWhere>
}

export type SubscriptionEnumTypeValueCreatedArgs = {
  where?: InputMaybe<EnumTypeValueSubscriptionWhere>
}

export type SubscriptionEnumTypeValueDeletedArgs = {
  where?: InputMaybe<EnumTypeValueSubscriptionWhere>
}

export type SubscriptionEnumTypeValueUpdatedArgs = {
  where?: InputMaybe<EnumTypeValueSubscriptionWhere>
}

export type SubscriptionFieldCreatedArgs = {
  where?: InputMaybe<FieldSubscriptionWhere>
}

export type SubscriptionFieldDeletedArgs = {
  where?: InputMaybe<FieldSubscriptionWhere>
}

export type SubscriptionFieldUpdatedArgs = {
  where?: InputMaybe<FieldSubscriptionWhere>
}

export type SubscriptionHookCreatedArgs = {
  where?: InputMaybe<HookSubscriptionWhere>
}

export type SubscriptionHookDeletedArgs = {
  where?: InputMaybe<HookSubscriptionWhere>
}

export type SubscriptionHookUpdatedArgs = {
  where?: InputMaybe<HookSubscriptionWhere>
}

export type SubscriptionInterfaceTypeCreatedArgs = {
  where?: InputMaybe<InterfaceTypeSubscriptionWhere>
}

export type SubscriptionInterfaceTypeDeletedArgs = {
  where?: InputMaybe<InterfaceTypeSubscriptionWhere>
}

export type SubscriptionInterfaceTypeUpdatedArgs = {
  where?: InputMaybe<InterfaceTypeSubscriptionWhere>
}

export type SubscriptionLambdaTypeCreatedArgs = {
  where?: InputMaybe<LambdaTypeSubscriptionWhere>
}

export type SubscriptionLambdaTypeDeletedArgs = {
  where?: InputMaybe<LambdaTypeSubscriptionWhere>
}

export type SubscriptionLambdaTypeUpdatedArgs = {
  where?: InputMaybe<LambdaTypeSubscriptionWhere>
}

export type SubscriptionPageCreatedArgs = {
  where?: InputMaybe<PageSubscriptionWhere>
}

export type SubscriptionPageDeletedArgs = {
  where?: InputMaybe<PageSubscriptionWhere>
}

export type SubscriptionPageTypeCreatedArgs = {
  where?: InputMaybe<PageTypeSubscriptionWhere>
}

export type SubscriptionPageTypeDeletedArgs = {
  where?: InputMaybe<PageTypeSubscriptionWhere>
}

export type SubscriptionPageTypeUpdatedArgs = {
  where?: InputMaybe<PageTypeSubscriptionWhere>
}

export type SubscriptionPageUpdatedArgs = {
  where?: InputMaybe<PageSubscriptionWhere>
}

export type SubscriptionPreferenceCreatedArgs = {
  where?: InputMaybe<PreferenceSubscriptionWhere>
}

export type SubscriptionPreferenceDeletedArgs = {
  where?: InputMaybe<PreferenceSubscriptionWhere>
}

export type SubscriptionPreferenceUpdatedArgs = {
  where?: InputMaybe<PreferenceSubscriptionWhere>
}

export type SubscriptionPrimitiveTypeCreatedArgs = {
  where?: InputMaybe<PrimitiveTypeSubscriptionWhere>
}

export type SubscriptionPrimitiveTypeDeletedArgs = {
  where?: InputMaybe<PrimitiveTypeSubscriptionWhere>
}

export type SubscriptionPrimitiveTypeUpdatedArgs = {
  where?: InputMaybe<PrimitiveTypeSubscriptionWhere>
}

export type SubscriptionProductionDomainConfigCreatedArgs = {
  where?: InputMaybe<ProductionDomainConfigSubscriptionWhere>
}

export type SubscriptionProductionDomainConfigDeletedArgs = {
  where?: InputMaybe<ProductionDomainConfigSubscriptionWhere>
}

export type SubscriptionProductionDomainConfigUpdatedArgs = {
  where?: InputMaybe<ProductionDomainConfigSubscriptionWhere>
}

export type SubscriptionPropCreatedArgs = {
  where?: InputMaybe<PropSubscriptionWhere>
}

export type SubscriptionPropDeletedArgs = {
  where?: InputMaybe<PropSubscriptionWhere>
}

export type SubscriptionPropUpdatedArgs = {
  where?: InputMaybe<PropSubscriptionWhere>
}

export type SubscriptionReactNodeTypeCreatedArgs = {
  where?: InputMaybe<ReactNodeTypeSubscriptionWhere>
}

export type SubscriptionReactNodeTypeDeletedArgs = {
  where?: InputMaybe<ReactNodeTypeSubscriptionWhere>
}

export type SubscriptionReactNodeTypeUpdatedArgs = {
  where?: InputMaybe<ReactNodeTypeSubscriptionWhere>
}

export type SubscriptionRedirectCreatedArgs = {
  where?: InputMaybe<RedirectSubscriptionWhere>
}

export type SubscriptionRedirectDeletedArgs = {
  where?: InputMaybe<RedirectSubscriptionWhere>
}

export type SubscriptionRedirectUpdatedArgs = {
  where?: InputMaybe<RedirectSubscriptionWhere>
}

export type SubscriptionRenderPropTypeCreatedArgs = {
  where?: InputMaybe<RenderPropTypeSubscriptionWhere>
}

export type SubscriptionRenderPropTypeDeletedArgs = {
  where?: InputMaybe<RenderPropTypeSubscriptionWhere>
}

export type SubscriptionRenderPropTypeUpdatedArgs = {
  where?: InputMaybe<RenderPropTypeSubscriptionWhere>
}

export type SubscriptionResourceCreatedArgs = {
  where?: InputMaybe<ResourceSubscriptionWhere>
}

export type SubscriptionResourceDeletedArgs = {
  where?: InputMaybe<ResourceSubscriptionWhere>
}

export type SubscriptionResourceUpdatedArgs = {
  where?: InputMaybe<ResourceSubscriptionWhere>
}

export type SubscriptionRichTextTypeCreatedArgs = {
  where?: InputMaybe<RichTextTypeSubscriptionWhere>
}

export type SubscriptionRichTextTypeDeletedArgs = {
  where?: InputMaybe<RichTextTypeSubscriptionWhere>
}

export type SubscriptionRichTextTypeUpdatedArgs = {
  where?: InputMaybe<RichTextTypeSubscriptionWhere>
}

export type SubscriptionStoreCreatedArgs = {
  where?: InputMaybe<StoreSubscriptionWhere>
}

export type SubscriptionStoreDeletedArgs = {
  where?: InputMaybe<StoreSubscriptionWhere>
}

export type SubscriptionStoreUpdatedArgs = {
  where?: InputMaybe<StoreSubscriptionWhere>
}

export type SubscriptionTagCreatedArgs = {
  where?: InputMaybe<TagSubscriptionWhere>
}

export type SubscriptionTagDeletedArgs = {
  where?: InputMaybe<TagSubscriptionWhere>
}

export type SubscriptionTagUpdatedArgs = {
  where?: InputMaybe<TagSubscriptionWhere>
}

export type SubscriptionTypeReferenceCreatedArgs = {
  where?: InputMaybe<TypeReferenceSubscriptionWhere>
}

export type SubscriptionTypeReferenceDeletedArgs = {
  where?: InputMaybe<TypeReferenceSubscriptionWhere>
}

export type SubscriptionTypeReferenceUpdatedArgs = {
  where?: InputMaybe<TypeReferenceSubscriptionWhere>
}

export type SubscriptionUnionTypeCreatedArgs = {
  where?: InputMaybe<UnionTypeSubscriptionWhere>
}

export type SubscriptionUnionTypeDeletedArgs = {
  where?: InputMaybe<UnionTypeSubscriptionWhere>
}

export type SubscriptionUnionTypeUpdatedArgs = {
  where?: InputMaybe<UnionTypeSubscriptionWhere>
}

export type SubscriptionUserCreatedArgs = {
  where?: InputMaybe<UserSubscriptionWhere>
}

export type SubscriptionUserDeletedArgs = {
  where?: InputMaybe<UserSubscriptionWhere>
}

export type SubscriptionUserUpdatedArgs = {
  where?: InputMaybe<UserSubscriptionWhere>
}

export type Tag = WithOwner & {
  atoms: Array<Atom>
  atomsAggregate?: Maybe<TagAtomAtomsAggregationSelection>
  atomsConnection: TagAtomsConnection
  children: Array<Tag>
  childrenAggregate?: Maybe<TagTagChildrenAggregationSelection>
  childrenConnection: TagChildrenConnection
  descendants: Array<Tag>
  id: Scalars['ID']['output']
  name: Scalars['String']['output']
  owner: User
  ownerAggregate?: Maybe<TagUserOwnerAggregationSelection>
  ownerConnection: WithOwnerOwnerConnection
  parent?: Maybe<Tag>
  parentAggregate?: Maybe<TagTagParentAggregationSelection>
  parentConnection: TagParentConnection
}

export type TagAtomsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<AtomOptions>
  sort?: InputMaybe<Array<AtomSort>>
  where?: InputMaybe<AtomWhere>
}

export type TagAtomsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<AtomWhere>
}

export type TagAtomsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<TagAtomsConnectionSort>>
  where?: InputMaybe<TagAtomsConnectionWhere>
}

export type TagChildrenArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<TagOptions>
  sort?: InputMaybe<Array<TagSort>>
  where?: InputMaybe<TagWhere>
}

export type TagChildrenAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<TagWhere>
}

export type TagChildrenConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<TagChildrenConnectionSort>>
  where?: InputMaybe<TagChildrenConnectionWhere>
}

export type TagOwnerArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<UserOptions>
  sort?: InputMaybe<Array<UserSort>>
  where?: InputMaybe<UserWhere>
}

export type TagOwnerAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<UserWhere>
}

export type TagOwnerConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<WithOwnerOwnerConnectionSort>>
  where?: InputMaybe<WithOwnerOwnerConnectionWhere>
}

export type TagParentArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<TagOptions>
  sort?: InputMaybe<Array<TagSort>>
  where?: InputMaybe<TagWhere>
}

export type TagParentAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<TagWhere>
}

export type TagParentConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<TagParentConnectionSort>>
  where?: InputMaybe<TagParentConnectionWhere>
}

export type TagAggregateSelection = {
  count: Scalars['Int']['output']
  id: IdAggregateSelection
  name: StringAggregateSelection
}

export type TagAtomAtomsAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<TagAtomAtomsNodeAggregateSelection>
}

export type TagAtomAtomsNodeAggregateSelection = {
  externalCssSource: StringAggregateSelection
  externalJsSource: StringAggregateSelection
  externalSourceType: StringAggregateSelection
  icon: StringAggregateSelection
  id: IdAggregateSelection
  name: StringAggregateSelection
}

export type TagAtomsAggregateInput = {
  AND?: InputMaybe<Array<TagAtomsAggregateInput>>
  NOT?: InputMaybe<TagAtomsAggregateInput>
  OR?: InputMaybe<Array<TagAtomsAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<TagAtomsNodeAggregationWhereInput>
}

export type TagAtomsConnectFieldInput = {
  connect?: InputMaybe<Array<AtomConnectInput>>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<AtomConnectWhere>
}

export type TagAtomsConnectOrCreateFieldInput = {
  onCreate: TagAtomsConnectOrCreateFieldInputOnCreate
  where: AtomConnectOrCreateWhere
}

export type TagAtomsConnectOrCreateFieldInputOnCreate = {
  node: AtomOnCreateInput
}

export type TagAtomsConnection = {
  edges: Array<TagAtomsRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type TagAtomsConnectionSort = {
  node?: InputMaybe<AtomSort>
}

export type TagAtomsConnectionWhere = {
  AND?: InputMaybe<Array<TagAtomsConnectionWhere>>
  NOT?: InputMaybe<TagAtomsConnectionWhere>
  OR?: InputMaybe<Array<TagAtomsConnectionWhere>>
  node?: InputMaybe<AtomWhere>
}

export type TagAtomsCreateFieldInput = {
  node: AtomCreateInput
}

export type TagAtomsDeleteFieldInput = {
  delete?: InputMaybe<AtomDeleteInput>
  where?: InputMaybe<TagAtomsConnectionWhere>
}

export type TagAtomsDisconnectFieldInput = {
  disconnect?: InputMaybe<AtomDisconnectInput>
  where?: InputMaybe<TagAtomsConnectionWhere>
}

export type TagAtomsFieldInput = {
  connect?: InputMaybe<Array<TagAtomsConnectFieldInput>>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<Array<TagAtomsConnectOrCreateFieldInput>>
  create?: InputMaybe<Array<TagAtomsCreateFieldInput>>
}

export type TagAtomsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<TagAtomsNodeAggregationWhereInput>>
  NOT?: InputMaybe<TagAtomsNodeAggregationWhereInput>
  OR?: InputMaybe<Array<TagAtomsNodeAggregationWhereInput>>
  externalCssSource_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  externalCssSource_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  externalCssSource_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  externalCssSource_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  externalCssSource_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  externalCssSource_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  externalCssSource_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  externalCssSource_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  externalCssSource_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  externalCssSource_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  externalCssSource_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  externalCssSource_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  externalCssSource_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  externalCssSource_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  externalCssSource_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  externalJsSource_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  externalJsSource_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  externalJsSource_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  externalJsSource_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  externalJsSource_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  externalJsSource_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  externalJsSource_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  externalJsSource_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  externalJsSource_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  externalJsSource_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  externalJsSource_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  externalJsSource_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  externalJsSource_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  externalJsSource_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  externalJsSource_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  externalSourceType_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  externalSourceType_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  externalSourceType_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  externalSourceType_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  externalSourceType_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  externalSourceType_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  externalSourceType_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  externalSourceType_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  externalSourceType_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  externalSourceType_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  externalSourceType_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  externalSourceType_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  externalSourceType_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  externalSourceType_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  externalSourceType_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  icon_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  icon_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  icon_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  icon_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  icon_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  icon_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  icon_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  icon_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  icon_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  icon_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  icon_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  icon_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  icon_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  icon_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  icon_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type TagAtomsRelationship = {
  cursor: Scalars['String']['output']
  node: Atom
}

export type TagAtomsUpdateConnectionInput = {
  node?: InputMaybe<AtomUpdateInput>
}

export type TagAtomsUpdateFieldInput = {
  connect?: InputMaybe<Array<TagAtomsConnectFieldInput>>
  connectOrCreate?: InputMaybe<Array<TagAtomsConnectOrCreateFieldInput>>
  create?: InputMaybe<Array<TagAtomsCreateFieldInput>>
  delete?: InputMaybe<Array<TagAtomsDeleteFieldInput>>
  disconnect?: InputMaybe<Array<TagAtomsDisconnectFieldInput>>
  update?: InputMaybe<TagAtomsUpdateConnectionInput>
  where?: InputMaybe<TagAtomsConnectionWhere>
}

export type TagChildrenAggregateInput = {
  AND?: InputMaybe<Array<TagChildrenAggregateInput>>
  NOT?: InputMaybe<TagChildrenAggregateInput>
  OR?: InputMaybe<Array<TagChildrenAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<TagChildrenNodeAggregationWhereInput>
}

export type TagChildrenConnectFieldInput = {
  connect?: InputMaybe<Array<TagConnectInput>>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<TagConnectWhere>
}

export type TagChildrenConnectOrCreateFieldInput = {
  onCreate: TagChildrenConnectOrCreateFieldInputOnCreate
  where: TagConnectOrCreateWhere
}

export type TagChildrenConnectOrCreateFieldInputOnCreate = {
  node: TagOnCreateInput
}

export type TagChildrenConnection = {
  edges: Array<TagChildrenRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type TagChildrenConnectionSort = {
  node?: InputMaybe<TagSort>
}

export type TagChildrenConnectionWhere = {
  AND?: InputMaybe<Array<TagChildrenConnectionWhere>>
  NOT?: InputMaybe<TagChildrenConnectionWhere>
  OR?: InputMaybe<Array<TagChildrenConnectionWhere>>
  node?: InputMaybe<TagWhere>
}

export type TagChildrenCreateFieldInput = {
  node: TagCreateInput
}

export type TagChildrenDeleteFieldInput = {
  delete?: InputMaybe<TagDeleteInput>
  where?: InputMaybe<TagChildrenConnectionWhere>
}

export type TagChildrenDisconnectFieldInput = {
  disconnect?: InputMaybe<TagDisconnectInput>
  where?: InputMaybe<TagChildrenConnectionWhere>
}

export type TagChildrenFieldInput = {
  connect?: InputMaybe<Array<TagChildrenConnectFieldInput>>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<Array<TagChildrenConnectOrCreateFieldInput>>
  create?: InputMaybe<Array<TagChildrenCreateFieldInput>>
}

export type TagChildrenNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<TagChildrenNodeAggregationWhereInput>>
  NOT?: InputMaybe<TagChildrenNodeAggregationWhereInput>
  OR?: InputMaybe<Array<TagChildrenNodeAggregationWhereInput>>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type TagChildrenRelationship = {
  cursor: Scalars['String']['output']
  node: Tag
}

export type TagChildrenUpdateConnectionInput = {
  node?: InputMaybe<TagUpdateInput>
}

export type TagChildrenUpdateFieldInput = {
  connect?: InputMaybe<Array<TagChildrenConnectFieldInput>>
  connectOrCreate?: InputMaybe<Array<TagChildrenConnectOrCreateFieldInput>>
  create?: InputMaybe<Array<TagChildrenCreateFieldInput>>
  delete?: InputMaybe<Array<TagChildrenDeleteFieldInput>>
  disconnect?: InputMaybe<Array<TagChildrenDisconnectFieldInput>>
  update?: InputMaybe<TagChildrenUpdateConnectionInput>
  where?: InputMaybe<TagChildrenConnectionWhere>
}

export type TagConnectInput = {
  atoms?: InputMaybe<Array<TagAtomsConnectFieldInput>>
  children?: InputMaybe<Array<TagChildrenConnectFieldInput>>
  owner?: InputMaybe<TagOwnerConnectFieldInput>
  parent?: InputMaybe<TagParentConnectFieldInput>
}

export type TagConnectOrCreateWhere = {
  node: TagUniqueWhere
}

export type TagConnectWhere = {
  node: TagWhere
}

export type TagCreateInput = {
  atoms?: InputMaybe<TagAtomsFieldInput>
  children?: InputMaybe<TagChildrenFieldInput>
  id: Scalars['ID']['input']
  name: Scalars['String']['input']
  owner?: InputMaybe<TagOwnerFieldInput>
  parent?: InputMaybe<TagParentFieldInput>
}

export type TagCreatedEvent = {
  createdTag: TagEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type TagDeleteInput = {
  atoms?: InputMaybe<Array<TagAtomsDeleteFieldInput>>
  children?: InputMaybe<Array<TagChildrenDeleteFieldInput>>
  owner?: InputMaybe<WithOwnerOwnerDeleteFieldInput>
  parent?: InputMaybe<TagParentDeleteFieldInput>
}

export type TagDeletedEvent = {
  deletedTag: TagEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type TagDisconnectInput = {
  atoms?: InputMaybe<Array<TagAtomsDisconnectFieldInput>>
  children?: InputMaybe<Array<TagChildrenDisconnectFieldInput>>
  owner?: InputMaybe<WithOwnerOwnerDisconnectFieldInput>
  parent?: InputMaybe<TagParentDisconnectFieldInput>
}

export type TagEdge = {
  cursor: Scalars['String']['output']
  node: Tag
}

export type TagEventPayload = {
  id: Scalars['ID']['output']
  name: Scalars['String']['output']
}

export type TagOnCreateInput = {
  id: Scalars['ID']['input']
  name: Scalars['String']['input']
}

export type TagOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  /** Specify one or more TagSort objects to sort Tags by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<TagSort>>
}

export type TagOwnerAggregateInput = {
  AND?: InputMaybe<Array<TagOwnerAggregateInput>>
  NOT?: InputMaybe<TagOwnerAggregateInput>
  OR?: InputMaybe<Array<TagOwnerAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<TagOwnerNodeAggregationWhereInput>
}

export type TagOwnerConnectFieldInput = {
  connect?: InputMaybe<UserConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<UserConnectWhere>
}

export type TagOwnerConnectOrCreateFieldInput = {
  onCreate: TagOwnerConnectOrCreateFieldInputOnCreate
  where: UserConnectOrCreateWhere
}

export type TagOwnerConnectOrCreateFieldInputOnCreate = {
  node: UserOnCreateInput
}

export type TagOwnerCreateFieldInput = {
  node: UserCreateInput
}

export type TagOwnerFieldInput = {
  connect?: InputMaybe<TagOwnerConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<TagOwnerConnectOrCreateFieldInput>
  create?: InputMaybe<TagOwnerCreateFieldInput>
}

export type TagOwnerNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<TagOwnerNodeAggregationWhereInput>>
  NOT?: InputMaybe<TagOwnerNodeAggregationWhereInput>
  OR?: InputMaybe<Array<TagOwnerNodeAggregationWhereInput>>
  auth0Id_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  auth0Id_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  email_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  email_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  username_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  username_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type TagOwnerUpdateConnectionInput = {
  node?: InputMaybe<UserUpdateInput>
}

export type TagOwnerUpdateFieldInput = {
  connect?: InputMaybe<TagOwnerConnectFieldInput>
  connectOrCreate?: InputMaybe<TagOwnerConnectOrCreateFieldInput>
  create?: InputMaybe<TagOwnerCreateFieldInput>
  delete?: InputMaybe<WithOwnerOwnerDeleteFieldInput>
  disconnect?: InputMaybe<WithOwnerOwnerDisconnectFieldInput>
  update?: InputMaybe<TagOwnerUpdateConnectionInput>
  where?: InputMaybe<WithOwnerOwnerConnectionWhere>
}

export type TagParentAggregateInput = {
  AND?: InputMaybe<Array<TagParentAggregateInput>>
  NOT?: InputMaybe<TagParentAggregateInput>
  OR?: InputMaybe<Array<TagParentAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<TagParentNodeAggregationWhereInput>
}

export type TagParentConnectFieldInput = {
  connect?: InputMaybe<TagConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<TagConnectWhere>
}

export type TagParentConnectOrCreateFieldInput = {
  onCreate: TagParentConnectOrCreateFieldInputOnCreate
  where: TagConnectOrCreateWhere
}

export type TagParentConnectOrCreateFieldInputOnCreate = {
  node: TagOnCreateInput
}

export type TagParentConnection = {
  edges: Array<TagParentRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type TagParentConnectionSort = {
  node?: InputMaybe<TagSort>
}

export type TagParentConnectionWhere = {
  AND?: InputMaybe<Array<TagParentConnectionWhere>>
  NOT?: InputMaybe<TagParentConnectionWhere>
  OR?: InputMaybe<Array<TagParentConnectionWhere>>
  node?: InputMaybe<TagWhere>
}

export type TagParentCreateFieldInput = {
  node: TagCreateInput
}

export type TagParentDeleteFieldInput = {
  delete?: InputMaybe<TagDeleteInput>
  where?: InputMaybe<TagParentConnectionWhere>
}

export type TagParentDisconnectFieldInput = {
  disconnect?: InputMaybe<TagDisconnectInput>
  where?: InputMaybe<TagParentConnectionWhere>
}

export type TagParentFieldInput = {
  connect?: InputMaybe<TagParentConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<TagParentConnectOrCreateFieldInput>
  create?: InputMaybe<TagParentCreateFieldInput>
}

export type TagParentNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<TagParentNodeAggregationWhereInput>>
  NOT?: InputMaybe<TagParentNodeAggregationWhereInput>
  OR?: InputMaybe<Array<TagParentNodeAggregationWhereInput>>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type TagParentRelationship = {
  cursor: Scalars['String']['output']
  node: Tag
}

export type TagParentUpdateConnectionInput = {
  node?: InputMaybe<TagUpdateInput>
}

export type TagParentUpdateFieldInput = {
  connect?: InputMaybe<TagParentConnectFieldInput>
  connectOrCreate?: InputMaybe<TagParentConnectOrCreateFieldInput>
  create?: InputMaybe<TagParentCreateFieldInput>
  delete?: InputMaybe<TagParentDeleteFieldInput>
  disconnect?: InputMaybe<TagParentDisconnectFieldInput>
  update?: InputMaybe<TagParentUpdateConnectionInput>
  where?: InputMaybe<TagParentConnectionWhere>
}

/** Fields to sort Tags by. The order in which sorts are applied is not guaranteed when specifying many fields in one TagSort object. */
export type TagSort = {
  id?: InputMaybe<SortDirection>
  name?: InputMaybe<SortDirection>
}

export type TagSubscriptionWhere = {
  AND?: InputMaybe<Array<TagSubscriptionWhere>>
  NOT?: InputMaybe<TagSubscriptionWhere>
  OR?: InputMaybe<Array<TagSubscriptionWhere>>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>
  name_MATCHES?: InputMaybe<Scalars['String']['input']>
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
}

export type TagTagChildrenAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<TagTagChildrenNodeAggregateSelection>
}

export type TagTagChildrenNodeAggregateSelection = {
  id: IdAggregateSelection
  name: StringAggregateSelection
}

export type TagTagParentAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<TagTagParentNodeAggregateSelection>
}

export type TagTagParentNodeAggregateSelection = {
  id: IdAggregateSelection
  name: StringAggregateSelection
}

export type TagUniqueWhere = {
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
}

export type TagUpdateInput = {
  atoms?: InputMaybe<Array<TagAtomsUpdateFieldInput>>
  children?: InputMaybe<Array<TagChildrenUpdateFieldInput>>
  /** @deprecated Please use the explicit _SET field */
  name?: InputMaybe<Scalars['String']['input']>
  name_SET?: InputMaybe<Scalars['String']['input']>
  owner?: InputMaybe<TagOwnerUpdateFieldInput>
  parent?: InputMaybe<TagParentUpdateFieldInput>
}

export type TagUpdatedEvent = {
  event: EventType
  previousState: TagEventPayload
  timestamp: Scalars['Float']['output']
  updatedTag: TagEventPayload
}

export type TagUserOwnerAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<TagUserOwnerNodeAggregateSelection>
}

export type TagUserOwnerNodeAggregateSelection = {
  auth0Id: StringAggregateSelection
  email: StringAggregateSelection
  id: IdAggregateSelection
  username: StringAggregateSelection
}

export type TagWhere = {
  AND?: InputMaybe<Array<TagWhere>>
  NOT?: InputMaybe<TagWhere>
  OR?: InputMaybe<Array<TagWhere>>
  atomsAggregate?: InputMaybe<TagAtomsAggregateInput>
  /** Return Tags where all of the related TagAtomsConnections match this filter */
  atomsConnection_ALL?: InputMaybe<TagAtomsConnectionWhere>
  /** Return Tags where none of the related TagAtomsConnections match this filter */
  atomsConnection_NONE?: InputMaybe<TagAtomsConnectionWhere>
  /** Return Tags where one of the related TagAtomsConnections match this filter */
  atomsConnection_SINGLE?: InputMaybe<TagAtomsConnectionWhere>
  /** Return Tags where some of the related TagAtomsConnections match this filter */
  atomsConnection_SOME?: InputMaybe<TagAtomsConnectionWhere>
  /** Return Tags where all of the related Atoms match this filter */
  atoms_ALL?: InputMaybe<AtomWhere>
  /** Return Tags where none of the related Atoms match this filter */
  atoms_NONE?: InputMaybe<AtomWhere>
  /** Return Tags where one of the related Atoms match this filter */
  atoms_SINGLE?: InputMaybe<AtomWhere>
  /** Return Tags where some of the related Atoms match this filter */
  atoms_SOME?: InputMaybe<AtomWhere>
  childrenAggregate?: InputMaybe<TagChildrenAggregateInput>
  /** Return Tags where all of the related TagChildrenConnections match this filter */
  childrenConnection_ALL?: InputMaybe<TagChildrenConnectionWhere>
  /** Return Tags where none of the related TagChildrenConnections match this filter */
  childrenConnection_NONE?: InputMaybe<TagChildrenConnectionWhere>
  /** Return Tags where one of the related TagChildrenConnections match this filter */
  childrenConnection_SINGLE?: InputMaybe<TagChildrenConnectionWhere>
  /** Return Tags where some of the related TagChildrenConnections match this filter */
  childrenConnection_SOME?: InputMaybe<TagChildrenConnectionWhere>
  /** Return Tags where all of the related Tags match this filter */
  children_ALL?: InputMaybe<TagWhere>
  /** Return Tags where none of the related Tags match this filter */
  children_NONE?: InputMaybe<TagWhere>
  /** Return Tags where one of the related Tags match this filter */
  children_SINGLE?: InputMaybe<TagWhere>
  /** Return Tags where some of the related Tags match this filter */
  children_SOME?: InputMaybe<TagWhere>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>
  name_MATCHES?: InputMaybe<Scalars['String']['input']>
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  owner?: InputMaybe<UserWhere>
  ownerAggregate?: InputMaybe<TagOwnerAggregateInput>
  ownerConnection?: InputMaybe<WithOwnerOwnerConnectionWhere>
  parent?: InputMaybe<TagWhere>
  parentAggregate?: InputMaybe<TagParentAggregateInput>
  parentConnection?: InputMaybe<TagParentConnectionWhere>
}

export type TagsConnection = {
  edges: Array<TagEdge>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export enum TypeKind {
  ActionType = 'ActionType',
  AppType = 'AppType',
  ArrayType = 'ArrayType',
  CodeMirrorType = 'CodeMirrorType',
  ElementType = 'ElementType',
  EnumType = 'EnumType',
  InterfaceType = 'InterfaceType',
  LambdaType = 'LambdaType',
  PageType = 'PageType',
  PrimitiveType = 'PrimitiveType',
  ReactNodeType = 'ReactNodeType',
  RenderPropType = 'RenderPropType',
  RichTextType = 'RichTextType',
  UnionType = 'UnionType',
}

export type TypeReference = {
  /** The type of resource - Atom, InterfaceType, etc. */
  label: Scalars['String']['output']
  /** The name of the resource referencing the type */
  name: Scalars['String']['output']
}

export type TypeReferenceAggregateSelection = {
  count: Scalars['Int']['output']
  label: StringAggregateSelection
  name: StringAggregateSelection
}

export type TypeReferenceCreateInput = {
  label: Scalars['String']['input']
  name: Scalars['String']['input']
}

export type TypeReferenceCreatedEvent = {
  createdTypeReference: TypeReferenceEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type TypeReferenceDeletedEvent = {
  deletedTypeReference: TypeReferenceEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type TypeReferenceEdge = {
  cursor: Scalars['String']['output']
  node: TypeReference
}

export type TypeReferenceEventPayload = {
  /** The type of resource - Atom, InterfaceType, etc. */
  label: Scalars['String']['output']
  /** The name of the resource referencing the type */
  name: Scalars['String']['output']
}

export type TypeReferenceOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  /** Specify one or more TypeReferenceSort objects to sort TypeReferences by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<TypeReferenceSort>>
}

/** Fields to sort TypeReferences by. The order in which sorts are applied is not guaranteed when specifying many fields in one TypeReferenceSort object. */
export type TypeReferenceSort = {
  label?: InputMaybe<SortDirection>
  name?: InputMaybe<SortDirection>
}

export type TypeReferenceSubscriptionWhere = {
  AND?: InputMaybe<Array<TypeReferenceSubscriptionWhere>>
  NOT?: InputMaybe<TypeReferenceSubscriptionWhere>
  OR?: InputMaybe<Array<TypeReferenceSubscriptionWhere>>
  /** @deprecated Please use the explicit _EQ version */
  label?: InputMaybe<Scalars['String']['input']>
  label_CONTAINS?: InputMaybe<Scalars['String']['input']>
  label_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  label_EQ?: InputMaybe<Scalars['String']['input']>
  label_IN?: InputMaybe<Array<Scalars['String']['input']>>
  label_MATCHES?: InputMaybe<Scalars['String']['input']>
  label_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>
  name_MATCHES?: InputMaybe<Scalars['String']['input']>
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
}

export type TypeReferenceUpdateInput = {
  /** @deprecated Please use the explicit _SET field */
  label?: InputMaybe<Scalars['String']['input']>
  label_SET?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _SET field */
  name?: InputMaybe<Scalars['String']['input']>
  name_SET?: InputMaybe<Scalars['String']['input']>
}

export type TypeReferenceUpdatedEvent = {
  event: EventType
  previousState: TypeReferenceEventPayload
  timestamp: Scalars['Float']['output']
  updatedTypeReference: TypeReferenceEventPayload
}

export type TypeReferenceWhere = {
  AND?: InputMaybe<Array<TypeReferenceWhere>>
  NOT?: InputMaybe<TypeReferenceWhere>
  OR?: InputMaybe<Array<TypeReferenceWhere>>
  /** @deprecated Please use the explicit _EQ version */
  label?: InputMaybe<Scalars['String']['input']>
  label_CONTAINS?: InputMaybe<Scalars['String']['input']>
  label_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  label_EQ?: InputMaybe<Scalars['String']['input']>
  label_IN?: InputMaybe<Array<Scalars['String']['input']>>
  label_MATCHES?: InputMaybe<Scalars['String']['input']>
  label_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>
  name_MATCHES?: InputMaybe<Scalars['String']['input']>
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
}

export type TypeReferencesConnection = {
  edges: Array<TypeReferenceEdge>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

/** Allows picking one of a set of types */
export type UnionType = IBaseType &
  WithDescendants & {
    descendantTypesIds: Array<Scalars['ID']['output']>
    fieldRefs: Array<Field>
    fieldRefsAggregate?: Maybe<UnionTypeFieldFieldRefsAggregationSelection>
    fieldRefsConnection: IBaseTypeFieldRefsConnection
    id: Scalars['ID']['output']
    kind: TypeKind
    name: Scalars['String']['output']
    owner: User
    ownerAggregate?: Maybe<UnionTypeUserOwnerAggregationSelection>
    ownerConnection: IBaseTypeOwnerConnection
    typesOfUnionType: Array<AnyType>
    typesOfUnionTypeConnection: UnionTypeTypesOfUnionTypeConnection
  }

/** Allows picking one of a set of types */
export type UnionTypeFieldRefsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<FieldOptions>
  sort?: InputMaybe<Array<FieldSort>>
  where?: InputMaybe<FieldWhere>
}

/** Allows picking one of a set of types */
export type UnionTypeFieldRefsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<FieldWhere>
}

/** Allows picking one of a set of types */
export type UnionTypeFieldRefsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<IBaseTypeFieldRefsConnectionSort>>
  where?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
}

/** Allows picking one of a set of types */
export type UnionTypeOwnerArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<UserOptions>
  sort?: InputMaybe<Array<UserSort>>
  where?: InputMaybe<UserWhere>
}

/** Allows picking one of a set of types */
export type UnionTypeOwnerAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<UserWhere>
}

/** Allows picking one of a set of types */
export type UnionTypeOwnerConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<IBaseTypeOwnerConnectionSort>>
  where?: InputMaybe<IBaseTypeOwnerConnectionWhere>
}

/** Allows picking one of a set of types */
export type UnionTypeTypesOfUnionTypeArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<QueryOptions>
  where?: InputMaybe<AnyTypeWhere>
}

/** Allows picking one of a set of types */
export type UnionTypeTypesOfUnionTypeConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  where?: InputMaybe<UnionTypeTypesOfUnionTypeConnectionWhere>
}

export type UnionTypeAggregateSelection = {
  count: Scalars['Int']['output']
  id: IdAggregateSelection
  name: StringAggregateSelection
}

export type UnionTypeConnectInput = {
  fieldRefs?: InputMaybe<Array<UnionTypeFieldRefsConnectFieldInput>>
  owner?: InputMaybe<UnionTypeOwnerConnectFieldInput>
  typesOfUnionType?: InputMaybe<UnionTypeTypesOfUnionTypeConnectInput>
}

export type UnionTypeConnectOrCreateWhere = {
  node: UnionTypeUniqueWhere
}

export type UnionTypeConnectWhere = {
  node: UnionTypeWhere
}

export type UnionTypeCreateInput = {
  fieldRefs?: InputMaybe<UnionTypeFieldRefsFieldInput>
  id: Scalars['ID']['input']
  kind?: TypeKind
  name: Scalars['String']['input']
  owner?: InputMaybe<UnionTypeOwnerFieldInput>
  typesOfUnionType?: InputMaybe<UnionTypeTypesOfUnionTypeCreateInput>
}

export type UnionTypeCreatedEvent = {
  createdUnionType: UnionTypeEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type UnionTypeDeleteInput = {
  fieldRefs?: InputMaybe<Array<IBaseTypeFieldRefsDeleteFieldInput>>
  owner?: InputMaybe<IBaseTypeOwnerDeleteFieldInput>
  typesOfUnionType?: InputMaybe<UnionTypeTypesOfUnionTypeDeleteInput>
}

export type UnionTypeDeletedEvent = {
  deletedUnionType: UnionTypeEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type UnionTypeDisconnectInput = {
  fieldRefs?: InputMaybe<Array<IBaseTypeFieldRefsDisconnectFieldInput>>
  owner?: InputMaybe<IBaseTypeOwnerDisconnectFieldInput>
  typesOfUnionType?: InputMaybe<UnionTypeTypesOfUnionTypeDisconnectInput>
}

export type UnionTypeEdge = {
  cursor: Scalars['String']['output']
  node: UnionType
}

export type UnionTypeEventPayload = {
  id: Scalars['ID']['output']
  kind: TypeKind
  name: Scalars['String']['output']
}

export type UnionTypeFieldFieldRefsAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<UnionTypeFieldFieldRefsNodeAggregateSelection>
}

export type UnionTypeFieldFieldRefsNodeAggregateSelection = {
  defaultValues: StringAggregateSelection
  description: StringAggregateSelection
  id: IdAggregateSelection
  key: StringAggregateSelection
  name: StringAggregateSelection
  validationRules: StringAggregateSelection
}

export type UnionTypeFieldRefsAggregateInput = {
  AND?: InputMaybe<Array<UnionTypeFieldRefsAggregateInput>>
  NOT?: InputMaybe<UnionTypeFieldRefsAggregateInput>
  OR?: InputMaybe<Array<UnionTypeFieldRefsAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<UnionTypeFieldRefsNodeAggregationWhereInput>
}

export type UnionTypeFieldRefsConnectFieldInput = {
  connect?: InputMaybe<Array<FieldConnectInput>>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<FieldConnectWhere>
}

export type UnionTypeFieldRefsConnectOrCreateFieldInput = {
  onCreate: UnionTypeFieldRefsConnectOrCreateFieldInputOnCreate
  where: FieldConnectOrCreateWhere
}

export type UnionTypeFieldRefsConnectOrCreateFieldInputOnCreate = {
  node: FieldOnCreateInput
}

export type UnionTypeFieldRefsCreateFieldInput = {
  node: FieldCreateInput
}

export type UnionTypeFieldRefsFieldInput = {
  connect?: InputMaybe<Array<UnionTypeFieldRefsConnectFieldInput>>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<
    Array<UnionTypeFieldRefsConnectOrCreateFieldInput>
  >
  create?: InputMaybe<Array<UnionTypeFieldRefsCreateFieldInput>>
}

export type UnionTypeFieldRefsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<UnionTypeFieldRefsNodeAggregationWhereInput>>
  NOT?: InputMaybe<UnionTypeFieldRefsNodeAggregationWhereInput>
  OR?: InputMaybe<Array<UnionTypeFieldRefsNodeAggregationWhereInput>>
  defaultValues_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  defaultValues_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  defaultValues_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  defaultValues_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  description_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  description_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  description_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  description_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  description_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  key_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  key_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  key_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  key_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  key_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  validationRules_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  validationRules_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  validationRules_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  validationRules_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type UnionTypeFieldRefsUpdateConnectionInput = {
  node?: InputMaybe<FieldUpdateInput>
}

export type UnionTypeFieldRefsUpdateFieldInput = {
  connect?: InputMaybe<Array<UnionTypeFieldRefsConnectFieldInput>>
  connectOrCreate?: InputMaybe<
    Array<UnionTypeFieldRefsConnectOrCreateFieldInput>
  >
  create?: InputMaybe<Array<UnionTypeFieldRefsCreateFieldInput>>
  delete?: InputMaybe<Array<IBaseTypeFieldRefsDeleteFieldInput>>
  disconnect?: InputMaybe<Array<IBaseTypeFieldRefsDisconnectFieldInput>>
  update?: InputMaybe<UnionTypeFieldRefsUpdateConnectionInput>
  where?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
}

export type UnionTypeOnCreateInput = {
  id: Scalars['ID']['input']
  kind?: TypeKind
  name: Scalars['String']['input']
}

export type UnionTypeOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  /** Specify one or more UnionTypeSort objects to sort UnionTypes by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<UnionTypeSort>>
}

export type UnionTypeOwnerAggregateInput = {
  AND?: InputMaybe<Array<UnionTypeOwnerAggregateInput>>
  NOT?: InputMaybe<UnionTypeOwnerAggregateInput>
  OR?: InputMaybe<Array<UnionTypeOwnerAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<UnionTypeOwnerNodeAggregationWhereInput>
}

export type UnionTypeOwnerConnectFieldInput = {
  connect?: InputMaybe<UserConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<UserConnectWhere>
}

export type UnionTypeOwnerConnectOrCreateFieldInput = {
  onCreate: UnionTypeOwnerConnectOrCreateFieldInputOnCreate
  where: UserConnectOrCreateWhere
}

export type UnionTypeOwnerConnectOrCreateFieldInputOnCreate = {
  node: UserOnCreateInput
}

export type UnionTypeOwnerCreateFieldInput = {
  node: UserCreateInput
}

export type UnionTypeOwnerFieldInput = {
  connect?: InputMaybe<UnionTypeOwnerConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<UnionTypeOwnerConnectOrCreateFieldInput>
  create?: InputMaybe<UnionTypeOwnerCreateFieldInput>
}

export type UnionTypeOwnerNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<UnionTypeOwnerNodeAggregationWhereInput>>
  NOT?: InputMaybe<UnionTypeOwnerNodeAggregationWhereInput>
  OR?: InputMaybe<Array<UnionTypeOwnerNodeAggregationWhereInput>>
  auth0Id_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  auth0Id_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  email_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  email_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  username_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  username_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type UnionTypeOwnerUpdateConnectionInput = {
  node?: InputMaybe<UserUpdateInput>
}

export type UnionTypeOwnerUpdateFieldInput = {
  connect?: InputMaybe<UnionTypeOwnerConnectFieldInput>
  connectOrCreate?: InputMaybe<UnionTypeOwnerConnectOrCreateFieldInput>
  create?: InputMaybe<UnionTypeOwnerCreateFieldInput>
  delete?: InputMaybe<IBaseTypeOwnerDeleteFieldInput>
  disconnect?: InputMaybe<IBaseTypeOwnerDisconnectFieldInput>
  update?: InputMaybe<UnionTypeOwnerUpdateConnectionInput>
  where?: InputMaybe<IBaseTypeOwnerConnectionWhere>
}

/** Fields to sort UnionTypes by. The order in which sorts are applied is not guaranteed when specifying many fields in one UnionTypeSort object. */
export type UnionTypeSort = {
  id?: InputMaybe<SortDirection>
  kind?: InputMaybe<SortDirection>
  name?: InputMaybe<SortDirection>
}

export type UnionTypeSubscriptionWhere = {
  AND?: InputMaybe<Array<UnionTypeSubscriptionWhere>>
  NOT?: InputMaybe<UnionTypeSubscriptionWhere>
  OR?: InputMaybe<Array<UnionTypeSubscriptionWhere>>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  kind?: InputMaybe<TypeKind>
  kind_EQ?: InputMaybe<TypeKind>
  kind_IN?: InputMaybe<Array<TypeKind>>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>
  name_MATCHES?: InputMaybe<Scalars['String']['input']>
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
}

export type UnionTypeTypesOfUnionTypeActionTypeConnectFieldInput = {
  connect?: InputMaybe<Array<ActionTypeConnectInput>>
  where?: InputMaybe<ActionTypeConnectWhere>
}

export type UnionTypeTypesOfUnionTypeActionTypeConnectOrCreateFieldInput = {
  onCreate: UnionTypeTypesOfUnionTypeActionTypeConnectOrCreateFieldInputOnCreate
  where: ActionTypeConnectOrCreateWhere
}

export type UnionTypeTypesOfUnionTypeActionTypeConnectOrCreateFieldInputOnCreate =
  {
    node: ActionTypeOnCreateInput
  }

export type UnionTypeTypesOfUnionTypeActionTypeConnectionWhere = {
  AND?: InputMaybe<Array<UnionTypeTypesOfUnionTypeActionTypeConnectionWhere>>
  NOT?: InputMaybe<UnionTypeTypesOfUnionTypeActionTypeConnectionWhere>
  OR?: InputMaybe<Array<UnionTypeTypesOfUnionTypeActionTypeConnectionWhere>>
  node?: InputMaybe<ActionTypeWhere>
}

export type UnionTypeTypesOfUnionTypeActionTypeCreateFieldInput = {
  node: ActionTypeCreateInput
}

export type UnionTypeTypesOfUnionTypeActionTypeDeleteFieldInput = {
  delete?: InputMaybe<ActionTypeDeleteInput>
  where?: InputMaybe<UnionTypeTypesOfUnionTypeActionTypeConnectionWhere>
}

export type UnionTypeTypesOfUnionTypeActionTypeDisconnectFieldInput = {
  disconnect?: InputMaybe<ActionTypeDisconnectInput>
  where?: InputMaybe<UnionTypeTypesOfUnionTypeActionTypeConnectionWhere>
}

export type UnionTypeTypesOfUnionTypeActionTypeFieldInput = {
  connect?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeActionTypeConnectFieldInput>
  >
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeActionTypeConnectOrCreateFieldInput>
  >
  create?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeActionTypeCreateFieldInput>
  >
}

export type UnionTypeTypesOfUnionTypeActionTypeUpdateConnectionInput = {
  node?: InputMaybe<ActionTypeUpdateInput>
}

export type UnionTypeTypesOfUnionTypeActionTypeUpdateFieldInput = {
  connect?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeActionTypeConnectFieldInput>
  >
  connectOrCreate?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeActionTypeConnectOrCreateFieldInput>
  >
  create?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeActionTypeCreateFieldInput>
  >
  delete?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeActionTypeDeleteFieldInput>
  >
  disconnect?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeActionTypeDisconnectFieldInput>
  >
  update?: InputMaybe<UnionTypeTypesOfUnionTypeActionTypeUpdateConnectionInput>
  where?: InputMaybe<UnionTypeTypesOfUnionTypeActionTypeConnectionWhere>
}

export type UnionTypeTypesOfUnionTypeAppTypeConnectFieldInput = {
  connect?: InputMaybe<Array<AppTypeConnectInput>>
  where?: InputMaybe<AppTypeConnectWhere>
}

export type UnionTypeTypesOfUnionTypeAppTypeConnectionWhere = {
  AND?: InputMaybe<Array<UnionTypeTypesOfUnionTypeAppTypeConnectionWhere>>
  NOT?: InputMaybe<UnionTypeTypesOfUnionTypeAppTypeConnectionWhere>
  OR?: InputMaybe<Array<UnionTypeTypesOfUnionTypeAppTypeConnectionWhere>>
  node?: InputMaybe<AppTypeWhere>
}

export type UnionTypeTypesOfUnionTypeAppTypeCreateFieldInput = {
  node: AppTypeCreateInput
}

export type UnionTypeTypesOfUnionTypeAppTypeDeleteFieldInput = {
  delete?: InputMaybe<AppTypeDeleteInput>
  where?: InputMaybe<UnionTypeTypesOfUnionTypeAppTypeConnectionWhere>
}

export type UnionTypeTypesOfUnionTypeAppTypeDisconnectFieldInput = {
  disconnect?: InputMaybe<AppTypeDisconnectInput>
  where?: InputMaybe<UnionTypeTypesOfUnionTypeAppTypeConnectionWhere>
}

export type UnionTypeTypesOfUnionTypeAppTypeFieldInput = {
  connect?: InputMaybe<Array<UnionTypeTypesOfUnionTypeAppTypeConnectFieldInput>>
  create?: InputMaybe<Array<UnionTypeTypesOfUnionTypeAppTypeCreateFieldInput>>
}

export type UnionTypeTypesOfUnionTypeAppTypeUpdateConnectionInput = {
  node?: InputMaybe<AppTypeUpdateInput>
}

export type UnionTypeTypesOfUnionTypeAppTypeUpdateFieldInput = {
  connect?: InputMaybe<Array<UnionTypeTypesOfUnionTypeAppTypeConnectFieldInput>>
  create?: InputMaybe<Array<UnionTypeTypesOfUnionTypeAppTypeCreateFieldInput>>
  delete?: InputMaybe<Array<UnionTypeTypesOfUnionTypeAppTypeDeleteFieldInput>>
  disconnect?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeAppTypeDisconnectFieldInput>
  >
  update?: InputMaybe<UnionTypeTypesOfUnionTypeAppTypeUpdateConnectionInput>
  where?: InputMaybe<UnionTypeTypesOfUnionTypeAppTypeConnectionWhere>
}

export type UnionTypeTypesOfUnionTypeArrayTypeConnectFieldInput = {
  connect?: InputMaybe<Array<ArrayTypeConnectInput>>
  where?: InputMaybe<ArrayTypeConnectWhere>
}

export type UnionTypeTypesOfUnionTypeArrayTypeConnectionWhere = {
  AND?: InputMaybe<Array<UnionTypeTypesOfUnionTypeArrayTypeConnectionWhere>>
  NOT?: InputMaybe<UnionTypeTypesOfUnionTypeArrayTypeConnectionWhere>
  OR?: InputMaybe<Array<UnionTypeTypesOfUnionTypeArrayTypeConnectionWhere>>
  node?: InputMaybe<ArrayTypeWhere>
}

export type UnionTypeTypesOfUnionTypeArrayTypeCreateFieldInput = {
  node: ArrayTypeCreateInput
}

export type UnionTypeTypesOfUnionTypeArrayTypeDeleteFieldInput = {
  delete?: InputMaybe<ArrayTypeDeleteInput>
  where?: InputMaybe<UnionTypeTypesOfUnionTypeArrayTypeConnectionWhere>
}

export type UnionTypeTypesOfUnionTypeArrayTypeDisconnectFieldInput = {
  disconnect?: InputMaybe<ArrayTypeDisconnectInput>
  where?: InputMaybe<UnionTypeTypesOfUnionTypeArrayTypeConnectionWhere>
}

export type UnionTypeTypesOfUnionTypeArrayTypeFieldInput = {
  connect?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeArrayTypeConnectFieldInput>
  >
  create?: InputMaybe<Array<UnionTypeTypesOfUnionTypeArrayTypeCreateFieldInput>>
}

export type UnionTypeTypesOfUnionTypeArrayTypeUpdateConnectionInput = {
  node?: InputMaybe<ArrayTypeUpdateInput>
}

export type UnionTypeTypesOfUnionTypeArrayTypeUpdateFieldInput = {
  connect?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeArrayTypeConnectFieldInput>
  >
  create?: InputMaybe<Array<UnionTypeTypesOfUnionTypeArrayTypeCreateFieldInput>>
  delete?: InputMaybe<Array<UnionTypeTypesOfUnionTypeArrayTypeDeleteFieldInput>>
  disconnect?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeArrayTypeDisconnectFieldInput>
  >
  update?: InputMaybe<UnionTypeTypesOfUnionTypeArrayTypeUpdateConnectionInput>
  where?: InputMaybe<UnionTypeTypesOfUnionTypeArrayTypeConnectionWhere>
}

export type UnionTypeTypesOfUnionTypeCodeMirrorTypeConnectFieldInput = {
  connect?: InputMaybe<Array<CodeMirrorTypeConnectInput>>
  where?: InputMaybe<CodeMirrorTypeConnectWhere>
}

export type UnionTypeTypesOfUnionTypeCodeMirrorTypeConnectionWhere = {
  AND?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeCodeMirrorTypeConnectionWhere>
  >
  NOT?: InputMaybe<UnionTypeTypesOfUnionTypeCodeMirrorTypeConnectionWhere>
  OR?: InputMaybe<Array<UnionTypeTypesOfUnionTypeCodeMirrorTypeConnectionWhere>>
  node?: InputMaybe<CodeMirrorTypeWhere>
}

export type UnionTypeTypesOfUnionTypeCodeMirrorTypeCreateFieldInput = {
  node: CodeMirrorTypeCreateInput
}

export type UnionTypeTypesOfUnionTypeCodeMirrorTypeDeleteFieldInput = {
  delete?: InputMaybe<CodeMirrorTypeDeleteInput>
  where?: InputMaybe<UnionTypeTypesOfUnionTypeCodeMirrorTypeConnectionWhere>
}

export type UnionTypeTypesOfUnionTypeCodeMirrorTypeDisconnectFieldInput = {
  disconnect?: InputMaybe<CodeMirrorTypeDisconnectInput>
  where?: InputMaybe<UnionTypeTypesOfUnionTypeCodeMirrorTypeConnectionWhere>
}

export type UnionTypeTypesOfUnionTypeCodeMirrorTypeFieldInput = {
  connect?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeCodeMirrorTypeConnectFieldInput>
  >
  create?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeCodeMirrorTypeCreateFieldInput>
  >
}

export type UnionTypeTypesOfUnionTypeCodeMirrorTypeUpdateConnectionInput = {
  node?: InputMaybe<CodeMirrorTypeUpdateInput>
}

export type UnionTypeTypesOfUnionTypeCodeMirrorTypeUpdateFieldInput = {
  connect?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeCodeMirrorTypeConnectFieldInput>
  >
  create?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeCodeMirrorTypeCreateFieldInput>
  >
  delete?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeCodeMirrorTypeDeleteFieldInput>
  >
  disconnect?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeCodeMirrorTypeDisconnectFieldInput>
  >
  update?: InputMaybe<UnionTypeTypesOfUnionTypeCodeMirrorTypeUpdateConnectionInput>
  where?: InputMaybe<UnionTypeTypesOfUnionTypeCodeMirrorTypeConnectionWhere>
}

export type UnionTypeTypesOfUnionTypeConnectInput = {
  ActionType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeActionTypeConnectFieldInput>
  >
  AppType?: InputMaybe<Array<UnionTypeTypesOfUnionTypeAppTypeConnectFieldInput>>
  ArrayType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeArrayTypeConnectFieldInput>
  >
  CodeMirrorType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeCodeMirrorTypeConnectFieldInput>
  >
  ElementType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeElementTypeConnectFieldInput>
  >
  EnumType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeEnumTypeConnectFieldInput>
  >
  InterfaceType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeInterfaceTypeConnectFieldInput>
  >
  LambdaType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeLambdaTypeConnectFieldInput>
  >
  PageType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypePageTypeConnectFieldInput>
  >
  PrimitiveType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypePrimitiveTypeConnectFieldInput>
  >
  ReactNodeType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeReactNodeTypeConnectFieldInput>
  >
  RenderPropType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeRenderPropTypeConnectFieldInput>
  >
  RichTextType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeRichTextTypeConnectFieldInput>
  >
  UnionType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeUnionTypeConnectFieldInput>
  >
}

export type UnionTypeTypesOfUnionTypeConnection = {
  edges: Array<UnionTypeTypesOfUnionTypeRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type UnionTypeTypesOfUnionTypeConnectionWhere = {
  ActionType?: InputMaybe<UnionTypeTypesOfUnionTypeActionTypeConnectionWhere>
  AppType?: InputMaybe<UnionTypeTypesOfUnionTypeAppTypeConnectionWhere>
  ArrayType?: InputMaybe<UnionTypeTypesOfUnionTypeArrayTypeConnectionWhere>
  CodeMirrorType?: InputMaybe<UnionTypeTypesOfUnionTypeCodeMirrorTypeConnectionWhere>
  ElementType?: InputMaybe<UnionTypeTypesOfUnionTypeElementTypeConnectionWhere>
  EnumType?: InputMaybe<UnionTypeTypesOfUnionTypeEnumTypeConnectionWhere>
  InterfaceType?: InputMaybe<UnionTypeTypesOfUnionTypeInterfaceTypeConnectionWhere>
  LambdaType?: InputMaybe<UnionTypeTypesOfUnionTypeLambdaTypeConnectionWhere>
  PageType?: InputMaybe<UnionTypeTypesOfUnionTypePageTypeConnectionWhere>
  PrimitiveType?: InputMaybe<UnionTypeTypesOfUnionTypePrimitiveTypeConnectionWhere>
  ReactNodeType?: InputMaybe<UnionTypeTypesOfUnionTypeReactNodeTypeConnectionWhere>
  RenderPropType?: InputMaybe<UnionTypeTypesOfUnionTypeRenderPropTypeConnectionWhere>
  RichTextType?: InputMaybe<UnionTypeTypesOfUnionTypeRichTextTypeConnectionWhere>
  UnionType?: InputMaybe<UnionTypeTypesOfUnionTypeUnionTypeConnectionWhere>
}

export type UnionTypeTypesOfUnionTypeCreateInput = {
  ActionType?: InputMaybe<UnionTypeTypesOfUnionTypeActionTypeFieldInput>
  AppType?: InputMaybe<UnionTypeTypesOfUnionTypeAppTypeFieldInput>
  ArrayType?: InputMaybe<UnionTypeTypesOfUnionTypeArrayTypeFieldInput>
  CodeMirrorType?: InputMaybe<UnionTypeTypesOfUnionTypeCodeMirrorTypeFieldInput>
  ElementType?: InputMaybe<UnionTypeTypesOfUnionTypeElementTypeFieldInput>
  EnumType?: InputMaybe<UnionTypeTypesOfUnionTypeEnumTypeFieldInput>
  InterfaceType?: InputMaybe<UnionTypeTypesOfUnionTypeInterfaceTypeFieldInput>
  LambdaType?: InputMaybe<UnionTypeTypesOfUnionTypeLambdaTypeFieldInput>
  PageType?: InputMaybe<UnionTypeTypesOfUnionTypePageTypeFieldInput>
  PrimitiveType?: InputMaybe<UnionTypeTypesOfUnionTypePrimitiveTypeFieldInput>
  ReactNodeType?: InputMaybe<UnionTypeTypesOfUnionTypeReactNodeTypeFieldInput>
  RenderPropType?: InputMaybe<UnionTypeTypesOfUnionTypeRenderPropTypeFieldInput>
  RichTextType?: InputMaybe<UnionTypeTypesOfUnionTypeRichTextTypeFieldInput>
  UnionType?: InputMaybe<UnionTypeTypesOfUnionTypeUnionTypeFieldInput>
}

export type UnionTypeTypesOfUnionTypeDeleteInput = {
  ActionType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeActionTypeDeleteFieldInput>
  >
  AppType?: InputMaybe<Array<UnionTypeTypesOfUnionTypeAppTypeDeleteFieldInput>>
  ArrayType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeArrayTypeDeleteFieldInput>
  >
  CodeMirrorType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeCodeMirrorTypeDeleteFieldInput>
  >
  ElementType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeElementTypeDeleteFieldInput>
  >
  EnumType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeEnumTypeDeleteFieldInput>
  >
  InterfaceType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeInterfaceTypeDeleteFieldInput>
  >
  LambdaType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeLambdaTypeDeleteFieldInput>
  >
  PageType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypePageTypeDeleteFieldInput>
  >
  PrimitiveType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypePrimitiveTypeDeleteFieldInput>
  >
  ReactNodeType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeReactNodeTypeDeleteFieldInput>
  >
  RenderPropType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeRenderPropTypeDeleteFieldInput>
  >
  RichTextType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeRichTextTypeDeleteFieldInput>
  >
  UnionType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeUnionTypeDeleteFieldInput>
  >
}

export type UnionTypeTypesOfUnionTypeDisconnectInput = {
  ActionType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeActionTypeDisconnectFieldInput>
  >
  AppType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeAppTypeDisconnectFieldInput>
  >
  ArrayType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeArrayTypeDisconnectFieldInput>
  >
  CodeMirrorType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeCodeMirrorTypeDisconnectFieldInput>
  >
  ElementType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeElementTypeDisconnectFieldInput>
  >
  EnumType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeEnumTypeDisconnectFieldInput>
  >
  InterfaceType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeInterfaceTypeDisconnectFieldInput>
  >
  LambdaType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeLambdaTypeDisconnectFieldInput>
  >
  PageType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypePageTypeDisconnectFieldInput>
  >
  PrimitiveType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypePrimitiveTypeDisconnectFieldInput>
  >
  ReactNodeType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeReactNodeTypeDisconnectFieldInput>
  >
  RenderPropType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeRenderPropTypeDisconnectFieldInput>
  >
  RichTextType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeRichTextTypeDisconnectFieldInput>
  >
  UnionType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeUnionTypeDisconnectFieldInput>
  >
}

export type UnionTypeTypesOfUnionTypeElementTypeConnectFieldInput = {
  connect?: InputMaybe<Array<ElementTypeConnectInput>>
  where?: InputMaybe<ElementTypeConnectWhere>
}

export type UnionTypeTypesOfUnionTypeElementTypeConnectionWhere = {
  AND?: InputMaybe<Array<UnionTypeTypesOfUnionTypeElementTypeConnectionWhere>>
  NOT?: InputMaybe<UnionTypeTypesOfUnionTypeElementTypeConnectionWhere>
  OR?: InputMaybe<Array<UnionTypeTypesOfUnionTypeElementTypeConnectionWhere>>
  node?: InputMaybe<ElementTypeWhere>
}

export type UnionTypeTypesOfUnionTypeElementTypeCreateFieldInput = {
  node: ElementTypeCreateInput
}

export type UnionTypeTypesOfUnionTypeElementTypeDeleteFieldInput = {
  delete?: InputMaybe<ElementTypeDeleteInput>
  where?: InputMaybe<UnionTypeTypesOfUnionTypeElementTypeConnectionWhere>
}

export type UnionTypeTypesOfUnionTypeElementTypeDisconnectFieldInput = {
  disconnect?: InputMaybe<ElementTypeDisconnectInput>
  where?: InputMaybe<UnionTypeTypesOfUnionTypeElementTypeConnectionWhere>
}

export type UnionTypeTypesOfUnionTypeElementTypeFieldInput = {
  connect?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeElementTypeConnectFieldInput>
  >
  create?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeElementTypeCreateFieldInput>
  >
}

export type UnionTypeTypesOfUnionTypeElementTypeUpdateConnectionInput = {
  node?: InputMaybe<ElementTypeUpdateInput>
}

export type UnionTypeTypesOfUnionTypeElementTypeUpdateFieldInput = {
  connect?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeElementTypeConnectFieldInput>
  >
  create?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeElementTypeCreateFieldInput>
  >
  delete?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeElementTypeDeleteFieldInput>
  >
  disconnect?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeElementTypeDisconnectFieldInput>
  >
  update?: InputMaybe<UnionTypeTypesOfUnionTypeElementTypeUpdateConnectionInput>
  where?: InputMaybe<UnionTypeTypesOfUnionTypeElementTypeConnectionWhere>
}

export type UnionTypeTypesOfUnionTypeEnumTypeConnectFieldInput = {
  connect?: InputMaybe<Array<EnumTypeConnectInput>>
  where?: InputMaybe<EnumTypeConnectWhere>
}

export type UnionTypeTypesOfUnionTypeEnumTypeConnectionWhere = {
  AND?: InputMaybe<Array<UnionTypeTypesOfUnionTypeEnumTypeConnectionWhere>>
  NOT?: InputMaybe<UnionTypeTypesOfUnionTypeEnumTypeConnectionWhere>
  OR?: InputMaybe<Array<UnionTypeTypesOfUnionTypeEnumTypeConnectionWhere>>
  node?: InputMaybe<EnumTypeWhere>
}

export type UnionTypeTypesOfUnionTypeEnumTypeCreateFieldInput = {
  node: EnumTypeCreateInput
}

export type UnionTypeTypesOfUnionTypeEnumTypeDeleteFieldInput = {
  delete?: InputMaybe<EnumTypeDeleteInput>
  where?: InputMaybe<UnionTypeTypesOfUnionTypeEnumTypeConnectionWhere>
}

export type UnionTypeTypesOfUnionTypeEnumTypeDisconnectFieldInput = {
  disconnect?: InputMaybe<EnumTypeDisconnectInput>
  where?: InputMaybe<UnionTypeTypesOfUnionTypeEnumTypeConnectionWhere>
}

export type UnionTypeTypesOfUnionTypeEnumTypeFieldInput = {
  connect?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeEnumTypeConnectFieldInput>
  >
  create?: InputMaybe<Array<UnionTypeTypesOfUnionTypeEnumTypeCreateFieldInput>>
}

export type UnionTypeTypesOfUnionTypeEnumTypeUpdateConnectionInput = {
  node?: InputMaybe<EnumTypeUpdateInput>
}

export type UnionTypeTypesOfUnionTypeEnumTypeUpdateFieldInput = {
  connect?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeEnumTypeConnectFieldInput>
  >
  create?: InputMaybe<Array<UnionTypeTypesOfUnionTypeEnumTypeCreateFieldInput>>
  delete?: InputMaybe<Array<UnionTypeTypesOfUnionTypeEnumTypeDeleteFieldInput>>
  disconnect?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeEnumTypeDisconnectFieldInput>
  >
  update?: InputMaybe<UnionTypeTypesOfUnionTypeEnumTypeUpdateConnectionInput>
  where?: InputMaybe<UnionTypeTypesOfUnionTypeEnumTypeConnectionWhere>
}

export type UnionTypeTypesOfUnionTypeInterfaceTypeConnectFieldInput = {
  connect?: InputMaybe<Array<InterfaceTypeConnectInput>>
  where?: InputMaybe<InterfaceTypeConnectWhere>
}

export type UnionTypeTypesOfUnionTypeInterfaceTypeConnectionWhere = {
  AND?: InputMaybe<Array<UnionTypeTypesOfUnionTypeInterfaceTypeConnectionWhere>>
  NOT?: InputMaybe<UnionTypeTypesOfUnionTypeInterfaceTypeConnectionWhere>
  OR?: InputMaybe<Array<UnionTypeTypesOfUnionTypeInterfaceTypeConnectionWhere>>
  node?: InputMaybe<InterfaceTypeWhere>
}

export type UnionTypeTypesOfUnionTypeInterfaceTypeCreateFieldInput = {
  node: InterfaceTypeCreateInput
}

export type UnionTypeTypesOfUnionTypeInterfaceTypeDeleteFieldInput = {
  delete?: InputMaybe<InterfaceTypeDeleteInput>
  where?: InputMaybe<UnionTypeTypesOfUnionTypeInterfaceTypeConnectionWhere>
}

export type UnionTypeTypesOfUnionTypeInterfaceTypeDisconnectFieldInput = {
  disconnect?: InputMaybe<InterfaceTypeDisconnectInput>
  where?: InputMaybe<UnionTypeTypesOfUnionTypeInterfaceTypeConnectionWhere>
}

export type UnionTypeTypesOfUnionTypeInterfaceTypeFieldInput = {
  connect?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeInterfaceTypeConnectFieldInput>
  >
  create?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeInterfaceTypeCreateFieldInput>
  >
}

export type UnionTypeTypesOfUnionTypeInterfaceTypeUpdateConnectionInput = {
  node?: InputMaybe<InterfaceTypeUpdateInput>
}

export type UnionTypeTypesOfUnionTypeInterfaceTypeUpdateFieldInput = {
  connect?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeInterfaceTypeConnectFieldInput>
  >
  create?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeInterfaceTypeCreateFieldInput>
  >
  delete?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeInterfaceTypeDeleteFieldInput>
  >
  disconnect?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeInterfaceTypeDisconnectFieldInput>
  >
  update?: InputMaybe<UnionTypeTypesOfUnionTypeInterfaceTypeUpdateConnectionInput>
  where?: InputMaybe<UnionTypeTypesOfUnionTypeInterfaceTypeConnectionWhere>
}

export type UnionTypeTypesOfUnionTypeLambdaTypeConnectFieldInput = {
  connect?: InputMaybe<Array<LambdaTypeConnectInput>>
  where?: InputMaybe<LambdaTypeConnectWhere>
}

export type UnionTypeTypesOfUnionTypeLambdaTypeConnectionWhere = {
  AND?: InputMaybe<Array<UnionTypeTypesOfUnionTypeLambdaTypeConnectionWhere>>
  NOT?: InputMaybe<UnionTypeTypesOfUnionTypeLambdaTypeConnectionWhere>
  OR?: InputMaybe<Array<UnionTypeTypesOfUnionTypeLambdaTypeConnectionWhere>>
  node?: InputMaybe<LambdaTypeWhere>
}

export type UnionTypeTypesOfUnionTypeLambdaTypeCreateFieldInput = {
  node: LambdaTypeCreateInput
}

export type UnionTypeTypesOfUnionTypeLambdaTypeDeleteFieldInput = {
  delete?: InputMaybe<LambdaTypeDeleteInput>
  where?: InputMaybe<UnionTypeTypesOfUnionTypeLambdaTypeConnectionWhere>
}

export type UnionTypeTypesOfUnionTypeLambdaTypeDisconnectFieldInput = {
  disconnect?: InputMaybe<LambdaTypeDisconnectInput>
  where?: InputMaybe<UnionTypeTypesOfUnionTypeLambdaTypeConnectionWhere>
}

export type UnionTypeTypesOfUnionTypeLambdaTypeFieldInput = {
  connect?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeLambdaTypeConnectFieldInput>
  >
  create?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeLambdaTypeCreateFieldInput>
  >
}

export type UnionTypeTypesOfUnionTypeLambdaTypeUpdateConnectionInput = {
  node?: InputMaybe<LambdaTypeUpdateInput>
}

export type UnionTypeTypesOfUnionTypeLambdaTypeUpdateFieldInput = {
  connect?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeLambdaTypeConnectFieldInput>
  >
  create?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeLambdaTypeCreateFieldInput>
  >
  delete?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeLambdaTypeDeleteFieldInput>
  >
  disconnect?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeLambdaTypeDisconnectFieldInput>
  >
  update?: InputMaybe<UnionTypeTypesOfUnionTypeLambdaTypeUpdateConnectionInput>
  where?: InputMaybe<UnionTypeTypesOfUnionTypeLambdaTypeConnectionWhere>
}

export type UnionTypeTypesOfUnionTypePageTypeConnectFieldInput = {
  connect?: InputMaybe<Array<PageTypeConnectInput>>
  where?: InputMaybe<PageTypeConnectWhere>
}

export type UnionTypeTypesOfUnionTypePageTypeConnectionWhere = {
  AND?: InputMaybe<Array<UnionTypeTypesOfUnionTypePageTypeConnectionWhere>>
  NOT?: InputMaybe<UnionTypeTypesOfUnionTypePageTypeConnectionWhere>
  OR?: InputMaybe<Array<UnionTypeTypesOfUnionTypePageTypeConnectionWhere>>
  node?: InputMaybe<PageTypeWhere>
}

export type UnionTypeTypesOfUnionTypePageTypeCreateFieldInput = {
  node: PageTypeCreateInput
}

export type UnionTypeTypesOfUnionTypePageTypeDeleteFieldInput = {
  delete?: InputMaybe<PageTypeDeleteInput>
  where?: InputMaybe<UnionTypeTypesOfUnionTypePageTypeConnectionWhere>
}

export type UnionTypeTypesOfUnionTypePageTypeDisconnectFieldInput = {
  disconnect?: InputMaybe<PageTypeDisconnectInput>
  where?: InputMaybe<UnionTypeTypesOfUnionTypePageTypeConnectionWhere>
}

export type UnionTypeTypesOfUnionTypePageTypeFieldInput = {
  connect?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypePageTypeConnectFieldInput>
  >
  create?: InputMaybe<Array<UnionTypeTypesOfUnionTypePageTypeCreateFieldInput>>
}

export type UnionTypeTypesOfUnionTypePageTypeUpdateConnectionInput = {
  node?: InputMaybe<PageTypeUpdateInput>
}

export type UnionTypeTypesOfUnionTypePageTypeUpdateFieldInput = {
  connect?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypePageTypeConnectFieldInput>
  >
  create?: InputMaybe<Array<UnionTypeTypesOfUnionTypePageTypeCreateFieldInput>>
  delete?: InputMaybe<Array<UnionTypeTypesOfUnionTypePageTypeDeleteFieldInput>>
  disconnect?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypePageTypeDisconnectFieldInput>
  >
  update?: InputMaybe<UnionTypeTypesOfUnionTypePageTypeUpdateConnectionInput>
  where?: InputMaybe<UnionTypeTypesOfUnionTypePageTypeConnectionWhere>
}

export type UnionTypeTypesOfUnionTypePrimitiveTypeConnectFieldInput = {
  connect?: InputMaybe<Array<PrimitiveTypeConnectInput>>
  where?: InputMaybe<PrimitiveTypeConnectWhere>
}

export type UnionTypeTypesOfUnionTypePrimitiveTypeConnectOrCreateFieldInput = {
  onCreate: UnionTypeTypesOfUnionTypePrimitiveTypeConnectOrCreateFieldInputOnCreate
  where: PrimitiveTypeConnectOrCreateWhere
}

export type UnionTypeTypesOfUnionTypePrimitiveTypeConnectOrCreateFieldInputOnCreate =
  {
    node: PrimitiveTypeOnCreateInput
  }

export type UnionTypeTypesOfUnionTypePrimitiveTypeConnectionWhere = {
  AND?: InputMaybe<Array<UnionTypeTypesOfUnionTypePrimitiveTypeConnectionWhere>>
  NOT?: InputMaybe<UnionTypeTypesOfUnionTypePrimitiveTypeConnectionWhere>
  OR?: InputMaybe<Array<UnionTypeTypesOfUnionTypePrimitiveTypeConnectionWhere>>
  node?: InputMaybe<PrimitiveTypeWhere>
}

export type UnionTypeTypesOfUnionTypePrimitiveTypeCreateFieldInput = {
  node: PrimitiveTypeCreateInput
}

export type UnionTypeTypesOfUnionTypePrimitiveTypeDeleteFieldInput = {
  delete?: InputMaybe<PrimitiveTypeDeleteInput>
  where?: InputMaybe<UnionTypeTypesOfUnionTypePrimitiveTypeConnectionWhere>
}

export type UnionTypeTypesOfUnionTypePrimitiveTypeDisconnectFieldInput = {
  disconnect?: InputMaybe<PrimitiveTypeDisconnectInput>
  where?: InputMaybe<UnionTypeTypesOfUnionTypePrimitiveTypeConnectionWhere>
}

export type UnionTypeTypesOfUnionTypePrimitiveTypeFieldInput = {
  connect?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypePrimitiveTypeConnectFieldInput>
  >
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypePrimitiveTypeConnectOrCreateFieldInput>
  >
  create?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypePrimitiveTypeCreateFieldInput>
  >
}

export type UnionTypeTypesOfUnionTypePrimitiveTypeUpdateConnectionInput = {
  node?: InputMaybe<PrimitiveTypeUpdateInput>
}

export type UnionTypeTypesOfUnionTypePrimitiveTypeUpdateFieldInput = {
  connect?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypePrimitiveTypeConnectFieldInput>
  >
  connectOrCreate?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypePrimitiveTypeConnectOrCreateFieldInput>
  >
  create?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypePrimitiveTypeCreateFieldInput>
  >
  delete?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypePrimitiveTypeDeleteFieldInput>
  >
  disconnect?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypePrimitiveTypeDisconnectFieldInput>
  >
  update?: InputMaybe<UnionTypeTypesOfUnionTypePrimitiveTypeUpdateConnectionInput>
  where?: InputMaybe<UnionTypeTypesOfUnionTypePrimitiveTypeConnectionWhere>
}

export type UnionTypeTypesOfUnionTypeReactNodeTypeConnectFieldInput = {
  connect?: InputMaybe<Array<ReactNodeTypeConnectInput>>
  where?: InputMaybe<ReactNodeTypeConnectWhere>
}

export type UnionTypeTypesOfUnionTypeReactNodeTypeConnectOrCreateFieldInput = {
  onCreate: UnionTypeTypesOfUnionTypeReactNodeTypeConnectOrCreateFieldInputOnCreate
  where: ReactNodeTypeConnectOrCreateWhere
}

export type UnionTypeTypesOfUnionTypeReactNodeTypeConnectOrCreateFieldInputOnCreate =
  {
    node: ReactNodeTypeOnCreateInput
  }

export type UnionTypeTypesOfUnionTypeReactNodeTypeConnectionWhere = {
  AND?: InputMaybe<Array<UnionTypeTypesOfUnionTypeReactNodeTypeConnectionWhere>>
  NOT?: InputMaybe<UnionTypeTypesOfUnionTypeReactNodeTypeConnectionWhere>
  OR?: InputMaybe<Array<UnionTypeTypesOfUnionTypeReactNodeTypeConnectionWhere>>
  node?: InputMaybe<ReactNodeTypeWhere>
}

export type UnionTypeTypesOfUnionTypeReactNodeTypeCreateFieldInput = {
  node: ReactNodeTypeCreateInput
}

export type UnionTypeTypesOfUnionTypeReactNodeTypeDeleteFieldInput = {
  delete?: InputMaybe<ReactNodeTypeDeleteInput>
  where?: InputMaybe<UnionTypeTypesOfUnionTypeReactNodeTypeConnectionWhere>
}

export type UnionTypeTypesOfUnionTypeReactNodeTypeDisconnectFieldInput = {
  disconnect?: InputMaybe<ReactNodeTypeDisconnectInput>
  where?: InputMaybe<UnionTypeTypesOfUnionTypeReactNodeTypeConnectionWhere>
}

export type UnionTypeTypesOfUnionTypeReactNodeTypeFieldInput = {
  connect?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeReactNodeTypeConnectFieldInput>
  >
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeReactNodeTypeConnectOrCreateFieldInput>
  >
  create?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeReactNodeTypeCreateFieldInput>
  >
}

export type UnionTypeTypesOfUnionTypeReactNodeTypeUpdateConnectionInput = {
  node?: InputMaybe<ReactNodeTypeUpdateInput>
}

export type UnionTypeTypesOfUnionTypeReactNodeTypeUpdateFieldInput = {
  connect?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeReactNodeTypeConnectFieldInput>
  >
  connectOrCreate?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeReactNodeTypeConnectOrCreateFieldInput>
  >
  create?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeReactNodeTypeCreateFieldInput>
  >
  delete?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeReactNodeTypeDeleteFieldInput>
  >
  disconnect?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeReactNodeTypeDisconnectFieldInput>
  >
  update?: InputMaybe<UnionTypeTypesOfUnionTypeReactNodeTypeUpdateConnectionInput>
  where?: InputMaybe<UnionTypeTypesOfUnionTypeReactNodeTypeConnectionWhere>
}

export type UnionTypeTypesOfUnionTypeRelationship = {
  cursor: Scalars['String']['output']
  node: AnyType
}

export type UnionTypeTypesOfUnionTypeRenderPropTypeConnectFieldInput = {
  connect?: InputMaybe<Array<RenderPropTypeConnectInput>>
  where?: InputMaybe<RenderPropTypeConnectWhere>
}

export type UnionTypeTypesOfUnionTypeRenderPropTypeConnectOrCreateFieldInput = {
  onCreate: UnionTypeTypesOfUnionTypeRenderPropTypeConnectOrCreateFieldInputOnCreate
  where: RenderPropTypeConnectOrCreateWhere
}

export type UnionTypeTypesOfUnionTypeRenderPropTypeConnectOrCreateFieldInputOnCreate =
  {
    node: RenderPropTypeOnCreateInput
  }

export type UnionTypeTypesOfUnionTypeRenderPropTypeConnectionWhere = {
  AND?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeRenderPropTypeConnectionWhere>
  >
  NOT?: InputMaybe<UnionTypeTypesOfUnionTypeRenderPropTypeConnectionWhere>
  OR?: InputMaybe<Array<UnionTypeTypesOfUnionTypeRenderPropTypeConnectionWhere>>
  node?: InputMaybe<RenderPropTypeWhere>
}

export type UnionTypeTypesOfUnionTypeRenderPropTypeCreateFieldInput = {
  node: RenderPropTypeCreateInput
}

export type UnionTypeTypesOfUnionTypeRenderPropTypeDeleteFieldInput = {
  delete?: InputMaybe<RenderPropTypeDeleteInput>
  where?: InputMaybe<UnionTypeTypesOfUnionTypeRenderPropTypeConnectionWhere>
}

export type UnionTypeTypesOfUnionTypeRenderPropTypeDisconnectFieldInput = {
  disconnect?: InputMaybe<RenderPropTypeDisconnectInput>
  where?: InputMaybe<UnionTypeTypesOfUnionTypeRenderPropTypeConnectionWhere>
}

export type UnionTypeTypesOfUnionTypeRenderPropTypeFieldInput = {
  connect?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeRenderPropTypeConnectFieldInput>
  >
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeRenderPropTypeConnectOrCreateFieldInput>
  >
  create?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeRenderPropTypeCreateFieldInput>
  >
}

export type UnionTypeTypesOfUnionTypeRenderPropTypeUpdateConnectionInput = {
  node?: InputMaybe<RenderPropTypeUpdateInput>
}

export type UnionTypeTypesOfUnionTypeRenderPropTypeUpdateFieldInput = {
  connect?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeRenderPropTypeConnectFieldInput>
  >
  connectOrCreate?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeRenderPropTypeConnectOrCreateFieldInput>
  >
  create?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeRenderPropTypeCreateFieldInput>
  >
  delete?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeRenderPropTypeDeleteFieldInput>
  >
  disconnect?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeRenderPropTypeDisconnectFieldInput>
  >
  update?: InputMaybe<UnionTypeTypesOfUnionTypeRenderPropTypeUpdateConnectionInput>
  where?: InputMaybe<UnionTypeTypesOfUnionTypeRenderPropTypeConnectionWhere>
}

export type UnionTypeTypesOfUnionTypeRichTextTypeConnectFieldInput = {
  connect?: InputMaybe<Array<RichTextTypeConnectInput>>
  where?: InputMaybe<RichTextTypeConnectWhere>
}

export type UnionTypeTypesOfUnionTypeRichTextTypeConnectionWhere = {
  AND?: InputMaybe<Array<UnionTypeTypesOfUnionTypeRichTextTypeConnectionWhere>>
  NOT?: InputMaybe<UnionTypeTypesOfUnionTypeRichTextTypeConnectionWhere>
  OR?: InputMaybe<Array<UnionTypeTypesOfUnionTypeRichTextTypeConnectionWhere>>
  node?: InputMaybe<RichTextTypeWhere>
}

export type UnionTypeTypesOfUnionTypeRichTextTypeCreateFieldInput = {
  node: RichTextTypeCreateInput
}

export type UnionTypeTypesOfUnionTypeRichTextTypeDeleteFieldInput = {
  delete?: InputMaybe<RichTextTypeDeleteInput>
  where?: InputMaybe<UnionTypeTypesOfUnionTypeRichTextTypeConnectionWhere>
}

export type UnionTypeTypesOfUnionTypeRichTextTypeDisconnectFieldInput = {
  disconnect?: InputMaybe<RichTextTypeDisconnectInput>
  where?: InputMaybe<UnionTypeTypesOfUnionTypeRichTextTypeConnectionWhere>
}

export type UnionTypeTypesOfUnionTypeRichTextTypeFieldInput = {
  connect?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeRichTextTypeConnectFieldInput>
  >
  create?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeRichTextTypeCreateFieldInput>
  >
}

export type UnionTypeTypesOfUnionTypeRichTextTypeUpdateConnectionInput = {
  node?: InputMaybe<RichTextTypeUpdateInput>
}

export type UnionTypeTypesOfUnionTypeRichTextTypeUpdateFieldInput = {
  connect?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeRichTextTypeConnectFieldInput>
  >
  create?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeRichTextTypeCreateFieldInput>
  >
  delete?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeRichTextTypeDeleteFieldInput>
  >
  disconnect?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeRichTextTypeDisconnectFieldInput>
  >
  update?: InputMaybe<UnionTypeTypesOfUnionTypeRichTextTypeUpdateConnectionInput>
  where?: InputMaybe<UnionTypeTypesOfUnionTypeRichTextTypeConnectionWhere>
}

export type UnionTypeTypesOfUnionTypeUnionTypeConnectFieldInput = {
  connect?: InputMaybe<Array<UnionTypeConnectInput>>
  where?: InputMaybe<UnionTypeConnectWhere>
}

export type UnionTypeTypesOfUnionTypeUnionTypeConnectOrCreateFieldInput = {
  onCreate: UnionTypeTypesOfUnionTypeUnionTypeConnectOrCreateFieldInputOnCreate
  where: UnionTypeConnectOrCreateWhere
}

export type UnionTypeTypesOfUnionTypeUnionTypeConnectOrCreateFieldInputOnCreate =
  {
    node: UnionTypeOnCreateInput
  }

export type UnionTypeTypesOfUnionTypeUnionTypeConnectionWhere = {
  AND?: InputMaybe<Array<UnionTypeTypesOfUnionTypeUnionTypeConnectionWhere>>
  NOT?: InputMaybe<UnionTypeTypesOfUnionTypeUnionTypeConnectionWhere>
  OR?: InputMaybe<Array<UnionTypeTypesOfUnionTypeUnionTypeConnectionWhere>>
  node?: InputMaybe<UnionTypeWhere>
}

export type UnionTypeTypesOfUnionTypeUnionTypeCreateFieldInput = {
  node: UnionTypeCreateInput
}

export type UnionTypeTypesOfUnionTypeUnionTypeDeleteFieldInput = {
  delete?: InputMaybe<UnionTypeDeleteInput>
  where?: InputMaybe<UnionTypeTypesOfUnionTypeUnionTypeConnectionWhere>
}

export type UnionTypeTypesOfUnionTypeUnionTypeDisconnectFieldInput = {
  disconnect?: InputMaybe<UnionTypeDisconnectInput>
  where?: InputMaybe<UnionTypeTypesOfUnionTypeUnionTypeConnectionWhere>
}

export type UnionTypeTypesOfUnionTypeUnionTypeFieldInput = {
  connect?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeUnionTypeConnectFieldInput>
  >
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeUnionTypeConnectOrCreateFieldInput>
  >
  create?: InputMaybe<Array<UnionTypeTypesOfUnionTypeUnionTypeCreateFieldInput>>
}

export type UnionTypeTypesOfUnionTypeUnionTypeUpdateConnectionInput = {
  node?: InputMaybe<UnionTypeUpdateInput>
}

export type UnionTypeTypesOfUnionTypeUnionTypeUpdateFieldInput = {
  connect?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeUnionTypeConnectFieldInput>
  >
  connectOrCreate?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeUnionTypeConnectOrCreateFieldInput>
  >
  create?: InputMaybe<Array<UnionTypeTypesOfUnionTypeUnionTypeCreateFieldInput>>
  delete?: InputMaybe<Array<UnionTypeTypesOfUnionTypeUnionTypeDeleteFieldInput>>
  disconnect?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeUnionTypeDisconnectFieldInput>
  >
  update?: InputMaybe<UnionTypeTypesOfUnionTypeUnionTypeUpdateConnectionInput>
  where?: InputMaybe<UnionTypeTypesOfUnionTypeUnionTypeConnectionWhere>
}

export type UnionTypeTypesOfUnionTypeUpdateInput = {
  ActionType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeActionTypeUpdateFieldInput>
  >
  AppType?: InputMaybe<Array<UnionTypeTypesOfUnionTypeAppTypeUpdateFieldInput>>
  ArrayType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeArrayTypeUpdateFieldInput>
  >
  CodeMirrorType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeCodeMirrorTypeUpdateFieldInput>
  >
  ElementType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeElementTypeUpdateFieldInput>
  >
  EnumType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeEnumTypeUpdateFieldInput>
  >
  InterfaceType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeInterfaceTypeUpdateFieldInput>
  >
  LambdaType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeLambdaTypeUpdateFieldInput>
  >
  PageType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypePageTypeUpdateFieldInput>
  >
  PrimitiveType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypePrimitiveTypeUpdateFieldInput>
  >
  ReactNodeType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeReactNodeTypeUpdateFieldInput>
  >
  RenderPropType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeRenderPropTypeUpdateFieldInput>
  >
  RichTextType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeRichTextTypeUpdateFieldInput>
  >
  UnionType?: InputMaybe<
    Array<UnionTypeTypesOfUnionTypeUnionTypeUpdateFieldInput>
  >
}

export type UnionTypeUniqueWhere = {
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
}

export type UnionTypeUpdateInput = {
  fieldRefs?: InputMaybe<Array<UnionTypeFieldRefsUpdateFieldInput>>
  /** @deprecated Please use the explicit _SET field */
  id?: InputMaybe<Scalars['ID']['input']>
  id_SET?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _SET field */
  kind?: InputMaybe<TypeKind>
  kind_SET?: InputMaybe<TypeKind>
  /** @deprecated Please use the explicit _SET field */
  name?: InputMaybe<Scalars['String']['input']>
  name_SET?: InputMaybe<Scalars['String']['input']>
  owner?: InputMaybe<UnionTypeOwnerUpdateFieldInput>
  typesOfUnionType?: InputMaybe<UnionTypeTypesOfUnionTypeUpdateInput>
}

export type UnionTypeUpdatedEvent = {
  event: EventType
  previousState: UnionTypeEventPayload
  timestamp: Scalars['Float']['output']
  updatedUnionType: UnionTypeEventPayload
}

export type UnionTypeUserOwnerAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<UnionTypeUserOwnerNodeAggregateSelection>
}

export type UnionTypeUserOwnerNodeAggregateSelection = {
  auth0Id: StringAggregateSelection
  email: StringAggregateSelection
  id: IdAggregateSelection
  username: StringAggregateSelection
}

export type UnionTypeWhere = {
  AND?: InputMaybe<Array<UnionTypeWhere>>
  NOT?: InputMaybe<UnionTypeWhere>
  OR?: InputMaybe<Array<UnionTypeWhere>>
  fieldRefsAggregate?: InputMaybe<UnionTypeFieldRefsAggregateInput>
  /** Return UnionTypes where all of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_ALL?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return UnionTypes where none of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_NONE?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return UnionTypes where one of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_SINGLE?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return UnionTypes where some of the related IBaseTypeFieldRefsConnections match this filter */
  fieldRefsConnection_SOME?: InputMaybe<IBaseTypeFieldRefsConnectionWhere>
  /** Return UnionTypes where all of the related Fields match this filter */
  fieldRefs_ALL?: InputMaybe<FieldWhere>
  /** Return UnionTypes where none of the related Fields match this filter */
  fieldRefs_NONE?: InputMaybe<FieldWhere>
  /** Return UnionTypes where one of the related Fields match this filter */
  fieldRefs_SINGLE?: InputMaybe<FieldWhere>
  /** Return UnionTypes where some of the related Fields match this filter */
  fieldRefs_SOME?: InputMaybe<FieldWhere>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  kind?: InputMaybe<TypeKind>
  kind_EQ?: InputMaybe<TypeKind>
  kind_IN?: InputMaybe<Array<TypeKind>>
  /** @deprecated Please use the explicit _EQ version */
  name?: InputMaybe<Scalars['String']['input']>
  name_CONTAINS?: InputMaybe<Scalars['String']['input']>
  name_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  name_EQ?: InputMaybe<Scalars['String']['input']>
  name_IN?: InputMaybe<Array<Scalars['String']['input']>>
  name_MATCHES?: InputMaybe<Scalars['String']['input']>
  name_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  owner?: InputMaybe<UserWhere>
  ownerAggregate?: InputMaybe<UnionTypeOwnerAggregateInput>
  ownerConnection?: InputMaybe<IBaseTypeOwnerConnectionWhere>
  /** Return UnionTypes where all of the related UnionTypeTypesOfUnionTypeConnections match this filter */
  typesOfUnionTypeConnection_ALL?: InputMaybe<UnionTypeTypesOfUnionTypeConnectionWhere>
  /** Return UnionTypes where none of the related UnionTypeTypesOfUnionTypeConnections match this filter */
  typesOfUnionTypeConnection_NONE?: InputMaybe<UnionTypeTypesOfUnionTypeConnectionWhere>
  /** Return UnionTypes where one of the related UnionTypeTypesOfUnionTypeConnections match this filter */
  typesOfUnionTypeConnection_SINGLE?: InputMaybe<UnionTypeTypesOfUnionTypeConnectionWhere>
  /** Return UnionTypes where some of the related UnionTypeTypesOfUnionTypeConnections match this filter */
  typesOfUnionTypeConnection_SOME?: InputMaybe<UnionTypeTypesOfUnionTypeConnectionWhere>
  /** Return UnionTypes where all of the related AnyTypes match this filter */
  typesOfUnionType_ALL?: InputMaybe<AnyTypeWhere>
  /** Return UnionTypes where none of the related AnyTypes match this filter */
  typesOfUnionType_NONE?: InputMaybe<AnyTypeWhere>
  /** Return UnionTypes where one of the related AnyTypes match this filter */
  typesOfUnionType_SINGLE?: InputMaybe<AnyTypeWhere>
  /** Return UnionTypes where some of the related AnyTypes match this filter */
  typesOfUnionType_SOME?: InputMaybe<AnyTypeWhere>
}

export type UnionTypesConnection = {
  edges: Array<UnionTypeEdge>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type UpdateActionTypesMutationResponse = {
  actionTypes: Array<ActionType>
  info: UpdateInfo
}

export type UpdateApiActionsMutationResponse = {
  apiActions: Array<ApiAction>
  info: UpdateInfo
}

export type UpdateAppTypesMutationResponse = {
  appTypes: Array<AppType>
  info: UpdateInfo
}

export type UpdateAppsMutationResponse = {
  apps: Array<App>
  info: UpdateInfo
}

export type UpdateArrayTypesMutationResponse = {
  arrayTypes: Array<ArrayType>
  info: UpdateInfo
}

export type UpdateAtomsMutationResponse = {
  atoms: Array<Atom>
  info: UpdateInfo
}

export type UpdateAuthGuardsMutationResponse = {
  authGuards: Array<AuthGuard>
  info: UpdateInfo
}

export type UpdateCodeActionsMutationResponse = {
  codeActions: Array<CodeAction>
  info: UpdateInfo
}

export type UpdateCodeMirrorTypesMutationResponse = {
  codeMirrorTypes: Array<CodeMirrorType>
  info: UpdateInfo
}

export type UpdateComponentsMutationResponse = {
  components: Array<Component>
  info: UpdateInfo
}

export type UpdateDomainsMutationResponse = {
  domains: Array<Domain>
  info: UpdateInfo
}

export type UpdateElementTypesMutationResponse = {
  elementTypes: Array<ElementType>
  info: UpdateInfo
}

export type UpdateElementsMutationResponse = {
  elements: Array<Element>
  info: UpdateInfo
}

export type UpdateEnumTypeValuesMutationResponse = {
  enumTypeValues: Array<EnumTypeValue>
  info: UpdateInfo
}

export type UpdateEnumTypesMutationResponse = {
  enumTypes: Array<EnumType>
  info: UpdateInfo
}

export type UpdateFieldsMutationResponse = {
  fields: Array<Field>
  info: UpdateInfo
}

export type UpdateHooksMutationResponse = {
  hooks: Array<Hook>
  info: UpdateInfo
}

/** Information about the number of nodes and relationships created and deleted during an update mutation */
export type UpdateInfo = {
  nodesCreated: Scalars['Int']['output']
  nodesDeleted: Scalars['Int']['output']
  relationshipsCreated: Scalars['Int']['output']
  relationshipsDeleted: Scalars['Int']['output']
}

export type UpdateInterfaceTypesMutationResponse = {
  info: UpdateInfo
  interfaceTypes: Array<InterfaceType>
}

export type UpdateLambdaTypesMutationResponse = {
  info: UpdateInfo
  lambdaTypes: Array<LambdaType>
}

export type UpdatePageTypesMutationResponse = {
  info: UpdateInfo
  pageTypes: Array<PageType>
}

export type UpdatePagesMutationResponse = {
  info: UpdateInfo
  pages: Array<Page>
}

export type UpdatePreferencesMutationResponse = {
  info: UpdateInfo
  preferences: Array<Preference>
}

export type UpdatePrimitiveTypesMutationResponse = {
  info: UpdateInfo
  primitiveTypes: Array<PrimitiveType>
}

export type UpdatePropsMutationResponse = {
  info: UpdateInfo
  props: Array<Prop>
}

export type UpdateReactNodeTypesMutationResponse = {
  info: UpdateInfo
  reactNodeTypes: Array<ReactNodeType>
}

export type UpdateRedirectsMutationResponse = {
  info: UpdateInfo
  redirects: Array<Redirect>
}

export type UpdateRenderPropTypesMutationResponse = {
  info: UpdateInfo
  renderPropTypes: Array<RenderPropType>
}

export type UpdateResourcesMutationResponse = {
  info: UpdateInfo
  resources: Array<Resource>
}

export type UpdateRichTextTypesMutationResponse = {
  info: UpdateInfo
  richTextTypes: Array<RichTextType>
}

export type UpdateStoresMutationResponse = {
  info: UpdateInfo
  stores: Array<Store>
}

export type UpdateTagsMutationResponse = {
  info: UpdateInfo
  tags: Array<Tag>
}

export type UpdateTypeReferencesMutationResponse = {
  info: UpdateInfo
  typeReferences: Array<TypeReference>
}

export type UpdateUnionTypesMutationResponse = {
  info: UpdateInfo
  unionTypes: Array<UnionType>
}

export type UpdateUsersMutationResponse = {
  info: UpdateInfo
  users: Array<User>
}

export type User = {
  apps: Array<App>
  appsAggregate?: Maybe<UserAppAppsAggregationSelection>
  appsConnection: UserAppsConnection
  atoms: Array<Atom>
  atomsAggregate?: Maybe<UserAtomAtomsAggregationSelection>
  atomsConnection: UserAtomsConnection
  auth0Id: Scalars['String']['output']
  components: Array<Component>
  componentsAggregate?: Maybe<UserComponentComponentsAggregationSelection>
  componentsConnection: UserComponentsConnection
  elements: Array<Element>
  elementsAggregate?: Maybe<UserElementElementsAggregationSelection>
  elementsConnection: UserElementsConnection
  email: Scalars['String']['output']
  id: Scalars['ID']['output']
  preferences?: Maybe<Preference>
  preferencesAggregate?: Maybe<UserPreferencePreferencesAggregationSelection>
  preferencesConnection: UserPreferencesConnection
  roles?: Maybe<Array<Role>>
  tags: Array<Tag>
  tagsAggregate?: Maybe<UserTagTagsAggregationSelection>
  tagsConnection: UserTagsConnection
  types: Array<IBaseType>
  typesAggregate?: Maybe<UserIBaseTypeTypesAggregationSelection>
  typesConnection: UserTypesConnection
  username: Scalars['String']['output']
}

export type UserAppsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<AppOptions>
  sort?: InputMaybe<Array<AppSort>>
  where?: InputMaybe<AppWhere>
}

export type UserAppsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<AppWhere>
}

export type UserAppsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<UserAppsConnectionSort>>
  where?: InputMaybe<UserAppsConnectionWhere>
}

export type UserAtomsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<AtomOptions>
  sort?: InputMaybe<Array<AtomSort>>
  where?: InputMaybe<AtomWhere>
}

export type UserAtomsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<AtomWhere>
}

export type UserAtomsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<UserAtomsConnectionSort>>
  where?: InputMaybe<UserAtomsConnectionWhere>
}

export type UserComponentsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<ComponentOptions>
  sort?: InputMaybe<Array<ComponentSort>>
  where?: InputMaybe<ComponentWhere>
}

export type UserComponentsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<ComponentWhere>
}

export type UserComponentsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<UserComponentsConnectionSort>>
  where?: InputMaybe<UserComponentsConnectionWhere>
}

export type UserElementsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<ElementOptions>
  sort?: InputMaybe<Array<ElementSort>>
  where?: InputMaybe<ElementWhere>
}

export type UserElementsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<ElementWhere>
}

export type UserElementsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<UserElementsConnectionSort>>
  where?: InputMaybe<UserElementsConnectionWhere>
}

export type UserPreferencesArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<PreferenceOptions>
  sort?: InputMaybe<Array<PreferenceSort>>
  where?: InputMaybe<PreferenceWhere>
}

export type UserPreferencesAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<PreferenceWhere>
}

export type UserPreferencesConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<UserPreferencesConnectionSort>>
  where?: InputMaybe<UserPreferencesConnectionWhere>
}

export type UserTagsArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<TagOptions>
  sort?: InputMaybe<Array<TagSort>>
  where?: InputMaybe<TagWhere>
}

export type UserTagsAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<TagWhere>
}

export type UserTagsConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<UserTagsConnectionSort>>
  where?: InputMaybe<UserTagsConnectionWhere>
}

export type UserTypesArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<IBaseTypeOptions>
  sort?: InputMaybe<Array<IBaseTypeSort>>
  where?: InputMaybe<IBaseTypeWhere>
}

export type UserTypesAggregateArgs = {
  directed?: InputMaybe<Scalars['Boolean']['input']>
  where?: InputMaybe<IBaseTypeWhere>
}

export type UserTypesConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  directed?: InputMaybe<Scalars['Boolean']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<UserTypesConnectionSort>>
  where?: InputMaybe<UserTypesConnectionWhere>
}

export type UserAggregateSelection = {
  auth0Id: StringAggregateSelection
  count: Scalars['Int']['output']
  email: StringAggregateSelection
  id: IdAggregateSelection
  username: StringAggregateSelection
}

export type UserAppAppsAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<UserAppAppsNodeAggregateSelection>
}

export type UserAppAppsNodeAggregateSelection = {
  compositeKey: StringAggregateSelection
  id: IdAggregateSelection
}

export type UserAppsAggregateInput = {
  AND?: InputMaybe<Array<UserAppsAggregateInput>>
  NOT?: InputMaybe<UserAppsAggregateInput>
  OR?: InputMaybe<Array<UserAppsAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<UserAppsNodeAggregationWhereInput>
}

export type UserAppsConnectFieldInput = {
  connect?: InputMaybe<Array<AppConnectInput>>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<AppConnectWhere>
}

export type UserAppsConnectOrCreateFieldInput = {
  onCreate: UserAppsConnectOrCreateFieldInputOnCreate
  where: AppConnectOrCreateWhere
}

export type UserAppsConnectOrCreateFieldInputOnCreate = {
  node: AppOnCreateInput
}

export type UserAppsConnection = {
  edges: Array<UserAppsRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type UserAppsConnectionSort = {
  node?: InputMaybe<AppSort>
}

export type UserAppsConnectionWhere = {
  AND?: InputMaybe<Array<UserAppsConnectionWhere>>
  NOT?: InputMaybe<UserAppsConnectionWhere>
  OR?: InputMaybe<Array<UserAppsConnectionWhere>>
  node?: InputMaybe<AppWhere>
}

export type UserAppsCreateFieldInput = {
  node: AppCreateInput
}

export type UserAppsDeleteFieldInput = {
  delete?: InputMaybe<AppDeleteInput>
  where?: InputMaybe<UserAppsConnectionWhere>
}

export type UserAppsDisconnectFieldInput = {
  disconnect?: InputMaybe<AppDisconnectInput>
  where?: InputMaybe<UserAppsConnectionWhere>
}

export type UserAppsFieldInput = {
  connect?: InputMaybe<Array<UserAppsConnectFieldInput>>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<Array<UserAppsConnectOrCreateFieldInput>>
  create?: InputMaybe<Array<UserAppsCreateFieldInput>>
}

export type UserAppsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<UserAppsNodeAggregationWhereInput>>
  NOT?: InputMaybe<UserAppsNodeAggregationWhereInput>
  OR?: InputMaybe<Array<UserAppsNodeAggregationWhereInput>>
  compositeKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
}

export type UserAppsRelationship = {
  cursor: Scalars['String']['output']
  node: App
}

export type UserAppsUpdateConnectionInput = {
  node?: InputMaybe<AppUpdateInput>
}

export type UserAppsUpdateFieldInput = {
  connect?: InputMaybe<Array<UserAppsConnectFieldInput>>
  connectOrCreate?: InputMaybe<Array<UserAppsConnectOrCreateFieldInput>>
  create?: InputMaybe<Array<UserAppsCreateFieldInput>>
  delete?: InputMaybe<Array<UserAppsDeleteFieldInput>>
  disconnect?: InputMaybe<Array<UserAppsDisconnectFieldInput>>
  update?: InputMaybe<UserAppsUpdateConnectionInput>
  where?: InputMaybe<UserAppsConnectionWhere>
}

export type UserAtomAtomsAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<UserAtomAtomsNodeAggregateSelection>
}

export type UserAtomAtomsNodeAggregateSelection = {
  externalCssSource: StringAggregateSelection
  externalJsSource: StringAggregateSelection
  externalSourceType: StringAggregateSelection
  icon: StringAggregateSelection
  id: IdAggregateSelection
  name: StringAggregateSelection
}

export type UserAtomsAggregateInput = {
  AND?: InputMaybe<Array<UserAtomsAggregateInput>>
  NOT?: InputMaybe<UserAtomsAggregateInput>
  OR?: InputMaybe<Array<UserAtomsAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<UserAtomsNodeAggregationWhereInput>
}

export type UserAtomsConnectFieldInput = {
  connect?: InputMaybe<Array<AtomConnectInput>>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<AtomConnectWhere>
}

export type UserAtomsConnectOrCreateFieldInput = {
  onCreate: UserAtomsConnectOrCreateFieldInputOnCreate
  where: AtomConnectOrCreateWhere
}

export type UserAtomsConnectOrCreateFieldInputOnCreate = {
  node: AtomOnCreateInput
}

export type UserAtomsConnection = {
  edges: Array<UserAtomsRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type UserAtomsConnectionSort = {
  node?: InputMaybe<AtomSort>
}

export type UserAtomsConnectionWhere = {
  AND?: InputMaybe<Array<UserAtomsConnectionWhere>>
  NOT?: InputMaybe<UserAtomsConnectionWhere>
  OR?: InputMaybe<Array<UserAtomsConnectionWhere>>
  node?: InputMaybe<AtomWhere>
}

export type UserAtomsCreateFieldInput = {
  node: AtomCreateInput
}

export type UserAtomsDeleteFieldInput = {
  delete?: InputMaybe<AtomDeleteInput>
  where?: InputMaybe<UserAtomsConnectionWhere>
}

export type UserAtomsDisconnectFieldInput = {
  disconnect?: InputMaybe<AtomDisconnectInput>
  where?: InputMaybe<UserAtomsConnectionWhere>
}

export type UserAtomsFieldInput = {
  connect?: InputMaybe<Array<UserAtomsConnectFieldInput>>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<Array<UserAtomsConnectOrCreateFieldInput>>
  create?: InputMaybe<Array<UserAtomsCreateFieldInput>>
}

export type UserAtomsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<UserAtomsNodeAggregationWhereInput>>
  NOT?: InputMaybe<UserAtomsNodeAggregationWhereInput>
  OR?: InputMaybe<Array<UserAtomsNodeAggregationWhereInput>>
  externalCssSource_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  externalCssSource_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  externalCssSource_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  externalCssSource_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  externalCssSource_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  externalCssSource_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  externalCssSource_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  externalCssSource_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  externalCssSource_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  externalCssSource_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  externalCssSource_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  externalCssSource_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  externalCssSource_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  externalCssSource_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  externalCssSource_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  externalJsSource_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  externalJsSource_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  externalJsSource_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  externalJsSource_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  externalJsSource_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  externalJsSource_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  externalJsSource_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  externalJsSource_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  externalJsSource_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  externalJsSource_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  externalJsSource_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  externalJsSource_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  externalJsSource_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  externalJsSource_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  externalJsSource_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  externalSourceType_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  externalSourceType_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  externalSourceType_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  externalSourceType_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  externalSourceType_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  externalSourceType_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  externalSourceType_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  externalSourceType_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  externalSourceType_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  externalSourceType_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  externalSourceType_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  externalSourceType_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  externalSourceType_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  externalSourceType_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  externalSourceType_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  icon_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  icon_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  icon_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  icon_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  icon_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  icon_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  icon_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  icon_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  icon_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  icon_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  icon_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  icon_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  icon_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  icon_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  icon_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type UserAtomsRelationship = {
  cursor: Scalars['String']['output']
  node: Atom
}

export type UserAtomsUpdateConnectionInput = {
  node?: InputMaybe<AtomUpdateInput>
}

export type UserAtomsUpdateFieldInput = {
  connect?: InputMaybe<Array<UserAtomsConnectFieldInput>>
  connectOrCreate?: InputMaybe<Array<UserAtomsConnectOrCreateFieldInput>>
  create?: InputMaybe<Array<UserAtomsCreateFieldInput>>
  delete?: InputMaybe<Array<UserAtomsDeleteFieldInput>>
  disconnect?: InputMaybe<Array<UserAtomsDisconnectFieldInput>>
  update?: InputMaybe<UserAtomsUpdateConnectionInput>
  where?: InputMaybe<UserAtomsConnectionWhere>
}

export type UserComponentComponentsAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<UserComponentComponentsNodeAggregateSelection>
}

export type UserComponentComponentsNodeAggregateSelection = {
  compositeKey: StringAggregateSelection
  id: IdAggregateSelection
}

export type UserComponentsAggregateInput = {
  AND?: InputMaybe<Array<UserComponentsAggregateInput>>
  NOT?: InputMaybe<UserComponentsAggregateInput>
  OR?: InputMaybe<Array<UserComponentsAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<UserComponentsNodeAggregationWhereInput>
}

export type UserComponentsConnectFieldInput = {
  connect?: InputMaybe<Array<ComponentConnectInput>>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<ComponentConnectWhere>
}

export type UserComponentsConnectOrCreateFieldInput = {
  onCreate: UserComponentsConnectOrCreateFieldInputOnCreate
  where: ComponentConnectOrCreateWhere
}

export type UserComponentsConnectOrCreateFieldInputOnCreate = {
  node: ComponentOnCreateInput
}

export type UserComponentsConnection = {
  edges: Array<UserComponentsRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type UserComponentsConnectionSort = {
  node?: InputMaybe<ComponentSort>
}

export type UserComponentsConnectionWhere = {
  AND?: InputMaybe<Array<UserComponentsConnectionWhere>>
  NOT?: InputMaybe<UserComponentsConnectionWhere>
  OR?: InputMaybe<Array<UserComponentsConnectionWhere>>
  node?: InputMaybe<ComponentWhere>
}

export type UserComponentsCreateFieldInput = {
  node: ComponentCreateInput
}

export type UserComponentsDeleteFieldInput = {
  delete?: InputMaybe<ComponentDeleteInput>
  where?: InputMaybe<UserComponentsConnectionWhere>
}

export type UserComponentsDisconnectFieldInput = {
  disconnect?: InputMaybe<ComponentDisconnectInput>
  where?: InputMaybe<UserComponentsConnectionWhere>
}

export type UserComponentsFieldInput = {
  connect?: InputMaybe<Array<UserComponentsConnectFieldInput>>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<Array<UserComponentsConnectOrCreateFieldInput>>
  create?: InputMaybe<Array<UserComponentsCreateFieldInput>>
}

export type UserComponentsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<UserComponentsNodeAggregationWhereInput>>
  NOT?: InputMaybe<UserComponentsNodeAggregationWhereInput>
  OR?: InputMaybe<Array<UserComponentsNodeAggregationWhereInput>>
  compositeKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
}

export type UserComponentsRelationship = {
  cursor: Scalars['String']['output']
  node: Component
}

export type UserComponentsUpdateConnectionInput = {
  node?: InputMaybe<ComponentUpdateInput>
}

export type UserComponentsUpdateFieldInput = {
  connect?: InputMaybe<Array<UserComponentsConnectFieldInput>>
  connectOrCreate?: InputMaybe<Array<UserComponentsConnectOrCreateFieldInput>>
  create?: InputMaybe<Array<UserComponentsCreateFieldInput>>
  delete?: InputMaybe<Array<UserComponentsDeleteFieldInput>>
  disconnect?: InputMaybe<Array<UserComponentsDisconnectFieldInput>>
  update?: InputMaybe<UserComponentsUpdateConnectionInput>
  where?: InputMaybe<UserComponentsConnectionWhere>
}

export type UserConnectInput = {
  apps?: InputMaybe<Array<UserAppsConnectFieldInput>>
  atoms?: InputMaybe<Array<UserAtomsConnectFieldInput>>
  components?: InputMaybe<Array<UserComponentsConnectFieldInput>>
  elements?: InputMaybe<Array<UserElementsConnectFieldInput>>
  preferences?: InputMaybe<UserPreferencesConnectFieldInput>
  tags?: InputMaybe<Array<UserTagsConnectFieldInput>>
  types?: InputMaybe<Array<UserTypesConnectFieldInput>>
}

export type UserConnectOrCreateWhere = {
  node: UserUniqueWhere
}

export type UserConnectWhere = {
  node: UserWhere
}

export type UserCreateInput = {
  apps?: InputMaybe<UserAppsFieldInput>
  atoms?: InputMaybe<UserAtomsFieldInput>
  auth0Id: Scalars['String']['input']
  components?: InputMaybe<UserComponentsFieldInput>
  elements?: InputMaybe<UserElementsFieldInput>
  email: Scalars['String']['input']
  id: Scalars['ID']['input']
  preferences?: InputMaybe<UserPreferencesFieldInput>
  roles?: InputMaybe<Array<Role>>
  tags?: InputMaybe<UserTagsFieldInput>
  types?: InputMaybe<UserTypesFieldInput>
  username: Scalars['String']['input']
}

export type UserCreatedEvent = {
  createdUser: UserEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type UserDeleteInput = {
  apps?: InputMaybe<Array<UserAppsDeleteFieldInput>>
  atoms?: InputMaybe<Array<UserAtomsDeleteFieldInput>>
  components?: InputMaybe<Array<UserComponentsDeleteFieldInput>>
  elements?: InputMaybe<Array<UserElementsDeleteFieldInput>>
  preferences?: InputMaybe<UserPreferencesDeleteFieldInput>
  tags?: InputMaybe<Array<UserTagsDeleteFieldInput>>
  types?: InputMaybe<Array<UserTypesDeleteFieldInput>>
}

export type UserDeletedEvent = {
  deletedUser: UserEventPayload
  event: EventType
  timestamp: Scalars['Float']['output']
}

export type UserDisconnectInput = {
  apps?: InputMaybe<Array<UserAppsDisconnectFieldInput>>
  atoms?: InputMaybe<Array<UserAtomsDisconnectFieldInput>>
  components?: InputMaybe<Array<UserComponentsDisconnectFieldInput>>
  elements?: InputMaybe<Array<UserElementsDisconnectFieldInput>>
  preferences?: InputMaybe<UserPreferencesDisconnectFieldInput>
  tags?: InputMaybe<Array<UserTagsDisconnectFieldInput>>
  types?: InputMaybe<Array<UserTypesDisconnectFieldInput>>
}

export type UserEdge = {
  cursor: Scalars['String']['output']
  node: User
}

export type UserElementElementsAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<UserElementElementsNodeAggregateSelection>
}

export type UserElementElementsNodeAggregateSelection = {
  childMapperPropKey: StringAggregateSelection
  compositeKey: StringAggregateSelection
  id: IdAggregateSelection
  renderForEachPropKey: StringAggregateSelection
  renderIfExpression: StringAggregateSelection
  style: StringAggregateSelection
}

export type UserElementsAggregateInput = {
  AND?: InputMaybe<Array<UserElementsAggregateInput>>
  NOT?: InputMaybe<UserElementsAggregateInput>
  OR?: InputMaybe<Array<UserElementsAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<UserElementsNodeAggregationWhereInput>
}

export type UserElementsConnectFieldInput = {
  connect?: InputMaybe<Array<ElementConnectInput>>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<ElementConnectWhere>
}

export type UserElementsConnectOrCreateFieldInput = {
  onCreate: UserElementsConnectOrCreateFieldInputOnCreate
  where: ElementConnectOrCreateWhere
}

export type UserElementsConnectOrCreateFieldInputOnCreate = {
  node: ElementOnCreateInput
}

export type UserElementsConnection = {
  edges: Array<UserElementsRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type UserElementsConnectionSort = {
  node?: InputMaybe<ElementSort>
}

export type UserElementsConnectionWhere = {
  AND?: InputMaybe<Array<UserElementsConnectionWhere>>
  NOT?: InputMaybe<UserElementsConnectionWhere>
  OR?: InputMaybe<Array<UserElementsConnectionWhere>>
  node?: InputMaybe<ElementWhere>
}

export type UserElementsCreateFieldInput = {
  node: ElementCreateInput
}

export type UserElementsDeleteFieldInput = {
  delete?: InputMaybe<ElementDeleteInput>
  where?: InputMaybe<UserElementsConnectionWhere>
}

export type UserElementsDisconnectFieldInput = {
  disconnect?: InputMaybe<ElementDisconnectInput>
  where?: InputMaybe<UserElementsConnectionWhere>
}

export type UserElementsFieldInput = {
  connect?: InputMaybe<Array<UserElementsConnectFieldInput>>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<Array<UserElementsConnectOrCreateFieldInput>>
  create?: InputMaybe<Array<UserElementsCreateFieldInput>>
}

export type UserElementsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<UserElementsNodeAggregationWhereInput>>
  NOT?: InputMaybe<UserElementsNodeAggregationWhereInput>
  OR?: InputMaybe<Array<UserElementsNodeAggregationWhereInput>>
  childMapperPropKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  childMapperPropKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  childMapperPropKey_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  childMapperPropKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  compositeKey_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  compositeKey_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  compositeKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_GTE?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  renderForEachPropKey_AVERAGE_LENGTH_LTE?: InputMaybe<
    Scalars['Float']['input']
  >
  renderForEachPropKey_LONGEST_LENGTH_EQUAL?: InputMaybe<
    Scalars['Int']['input']
  >
  renderForEachPropKey_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_EQUAL?: InputMaybe<
    Scalars['Int']['input']
  >
  renderForEachPropKey_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderForEachPropKey_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_AVERAGE_LENGTH_EQUAL?: InputMaybe<
    Scalars['Float']['input']
  >
  renderIfExpression_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  renderIfExpression_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  renderIfExpression_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  style_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  style_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  style_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  style_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  style_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type UserElementsRelationship = {
  cursor: Scalars['String']['output']
  node: Element
}

export type UserElementsUpdateConnectionInput = {
  node?: InputMaybe<ElementUpdateInput>
}

export type UserElementsUpdateFieldInput = {
  connect?: InputMaybe<Array<UserElementsConnectFieldInput>>
  connectOrCreate?: InputMaybe<Array<UserElementsConnectOrCreateFieldInput>>
  create?: InputMaybe<Array<UserElementsCreateFieldInput>>
  delete?: InputMaybe<Array<UserElementsDeleteFieldInput>>
  disconnect?: InputMaybe<Array<UserElementsDisconnectFieldInput>>
  update?: InputMaybe<UserElementsUpdateConnectionInput>
  where?: InputMaybe<UserElementsConnectionWhere>
}

export type UserEventPayload = {
  auth0Id: Scalars['String']['output']
  email: Scalars['String']['output']
  id: Scalars['ID']['output']
  roles?: Maybe<Array<Role>>
  username: Scalars['String']['output']
}

export type UserIBaseTypeTypesAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<UserIBaseTypeTypesNodeAggregateSelection>
}

export type UserIBaseTypeTypesNodeAggregateSelection = {
  id: IdAggregateSelection
  name: StringAggregateSelection
}

export type UserOnCreateInput = {
  auth0Id: Scalars['String']['input']
  email: Scalars['String']['input']
  id: Scalars['ID']['input']
  roles?: InputMaybe<Array<Role>>
  username: Scalars['String']['input']
}

export type UserOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  /** Specify one or more UserSort objects to sort Users by. The sorts will be applied in the order in which they are arranged in the array. */
  sort?: InputMaybe<Array<UserSort>>
}

export type UserPreferencePreferencesAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<UserPreferencePreferencesNodeAggregateSelection>
}

export type UserPreferencePreferencesNodeAggregateSelection = {
  builderWidth: FloatAggregateSelection
  id: IdAggregateSelection
}

export type UserPreferencesAggregateInput = {
  AND?: InputMaybe<Array<UserPreferencesAggregateInput>>
  NOT?: InputMaybe<UserPreferencesAggregateInput>
  OR?: InputMaybe<Array<UserPreferencesAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<UserPreferencesNodeAggregationWhereInput>
}

export type UserPreferencesConnectFieldInput = {
  connect?: InputMaybe<PreferenceConnectInput>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<PreferenceConnectWhere>
}

export type UserPreferencesConnectOrCreateFieldInput = {
  onCreate: UserPreferencesConnectOrCreateFieldInputOnCreate
  where: PreferenceConnectOrCreateWhere
}

export type UserPreferencesConnectOrCreateFieldInputOnCreate = {
  node: PreferenceOnCreateInput
}

export type UserPreferencesConnection = {
  edges: Array<UserPreferencesRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type UserPreferencesConnectionSort = {
  node?: InputMaybe<PreferenceSort>
}

export type UserPreferencesConnectionWhere = {
  AND?: InputMaybe<Array<UserPreferencesConnectionWhere>>
  NOT?: InputMaybe<UserPreferencesConnectionWhere>
  OR?: InputMaybe<Array<UserPreferencesConnectionWhere>>
  node?: InputMaybe<PreferenceWhere>
}

export type UserPreferencesCreateFieldInput = {
  node: PreferenceCreateInput
}

export type UserPreferencesDeleteFieldInput = {
  delete?: InputMaybe<PreferenceDeleteInput>
  where?: InputMaybe<UserPreferencesConnectionWhere>
}

export type UserPreferencesDisconnectFieldInput = {
  disconnect?: InputMaybe<PreferenceDisconnectInput>
  where?: InputMaybe<UserPreferencesConnectionWhere>
}

export type UserPreferencesFieldInput = {
  connect?: InputMaybe<UserPreferencesConnectFieldInput>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<UserPreferencesConnectOrCreateFieldInput>
  create?: InputMaybe<UserPreferencesCreateFieldInput>
}

export type UserPreferencesNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<UserPreferencesNodeAggregationWhereInput>>
  NOT?: InputMaybe<UserPreferencesNodeAggregationWhereInput>
  OR?: InputMaybe<Array<UserPreferencesNodeAggregationWhereInput>>
  builderWidth_AVERAGE_EQUAL?: InputMaybe<Scalars['Float']['input']>
  builderWidth_AVERAGE_GT?: InputMaybe<Scalars['Float']['input']>
  builderWidth_AVERAGE_GTE?: InputMaybe<Scalars['Float']['input']>
  builderWidth_AVERAGE_LT?: InputMaybe<Scalars['Float']['input']>
  builderWidth_AVERAGE_LTE?: InputMaybe<Scalars['Float']['input']>
  builderWidth_MAX_EQUAL?: InputMaybe<Scalars['Float']['input']>
  builderWidth_MAX_GT?: InputMaybe<Scalars['Float']['input']>
  builderWidth_MAX_GTE?: InputMaybe<Scalars['Float']['input']>
  builderWidth_MAX_LT?: InputMaybe<Scalars['Float']['input']>
  builderWidth_MAX_LTE?: InputMaybe<Scalars['Float']['input']>
  builderWidth_MIN_EQUAL?: InputMaybe<Scalars['Float']['input']>
  builderWidth_MIN_GT?: InputMaybe<Scalars['Float']['input']>
  builderWidth_MIN_GTE?: InputMaybe<Scalars['Float']['input']>
  builderWidth_MIN_LT?: InputMaybe<Scalars['Float']['input']>
  builderWidth_MIN_LTE?: InputMaybe<Scalars['Float']['input']>
  builderWidth_SUM_EQUAL?: InputMaybe<Scalars['Float']['input']>
  builderWidth_SUM_GT?: InputMaybe<Scalars['Float']['input']>
  builderWidth_SUM_GTE?: InputMaybe<Scalars['Float']['input']>
  builderWidth_SUM_LT?: InputMaybe<Scalars['Float']['input']>
  builderWidth_SUM_LTE?: InputMaybe<Scalars['Float']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
}

export type UserPreferencesRelationship = {
  cursor: Scalars['String']['output']
  node: Preference
}

export type UserPreferencesUpdateConnectionInput = {
  node?: InputMaybe<PreferenceUpdateInput>
}

export type UserPreferencesUpdateFieldInput = {
  connect?: InputMaybe<UserPreferencesConnectFieldInput>
  connectOrCreate?: InputMaybe<UserPreferencesConnectOrCreateFieldInput>
  create?: InputMaybe<UserPreferencesCreateFieldInput>
  delete?: InputMaybe<UserPreferencesDeleteFieldInput>
  disconnect?: InputMaybe<UserPreferencesDisconnectFieldInput>
  update?: InputMaybe<UserPreferencesUpdateConnectionInput>
  where?: InputMaybe<UserPreferencesConnectionWhere>
}

/** Fields to sort Users by. The order in which sorts are applied is not guaranteed when specifying many fields in one UserSort object. */
export type UserSort = {
  auth0Id?: InputMaybe<SortDirection>
  email?: InputMaybe<SortDirection>
  id?: InputMaybe<SortDirection>
  username?: InputMaybe<SortDirection>
}

export type UserSubscriptionWhere = {
  AND?: InputMaybe<Array<UserSubscriptionWhere>>
  NOT?: InputMaybe<UserSubscriptionWhere>
  OR?: InputMaybe<Array<UserSubscriptionWhere>>
  /** @deprecated Please use the explicit _EQ version */
  auth0Id?: InputMaybe<Scalars['String']['input']>
  auth0Id_CONTAINS?: InputMaybe<Scalars['String']['input']>
  auth0Id_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  auth0Id_EQ?: InputMaybe<Scalars['String']['input']>
  auth0Id_IN?: InputMaybe<Array<Scalars['String']['input']>>
  auth0Id_MATCHES?: InputMaybe<Scalars['String']['input']>
  auth0Id_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  email?: InputMaybe<Scalars['String']['input']>
  email_CONTAINS?: InputMaybe<Scalars['String']['input']>
  email_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  email_EQ?: InputMaybe<Scalars['String']['input']>
  email_IN?: InputMaybe<Array<Scalars['String']['input']>>
  email_MATCHES?: InputMaybe<Scalars['String']['input']>
  email_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  roles?: InputMaybe<Array<Role>>
  roles_EQ?: InputMaybe<Array<Role>>
  roles_INCLUDES?: InputMaybe<Role>
  /** @deprecated Please use the explicit _EQ version */
  username?: InputMaybe<Scalars['String']['input']>
  username_CONTAINS?: InputMaybe<Scalars['String']['input']>
  username_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  username_EQ?: InputMaybe<Scalars['String']['input']>
  username_IN?: InputMaybe<Array<Scalars['String']['input']>>
  username_MATCHES?: InputMaybe<Scalars['String']['input']>
  username_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
}

export type UserTagTagsAggregationSelection = {
  count: Scalars['Int']['output']
  node?: Maybe<UserTagTagsNodeAggregateSelection>
}

export type UserTagTagsNodeAggregateSelection = {
  id: IdAggregateSelection
  name: StringAggregateSelection
}

export type UserTagsAggregateInput = {
  AND?: InputMaybe<Array<UserTagsAggregateInput>>
  NOT?: InputMaybe<UserTagsAggregateInput>
  OR?: InputMaybe<Array<UserTagsAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<UserTagsNodeAggregationWhereInput>
}

export type UserTagsConnectFieldInput = {
  connect?: InputMaybe<Array<TagConnectInput>>
  /**
   * Whether or not to overwrite any matching relationship with the new properties.
   * @deprecated The overwrite argument is deprecated and will be removed
   */
  overwrite?: Scalars['Boolean']['input']
  where?: InputMaybe<TagConnectWhere>
}

export type UserTagsConnectOrCreateFieldInput = {
  onCreate: UserTagsConnectOrCreateFieldInputOnCreate
  where: TagConnectOrCreateWhere
}

export type UserTagsConnectOrCreateFieldInputOnCreate = {
  node: TagOnCreateInput
}

export type UserTagsConnection = {
  edges: Array<UserTagsRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type UserTagsConnectionSort = {
  node?: InputMaybe<TagSort>
}

export type UserTagsConnectionWhere = {
  AND?: InputMaybe<Array<UserTagsConnectionWhere>>
  NOT?: InputMaybe<UserTagsConnectionWhere>
  OR?: InputMaybe<Array<UserTagsConnectionWhere>>
  node?: InputMaybe<TagWhere>
}

export type UserTagsCreateFieldInput = {
  node: TagCreateInput
}

export type UserTagsDeleteFieldInput = {
  delete?: InputMaybe<TagDeleteInput>
  where?: InputMaybe<UserTagsConnectionWhere>
}

export type UserTagsDisconnectFieldInput = {
  disconnect?: InputMaybe<TagDisconnectInput>
  where?: InputMaybe<UserTagsConnectionWhere>
}

export type UserTagsFieldInput = {
  connect?: InputMaybe<Array<UserTagsConnectFieldInput>>
  /** @deprecated The connectOrCreate operation is deprecated and will be removed */
  connectOrCreate?: InputMaybe<Array<UserTagsConnectOrCreateFieldInput>>
  create?: InputMaybe<Array<UserTagsCreateFieldInput>>
}

export type UserTagsNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<UserTagsNodeAggregationWhereInput>>
  NOT?: InputMaybe<UserTagsNodeAggregationWhereInput>
  OR?: InputMaybe<Array<UserTagsNodeAggregationWhereInput>>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type UserTagsRelationship = {
  cursor: Scalars['String']['output']
  node: Tag
}

export type UserTagsUpdateConnectionInput = {
  node?: InputMaybe<TagUpdateInput>
}

export type UserTagsUpdateFieldInput = {
  connect?: InputMaybe<Array<UserTagsConnectFieldInput>>
  connectOrCreate?: InputMaybe<Array<UserTagsConnectOrCreateFieldInput>>
  create?: InputMaybe<Array<UserTagsCreateFieldInput>>
  delete?: InputMaybe<Array<UserTagsDeleteFieldInput>>
  disconnect?: InputMaybe<Array<UserTagsDisconnectFieldInput>>
  update?: InputMaybe<UserTagsUpdateConnectionInput>
  where?: InputMaybe<UserTagsConnectionWhere>
}

export type UserTypesAggregateInput = {
  AND?: InputMaybe<Array<UserTypesAggregateInput>>
  NOT?: InputMaybe<UserTypesAggregateInput>
  OR?: InputMaybe<Array<UserTypesAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<UserTypesNodeAggregationWhereInput>
}

export type UserTypesConnectFieldInput = {
  connect?: InputMaybe<IBaseTypeConnectInput>
  where?: InputMaybe<IBaseTypeConnectWhere>
}

export type UserTypesConnection = {
  edges: Array<UserTypesRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type UserTypesConnectionSort = {
  node?: InputMaybe<IBaseTypeSort>
}

export type UserTypesConnectionWhere = {
  AND?: InputMaybe<Array<UserTypesConnectionWhere>>
  NOT?: InputMaybe<UserTypesConnectionWhere>
  OR?: InputMaybe<Array<UserTypesConnectionWhere>>
  node?: InputMaybe<IBaseTypeWhere>
}

export type UserTypesCreateFieldInput = {
  node: IBaseTypeCreateInput
}

export type UserTypesDeleteFieldInput = {
  delete?: InputMaybe<IBaseTypeDeleteInput>
  where?: InputMaybe<UserTypesConnectionWhere>
}

export type UserTypesDisconnectFieldInput = {
  disconnect?: InputMaybe<IBaseTypeDisconnectInput>
  where?: InputMaybe<UserTypesConnectionWhere>
}

export type UserTypesFieldInput = {
  connect?: InputMaybe<Array<UserTypesConnectFieldInput>>
  create?: InputMaybe<Array<UserTypesCreateFieldInput>>
}

export type UserTypesNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<UserTypesNodeAggregationWhereInput>>
  NOT?: InputMaybe<UserTypesNodeAggregationWhereInput>
  OR?: InputMaybe<Array<UserTypesNodeAggregationWhereInput>>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  name_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  name_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  name_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  name_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type UserTypesRelationship = {
  cursor: Scalars['String']['output']
  node: IBaseType
}

export type UserTypesUpdateConnectionInput = {
  node?: InputMaybe<IBaseTypeUpdateInput>
}

export type UserTypesUpdateFieldInput = {
  connect?: InputMaybe<Array<UserTypesConnectFieldInput>>
  create?: InputMaybe<Array<UserTypesCreateFieldInput>>
  delete?: InputMaybe<Array<UserTypesDeleteFieldInput>>
  disconnect?: InputMaybe<Array<UserTypesDisconnectFieldInput>>
  update?: InputMaybe<UserTypesUpdateConnectionInput>
  where?: InputMaybe<UserTypesConnectionWhere>
}

export type UserUniqueWhere = {
  /** @deprecated Please use the explicit _EQ version */
  auth0Id?: InputMaybe<Scalars['String']['input']>
  auth0Id_EQ?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  email?: InputMaybe<Scalars['String']['input']>
  email_EQ?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  /** @deprecated Please use the explicit _EQ version */
  username?: InputMaybe<Scalars['String']['input']>
  username_EQ?: InputMaybe<Scalars['String']['input']>
}

export type UserUpdateInput = {
  apps?: InputMaybe<Array<UserAppsUpdateFieldInput>>
  atoms?: InputMaybe<Array<UserAtomsUpdateFieldInput>>
  /** @deprecated Please use the explicit _SET field */
  auth0Id?: InputMaybe<Scalars['String']['input']>
  auth0Id_SET?: InputMaybe<Scalars['String']['input']>
  components?: InputMaybe<Array<UserComponentsUpdateFieldInput>>
  elements?: InputMaybe<Array<UserElementsUpdateFieldInput>>
  /** @deprecated Please use the explicit _SET field */
  email?: InputMaybe<Scalars['String']['input']>
  email_SET?: InputMaybe<Scalars['String']['input']>
  preferences?: InputMaybe<UserPreferencesUpdateFieldInput>
  /** @deprecated Please use the explicit _SET field */
  roles?: InputMaybe<Array<Role>>
  roles_SET?: InputMaybe<Array<Role>>
  tags?: InputMaybe<Array<UserTagsUpdateFieldInput>>
  types?: InputMaybe<Array<UserTypesUpdateFieldInput>>
  /** @deprecated Please use the explicit _SET field */
  username?: InputMaybe<Scalars['String']['input']>
  username_SET?: InputMaybe<Scalars['String']['input']>
}

export type UserUpdatedEvent = {
  event: EventType
  previousState: UserEventPayload
  timestamp: Scalars['Float']['output']
  updatedUser: UserEventPayload
}

export type UserWhere = {
  AND?: InputMaybe<Array<UserWhere>>
  NOT?: InputMaybe<UserWhere>
  OR?: InputMaybe<Array<UserWhere>>
  appsAggregate?: InputMaybe<UserAppsAggregateInput>
  /** Return Users where all of the related UserAppsConnections match this filter */
  appsConnection_ALL?: InputMaybe<UserAppsConnectionWhere>
  /** Return Users where none of the related UserAppsConnections match this filter */
  appsConnection_NONE?: InputMaybe<UserAppsConnectionWhere>
  /** Return Users where one of the related UserAppsConnections match this filter */
  appsConnection_SINGLE?: InputMaybe<UserAppsConnectionWhere>
  /** Return Users where some of the related UserAppsConnections match this filter */
  appsConnection_SOME?: InputMaybe<UserAppsConnectionWhere>
  /** Return Users where all of the related Apps match this filter */
  apps_ALL?: InputMaybe<AppWhere>
  /** Return Users where none of the related Apps match this filter */
  apps_NONE?: InputMaybe<AppWhere>
  /** Return Users where one of the related Apps match this filter */
  apps_SINGLE?: InputMaybe<AppWhere>
  /** Return Users where some of the related Apps match this filter */
  apps_SOME?: InputMaybe<AppWhere>
  atomsAggregate?: InputMaybe<UserAtomsAggregateInput>
  /** Return Users where all of the related UserAtomsConnections match this filter */
  atomsConnection_ALL?: InputMaybe<UserAtomsConnectionWhere>
  /** Return Users where none of the related UserAtomsConnections match this filter */
  atomsConnection_NONE?: InputMaybe<UserAtomsConnectionWhere>
  /** Return Users where one of the related UserAtomsConnections match this filter */
  atomsConnection_SINGLE?: InputMaybe<UserAtomsConnectionWhere>
  /** Return Users where some of the related UserAtomsConnections match this filter */
  atomsConnection_SOME?: InputMaybe<UserAtomsConnectionWhere>
  /** Return Users where all of the related Atoms match this filter */
  atoms_ALL?: InputMaybe<AtomWhere>
  /** Return Users where none of the related Atoms match this filter */
  atoms_NONE?: InputMaybe<AtomWhere>
  /** Return Users where one of the related Atoms match this filter */
  atoms_SINGLE?: InputMaybe<AtomWhere>
  /** Return Users where some of the related Atoms match this filter */
  atoms_SOME?: InputMaybe<AtomWhere>
  /** @deprecated Please use the explicit _EQ version */
  auth0Id?: InputMaybe<Scalars['String']['input']>
  auth0Id_CONTAINS?: InputMaybe<Scalars['String']['input']>
  auth0Id_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  auth0Id_EQ?: InputMaybe<Scalars['String']['input']>
  auth0Id_IN?: InputMaybe<Array<Scalars['String']['input']>>
  auth0Id_MATCHES?: InputMaybe<Scalars['String']['input']>
  auth0Id_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  componentsAggregate?: InputMaybe<UserComponentsAggregateInput>
  /** Return Users where all of the related UserComponentsConnections match this filter */
  componentsConnection_ALL?: InputMaybe<UserComponentsConnectionWhere>
  /** Return Users where none of the related UserComponentsConnections match this filter */
  componentsConnection_NONE?: InputMaybe<UserComponentsConnectionWhere>
  /** Return Users where one of the related UserComponentsConnections match this filter */
  componentsConnection_SINGLE?: InputMaybe<UserComponentsConnectionWhere>
  /** Return Users where some of the related UserComponentsConnections match this filter */
  componentsConnection_SOME?: InputMaybe<UserComponentsConnectionWhere>
  /** Return Users where all of the related Components match this filter */
  components_ALL?: InputMaybe<ComponentWhere>
  /** Return Users where none of the related Components match this filter */
  components_NONE?: InputMaybe<ComponentWhere>
  /** Return Users where one of the related Components match this filter */
  components_SINGLE?: InputMaybe<ComponentWhere>
  /** Return Users where some of the related Components match this filter */
  components_SOME?: InputMaybe<ComponentWhere>
  elementsAggregate?: InputMaybe<UserElementsAggregateInput>
  /** Return Users where all of the related UserElementsConnections match this filter */
  elementsConnection_ALL?: InputMaybe<UserElementsConnectionWhere>
  /** Return Users where none of the related UserElementsConnections match this filter */
  elementsConnection_NONE?: InputMaybe<UserElementsConnectionWhere>
  /** Return Users where one of the related UserElementsConnections match this filter */
  elementsConnection_SINGLE?: InputMaybe<UserElementsConnectionWhere>
  /** Return Users where some of the related UserElementsConnections match this filter */
  elementsConnection_SOME?: InputMaybe<UserElementsConnectionWhere>
  /** Return Users where all of the related Elements match this filter */
  elements_ALL?: InputMaybe<ElementWhere>
  /** Return Users where none of the related Elements match this filter */
  elements_NONE?: InputMaybe<ElementWhere>
  /** Return Users where one of the related Elements match this filter */
  elements_SINGLE?: InputMaybe<ElementWhere>
  /** Return Users where some of the related Elements match this filter */
  elements_SOME?: InputMaybe<ElementWhere>
  /** @deprecated Please use the explicit _EQ version */
  email?: InputMaybe<Scalars['String']['input']>
  email_CONTAINS?: InputMaybe<Scalars['String']['input']>
  email_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  email_EQ?: InputMaybe<Scalars['String']['input']>
  email_IN?: InputMaybe<Array<Scalars['String']['input']>>
  email_MATCHES?: InputMaybe<Scalars['String']['input']>
  email_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
  /** @deprecated Please use the explicit _EQ version */
  id?: InputMaybe<Scalars['ID']['input']>
  id_CONTAINS?: InputMaybe<Scalars['ID']['input']>
  id_ENDS_WITH?: InputMaybe<Scalars['ID']['input']>
  id_EQ?: InputMaybe<Scalars['ID']['input']>
  id_IN?: InputMaybe<Array<Scalars['ID']['input']>>
  id_STARTS_WITH?: InputMaybe<Scalars['ID']['input']>
  preferences?: InputMaybe<PreferenceWhere>
  preferencesAggregate?: InputMaybe<UserPreferencesAggregateInput>
  preferencesConnection?: InputMaybe<UserPreferencesConnectionWhere>
  /** @deprecated Please use the explicit _EQ version */
  roles?: InputMaybe<Array<Role>>
  roles_EQ?: InputMaybe<Array<Role>>
  roles_INCLUDES?: InputMaybe<Role>
  tagsAggregate?: InputMaybe<UserTagsAggregateInput>
  /** Return Users where all of the related UserTagsConnections match this filter */
  tagsConnection_ALL?: InputMaybe<UserTagsConnectionWhere>
  /** Return Users where none of the related UserTagsConnections match this filter */
  tagsConnection_NONE?: InputMaybe<UserTagsConnectionWhere>
  /** Return Users where one of the related UserTagsConnections match this filter */
  tagsConnection_SINGLE?: InputMaybe<UserTagsConnectionWhere>
  /** Return Users where some of the related UserTagsConnections match this filter */
  tagsConnection_SOME?: InputMaybe<UserTagsConnectionWhere>
  /** Return Users where all of the related Tags match this filter */
  tags_ALL?: InputMaybe<TagWhere>
  /** Return Users where none of the related Tags match this filter */
  tags_NONE?: InputMaybe<TagWhere>
  /** Return Users where one of the related Tags match this filter */
  tags_SINGLE?: InputMaybe<TagWhere>
  /** Return Users where some of the related Tags match this filter */
  tags_SOME?: InputMaybe<TagWhere>
  typesAggregate?: InputMaybe<UserTypesAggregateInput>
  /** Return Users where all of the related UserTypesConnections match this filter */
  typesConnection_ALL?: InputMaybe<UserTypesConnectionWhere>
  /** Return Users where none of the related UserTypesConnections match this filter */
  typesConnection_NONE?: InputMaybe<UserTypesConnectionWhere>
  /** Return Users where one of the related UserTypesConnections match this filter */
  typesConnection_SINGLE?: InputMaybe<UserTypesConnectionWhere>
  /** Return Users where some of the related UserTypesConnections match this filter */
  typesConnection_SOME?: InputMaybe<UserTypesConnectionWhere>
  /** Return Users where all of the related IBaseTypes match this filter */
  types_ALL?: InputMaybe<IBaseTypeWhere>
  /** Return Users where none of the related IBaseTypes match this filter */
  types_NONE?: InputMaybe<IBaseTypeWhere>
  /** Return Users where one of the related IBaseTypes match this filter */
  types_SINGLE?: InputMaybe<IBaseTypeWhere>
  /** Return Users where some of the related IBaseTypes match this filter */
  types_SOME?: InputMaybe<IBaseTypeWhere>
  /** @deprecated Please use the explicit _EQ version */
  username?: InputMaybe<Scalars['String']['input']>
  username_CONTAINS?: InputMaybe<Scalars['String']['input']>
  username_ENDS_WITH?: InputMaybe<Scalars['String']['input']>
  username_EQ?: InputMaybe<Scalars['String']['input']>
  username_IN?: InputMaybe<Array<Scalars['String']['input']>>
  username_MATCHES?: InputMaybe<Scalars['String']['input']>
  username_STARTS_WITH?: InputMaybe<Scalars['String']['input']>
}

export type UsersConnection = {
  edges: Array<UserEdge>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type WithDescendants = {
  descendantTypesIds: Array<Scalars['ID']['output']>
}

export type WithDescendantsAggregateSelection = {
  count: Scalars['Int']['output']
}

export type WithDescendantsConnection = {
  edges: Array<WithDescendantsEdge>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type WithDescendantsEdge = {
  cursor: Scalars['String']['output']
  node: WithDescendants
}

export enum WithDescendantsImplementation {
  ArrayType = 'ArrayType',
  InterfaceType = 'InterfaceType',
  UnionType = 'UnionType',
}

export type WithDescendantsOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
}

export type WithDescendantsWhere = {
  AND?: InputMaybe<Array<WithDescendantsWhere>>
  NOT?: InputMaybe<WithDescendantsWhere>
  OR?: InputMaybe<Array<WithDescendantsWhere>>
  /** @deprecated Please use the explicit _EQ version */
  descendantTypesIds?: InputMaybe<Array<Scalars['ID']['input']>>
  descendantTypesIds_EQ?: InputMaybe<Array<Scalars['ID']['input']>>
  descendantTypesIds_INCLUDES?: InputMaybe<Scalars['ID']['input']>
  typename_IN?: InputMaybe<Array<WithDescendantsImplementation>>
}

export type WithOwner = {
  owner: User
  ownerConnection: WithOwnerOwnerConnection
}

export type WithOwnerOwnerArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
  options?: InputMaybe<UserOptions>
  sort?: InputMaybe<Array<UserSort>>
  where?: InputMaybe<UserWhere>
}

export type WithOwnerOwnerConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  sort?: InputMaybe<Array<WithOwnerOwnerConnectionSort>>
  where?: InputMaybe<WithOwnerOwnerConnectionWhere>
}

export type WithOwnerAggregateSelection = {
  count: Scalars['Int']['output']
}

export type WithOwnerEdge = {
  cursor: Scalars['String']['output']
  node: WithOwner
}

export enum WithOwnerImplementation {
  App = 'App',
  Atom = 'Atom',
  AuthGuard = 'AuthGuard',
  Component = 'Component',
  Preference = 'Preference',
  Resource = 'Resource',
  Tag = 'Tag',
}

export type WithOwnerOptions = {
  limit?: InputMaybe<Scalars['Int']['input']>
  offset?: InputMaybe<Scalars['Int']['input']>
}

export type WithOwnerOwnerAggregateInput = {
  AND?: InputMaybe<Array<WithOwnerOwnerAggregateInput>>
  NOT?: InputMaybe<WithOwnerOwnerAggregateInput>
  OR?: InputMaybe<Array<WithOwnerOwnerAggregateInput>>
  /** @deprecated Please use the explicit _EQ version */
  count?: InputMaybe<Scalars['Int']['input']>
  count_EQ?: InputMaybe<Scalars['Int']['input']>
  count_GT?: InputMaybe<Scalars['Int']['input']>
  count_GTE?: InputMaybe<Scalars['Int']['input']>
  count_LT?: InputMaybe<Scalars['Int']['input']>
  count_LTE?: InputMaybe<Scalars['Int']['input']>
  node?: InputMaybe<WithOwnerOwnerNodeAggregationWhereInput>
}

export type WithOwnerOwnerConnection = {
  edges: Array<WithOwnerOwnerRelationship>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type WithOwnerOwnerConnectionSort = {
  node?: InputMaybe<UserSort>
}

export type WithOwnerOwnerConnectionWhere = {
  AND?: InputMaybe<Array<WithOwnerOwnerConnectionWhere>>
  NOT?: InputMaybe<WithOwnerOwnerConnectionWhere>
  OR?: InputMaybe<Array<WithOwnerOwnerConnectionWhere>>
  node?: InputMaybe<UserWhere>
}

export type WithOwnerOwnerDeleteFieldInput = {
  delete?: InputMaybe<UserDeleteInput>
  where?: InputMaybe<WithOwnerOwnerConnectionWhere>
}

export type WithOwnerOwnerDisconnectFieldInput = {
  disconnect?: InputMaybe<UserDisconnectInput>
  where?: InputMaybe<WithOwnerOwnerConnectionWhere>
}

export type WithOwnerOwnerNodeAggregationWhereInput = {
  AND?: InputMaybe<Array<WithOwnerOwnerNodeAggregationWhereInput>>
  NOT?: InputMaybe<WithOwnerOwnerNodeAggregationWhereInput>
  OR?: InputMaybe<Array<WithOwnerOwnerNodeAggregationWhereInput>>
  auth0Id_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  auth0Id_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  auth0Id_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  auth0Id_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  email_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  email_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  email_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  email_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  email_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  id_MAX_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LT?: InputMaybe<Scalars['ID']['input']>
  id_MAX_LTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_EQUAL?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_GTE?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LT?: InputMaybe<Scalars['ID']['input']>
  id_MIN_LTE?: InputMaybe<Scalars['ID']['input']>
  username_AVERAGE_LENGTH_EQUAL?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_GT?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_GTE?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_LT?: InputMaybe<Scalars['Float']['input']>
  username_AVERAGE_LENGTH_LTE?: InputMaybe<Scalars['Float']['input']>
  username_LONGEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  username_LONGEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_EQUAL?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_GT?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_GTE?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_LT?: InputMaybe<Scalars['Int']['input']>
  username_SHORTEST_LENGTH_LTE?: InputMaybe<Scalars['Int']['input']>
}

export type WithOwnerOwnerRelationship = {
  cursor: Scalars['String']['output']
  node: User
}

export type WithOwnerWhere = {
  AND?: InputMaybe<Array<WithOwnerWhere>>
  NOT?: InputMaybe<WithOwnerWhere>
  OR?: InputMaybe<Array<WithOwnerWhere>>
  owner?: InputMaybe<UserWhere>
  ownerAggregate?: InputMaybe<WithOwnerOwnerAggregateInput>
  ownerConnection?: InputMaybe<WithOwnerOwnerConnectionWhere>
  typename_IN?: InputMaybe<Array<WithOwnerImplementation>>
}

export type WithOwnersConnection = {
  edges: Array<WithOwnerEdge>
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type DomainCreatedSubscriptionVariables = Exact<{ [key: string]: never }>

export type DomainCreatedSubscription = {
  domainCreated: {
    event: EventType
    timestamp: number
    createdDomain: { id: string; name: string }
  }
}

export type DomainUpdatedSubscriptionVariables = Exact<{ [key: string]: never }>

export type DomainUpdatedSubscription = {
  domainUpdated: {
    event: EventType
    timestamp: number
    updatedDomain: { id: string; name: string }
  }
}

export type DomainDeletedSubscriptionVariables = Exact<{ [key: string]: never }>

export type DomainDeletedSubscription = {
  domainDeleted: {
    event: EventType
    timestamp: number
    deletedDomain: { id: string; name: string }
  }
}

type BaseAction_ApiAction_Fragment = {
  __typename: 'ApiAction'
  id: string
  name: string
  type: ActionKind
  store: { id: string; name: string }
}

type BaseAction_CodeAction_Fragment = {
  __typename: 'CodeAction'
  id: string
  name: string
  type: ActionKind
  store: { id: string; name: string }
}

export type BaseActionFragment =
  | BaseAction_ApiAction_Fragment
  | BaseAction_CodeAction_Fragment

type Action_ApiAction_Fragment = ApiActionFragment &
  BaseAction_ApiAction_Fragment

type Action_CodeAction_Fragment = CodeActionFragment &
  BaseAction_CodeAction_Fragment

export type ActionFragment =
  | Action_ApiAction_Fragment
  | Action_CodeAction_Fragment

export type ApiActionFragment = {
  config: { data: string; id: string }
  errorAction?:
    | BaseAction_ApiAction_Fragment
    | BaseAction_CodeAction_Fragment
    | null
  resource: ResourceFragment
  successAction?:
    | BaseAction_ApiAction_Fragment
    | BaseAction_CodeAction_Fragment
    | null
} & BaseAction_ApiAction_Fragment

export type CodeActionFragment = {
  code: string
} & BaseAction_CodeAction_Fragment

export type AppPreviewFragment = {
  id: string
  name: string
  slug: string
  domains: Array<DomainFragment>
  owner: OwnerFragment
  pages: Array<PagePreviewFragment>
}

export type AppFragment = {
  id: string
  name: string
  slug: string
  domains: Array<DomainFragment>
  owner: OwnerFragment
  pages: Array<PageFragment>
}

export type AppBuilderFragment = {
  id: string
  name: string
  slug: string
  owner: OwnerFragment
  pages: Array<PageDevelopmentFragment>
}

export type AppProductionFragment = {
  id: string
  name: string
  slug: string
  owner: OwnerFragment
  pages: Array<PageProductionFragment>
}

export type AtomFragment = {
  __typename: 'Atom'
  externalCssSource?: string | null
  externalJsSource?: string | null
  externalSourceType?: string | null
  icon?: string | null
  id: string
  name: string
  type: AtomType
  api: InterfaceTypeFragment
  requiredParents: Array<{ id: string; name: string; type: AtomType }>
  suggestedChildren: Array<{ id: string; name: string; type: AtomType }>
  tags: Array<TagPreviewFragment>
  owner: { id: string }
}

export type AtomBuilderFragment = {
  __typename: 'Atom'
  icon?: string | null
  id: string
  name: string
  type: AtomType
  api: InterfaceTypeFragment
  requiredParents: Array<{ id: string; name: string; type: AtomType }>
  suggestedChildren: Array<{ id: string; name: string; type: AtomType }>
  tags: Array<TagPreviewFragment>
  owner: { id: string }
}

export type AtomProductionFragment = {
  __typename: 'Atom'
  externalCssSource?: string | null
  externalJsSource?: string | null
  externalSourceType?: string | null
  icon?: string | null
  id: string
  name: string
  type: AtomType
  requiredParents: Array<{ id: string; name: string; type: AtomType }>
  suggestedChildren: Array<{ id: string; name: string; type: AtomType }>
}

export type AuthGuardFragment = {
  id: string
  name: string
  responseTransformer: string
  config: PropFragment
  resource: ResourceFragment
  owner: { id: string }
}

export type ComponentFragment = {
  __typename: 'Component'
  id: string
  name: string
  compositeKey: string
  api: { id: string }
  owner: OwnerFragment
  props: PropFragment
  rootElement: { id: string }
  store: StoreFragment
}

export type ComponentBuilderFragment = {
  __typename: 'Component'
  id: string
  name: string
  compositeKey: string
  api: InterfaceTypeFragment
  elements: Array<ElementFragment>
  owner: OwnerFragment
  props: PropFragment
  rootElement: { id: string; name: string }
  store: StoreFragment
}

export type ComponentProductionFragment = {
  id: string
  name: string
  compositeKey: string
  owner: OwnerFragment
  props: PropFragment
  rootElement: { id: string; name: string }
  store: StoreFragment
}

export type DomainFragment = {
  id: string
  name: string
  app: { id: string }
  domainConfig: { misconfigured: boolean }
}

export type ElementFragment = {
  __typename: 'Element'
  childMapperPropKey?: string | null
  id: string
  name: string
  renderForEachPropKey?: string | null
  renderIfExpression?: string | null
  style?: string | null
  tailwindClassNames?: Array<string> | null
  expanded?: boolean | null
  childMapperComponent?: { id: string; name: string } | null
  childMapperPreviousSibling?: { id: string } | null
  dependantTypes: Array<
    | Type_ActionType_Fragment
    | Type_AppType_Fragment
    | Type_ArrayType_Fragment
    | Type_CodeMirrorType_Fragment
    | Type_ElementType_Fragment
    | Type_EnumType_Fragment
    | Type_InterfaceType_Fragment
    | Type_LambdaType_Fragment
    | Type_PageType_Fragment
    | Type_PrimitiveType_Fragment
    | Type_ReactNodeType_Fragment
    | Type_RenderPropType_Fragment
    | Type_RichTextType_Fragment
    | Type_UnionType_Fragment
  >
  firstChild?: { id: string } | null
  nextSibling?: { id: string } | null
  page?: { id: string } | null
  parentComponent?: { id: string } | null
  parentElement?: { id: string } | null
  postRenderActions: Array<
    { id: string; type: ActionKind } | { id: string; type: ActionKind }
  >
  preRenderActions: Array<
    { id: string; type: ActionKind } | { id: string; type: ActionKind }
  >
  prevSibling?: { id: string } | null
  props: PropFragment
  renderType:
    | ({ __typename: 'Atom' } & AtomBuilderFragment)
    | { __typename: 'Component'; id: string }
}

export type ElementProductionFragment = {
  __typename: 'Element'
  childMapperPropKey?: string | null
  id: string
  name: string
  renderForEachPropKey?: string | null
  renderIfExpression?: string | null
  style?: string | null
  tailwindClassNames?: Array<string> | null
  childMapperComponent?: { id: string; name: string } | null
  childMapperPreviousSibling?: { id: string } | null
  dependantTypes: Array<
    | Type_ActionType_Fragment
    | Type_AppType_Fragment
    | Type_ArrayType_Fragment
    | Type_CodeMirrorType_Fragment
    | Type_ElementType_Fragment
    | Type_EnumType_Fragment
    | Type_InterfaceType_Fragment
    | Type_LambdaType_Fragment
    | Type_PageType_Fragment
    | Type_PrimitiveType_Fragment
    | Type_ReactNodeType_Fragment
    | Type_RenderPropType_Fragment
    | Type_RichTextType_Fragment
    | Type_UnionType_Fragment
  >
  firstChild?: { id: string } | null
  nextSibling?: { id: string } | null
  page?: { id: string } | null
  parentComponent?: { id: string } | null
  parentElement?: { id: string } | null
  postRenderActions: Array<
    { id: string; type: ActionKind } | { id: string; type: ActionKind }
  >
  preRenderActions: Array<
    { id: string; type: ActionKind } | { id: string; type: ActionKind }
  >
  prevSibling?: { id: string } | null
  props: PropFragment
  renderType:
    | ({ __typename: 'Atom' } & AtomProductionFragment)
    | { __typename: 'Component'; id: string }
}

export type HookPropFragment = { data: string; id: string }

export type HookFragment = {
  id: string
  type: AtomType
  config: HookPropFragment
  element: { id: string; name: string }
}

export type PagePreviewFragment = {
  id: string
  kind: PageKind
  name: string
  urlPattern: string
  app: { id: string }
  rootElement: { id: string }
  elements: Array<{ id: string }>
  store: { id: string }
}

export type PageFragment = {
  id: string
  kind: PageKind
  name: string
  urlPattern: string
  app: { id: string }
  elements: Array<ElementFragment>
  pageContentContainer?: { id: string } | null
  redirect?: { id: string } | null
  rootElement: { id: string }
  store: StoreFragment
}

export type PageDevelopmentFragment = {
  id: string
  kind: PageKind
  name: string
  urlPattern: string
  app: { id: string }
  elements: Array<ElementFragment>
  pageContentContainer?: { id: string } | null
  redirect?: { id: string } | null
  rootElement: { id: string }
  store: StoreFragment
}

export type PageProductionFragment = {
  id: string
  kind: PageKind
  name: string
  slug: string
  urlPattern: string
  app: { id: string }
  elements: Array<ElementProductionFragment>
  pageContentContainer?: { id: string } | null
  redirect?: { id: string } | null
  rootElement: { id: string }
  store: StoreFragment
}

export type PreferenceFragment = {
  id: string
  builderBreakpointType: BreakpointType
  builderWidth: number
  owner: { id: string }
}

export type PropFragment = { data: string; id: string }

export type RedirectFragment = {
  id: string
  targetType: RedirectTargetType
  targetUrl?: string | null
  authGuard: { id: string }
  source: { id: string }
  targetPage?: { id: string } | null
}

export type ResourceFragment = {
  id: string
  name: string
  type: ResourceType
  config: PropFragment
  owner: { id: string }
}

export type StoreFragment = {
  id: string
  name: string
  actions: Array<Action_ApiAction_Fragment | Action_CodeAction_Fragment>
  api: InterfaceTypeFragment
}

export type ProductionStoreFragment = {
  id: string
  name: string
  actions: Array<Action_ApiAction_Fragment | Action_CodeAction_Fragment>
}

export type TagFragment = {
  id: string
  name: string
  children: Array<{ id: string; name: string; owner: { id: string } }>
  descendants: Array<{ id: string; name: string }>
  owner: { id: string }
  parent?: { id: string } | null
}

export type TagPreviewFragment = {
  id: string
  name: string
  owner: { id: string }
}

export type ActionTypeFragment = BaseType_ActionType_Fragment

export type AppTypeFragment = BaseType_AppType_Fragment

export type ArrayTypeFragment = {
  itemType:
    | { id: string; kind: TypeKind; name: string }
    | { id: string; kind: TypeKind; name: string }
    | { id: string; kind: TypeKind; name: string }
    | { id: string; kind: TypeKind; name: string }
    | { id: string; kind: TypeKind; name: string }
    | { id: string; kind: TypeKind; name: string }
    | { id: string; kind: TypeKind; name: string }
    | { id: string; kind: TypeKind; name: string }
    | { id: string; kind: TypeKind; name: string }
    | { id: string; kind: TypeKind; name: string }
    | { id: string; kind: TypeKind; name: string }
    | { id: string; kind: TypeKind; name: string }
    | { id: string; kind: TypeKind; name: string }
    | { id: string; kind: TypeKind; name: string }
} & BaseType_ArrayType_Fragment

type BaseType_ActionType_Fragment = {
  __typename: 'ActionType'
  id: string
  kind: TypeKind
  name: string
  owner: { id: string }
}

type BaseType_AppType_Fragment = {
  __typename: 'AppType'
  id: string
  kind: TypeKind
  name: string
  owner: { id: string }
}

type BaseType_ArrayType_Fragment = {
  __typename: 'ArrayType'
  id: string
  kind: TypeKind
  name: string
  owner: { id: string }
}

type BaseType_CodeMirrorType_Fragment = {
  __typename: 'CodeMirrorType'
  id: string
  kind: TypeKind
  name: string
  owner: { id: string }
}

type BaseType_ElementType_Fragment = {
  __typename: 'ElementType'
  id: string
  kind: TypeKind
  name: string
  owner: { id: string }
}

type BaseType_EnumType_Fragment = {
  __typename: 'EnumType'
  id: string
  kind: TypeKind
  name: string
  owner: { id: string }
}

type BaseType_InterfaceType_Fragment = {
  __typename: 'InterfaceType'
  id: string
  kind: TypeKind
  name: string
  owner: { id: string }
}

type BaseType_LambdaType_Fragment = {
  __typename: 'LambdaType'
  id: string
  kind: TypeKind
  name: string
  owner: { id: string }
}

type BaseType_PageType_Fragment = {
  __typename: 'PageType'
  id: string
  kind: TypeKind
  name: string
  owner: { id: string }
}

type BaseType_PrimitiveType_Fragment = {
  __typename: 'PrimitiveType'
  id: string
  kind: TypeKind
  name: string
  owner: { id: string }
}

type BaseType_ReactNodeType_Fragment = {
  __typename: 'ReactNodeType'
  id: string
  kind: TypeKind
  name: string
  owner: { id: string }
}

type BaseType_RenderPropType_Fragment = {
  __typename: 'RenderPropType'
  id: string
  kind: TypeKind
  name: string
  owner: { id: string }
}

type BaseType_RichTextType_Fragment = {
  __typename: 'RichTextType'
  id: string
  kind: TypeKind
  name: string
  owner: { id: string }
}

type BaseType_UnionType_Fragment = {
  __typename: 'UnionType'
  id: string
  kind: TypeKind
  name: string
  owner: { id: string }
}

export type BaseTypeFragment =
  | BaseType_ActionType_Fragment
  | BaseType_AppType_Fragment
  | BaseType_ArrayType_Fragment
  | BaseType_CodeMirrorType_Fragment
  | BaseType_ElementType_Fragment
  | BaseType_EnumType_Fragment
  | BaseType_InterfaceType_Fragment
  | BaseType_LambdaType_Fragment
  | BaseType_PageType_Fragment
  | BaseType_PrimitiveType_Fragment
  | BaseType_ReactNodeType_Fragment
  | BaseType_RenderPropType_Fragment
  | BaseType_RichTextType_Fragment
  | BaseType_UnionType_Fragment

export type CodeMirrorTypeFragment = {
  language: CodeMirrorLanguage
} & BaseType_CodeMirrorType_Fragment

export type ElementTypeFragment = {
  elementKind: ElementTypeKind
} & BaseType_ElementType_Fragment

export type EnumTypeValueFragment = { id: string; key: string; value: string }

export type EnumTypeFragment = {
  allowedValues: Array<EnumTypeValueFragment>
} & BaseType_EnumType_Fragment

export type FieldFragment = {
  defaultValues?: string | null
  description?: string | null
  id: string
  key: string
  name?: string | null
  validationRules?: string | null
  api: { id: string }
  fieldType:
    | { __typename: 'ActionType'; id: string; kind: TypeKind; name: string }
    | { __typename: 'AppType'; id: string; kind: TypeKind; name: string }
    | { __typename: 'ArrayType'; id: string; kind: TypeKind; name: string }
    | { __typename: 'CodeMirrorType'; id: string; kind: TypeKind; name: string }
    | { __typename: 'ElementType'; id: string; kind: TypeKind; name: string }
    | { __typename: 'EnumType'; id: string; kind: TypeKind; name: string }
    | { __typename: 'InterfaceType'; id: string; kind: TypeKind; name: string }
    | { __typename: 'LambdaType'; id: string; kind: TypeKind; name: string }
    | { __typename: 'PageType'; id: string; kind: TypeKind; name: string }
    | { __typename: 'PrimitiveType'; id: string; kind: TypeKind; name: string }
    | { __typename: 'ReactNodeType'; id: string; kind: TypeKind; name: string }
    | { __typename: 'RenderPropType'; id: string; kind: TypeKind; name: string }
    | { __typename: 'RichTextType'; id: string; kind: TypeKind; name: string }
    | { __typename: 'UnionType'; id: string; kind: TypeKind; name: string }
  nextSibling?: { id: string } | null
  prevSibling?: { id: string } | null
}

export type InterfaceTypeFragment = {
  fields: Array<FieldFragment>
} & BaseType_InterfaceType_Fragment

export type LambdaTypeFragment = BaseType_LambdaType_Fragment

export type PageTypeFragment = BaseType_PageType_Fragment

export type PrimitiveTypeFragment = {
  primitiveKind: PrimitiveTypeKind
} & BaseType_PrimitiveType_Fragment

export type ReactNodeTypeFragment = BaseType_ReactNodeType_Fragment

export type RenderPropTypeFragment = BaseType_RenderPropType_Fragment

export type RichTextTypeFragment = BaseType_RichTextType_Fragment

type Type_ActionType_Fragment = ActionTypeFragment

type Type_AppType_Fragment = AppTypeFragment

type Type_ArrayType_Fragment = ArrayTypeFragment

type Type_CodeMirrorType_Fragment = CodeMirrorTypeFragment

type Type_ElementType_Fragment = ElementTypeFragment

type Type_EnumType_Fragment = EnumTypeFragment

type Type_InterfaceType_Fragment = InterfaceTypeFragment

type Type_LambdaType_Fragment = LambdaTypeFragment

type Type_PageType_Fragment = PageTypeFragment

type Type_PrimitiveType_Fragment = PrimitiveTypeFragment

type Type_ReactNodeType_Fragment = ReactNodeTypeFragment

type Type_RenderPropType_Fragment = RenderPropTypeFragment

type Type_RichTextType_Fragment = RichTextTypeFragment

type Type_UnionType_Fragment = UnionTypeFragment

export type TypeFragment =
  | Type_ActionType_Fragment
  | Type_AppType_Fragment
  | Type_ArrayType_Fragment
  | Type_CodeMirrorType_Fragment
  | Type_ElementType_Fragment
  | Type_EnumType_Fragment
  | Type_InterfaceType_Fragment
  | Type_LambdaType_Fragment
  | Type_PageType_Fragment
  | Type_PrimitiveType_Fragment
  | Type_ReactNodeType_Fragment
  | Type_RenderPropType_Fragment
  | Type_RichTextType_Fragment
  | Type_UnionType_Fragment

export type UnionTypeFragment = {
  typesOfUnionType: Array<
    | BaseType_ActionType_Fragment
    | BaseType_AppType_Fragment
    | BaseType_ArrayType_Fragment
    | BaseType_CodeMirrorType_Fragment
    | BaseType_ElementType_Fragment
    | BaseType_EnumType_Fragment
    | BaseType_InterfaceType_Fragment
    | BaseType_LambdaType_Fragment
    | BaseType_PageType_Fragment
    | BaseType_PrimitiveType_Fragment
    | BaseType_ReactNodeType_Fragment
    | BaseType_RenderPropType_Fragment
    | BaseType_RichTextType_Fragment
    | BaseType_UnionType_Fragment
  >
} & BaseType_UnionType_Fragment

export type OwnerFragment = { id: string }

export type UserFragment = {
  auth0Id: string
  email: string
  id: string
  roles?: Array<Role> | null
  username: string
  apps: Array<{ id: string }>
  preferences?: PreferenceFragment | null
}

export type GetAppBuilderQueryVariables = Exact<{
  appId: Scalars['ID']['input']
  pageIds?: InputMaybe<Array<Scalars['ID']['input']> | Scalars['ID']['input']>
}>

export type GetAppBuilderQuery = {
  actionTypes: Array<ActionTypeFragment>
  apps: Array<AppBuilderFragment>
  atoms: Array<AtomBuilderFragment>
  authGuards: Array<AuthGuardFragment>
  codeMirrorTypes: Array<CodeMirrorTypeFragment>
  components: Array<ComponentBuilderFragment>
  primitiveTypes: Array<PrimitiveTypeFragment>
  reactNodeTypes: Array<ReactNodeTypeFragment>
  redirects: Array<RedirectFragment>
  renderPropTypes: Array<RenderPropTypeFragment>
  resources: Array<ResourceFragment>
  richTextTypes: Array<RichTextTypeFragment>
}

export type GetSelectAtomOptionsQueryVariables = Exact<{ [key: string]: never }>

export type GetSelectAtomOptionsQuery = {
  atoms: Array<{
    __typename: 'Atom'
    id: string
    name: string
    type: AtomType
    requiredParents: Array<{ id: string; type: AtomType }>
  }>
}

export type GetAuthGuardsQueryVariables = Exact<{
  options?: InputMaybe<AuthGuardOptions>
  where?: InputMaybe<AuthGuardWhere>
}>

export type GetAuthGuardsQuery = {
  aggregate: { count: number }
  items: Array<AuthGuardFragment>
}

export type CreateAuthGuardsMutationVariables = Exact<{
  input: Array<AuthGuardCreateInput> | AuthGuardCreateInput
}>

export type CreateAuthGuardsMutation = {
  createAuthGuards: { authGuards: Array<{ id: string }> }
}

export type UpdateAuthGuardMutationVariables = Exact<{
  where?: InputMaybe<AuthGuardWhere>
  update?: InputMaybe<AuthGuardUpdateInput>
}>

export type UpdateAuthGuardMutation = {
  updateAuthGuards: { authGuards: Array<{ id: string }> }
}

export type DeleteAuthGuardsMutationVariables = Exact<{
  where?: InputMaybe<AuthGuardWhere>
  delete?: InputMaybe<AuthGuardDeleteInput>
}>

export type DeleteAuthGuardsMutation = {
  deleteAuthGuards: { nodesDeleted: number }
}

export type GetComponentBuilderQueryVariables = Exact<{ [key: string]: never }>

export type GetComponentBuilderQuery = {
  actionTypes: Array<ActionTypeFragment>
  atoms: Array<AtomBuilderFragment>
  codeMirrorTypes: Array<CodeMirrorTypeFragment>
  components: Array<ComponentBuilderFragment>
  primitiveTypes: Array<PrimitiveTypeFragment>
  reactNodeTypes: Array<ReactNodeTypeFragment>
  renderPropTypes: Array<RenderPropTypeFragment>
  resources: Array<ResourceFragment>
  richTextTypes: Array<RichTextTypeFragment>
}

export type CreateComponentsMutationVariables = Exact<{
  input: Array<ComponentCreateInput> | ComponentCreateInput
}>

export type CreateComponentsMutation = {
  createComponents: { components: Array<{ id: string; store: { id: string } }> }
}

export type DeleteComponentsMutationVariables = Exact<{
  where?: InputMaybe<ComponentWhere>
  delete?: InputMaybe<ComponentDeleteInput>
}>

export type DeleteComponentsMutation = {
  deleteComponents: { nodesDeleted: number }
}

export type UpdateComponentsMutationVariables = Exact<{
  where?: InputMaybe<ComponentWhere>
  update?: InputMaybe<ComponentUpdateInput>
}>

export type UpdateComponentsMutation = {
  updateComponents: { components: Array<{ id: string }> }
}

export type ComponentListQueryVariables = Exact<{
  options?: InputMaybe<ComponentOptions>
  where?: InputMaybe<ComponentWhere>
}>

export type ComponentListQuery = {
  aggregate: { count: number }
  items: Array<ComponentFragment>
}

export type DomainListQueryVariables = Exact<{
  options?: InputMaybe<DomainOptions>
  where?: InputMaybe<DomainWhere>
}>

export type DomainListQuery = {
  aggregate: { count: number }
  items: Array<DomainFragment>
}

export type CreateDomainsMutationVariables = Exact<{
  input: Array<DomainCreateInput> | DomainCreateInput
}>

export type CreateDomainsMutation = {
  createDomains: { domains: Array<{ id: string }> }
}

export type UpdateDomainsMutationVariables = Exact<{
  where: DomainWhere
  update: DomainUpdateInput
}>

export type UpdateDomainsMutation = {
  updateDomains: { domains: Array<{ id: string }> }
}

export type DeleteDomainsMutationVariables = Exact<{
  where: DomainWhere
}>

export type DeleteDomainsMutation = { deleteDomains: { nodesDeleted: number } }

export type CreateElementsMutationVariables = Exact<{
  input: Array<ElementCreateInput> | ElementCreateInput
}>

export type CreateElementsMutation = {
  createElements: { elements: Array<{ id: string }> }
}

export type DeleteElementsMutationVariables = Exact<{
  where: ElementWhere
  delete?: InputMaybe<ElementDeleteInput>
}>

export type DeleteElementsMutation = {
  deleteElements: { nodesDeleted: number }
}

export type UpdateElementsMutationVariables = Exact<{
  where?: InputMaybe<ElementWhere>
  update?: InputMaybe<ElementUpdateInput>
}>

export type UpdateElementsMutation = {
  updateElements: { elements: Array<{ id: string }> }
}

export type ElementListQueryVariables = Exact<{
  options?: InputMaybe<ElementOptions>
  where?: InputMaybe<ElementWhere>
}>

export type ElementListQuery = {
  aggregate: { count: number }
  items: Array<ElementFragment>
}

export type CreateHooksMutationVariables = Exact<{
  input: Array<HookCreateInput> | HookCreateInput
}>

export type CreateHooksMutation = {
  createHooks: { hooks: Array<HookFragment> }
}

export type DeleteHooksMutationVariables = Exact<{
  where: HookWhere
}>

export type DeleteHooksMutation = { deleteHooks: { nodesDeleted: number } }

export type CreatePagesMutationVariables = Exact<{
  input: Array<PageCreateInput> | PageCreateInput
}>

export type CreatePagesMutation = {
  createPages: { pages: Array<{ id: string }> }
}

export type DeletePagesMutationVariables = Exact<{
  where?: InputMaybe<PageWhere>
  delete?: InputMaybe<PageDeleteInput>
}>

export type DeletePagesMutation = { deletePages: { nodesDeleted: number } }

export type UpdatePagesMutationVariables = Exact<{
  where?: InputMaybe<PageWhere>
  update?: InputMaybe<PageUpdateInput>
}>

export type UpdatePagesMutation = {
  updatePages: { pages: Array<{ id: string }> }
}

export type PageListQueryVariables = Exact<{
  options?: InputMaybe<PageOptions>
  where?: InputMaybe<PageWhere>
}>

export type PageListQuery = {
  aggregate: { count: number }
  items: Array<PageFragment>
}

export type GetRenderedPageQueryVariables = Exact<{
  pageId: Scalars['ID']['input']
}>

export type GetRenderedPageQuery = { pages: Array<PageDevelopmentFragment> }

export type CreatePreferencesMutationVariables = Exact<{
  input: Array<PreferenceCreateInput> | PreferenceCreateInput
}>

export type CreatePreferencesMutation = {
  createPreferences: {
    info: { nodesCreated: number; relationshipsCreated: number }
    preferences: Array<{ id: string }>
  }
}

export type DeletePreferencesMutationVariables = Exact<{
  where?: InputMaybe<PreferenceWhere>
  delete?: InputMaybe<PreferenceDeleteInput>
}>

export type DeletePreferencesMutation = {
  deletePreferences: { nodesDeleted: number }
}

export type GetPreferencesQueryVariables = Exact<{
  where?: InputMaybe<PreferenceWhere>
  options?: InputMaybe<PreferenceOptions>
}>

export type GetPreferencesQuery = {
  aggregate: { count: number }
  items: Array<PreferenceFragment>
}

export type UpdatePreferencesMutationVariables = Exact<{
  where?: InputMaybe<PreferenceWhere>
  update?: InputMaybe<PreferenceUpdateInput>
}>

export type UpdatePreferencesMutation = {
  updatePreferences: { preferences: Array<{ id: string }> }
}

export type CreatePropsMutationVariables = Exact<{
  input: Array<PropCreateInput> | PropCreateInput
}>

export type CreatePropsMutation = {
  createProps: { props: Array<{ id: string }> }
}

export type UpdatePropsMutationVariables = Exact<{
  where?: InputMaybe<PropWhere>
  update?: InputMaybe<PropUpdateInput>
}>

export type UpdatePropsMutation = {
  updateProps: { props: Array<{ id: string }> }
}

export type DeletePropsMutationVariables = Exact<{
  where: PropWhere
}>

export type DeletePropsMutation = { deleteProps: { nodesDeleted: number } }

export type GetPropsQueryVariables = Exact<{
  options?: InputMaybe<PropOptions>
  where?: InputMaybe<PropWhere>
}>

export type GetPropsQuery = {
  aggregate: { count: number }
  items: Array<PropFragment>
}

export type CreateRedirectsMutationVariables = Exact<{
  input: Array<RedirectCreateInput> | RedirectCreateInput
}>

export type CreateRedirectsMutation = {
  createRedirects: { redirects: Array<{ id: string }> }
}

export type DeleteRedirectsMutationVariables = Exact<{
  where?: InputMaybe<RedirectWhere>
  delete?: InputMaybe<RedirectDeleteInput>
}>

export type DeleteRedirectsMutation = {
  deleteRedirects: { nodesDeleted: number }
}

export type UpdateRedirectsMutationVariables = Exact<{
  where?: InputMaybe<RedirectWhere>
  update?: InputMaybe<RedirectUpdateInput>
}>

export type UpdateRedirectsMutation = {
  updateRedirects: { redirects: Array<{ id: string }> }
}

export type GetRedirectsQueryVariables = Exact<{
  options?: InputMaybe<RedirectOptions>
  where?: InputMaybe<RedirectWhere>
}>

export type GetRedirectsQuery = {
  aggregate: { count: number }
  items: Array<RedirectFragment>
}

export type ResourceListQueryVariables = Exact<{
  options?: InputMaybe<ResourceOptions>
  where?: InputMaybe<ResourceWhere>
}>

export type ResourceListQuery = {
  aggregate: { count: number }
  items: Array<ResourceFragment>
}

export type CreateResourcesMutationVariables = Exact<{
  input: Array<ResourceCreateInput> | ResourceCreateInput
}>

export type CreateResourcesMutation = {
  createResources: { resources: Array<{ id: string }> }
}

export type UpdateResourceMutationVariables = Exact<{
  where?: InputMaybe<ResourceWhere>
  update?: InputMaybe<ResourceUpdateInput>
}>

export type UpdateResourceMutation = {
  updateResources: { resources: Array<{ id: string }> }
}

export type DeleteResourcesMutationVariables = Exact<{
  where?: InputMaybe<ResourceWhere>
  delete?: InputMaybe<ResourceDeleteInput>
}>

export type DeleteResourcesMutation = {
  deleteResources: { nodesDeleted: number }
}

export type CreateCodeActionsMutationVariables = Exact<{
  input: Array<CodeActionCreateInput> | CodeActionCreateInput
}>

export type CreateCodeActionsMutation = {
  createCodeActions: { codeActions: Array<{ id: string }> }
}

export type CreateApiActionsMutationVariables = Exact<{
  input: Array<ApiActionCreateInput> | ApiActionCreateInput
}>

export type CreateApiActionsMutation = {
  createApiActions: { apiActions: Array<{ id: string }> }
}

export type DeleteCodeActionsMutationVariables = Exact<{
  where: CodeActionWhere
  delete?: InputMaybe<CodeActionDeleteInput>
}>

export type DeleteCodeActionsMutation = {
  deleteCodeActions: { nodesDeleted: number; relationshipsDeleted: number }
}

export type DeleteApiActionsMutationVariables = Exact<{
  where: ApiActionWhere
  delete?: InputMaybe<ApiActionDeleteInput>
}>

export type DeleteApiActionsMutation = {
  deleteApiActions: { nodesDeleted: number; relationshipsDeleted: number }
}

export type GetActionsQueryVariables = Exact<{
  codeActionWhere?: InputMaybe<CodeActionWhere>
  apiActionWhere?: InputMaybe<ApiActionWhere>
}>

export type GetActionsQuery = {
  apiActions: Array<Action_ApiAction_Fragment>
  codeActions: Array<Action_CodeAction_Fragment>
}

export type CreateStoresMutationVariables = Exact<{
  input: Array<StoreCreateInput> | StoreCreateInput
}>

export type CreateStoresMutation = {
  createStores: {
    info: { nodesCreated: number; relationshipsCreated: number }
    stores: Array<{ id: string }>
  }
}

export type DeleteStoresMutationVariables = Exact<{
  where?: InputMaybe<StoreWhere>
  delete?: InputMaybe<StoreDeleteInput>
}>

export type DeleteStoresMutation = { deleteStores: { nodesDeleted: number } }

export type GetStoresQueryVariables = Exact<{
  where?: InputMaybe<StoreWhere>
  options?: InputMaybe<StoreOptions>
}>

export type GetStoresQuery = {
  aggregate: { count: number }
  items: Array<StoreFragment>
}

export type UpdateStoresMutationVariables = Exact<{
  where?: InputMaybe<StoreWhere>
  update?: InputMaybe<StoreUpdateInput>
}>

export type UpdateStoresMutation = {
  updateStores: { stores: Array<{ id: string }> }
}

export type UpdateCodeActionsMutationVariables = Exact<{
  update?: InputMaybe<CodeActionUpdateInput>
  where?: InputMaybe<CodeActionWhere>
}>

export type UpdateCodeActionsMutation = {
  updateCodeActions: { codeActions: Array<{ id: string }> }
}

export type UpdateApiActionsMutationVariables = Exact<{
  update?: InputMaybe<ApiActionUpdateInput>
  where?: InputMaybe<ApiActionWhere>
}>

export type UpdateApiActionsMutation = {
  updateApiActions: { apiActions: Array<{ id: string }> }
}

export type CreateTagsMutationVariables = Exact<{
  input: Array<TagCreateInput> | TagCreateInput
}>

export type CreateTagsMutation = { createTags: { tags: Array<{ id: string }> } }

export type UpdateTagsMutationVariables = Exact<{
  where: TagWhere
  update: TagUpdateInput
}>

export type UpdateTagsMutation = { updateTags: { tags: Array<{ id: string }> } }

export type DeleteTagsMutationVariables = Exact<{
  where: TagWhere
}>

export type DeleteTagsMutation = { deleteTags: { nodesDeleted: number } }

export type GetTagsQueryVariables = Exact<{
  options?: InputMaybe<TagOptions>
  where?: InputMaybe<TagWhere>
}>

export type GetTagsQuery = {
  aggregate: { count: number }
  items: Array<TagFragment>
}

export type CreatePrimitiveTypesMutationVariables = Exact<{
  input: Array<PrimitiveTypeCreateInput> | PrimitiveTypeCreateInput
}>

export type CreatePrimitiveTypesMutation = {
  types: { types: Array<{ id: string }> }
}

export type CreateArrayTypesMutationVariables = Exact<{
  input: Array<ArrayTypeCreateInput> | ArrayTypeCreateInput
}>

export type CreateArrayTypesMutation = {
  types: { types: Array<{ id: string }> }
}

export type CreateUnionTypesMutationVariables = Exact<{
  input: Array<UnionTypeCreateInput> | UnionTypeCreateInput
}>

export type CreateUnionTypesMutation = {
  types: { types: Array<{ id: string }> }
}

export type CreateInterfaceTypesMutationVariables = Exact<{
  input: Array<InterfaceTypeCreateInput> | InterfaceTypeCreateInput
}>

export type CreateInterfaceTypesMutation = {
  types: { types: Array<{ id: string }> }
}

export type CreateElementTypesMutationVariables = Exact<{
  input: Array<ElementTypeCreateInput> | ElementTypeCreateInput
}>

export type CreateElementTypesMutation = {
  types: { types: Array<{ id: string }> }
}

export type CreateRenderPropTypesMutationVariables = Exact<{
  input: Array<RenderPropTypeCreateInput> | RenderPropTypeCreateInput
}>

export type CreateRenderPropTypesMutation = {
  types: { types: Array<{ id: string }> }
}

export type CreateReactNodeTypesMutationVariables = Exact<{
  input: Array<ReactNodeTypeCreateInput> | ReactNodeTypeCreateInput
}>

export type CreateReactNodeTypesMutation = {
  types: { types: Array<{ id: string }> }
}

export type CreateEnumTypesMutationVariables = Exact<{
  input: Array<EnumTypeCreateInput> | EnumTypeCreateInput
}>

export type CreateEnumTypesMutation = {
  types: { types: Array<{ id: string }> }
}

export type CreateLambdaTypesMutationVariables = Exact<{
  input: Array<LambdaTypeCreateInput> | LambdaTypeCreateInput
}>

export type CreateLambdaTypesMutation = {
  types: { types: Array<{ id: string }> }
}

export type CreatePageTypesMutationVariables = Exact<{
  input: Array<PageTypeCreateInput> | PageTypeCreateInput
}>

export type CreatePageTypesMutation = {
  types: { types: Array<{ id: string }> }
}

export type CreateAppTypesMutationVariables = Exact<{
  input: Array<AppTypeCreateInput> | AppTypeCreateInput
}>

export type CreateAppTypesMutation = { types: { types: Array<{ id: string }> } }

export type CreateRichTextTypesMutationVariables = Exact<{
  input: Array<RichTextTypeCreateInput> | RichTextTypeCreateInput
}>

export type CreateRichTextTypesMutation = {
  types: { types: Array<{ id: string }> }
}

export type CreateActionTypesMutationVariables = Exact<{
  input: Array<ActionTypeCreateInput> | ActionTypeCreateInput
}>

export type CreateActionTypesMutation = {
  types: { types: Array<{ id: string }> }
}

export type CreateCodeMirrorTypesMutationVariables = Exact<{
  input: Array<CodeMirrorTypeCreateInput> | CodeMirrorTypeCreateInput
}>

export type CreateCodeMirrorTypesMutation = {
  types: { types: Array<{ id: string }> }
}

export type DeletePrimitiveTypesMutationVariables = Exact<{
  delete?: InputMaybe<PrimitiveTypeDeleteInput>
  where?: InputMaybe<PrimitiveTypeWhere>
}>

export type DeletePrimitiveTypesMutation = {
  deletePrimitiveTypes: { nodesDeleted: number; relationshipsDeleted: number }
}

export type DeleteArrayTypesMutationVariables = Exact<{
  delete?: InputMaybe<ArrayTypeDeleteInput>
  where?: InputMaybe<ArrayTypeWhere>
}>

export type DeleteArrayTypesMutation = {
  deleteArrayTypes: { nodesDeleted: number; relationshipsDeleted: number }
}

export type DeleteReactNodeTypesMutationVariables = Exact<{
  delete?: InputMaybe<ReactNodeTypeDeleteInput>
  where?: InputMaybe<ReactNodeTypeWhere>
}>

export type DeleteReactNodeTypesMutation = {
  deleteReactNodeTypes: { nodesDeleted: number; relationshipsDeleted: number }
}

export type DeleteUnionTypesMutationVariables = Exact<{
  delete?: InputMaybe<UnionTypeDeleteInput>
  where?: InputMaybe<UnionTypeWhere>
}>

export type DeleteUnionTypesMutation = {
  deleteUnionTypes: { nodesDeleted: number; relationshipsDeleted: number }
}

export type DeleteInterfaceTypesMutationVariables = Exact<{
  delete?: InputMaybe<InterfaceTypeDeleteInput>
  where?: InputMaybe<InterfaceTypeWhere>
}>

export type DeleteInterfaceTypesMutation = {
  deleteInterfaceTypes: { nodesDeleted: number; relationshipsDeleted: number }
}

export type DeleteElementTypesMutationVariables = Exact<{
  delete?: InputMaybe<ElementTypeDeleteInput>
  where?: InputMaybe<ElementTypeWhere>
}>

export type DeleteElementTypesMutation = {
  deleteElementTypes: { nodesDeleted: number; relationshipsDeleted: number }
}

export type DeleteRenderPropTypesMutationVariables = Exact<{
  delete?: InputMaybe<RenderPropTypeDeleteInput>
  where?: InputMaybe<RenderPropTypeWhere>
}>

export type DeleteRenderPropTypesMutation = {
  deleteRenderPropTypes: { nodesDeleted: number; relationshipsDeleted: number }
}

export type DeleteRichTextTypesMutationVariables = Exact<{
  delete?: InputMaybe<RichTextTypeDeleteInput>
  where?: InputMaybe<RichTextTypeWhere>
}>

export type DeleteRichTextTypesMutation = {
  deleteRichTextTypes: { nodesDeleted: number; relationshipsDeleted: number }
}

export type DeleteEnumTypesMutationVariables = Exact<{
  delete?: InputMaybe<EnumTypeDeleteInput>
  where?: InputMaybe<EnumTypeWhere>
}>

export type DeleteEnumTypesMutation = {
  deleteEnumTypes: { nodesDeleted: number; relationshipsDeleted: number }
  deleteEnumTypeValues: { nodesDeleted: number }
}

export type DeleteLambdaTypesMutationVariables = Exact<{
  delete?: InputMaybe<LambdaTypeDeleteInput>
  where?: InputMaybe<LambdaTypeWhere>
}>

export type DeleteLambdaTypesMutation = {
  deleteLambdaTypes: { nodesDeleted: number; relationshipsDeleted: number }
}

export type DeletePageTypesMutationVariables = Exact<{
  delete?: InputMaybe<PageTypeDeleteInput>
  where?: InputMaybe<PageTypeWhere>
}>

export type DeletePageTypesMutation = {
  deletePageTypes: { nodesDeleted: number; relationshipsDeleted: number }
}

export type DeleteAppTypesMutationVariables = Exact<{
  delete?: InputMaybe<AppTypeDeleteInput>
  where?: InputMaybe<AppTypeWhere>
}>

export type DeleteAppTypesMutation = {
  deleteAppTypes: { nodesDeleted: number; relationshipsDeleted: number }
}

export type DeleteActionTypesMutationVariables = Exact<{
  delete?: InputMaybe<ActionTypeDeleteInput>
  where?: InputMaybe<ActionTypeWhere>
}>

export type DeleteActionTypesMutation = {
  deleteActionTypes: { nodesDeleted: number; relationshipsDeleted: number }
}

export type DeleteCodeMirrorTypesMutationVariables = Exact<{
  delete?: InputMaybe<CodeMirrorTypeDeleteInput>
  where?: InputMaybe<CodeMirrorTypeWhere>
}>

export type DeleteCodeMirrorTypesMutation = {
  deleteCodeMirrorTypes: { nodesDeleted: number; relationshipsDeleted: number }
}

export type GetBaseTypesQueryVariables = Exact<{
  where?: InputMaybe<IBaseTypeWhere>
  options?: InputMaybe<IBaseTypeOptions>
}>

export type GetBaseTypesQuery = {
  iBaseTypes: Array<
    | ({
        ownerConnection: { totalCount: number }
      } & BaseType_ActionType_Fragment)
    | ({ ownerConnection: { totalCount: number } } & BaseType_AppType_Fragment)
    | ({
        ownerConnection: { totalCount: number }
      } & BaseType_ArrayType_Fragment)
    | ({
        ownerConnection: { totalCount: number }
      } & BaseType_CodeMirrorType_Fragment)
    | ({
        ownerConnection: { totalCount: number }
      } & BaseType_ElementType_Fragment)
    | ({ ownerConnection: { totalCount: number } } & BaseType_EnumType_Fragment)
    | ({
        ownerConnection: { totalCount: number }
      } & BaseType_InterfaceType_Fragment)
    | ({
        ownerConnection: { totalCount: number }
      } & BaseType_LambdaType_Fragment)
    | ({ ownerConnection: { totalCount: number } } & BaseType_PageType_Fragment)
    | ({
        ownerConnection: { totalCount: number }
      } & BaseType_PrimitiveType_Fragment)
    | ({
        ownerConnection: { totalCount: number }
      } & BaseType_ReactNodeType_Fragment)
    | ({
        ownerConnection: { totalCount: number }
      } & BaseType_RenderPropType_Fragment)
    | ({
        ownerConnection: { totalCount: number }
      } & BaseType_RichTextType_Fragment)
    | ({
        ownerConnection: { totalCount: number }
      } & BaseType_UnionType_Fragment)
  >
}

export type GetTypesQueryVariables = Exact<{
  ids?: InputMaybe<Array<Scalars['ID']['input']> | Scalars['ID']['input']>
}>

export type GetTypesQuery = {
  actionTypes: Array<Type_ActionType_Fragment>
  appTypes: Array<Type_AppType_Fragment>
  arrayTypes: Array<Type_ArrayType_Fragment>
  codeMirrorTypes: Array<Type_CodeMirrorType_Fragment>
  elementTypes: Array<Type_ElementType_Fragment>
  enumTypes: Array<Type_EnumType_Fragment>
  interfaceTypes: Array<Type_InterfaceType_Fragment>
  lambdaTypes: Array<Type_LambdaType_Fragment>
  pageTypes: Array<Type_PageType_Fragment>
  primitiveTypes: Array<Type_PrimitiveType_Fragment>
  reactNodeTypes: Array<Type_ReactNodeType_Fragment>
  renderPropTypes: Array<Type_RenderPropType_Fragment>
  richTextTypes: Array<Type_RichTextType_Fragment>
  unionTypes: Array<Type_UnionType_Fragment>
}

export type GetDescendantsQueryVariables = Exact<{
  ids?: InputMaybe<Array<Scalars['ID']['input']> | Scalars['ID']['input']>
}>

export type GetDescendantsQuery = {
  arrayTypes: Array<{ descendantTypesIds: Array<string> }>
  interfaceTypes: Array<{ descendantTypesIds: Array<string> }>
  unionTypes: Array<{ descendantTypesIds: Array<string> }>
}

export type GetPrimitiveTypesQueryVariables = Exact<{
  options?: InputMaybe<PrimitiveTypeOptions>
  where?: InputMaybe<PrimitiveTypeWhere>
}>

export type GetPrimitiveTypesQuery = {
  types: Array<Type_PrimitiveType_Fragment>
}

export type GetArrayTypesQueryVariables = Exact<{
  options?: InputMaybe<ArrayTypeOptions>
  where?: InputMaybe<ArrayTypeWhere>
}>

export type GetArrayTypesQuery = { types: Array<Type_ArrayType_Fragment> }

export type GetUnionTypesQueryVariables = Exact<{
  options?: InputMaybe<UnionTypeOptions>
  where?: InputMaybe<UnionTypeWhere>
}>

export type GetUnionTypesQuery = { types: Array<Type_UnionType_Fragment> }

export type GetInterfaceTypesQueryVariables = Exact<{
  options?: InputMaybe<InterfaceTypeOptions>
  where?: InputMaybe<InterfaceTypeWhere>
}>

export type GetInterfaceTypesQuery = {
  types: Array<Type_InterfaceType_Fragment>
}

export type GetElementTypesQueryVariables = Exact<{
  options?: InputMaybe<ElementTypeOptions>
  where?: InputMaybe<ElementTypeWhere>
}>

export type GetElementTypesQuery = { types: Array<Type_ElementType_Fragment> }

export type GetRenderPropTypesQueryVariables = Exact<{
  options?: InputMaybe<RenderPropTypeOptions>
  where?: InputMaybe<RenderPropTypeWhere>
}>

export type GetRenderPropTypesQuery = {
  types: Array<Type_RenderPropType_Fragment>
}

export type GetReactNodeTypesQueryVariables = Exact<{
  options?: InputMaybe<ReactNodeTypeOptions>
  where?: InputMaybe<ReactNodeTypeWhere>
}>

export type GetReactNodeTypesQuery = { types: Array<ReactNodeTypeFragment> }

export type GetRichTextTypesQueryVariables = Exact<{
  options?: InputMaybe<RichTextTypeOptions>
  where?: InputMaybe<RichTextTypeWhere>
}>

export type GetRichTextTypesQuery = { types: Array<RichTextTypeFragment> }

export type GetEnumTypesQueryVariables = Exact<{
  options?: InputMaybe<EnumTypeOptions>
  where?: InputMaybe<EnumTypeWhere>
}>

export type GetEnumTypesQuery = { types: Array<Type_EnumType_Fragment> }

export type GetLambdaTypesQueryVariables = Exact<{
  options?: InputMaybe<LambdaTypeOptions>
  where?: InputMaybe<LambdaTypeWhere>
}>

export type GetLambdaTypesQuery = { types: Array<Type_LambdaType_Fragment> }

export type GetPageTypesQueryVariables = Exact<{
  options?: InputMaybe<PageTypeOptions>
  where?: InputMaybe<PageTypeWhere>
}>

export type GetPageTypesQuery = { types: Array<Type_PageType_Fragment> }

export type GetAppTypesQueryVariables = Exact<{
  options?: InputMaybe<AppTypeOptions>
  where?: InputMaybe<AppTypeWhere>
}>

export type GetAppTypesQuery = { types: Array<Type_AppType_Fragment> }

export type GetActionTypesQueryVariables = Exact<{
  options?: InputMaybe<ActionTypeOptions>
  where?: InputMaybe<ActionTypeWhere>
}>

export type GetActionTypesQuery = { types: Array<Type_ActionType_Fragment> }

export type GetCodeMirrorTypesQueryVariables = Exact<{
  options?: InputMaybe<CodeMirrorTypeOptions>
  where?: InputMaybe<CodeMirrorTypeWhere>
}>

export type GetCodeMirrorTypesQuery = {
  types: Array<Type_CodeMirrorType_Fragment>
}

export type InterfaceForm_GetAppsQueryVariables = Exact<{
  options?: InputMaybe<AppOptions>
  where?: InputMaybe<AppWhere>
}>

export type InterfaceForm_GetAppsQuery = {
  apps: Array<{ id: string; name: string }>
}

export type InterfaceForm_GetAtomsQueryVariables = Exact<{
  options?: InputMaybe<AtomOptions>
  where?: InputMaybe<AtomWhere>
}>

export type InterfaceForm_GetAtomsQuery = {
  atoms: Array<{ id: string; name: string; type: AtomType }>
}

export type InterfaceForm_GetActionsQueryVariables = Exact<{
  appId?: InputMaybe<Scalars['ID']['input']>
}>

export type InterfaceForm_GetActionsQuery = {
  apiActions: Array<{ id: string; name: string }>
  codeActions: Array<{ id: string; name: string }>
}

export type InterfaceForm_GetStoresQueryVariables = Exact<{
  options?: InputMaybe<StoreOptions>
  where?: InputMaybe<StoreWhere>
}>

export type InterfaceForm_GetStoresQuery = {
  stores: Array<{ id: string; name: string }>
}

export type InterfaceForm_GetResourceQueryVariables = Exact<{
  options?: InputMaybe<ResourceOptions>
  where?: InputMaybe<ResourceWhere>
}>

export type InterfaceForm_GetResourceQuery = {
  resources: Array<{ id: string; name: string }>
}

export type InterfaceForm_GetPagesQueryVariables = Exact<{
  options?: InputMaybe<PageOptions>
  where?: InputMaybe<PageWhere>
}>

export type InterfaceForm_GetPagesQuery = {
  pages: Array<{ id: string; name: string }>
}

export type IsTypeDescendantOfQueryVariables = Exact<{
  descendantTypeId: Scalars['ID']['input']
  parentTypeId: Scalars['ID']['input']
}>

export type IsTypeDescendantOfQuery = { isTypeDescendantOf?: boolean | null }

export type GetTypeReferencesQueryVariables = Exact<{
  typeId: Scalars['ID']['input']
}>

export type GetTypeReferencesQuery = {
  getTypeReferences?: Array<{ label: string; name: string }> | null
}

export type UpdatePrimitiveTypesMutationVariables = Exact<{
  update?: InputMaybe<PrimitiveTypeUpdateInput>
  where?: InputMaybe<PrimitiveTypeWhere>
}>

export type UpdatePrimitiveTypesMutation = {
  types: { types: Array<{ id: string }> }
}

export type UpdateArrayTypesMutationVariables = Exact<{
  update?: InputMaybe<ArrayTypeUpdateInput>
  where?: InputMaybe<ArrayTypeWhere>
}>

export type UpdateArrayTypesMutation = {
  types: { types: Array<{ id: string }> }
}

export type UpdateUnionTypesMutationVariables = Exact<{
  update?: InputMaybe<UnionTypeUpdateInput>
  where?: InputMaybe<UnionTypeWhere>
}>

export type UpdateUnionTypesMutation = {
  types: { types: Array<{ id: string }> }
}

export type UpdateInterfaceTypesMutationVariables = Exact<{
  update?: InputMaybe<InterfaceTypeUpdateInput>
  where?: InputMaybe<InterfaceTypeWhere>
}>

export type UpdateInterfaceTypesMutation = {
  types: { types: Array<{ id: string }> }
}

export type UpdateReactNodeTypesMutationVariables = Exact<{
  update?: InputMaybe<ReactNodeTypeUpdateInput>
  where?: InputMaybe<ReactNodeTypeWhere>
}>

export type UpdateReactNodeTypesMutation = {
  types: { types: Array<{ id: string }> }
}

export type UpdateElementTypesMutationVariables = Exact<{
  update?: InputMaybe<ElementTypeUpdateInput>
  where?: InputMaybe<ElementTypeWhere>
}>

export type UpdateElementTypesMutation = {
  types: { types: Array<{ id: string }> }
}

export type UpdateRenderPropTypesMutationVariables = Exact<{
  update?: InputMaybe<RenderPropTypeUpdateInput>
  where?: InputMaybe<RenderPropTypeWhere>
}>

export type UpdateRenderPropTypesMutation = {
  types: { types: Array<{ id: string }> }
}

export type UpdateEnumTypesMutationVariables = Exact<{
  update?: InputMaybe<EnumTypeUpdateInput>
  where?: InputMaybe<EnumTypeWhere>
}>

export type UpdateEnumTypesMutation = {
  types: { types: Array<{ id: string }> }
}

export type UpdateLambdaTypesMutationVariables = Exact<{
  update?: InputMaybe<LambdaTypeUpdateInput>
  where?: InputMaybe<LambdaTypeWhere>
}>

export type UpdateLambdaTypesMutation = {
  types: { types: Array<{ id: string }> }
}

export type UpdatePageTypesMutationVariables = Exact<{
  update?: InputMaybe<PageTypeUpdateInput>
  where?: InputMaybe<PageTypeWhere>
}>

export type UpdatePageTypesMutation = {
  types: { types: Array<{ id: string }> }
}

export type UpdateAppTypesMutationVariables = Exact<{
  update?: InputMaybe<AppTypeUpdateInput>
  where?: InputMaybe<AppTypeWhere>
}>

export type UpdateAppTypesMutation = { types: { types: Array<{ id: string }> } }

export type UpdateRichTextTypesMutationVariables = Exact<{
  update?: InputMaybe<RichTextTypeUpdateInput>
  where?: InputMaybe<RichTextTypeWhere>
}>

export type UpdateRichTextTypesMutation = {
  types: { types: Array<{ id: string }> }
}

export type UpdateActionTypesMutationVariables = Exact<{
  update?: InputMaybe<ActionTypeUpdateInput>
  where?: InputMaybe<ActionTypeWhere>
}>

export type UpdateActionTypesMutation = {
  types: { types: Array<{ id: string }> }
}

export type UpdateCodeMirrorTypesMutationVariables = Exact<{
  update?: InputMaybe<CodeMirrorTypeUpdateInput>
  where?: InputMaybe<CodeMirrorTypeWhere>
}>

export type UpdateCodeMirrorTypesMutation = {
  types: { types: Array<{ id: string }> }
}

export type GetUsersQueryVariables = Exact<{
  where?: InputMaybe<UserWhere>
}>

export type GetUsersQuery = {
  aggregate: { count: number }
  items: Array<UserFragment>
}

export type CreateUserMutationVariables = Exact<{
  input: Array<UserCreateInput> | UserCreateInput
}>

export type CreateUserMutation = {
  createUsers: { users: Array<{ email: string; id: string }> }
}

export type DeleteUsersMutationVariables = Exact<{
  where: UserWhere
}>

export type DeleteUsersMutation = { deleteUsers: { nodesDeleted: number } }

export type CreateAppsMutationVariables = Exact<{
  input: Array<AppCreateInput> | AppCreateInput
}>

export type CreateAppsMutation = { createApps: { apps: Array<{ id: string }> } }

export type UpdateAppsMutationVariables = Exact<{
  where: AppWhere
  update: AppUpdateInput
}>

export type UpdateAppsMutation = { updateApps: { apps: Array<{ id: string }> } }

export type DeleteAppsMutationVariables = Exact<{
  where: AppWhere
  delete?: InputMaybe<AppDeleteInput>
}>

export type DeleteAppsMutation = { deleteApps: { nodesDeleted: number } }

export type AppListPreviewQueryVariables = Exact<{
  options?: InputMaybe<AppOptions>
  where?: InputMaybe<AppWhere>
}>

export type AppListPreviewQuery = {
  aggregate: { count: number }
  items: Array<AppPreviewFragment>
}

export type AppListQueryVariables = Exact<{
  options?: InputMaybe<AppOptions>
  where?: InputMaybe<AppWhere>
}>

export type AppListQuery = {
  items: Array<AppFragment>
  aggregate: { count: number }
  atoms: Array<AtomBuilderFragment>
}

export type GetAppProductionQueryVariables = Exact<{
  domain: Scalars['String']['input']
  pageUrlPattern: Scalars['String']['input']
}>

export type GetAppProductionQuery = {
  apps: Array<AppProductionFragment>
  atoms: Array<AtomProductionFragment>
  resources: Array<ResourceFragment>
}

export type CreateAtomsMutationVariables = Exact<{
  input: Array<AtomCreateInput> | AtomCreateInput
}>

export type CreateAtomsMutation = {
  createAtoms: {
    atoms: Array<{ id: string }>
    info: { nodesCreated: number; relationshipsCreated: number }
  }
}

export type DeleteAtomsMutationVariables = Exact<{
  where: AtomWhere
  delete?: InputMaybe<AtomDeleteInput>
}>

export type DeleteAtomsMutation = {
  deleteAtoms: { nodesDeleted: number; relationshipsDeleted: number }
}

export type AtomListQueryVariables = Exact<{
  where?: InputMaybe<AtomWhere>
  options?: InputMaybe<AtomOptions>
}>

export type AtomListQuery = {
  aggregate: { count: number }
  items: Array<AtomFragment>
}

export type UpdateAtomsMutationVariables = Exact<{
  where?: InputMaybe<AtomWhere>
  update?: InputMaybe<AtomUpdateInput>
}>

export type UpdateAtomsMutation = {
  updateAtoms: { atoms: Array<{ id: string }> }
}

export type CreateFieldsMutationVariables = Exact<{
  input: Array<FieldCreateInput> | FieldCreateInput
}>

export type CreateFieldsMutation = {
  createFields: { fields: Array<{ id: string }> }
}

export type UpdateFieldsMutationVariables = Exact<{
  where: FieldWhere
  update: FieldUpdateInput
}>

export type UpdateFieldsMutation = {
  updateFields: { fields: Array<{ id: string }> }
}

export type DeleteFieldsMutationVariables = Exact<{
  where: FieldWhere
}>

export type DeleteFieldsMutation = { deleteFields: { nodesDeleted: number } }

export type GetFieldsQueryVariables = Exact<{
  where?: InputMaybe<FieldWhere>
  options?: InputMaybe<FieldOptions>
}>

export type GetFieldsQuery = {
  aggregate: { count: number }
  items: Array<FieldFragment>
}

export class TypedDocumentString<TResult, TVariables>
  extends String
  implements DocumentTypeDecoration<TResult, TVariables>
{
  __apiType?: DocumentTypeDecoration<TResult, TVariables>['__apiType']

  constructor(
    private value: string,
    public __meta__?: Record<string, any> | undefined,
  ) {
    super(value)
  }

  toString(): string & DocumentTypeDecoration<TResult, TVariables> {
    return this.value
  }
}
export const DomainFragmentDoc = new TypedDocumentString(
  `
    fragment Domain on Domain {
  app {
    id
  }
  domainConfig {
    misconfigured
  }
  id
  name
}
    `,
  { fragmentName: 'Domain' },
) as unknown as TypedDocumentString<DomainFragment, unknown>
export const OwnerFragmentDoc = new TypedDocumentString(
  `
    fragment Owner on User {
  id
}
    `,
  { fragmentName: 'Owner' },
) as unknown as TypedDocumentString<OwnerFragment, unknown>
export const PagePreviewFragmentDoc = new TypedDocumentString(
  `
    fragment PagePreview on Page {
  app {
    id
  }
  id
  kind
  name
  rootElement {
    id
  }
  elements {
    id
  }
  store {
    id
  }
  urlPattern
}
    `,
  { fragmentName: 'PagePreview' },
) as unknown as TypedDocumentString<PagePreviewFragment, unknown>
export const AppPreviewFragmentDoc = new TypedDocumentString(
  `
    fragment AppPreview on App {
  domains {
    ...Domain
  }
  id
  name
  owner {
    ...Owner
  }
  pages {
    ...PagePreview
  }
  slug
}
    fragment Domain on Domain {
  app {
    id
  }
  domainConfig {
    misconfigured
  }
  id
  name
}
fragment PagePreview on Page {
  app {
    id
  }
  id
  kind
  name
  rootElement {
    id
  }
  elements {
    id
  }
  store {
    id
  }
  urlPattern
}
fragment Owner on User {
  id
}`,
  { fragmentName: 'AppPreview' },
) as unknown as TypedDocumentString<AppPreviewFragment, unknown>
export const BaseTypeFragmentDoc = new TypedDocumentString(
  `
    fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}
    `,
  { fragmentName: 'BaseType' },
) as unknown as TypedDocumentString<BaseTypeFragment, unknown>
export const ActionTypeFragmentDoc = new TypedDocumentString(
  `
    fragment ActionType on ActionType {
  ...BaseType
}
    fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}`,
  { fragmentName: 'ActionType' },
) as unknown as TypedDocumentString<ActionTypeFragment, unknown>
export const AppTypeFragmentDoc = new TypedDocumentString(
  `
    fragment AppType on AppType {
  ...BaseType
}
    fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}`,
  { fragmentName: 'AppType' },
) as unknown as TypedDocumentString<AppTypeFragment, unknown>
export const ArrayTypeFragmentDoc = new TypedDocumentString(
  `
    fragment ArrayType on ArrayType {
  ...BaseType
  itemType {
    ... on IBaseType {
      id
      kind
      name
    }
  }
}
    fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}`,
  { fragmentName: 'ArrayType' },
) as unknown as TypedDocumentString<ArrayTypeFragment, unknown>
export const CodeMirrorTypeFragmentDoc = new TypedDocumentString(
  `
    fragment CodeMirrorType on CodeMirrorType {
  ...BaseType
  language
}
    fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}`,
  { fragmentName: 'CodeMirrorType' },
) as unknown as TypedDocumentString<CodeMirrorTypeFragment, unknown>
export const ElementTypeFragmentDoc = new TypedDocumentString(
  `
    fragment ElementType on ElementType {
  ...BaseType
  elementKind
}
    fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}`,
  { fragmentName: 'ElementType' },
) as unknown as TypedDocumentString<ElementTypeFragment, unknown>
export const EnumTypeValueFragmentDoc = new TypedDocumentString(
  `
    fragment EnumTypeValue on EnumTypeValue {
  id
  key
  value
}
    `,
  { fragmentName: 'EnumTypeValue' },
) as unknown as TypedDocumentString<EnumTypeValueFragment, unknown>
export const EnumTypeFragmentDoc = new TypedDocumentString(
  `
    fragment EnumType on EnumType {
  allowedValues {
    ...EnumTypeValue
  }
  ...BaseType
}
    fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}
fragment EnumTypeValue on EnumTypeValue {
  id
  key
  value
}`,
  { fragmentName: 'EnumType' },
) as unknown as TypedDocumentString<EnumTypeFragment, unknown>
export const FieldFragmentDoc = new TypedDocumentString(
  `
    fragment Field on Field {
  api {
    ... on InterfaceType {
      id
    }
  }
  defaultValues
  description
  fieldType {
    ... on IBaseType {
      __typename
      id
      kind
      name
    }
  }
  id
  key
  name
  nextSibling {
    id
  }
  prevSibling {
    id
  }
  validationRules
}
    `,
  { fragmentName: 'Field' },
) as unknown as TypedDocumentString<FieldFragment, unknown>
export const InterfaceTypeFragmentDoc = new TypedDocumentString(
  `
    fragment InterfaceType on InterfaceType {
  ...BaseType
  fields {
    ...Field
  }
}
    fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}
fragment Field on Field {
  api {
    ... on InterfaceType {
      id
    }
  }
  defaultValues
  description
  fieldType {
    ... on IBaseType {
      __typename
      id
      kind
      name
    }
  }
  id
  key
  name
  nextSibling {
    id
  }
  prevSibling {
    id
  }
  validationRules
}`,
  { fragmentName: 'InterfaceType' },
) as unknown as TypedDocumentString<InterfaceTypeFragment, unknown>
export const LambdaTypeFragmentDoc = new TypedDocumentString(
  `
    fragment LambdaType on LambdaType {
  ...BaseType
}
    fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}`,
  { fragmentName: 'LambdaType' },
) as unknown as TypedDocumentString<LambdaTypeFragment, unknown>
export const PageTypeFragmentDoc = new TypedDocumentString(
  `
    fragment PageType on PageType {
  ...BaseType
}
    fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}`,
  { fragmentName: 'PageType' },
) as unknown as TypedDocumentString<PageTypeFragment, unknown>
export const PrimitiveTypeFragmentDoc = new TypedDocumentString(
  `
    fragment PrimitiveType on PrimitiveType {
  ...BaseType
  primitiveKind
}
    fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}`,
  { fragmentName: 'PrimitiveType' },
) as unknown as TypedDocumentString<PrimitiveTypeFragment, unknown>
export const ReactNodeTypeFragmentDoc = new TypedDocumentString(
  `
    fragment ReactNodeType on ReactNodeType {
  ...BaseType
}
    fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}`,
  { fragmentName: 'ReactNodeType' },
) as unknown as TypedDocumentString<ReactNodeTypeFragment, unknown>
export const RenderPropTypeFragmentDoc = new TypedDocumentString(
  `
    fragment RenderPropType on RenderPropType {
  ...BaseType
}
    fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}`,
  { fragmentName: 'RenderPropType' },
) as unknown as TypedDocumentString<RenderPropTypeFragment, unknown>
export const RichTextTypeFragmentDoc = new TypedDocumentString(
  `
    fragment RichTextType on RichTextType {
  ...BaseType
}
    fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}`,
  { fragmentName: 'RichTextType' },
) as unknown as TypedDocumentString<RichTextTypeFragment, unknown>
export const UnionTypeFragmentDoc = new TypedDocumentString(
  `
    fragment UnionType on UnionType {
  ...BaseType
  typesOfUnionType {
    ... on IBaseType {
      ...BaseType
    }
  }
}
    fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}`,
  { fragmentName: 'UnionType' },
) as unknown as TypedDocumentString<UnionTypeFragment, unknown>
export const TypeFragmentDoc = new TypedDocumentString(
  `
    fragment Type on IBaseType {
  ...ActionType
  ...AppType
  ...ArrayType
  ...CodeMirrorType
  ...ElementType
  ...EnumType
  ...InterfaceType
  ...LambdaType
  ...PageType
  ...PrimitiveType
  ...ReactNodeType
  ...RenderPropType
  ...RichTextType
  ...UnionType
}
    fragment ActionType on ActionType {
  ...BaseType
}
fragment AppType on AppType {
  ...BaseType
}
fragment ArrayType on ArrayType {
  ...BaseType
  itemType {
    ... on IBaseType {
      id
      kind
      name
    }
  }
}
fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}
fragment CodeMirrorType on CodeMirrorType {
  ...BaseType
  language
}
fragment ElementType on ElementType {
  ...BaseType
  elementKind
}
fragment EnumTypeValue on EnumTypeValue {
  id
  key
  value
}
fragment EnumType on EnumType {
  allowedValues {
    ...EnumTypeValue
  }
  ...BaseType
}
fragment Field on Field {
  api {
    ... on InterfaceType {
      id
    }
  }
  defaultValues
  description
  fieldType {
    ... on IBaseType {
      __typename
      id
      kind
      name
    }
  }
  id
  key
  name
  nextSibling {
    id
  }
  prevSibling {
    id
  }
  validationRules
}
fragment InterfaceType on InterfaceType {
  ...BaseType
  fields {
    ...Field
  }
}
fragment LambdaType on LambdaType {
  ...BaseType
}
fragment PageType on PageType {
  ...BaseType
}
fragment PrimitiveType on PrimitiveType {
  ...BaseType
  primitiveKind
}
fragment ReactNodeType on ReactNodeType {
  ...BaseType
}
fragment RenderPropType on RenderPropType {
  ...BaseType
}
fragment RichTextType on RichTextType {
  ...BaseType
}
fragment UnionType on UnionType {
  ...BaseType
  typesOfUnionType {
    ... on IBaseType {
      ...BaseType
    }
  }
}`,
  { fragmentName: 'Type' },
) as unknown as TypedDocumentString<TypeFragment, unknown>
export const PropFragmentDoc = new TypedDocumentString(
  `
    fragment Prop on Prop {
  data
  id
}
    `,
  { fragmentName: 'Prop' },
) as unknown as TypedDocumentString<PropFragment, unknown>
export const TagPreviewFragmentDoc = new TypedDocumentString(
  `
    fragment TagPreview on Tag {
  id
  name
  owner {
    id
  }
}
    `,
  { fragmentName: 'TagPreview' },
) as unknown as TypedDocumentString<TagPreviewFragment, unknown>
export const AtomBuilderFragmentDoc = new TypedDocumentString(
  `
    fragment AtomBuilder on Atom {
  __typename
  api {
    ...InterfaceType
  }
  icon
  id
  name
  requiredParents {
    id
    name
    type
  }
  suggestedChildren {
    id
    name
    type
  }
  tags {
    ...TagPreview
  }
  type
  owner {
    id
  }
}
    fragment TagPreview on Tag {
  id
  name
  owner {
    id
  }
}
fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}
fragment Field on Field {
  api {
    ... on InterfaceType {
      id
    }
  }
  defaultValues
  description
  fieldType {
    ... on IBaseType {
      __typename
      id
      kind
      name
    }
  }
  id
  key
  name
  nextSibling {
    id
  }
  prevSibling {
    id
  }
  validationRules
}
fragment InterfaceType on InterfaceType {
  ...BaseType
  fields {
    ...Field
  }
}`,
  { fragmentName: 'AtomBuilder' },
) as unknown as TypedDocumentString<AtomBuilderFragment, unknown>
export const ElementFragmentDoc = new TypedDocumentString(
  `
    fragment Element on Element {
  __typename
  childMapperComponent {
    id
    name
  }
  childMapperPreviousSibling {
    id
  }
  childMapperPropKey
  dependantTypes {
    ...Type
  }
  firstChild {
    id
  }
  id
  name
  nextSibling {
    id
  }
  page {
    id
  }
  parentComponent {
    id
  }
  parentElement {
    id
  }
  postRenderActions {
    id
    type
  }
  preRenderActions {
    id
    type
  }
  prevSibling {
    id
  }
  props {
    ...Prop
  }
  renderForEachPropKey
  renderIfExpression
  renderType {
    ... on Atom {
      __typename
      ...AtomBuilder
    }
    ... on Component {
      __typename
      id
    }
  }
  style
  tailwindClassNames
  expanded
}
    fragment AtomBuilder on Atom {
  __typename
  api {
    ...InterfaceType
  }
  icon
  id
  name
  requiredParents {
    id
    name
    type
  }
  suggestedChildren {
    id
    name
    type
  }
  tags {
    ...TagPreview
  }
  type
  owner {
    id
  }
}
fragment Prop on Prop {
  data
  id
}
fragment TagPreview on Tag {
  id
  name
  owner {
    id
  }
}
fragment ActionType on ActionType {
  ...BaseType
}
fragment AppType on AppType {
  ...BaseType
}
fragment ArrayType on ArrayType {
  ...BaseType
  itemType {
    ... on IBaseType {
      id
      kind
      name
    }
  }
}
fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}
fragment CodeMirrorType on CodeMirrorType {
  ...BaseType
  language
}
fragment ElementType on ElementType {
  ...BaseType
  elementKind
}
fragment EnumTypeValue on EnumTypeValue {
  id
  key
  value
}
fragment EnumType on EnumType {
  allowedValues {
    ...EnumTypeValue
  }
  ...BaseType
}
fragment Field on Field {
  api {
    ... on InterfaceType {
      id
    }
  }
  defaultValues
  description
  fieldType {
    ... on IBaseType {
      __typename
      id
      kind
      name
    }
  }
  id
  key
  name
  nextSibling {
    id
  }
  prevSibling {
    id
  }
  validationRules
}
fragment InterfaceType on InterfaceType {
  ...BaseType
  fields {
    ...Field
  }
}
fragment LambdaType on LambdaType {
  ...BaseType
}
fragment PageType on PageType {
  ...BaseType
}
fragment PrimitiveType on PrimitiveType {
  ...BaseType
  primitiveKind
}
fragment ReactNodeType on ReactNodeType {
  ...BaseType
}
fragment RenderPropType on RenderPropType {
  ...BaseType
}
fragment RichTextType on RichTextType {
  ...BaseType
}
fragment Type on IBaseType {
  ...ActionType
  ...AppType
  ...ArrayType
  ...CodeMirrorType
  ...ElementType
  ...EnumType
  ...InterfaceType
  ...LambdaType
  ...PageType
  ...PrimitiveType
  ...ReactNodeType
  ...RenderPropType
  ...RichTextType
  ...UnionType
}
fragment UnionType on UnionType {
  ...BaseType
  typesOfUnionType {
    ... on IBaseType {
      ...BaseType
    }
  }
}`,
  { fragmentName: 'Element' },
) as unknown as TypedDocumentString<ElementFragment, unknown>
export const BaseActionFragmentDoc = new TypedDocumentString(
  `
    fragment BaseAction on BaseAction {
  __typename
  id
  name
  store {
    id
    name
  }
  type
}
    `,
  { fragmentName: 'BaseAction' },
) as unknown as TypedDocumentString<BaseActionFragment, unknown>
export const CodeActionFragmentDoc = new TypedDocumentString(
  `
    fragment CodeAction on CodeAction {
  ...BaseAction
  code
}
    fragment BaseAction on BaseAction {
  __typename
  id
  name
  store {
    id
    name
  }
  type
}`,
  { fragmentName: 'CodeAction' },
) as unknown as TypedDocumentString<CodeActionFragment, unknown>
export const ResourceFragmentDoc = new TypedDocumentString(
  `
    fragment Resource on Resource {
  config {
    ...Prop
  }
  id
  name
  type
  owner {
    id
  }
}
    fragment Prop on Prop {
  data
  id
}`,
  { fragmentName: 'Resource' },
) as unknown as TypedDocumentString<ResourceFragment, unknown>
export const ApiActionFragmentDoc = new TypedDocumentString(
  `
    fragment ApiAction on ApiAction {
  ...BaseAction
  config {
    data
    id
  }
  errorAction {
    ...BaseAction
  }
  resource {
    ...Resource
  }
  successAction {
    ...BaseAction
  }
}
    fragment BaseAction on BaseAction {
  __typename
  id
  name
  store {
    id
    name
  }
  type
}
fragment Prop on Prop {
  data
  id
}
fragment Resource on Resource {
  config {
    ...Prop
  }
  id
  name
  type
  owner {
    id
  }
}`,
  { fragmentName: 'ApiAction' },
) as unknown as TypedDocumentString<ApiActionFragment, unknown>
export const ActionFragmentDoc = new TypedDocumentString(
  `
    fragment Action on BaseAction {
  ...BaseAction
  ... on CodeAction {
    ...CodeAction
  }
  ... on ApiAction {
    ...ApiAction
  }
}
    fragment BaseAction on BaseAction {
  __typename
  id
  name
  store {
    id
    name
  }
  type
}
fragment ApiAction on ApiAction {
  ...BaseAction
  config {
    data
    id
  }
  errorAction {
    ...BaseAction
  }
  resource {
    ...Resource
  }
  successAction {
    ...BaseAction
  }
}
fragment CodeAction on CodeAction {
  ...BaseAction
  code
}
fragment Prop on Prop {
  data
  id
}
fragment Resource on Resource {
  config {
    ...Prop
  }
  id
  name
  type
  owner {
    id
  }
}`,
  { fragmentName: 'Action' },
) as unknown as TypedDocumentString<ActionFragment, unknown>
export const StoreFragmentDoc = new TypedDocumentString(
  `
    fragment Store on Store {
  actions {
    ...Action
  }
  api {
    ...InterfaceType
  }
  id
  name
}
    fragment BaseAction on BaseAction {
  __typename
  id
  name
  store {
    id
    name
  }
  type
}
fragment Action on BaseAction {
  ...BaseAction
  ... on CodeAction {
    ...CodeAction
  }
  ... on ApiAction {
    ...ApiAction
  }
}
fragment ApiAction on ApiAction {
  ...BaseAction
  config {
    data
    id
  }
  errorAction {
    ...BaseAction
  }
  resource {
    ...Resource
  }
  successAction {
    ...BaseAction
  }
}
fragment CodeAction on CodeAction {
  ...BaseAction
  code
}
fragment Prop on Prop {
  data
  id
}
fragment Resource on Resource {
  config {
    ...Prop
  }
  id
  name
  type
  owner {
    id
  }
}
fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}
fragment Field on Field {
  api {
    ... on InterfaceType {
      id
    }
  }
  defaultValues
  description
  fieldType {
    ... on IBaseType {
      __typename
      id
      kind
      name
    }
  }
  id
  key
  name
  nextSibling {
    id
  }
  prevSibling {
    id
  }
  validationRules
}
fragment InterfaceType on InterfaceType {
  ...BaseType
  fields {
    ...Field
  }
}`,
  { fragmentName: 'Store' },
) as unknown as TypedDocumentString<StoreFragment, unknown>
export const PageFragmentDoc = new TypedDocumentString(
  `
    fragment Page on Page {
  app {
    id
  }
  elements {
    ...Element
  }
  id
  kind
  name
  pageContentContainer {
    id
  }
  redirect {
    id
  }
  rootElement {
    id
  }
  store {
    ...Store
  }
  urlPattern
}
    fragment BaseAction on BaseAction {
  __typename
  id
  name
  store {
    id
    name
  }
  type
}
fragment Action on BaseAction {
  ...BaseAction
  ... on CodeAction {
    ...CodeAction
  }
  ... on ApiAction {
    ...ApiAction
  }
}
fragment ApiAction on ApiAction {
  ...BaseAction
  config {
    data
    id
  }
  errorAction {
    ...BaseAction
  }
  resource {
    ...Resource
  }
  successAction {
    ...BaseAction
  }
}
fragment CodeAction on CodeAction {
  ...BaseAction
  code
}
fragment AtomBuilder on Atom {
  __typename
  api {
    ...InterfaceType
  }
  icon
  id
  name
  requiredParents {
    id
    name
    type
  }
  suggestedChildren {
    id
    name
    type
  }
  tags {
    ...TagPreview
  }
  type
  owner {
    id
  }
}
fragment Element on Element {
  __typename
  childMapperComponent {
    id
    name
  }
  childMapperPreviousSibling {
    id
  }
  childMapperPropKey
  dependantTypes {
    ...Type
  }
  firstChild {
    id
  }
  id
  name
  nextSibling {
    id
  }
  page {
    id
  }
  parentComponent {
    id
  }
  parentElement {
    id
  }
  postRenderActions {
    id
    type
  }
  preRenderActions {
    id
    type
  }
  prevSibling {
    id
  }
  props {
    ...Prop
  }
  renderForEachPropKey
  renderIfExpression
  renderType {
    ... on Atom {
      __typename
      ...AtomBuilder
    }
    ... on Component {
      __typename
      id
    }
  }
  style
  tailwindClassNames
  expanded
}
fragment Prop on Prop {
  data
  id
}
fragment Resource on Resource {
  config {
    ...Prop
  }
  id
  name
  type
  owner {
    id
  }
}
fragment Store on Store {
  actions {
    ...Action
  }
  api {
    ...InterfaceType
  }
  id
  name
}
fragment TagPreview on Tag {
  id
  name
  owner {
    id
  }
}
fragment ActionType on ActionType {
  ...BaseType
}
fragment AppType on AppType {
  ...BaseType
}
fragment ArrayType on ArrayType {
  ...BaseType
  itemType {
    ... on IBaseType {
      id
      kind
      name
    }
  }
}
fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}
fragment CodeMirrorType on CodeMirrorType {
  ...BaseType
  language
}
fragment ElementType on ElementType {
  ...BaseType
  elementKind
}
fragment EnumTypeValue on EnumTypeValue {
  id
  key
  value
}
fragment EnumType on EnumType {
  allowedValues {
    ...EnumTypeValue
  }
  ...BaseType
}
fragment Field on Field {
  api {
    ... on InterfaceType {
      id
    }
  }
  defaultValues
  description
  fieldType {
    ... on IBaseType {
      __typename
      id
      kind
      name
    }
  }
  id
  key
  name
  nextSibling {
    id
  }
  prevSibling {
    id
  }
  validationRules
}
fragment InterfaceType on InterfaceType {
  ...BaseType
  fields {
    ...Field
  }
}
fragment LambdaType on LambdaType {
  ...BaseType
}
fragment PageType on PageType {
  ...BaseType
}
fragment PrimitiveType on PrimitiveType {
  ...BaseType
  primitiveKind
}
fragment ReactNodeType on ReactNodeType {
  ...BaseType
}
fragment RenderPropType on RenderPropType {
  ...BaseType
}
fragment RichTextType on RichTextType {
  ...BaseType
}
fragment Type on IBaseType {
  ...ActionType
  ...AppType
  ...ArrayType
  ...CodeMirrorType
  ...ElementType
  ...EnumType
  ...InterfaceType
  ...LambdaType
  ...PageType
  ...PrimitiveType
  ...ReactNodeType
  ...RenderPropType
  ...RichTextType
  ...UnionType
}
fragment UnionType on UnionType {
  ...BaseType
  typesOfUnionType {
    ... on IBaseType {
      ...BaseType
    }
  }
}`,
  { fragmentName: 'Page' },
) as unknown as TypedDocumentString<PageFragment, unknown>
export const AppFragmentDoc = new TypedDocumentString(
  `
    fragment App on App {
  domains {
    ...Domain
  }
  id
  name
  owner {
    ...Owner
  }
  pages {
    ...Page
  }
  slug
}
    fragment BaseAction on BaseAction {
  __typename
  id
  name
  store {
    id
    name
  }
  type
}
fragment Action on BaseAction {
  ...BaseAction
  ... on CodeAction {
    ...CodeAction
  }
  ... on ApiAction {
    ...ApiAction
  }
}
fragment ApiAction on ApiAction {
  ...BaseAction
  config {
    data
    id
  }
  errorAction {
    ...BaseAction
  }
  resource {
    ...Resource
  }
  successAction {
    ...BaseAction
  }
}
fragment CodeAction on CodeAction {
  ...BaseAction
  code
}
fragment AtomBuilder on Atom {
  __typename
  api {
    ...InterfaceType
  }
  icon
  id
  name
  requiredParents {
    id
    name
    type
  }
  suggestedChildren {
    id
    name
    type
  }
  tags {
    ...TagPreview
  }
  type
  owner {
    id
  }
}
fragment Domain on Domain {
  app {
    id
  }
  domainConfig {
    misconfigured
  }
  id
  name
}
fragment Element on Element {
  __typename
  childMapperComponent {
    id
    name
  }
  childMapperPreviousSibling {
    id
  }
  childMapperPropKey
  dependantTypes {
    ...Type
  }
  firstChild {
    id
  }
  id
  name
  nextSibling {
    id
  }
  page {
    id
  }
  parentComponent {
    id
  }
  parentElement {
    id
  }
  postRenderActions {
    id
    type
  }
  preRenderActions {
    id
    type
  }
  prevSibling {
    id
  }
  props {
    ...Prop
  }
  renderForEachPropKey
  renderIfExpression
  renderType {
    ... on Atom {
      __typename
      ...AtomBuilder
    }
    ... on Component {
      __typename
      id
    }
  }
  style
  tailwindClassNames
  expanded
}
fragment Page on Page {
  app {
    id
  }
  elements {
    ...Element
  }
  id
  kind
  name
  pageContentContainer {
    id
  }
  redirect {
    id
  }
  rootElement {
    id
  }
  store {
    ...Store
  }
  urlPattern
}
fragment Prop on Prop {
  data
  id
}
fragment Resource on Resource {
  config {
    ...Prop
  }
  id
  name
  type
  owner {
    id
  }
}
fragment Store on Store {
  actions {
    ...Action
  }
  api {
    ...InterfaceType
  }
  id
  name
}
fragment TagPreview on Tag {
  id
  name
  owner {
    id
  }
}
fragment ActionType on ActionType {
  ...BaseType
}
fragment AppType on AppType {
  ...BaseType
}
fragment ArrayType on ArrayType {
  ...BaseType
  itemType {
    ... on IBaseType {
      id
      kind
      name
    }
  }
}
fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}
fragment CodeMirrorType on CodeMirrorType {
  ...BaseType
  language
}
fragment ElementType on ElementType {
  ...BaseType
  elementKind
}
fragment EnumTypeValue on EnumTypeValue {
  id
  key
  value
}
fragment EnumType on EnumType {
  allowedValues {
    ...EnumTypeValue
  }
  ...BaseType
}
fragment Field on Field {
  api {
    ... on InterfaceType {
      id
    }
  }
  defaultValues
  description
  fieldType {
    ... on IBaseType {
      __typename
      id
      kind
      name
    }
  }
  id
  key
  name
  nextSibling {
    id
  }
  prevSibling {
    id
  }
  validationRules
}
fragment InterfaceType on InterfaceType {
  ...BaseType
  fields {
    ...Field
  }
}
fragment LambdaType on LambdaType {
  ...BaseType
}
fragment PageType on PageType {
  ...BaseType
}
fragment PrimitiveType on PrimitiveType {
  ...BaseType
  primitiveKind
}
fragment ReactNodeType on ReactNodeType {
  ...BaseType
}
fragment RenderPropType on RenderPropType {
  ...BaseType
}
fragment RichTextType on RichTextType {
  ...BaseType
}
fragment Type on IBaseType {
  ...ActionType
  ...AppType
  ...ArrayType
  ...CodeMirrorType
  ...ElementType
  ...EnumType
  ...InterfaceType
  ...LambdaType
  ...PageType
  ...PrimitiveType
  ...ReactNodeType
  ...RenderPropType
  ...RichTextType
  ...UnionType
}
fragment UnionType on UnionType {
  ...BaseType
  typesOfUnionType {
    ... on IBaseType {
      ...BaseType
    }
  }
}
fragment Owner on User {
  id
}`,
  { fragmentName: 'App' },
) as unknown as TypedDocumentString<AppFragment, unknown>
export const PageDevelopmentFragmentDoc = new TypedDocumentString(
  `
    fragment PageDevelopment on Page {
  app {
    id
  }
  elements {
    ...Element
  }
  id
  kind
  name
  pageContentContainer {
    id
  }
  redirect {
    id
  }
  rootElement {
    id
  }
  store {
    ...Store
  }
  urlPattern
}
    fragment BaseAction on BaseAction {
  __typename
  id
  name
  store {
    id
    name
  }
  type
}
fragment Action on BaseAction {
  ...BaseAction
  ... on CodeAction {
    ...CodeAction
  }
  ... on ApiAction {
    ...ApiAction
  }
}
fragment ApiAction on ApiAction {
  ...BaseAction
  config {
    data
    id
  }
  errorAction {
    ...BaseAction
  }
  resource {
    ...Resource
  }
  successAction {
    ...BaseAction
  }
}
fragment CodeAction on CodeAction {
  ...BaseAction
  code
}
fragment AtomBuilder on Atom {
  __typename
  api {
    ...InterfaceType
  }
  icon
  id
  name
  requiredParents {
    id
    name
    type
  }
  suggestedChildren {
    id
    name
    type
  }
  tags {
    ...TagPreview
  }
  type
  owner {
    id
  }
}
fragment Element on Element {
  __typename
  childMapperComponent {
    id
    name
  }
  childMapperPreviousSibling {
    id
  }
  childMapperPropKey
  dependantTypes {
    ...Type
  }
  firstChild {
    id
  }
  id
  name
  nextSibling {
    id
  }
  page {
    id
  }
  parentComponent {
    id
  }
  parentElement {
    id
  }
  postRenderActions {
    id
    type
  }
  preRenderActions {
    id
    type
  }
  prevSibling {
    id
  }
  props {
    ...Prop
  }
  renderForEachPropKey
  renderIfExpression
  renderType {
    ... on Atom {
      __typename
      ...AtomBuilder
    }
    ... on Component {
      __typename
      id
    }
  }
  style
  tailwindClassNames
  expanded
}
fragment Prop on Prop {
  data
  id
}
fragment Resource on Resource {
  config {
    ...Prop
  }
  id
  name
  type
  owner {
    id
  }
}
fragment Store on Store {
  actions {
    ...Action
  }
  api {
    ...InterfaceType
  }
  id
  name
}
fragment TagPreview on Tag {
  id
  name
  owner {
    id
  }
}
fragment ActionType on ActionType {
  ...BaseType
}
fragment AppType on AppType {
  ...BaseType
}
fragment ArrayType on ArrayType {
  ...BaseType
  itemType {
    ... on IBaseType {
      id
      kind
      name
    }
  }
}
fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}
fragment CodeMirrorType on CodeMirrorType {
  ...BaseType
  language
}
fragment ElementType on ElementType {
  ...BaseType
  elementKind
}
fragment EnumTypeValue on EnumTypeValue {
  id
  key
  value
}
fragment EnumType on EnumType {
  allowedValues {
    ...EnumTypeValue
  }
  ...BaseType
}
fragment Field on Field {
  api {
    ... on InterfaceType {
      id
    }
  }
  defaultValues
  description
  fieldType {
    ... on IBaseType {
      __typename
      id
      kind
      name
    }
  }
  id
  key
  name
  nextSibling {
    id
  }
  prevSibling {
    id
  }
  validationRules
}
fragment InterfaceType on InterfaceType {
  ...BaseType
  fields {
    ...Field
  }
}
fragment LambdaType on LambdaType {
  ...BaseType
}
fragment PageType on PageType {
  ...BaseType
}
fragment PrimitiveType on PrimitiveType {
  ...BaseType
  primitiveKind
}
fragment ReactNodeType on ReactNodeType {
  ...BaseType
}
fragment RenderPropType on RenderPropType {
  ...BaseType
}
fragment RichTextType on RichTextType {
  ...BaseType
}
fragment Type on IBaseType {
  ...ActionType
  ...AppType
  ...ArrayType
  ...CodeMirrorType
  ...ElementType
  ...EnumType
  ...InterfaceType
  ...LambdaType
  ...PageType
  ...PrimitiveType
  ...ReactNodeType
  ...RenderPropType
  ...RichTextType
  ...UnionType
}
fragment UnionType on UnionType {
  ...BaseType
  typesOfUnionType {
    ... on IBaseType {
      ...BaseType
    }
  }
}`,
  { fragmentName: 'PageDevelopment' },
) as unknown as TypedDocumentString<PageDevelopmentFragment, unknown>
export const AppBuilderFragmentDoc = new TypedDocumentString(
  `
    fragment AppBuilder on App {
  id
  name
  owner {
    ...Owner
  }
  pages(
    where: {OR: [{id_IN: $pageIds}, {kind: Provider}, {kind: NotFound}, {kind: InternalServerError}, {kind: Regular}]}
  ) {
    ...PageDevelopment
  }
  slug
}
    fragment BaseAction on BaseAction {
  __typename
  id
  name
  store {
    id
    name
  }
  type
}
fragment Action on BaseAction {
  ...BaseAction
  ... on CodeAction {
    ...CodeAction
  }
  ... on ApiAction {
    ...ApiAction
  }
}
fragment ApiAction on ApiAction {
  ...BaseAction
  config {
    data
    id
  }
  errorAction {
    ...BaseAction
  }
  resource {
    ...Resource
  }
  successAction {
    ...BaseAction
  }
}
fragment CodeAction on CodeAction {
  ...BaseAction
  code
}
fragment AtomBuilder on Atom {
  __typename
  api {
    ...InterfaceType
  }
  icon
  id
  name
  requiredParents {
    id
    name
    type
  }
  suggestedChildren {
    id
    name
    type
  }
  tags {
    ...TagPreview
  }
  type
  owner {
    id
  }
}
fragment Element on Element {
  __typename
  childMapperComponent {
    id
    name
  }
  childMapperPreviousSibling {
    id
  }
  childMapperPropKey
  dependantTypes {
    ...Type
  }
  firstChild {
    id
  }
  id
  name
  nextSibling {
    id
  }
  page {
    id
  }
  parentComponent {
    id
  }
  parentElement {
    id
  }
  postRenderActions {
    id
    type
  }
  preRenderActions {
    id
    type
  }
  prevSibling {
    id
  }
  props {
    ...Prop
  }
  renderForEachPropKey
  renderIfExpression
  renderType {
    ... on Atom {
      __typename
      ...AtomBuilder
    }
    ... on Component {
      __typename
      id
    }
  }
  style
  tailwindClassNames
  expanded
}
fragment PageDevelopment on Page {
  app {
    id
  }
  elements {
    ...Element
  }
  id
  kind
  name
  pageContentContainer {
    id
  }
  redirect {
    id
  }
  rootElement {
    id
  }
  store {
    ...Store
  }
  urlPattern
}
fragment Prop on Prop {
  data
  id
}
fragment Resource on Resource {
  config {
    ...Prop
  }
  id
  name
  type
  owner {
    id
  }
}
fragment Store on Store {
  actions {
    ...Action
  }
  api {
    ...InterfaceType
  }
  id
  name
}
fragment TagPreview on Tag {
  id
  name
  owner {
    id
  }
}
fragment ActionType on ActionType {
  ...BaseType
}
fragment AppType on AppType {
  ...BaseType
}
fragment ArrayType on ArrayType {
  ...BaseType
  itemType {
    ... on IBaseType {
      id
      kind
      name
    }
  }
}
fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}
fragment CodeMirrorType on CodeMirrorType {
  ...BaseType
  language
}
fragment ElementType on ElementType {
  ...BaseType
  elementKind
}
fragment EnumTypeValue on EnumTypeValue {
  id
  key
  value
}
fragment EnumType on EnumType {
  allowedValues {
    ...EnumTypeValue
  }
  ...BaseType
}
fragment Field on Field {
  api {
    ... on InterfaceType {
      id
    }
  }
  defaultValues
  description
  fieldType {
    ... on IBaseType {
      __typename
      id
      kind
      name
    }
  }
  id
  key
  name
  nextSibling {
    id
  }
  prevSibling {
    id
  }
  validationRules
}
fragment InterfaceType on InterfaceType {
  ...BaseType
  fields {
    ...Field
  }
}
fragment LambdaType on LambdaType {
  ...BaseType
}
fragment PageType on PageType {
  ...BaseType
}
fragment PrimitiveType on PrimitiveType {
  ...BaseType
  primitiveKind
}
fragment ReactNodeType on ReactNodeType {
  ...BaseType
}
fragment RenderPropType on RenderPropType {
  ...BaseType
}
fragment RichTextType on RichTextType {
  ...BaseType
}
fragment Type on IBaseType {
  ...ActionType
  ...AppType
  ...ArrayType
  ...CodeMirrorType
  ...ElementType
  ...EnumType
  ...InterfaceType
  ...LambdaType
  ...PageType
  ...PrimitiveType
  ...ReactNodeType
  ...RenderPropType
  ...RichTextType
  ...UnionType
}
fragment UnionType on UnionType {
  ...BaseType
  typesOfUnionType {
    ... on IBaseType {
      ...BaseType
    }
  }
}
fragment Owner on User {
  id
}`,
  { fragmentName: 'AppBuilder' },
) as unknown as TypedDocumentString<AppBuilderFragment, unknown>
export const AtomProductionFragmentDoc = new TypedDocumentString(
  `
    fragment AtomProduction on Atom {
  __typename
  externalCssSource
  externalJsSource
  externalSourceType
  icon
  id
  name
  requiredParents {
    id
    name
    type
  }
  suggestedChildren {
    id
    name
    type
  }
  type
}
    `,
  { fragmentName: 'AtomProduction' },
) as unknown as TypedDocumentString<AtomProductionFragment, unknown>
export const ElementProductionFragmentDoc = new TypedDocumentString(
  `
    fragment ElementProduction on Element {
  __typename
  childMapperComponent {
    id
    name
  }
  childMapperPreviousSibling {
    id
  }
  childMapperPropKey
  dependantTypes {
    ...Type
  }
  firstChild {
    id
  }
  id
  name
  nextSibling {
    id
  }
  page {
    id
  }
  parentComponent {
    id
  }
  parentElement {
    id
  }
  postRenderActions {
    id
    type
  }
  preRenderActions {
    id
    type
  }
  prevSibling {
    id
  }
  props {
    ...Prop
  }
  renderForEachPropKey
  renderIfExpression
  renderType {
    ... on Atom {
      __typename
      ...AtomProduction
    }
    ... on Component {
      __typename
      id
    }
  }
  style
  tailwindClassNames
}
    fragment AtomProduction on Atom {
  __typename
  externalCssSource
  externalJsSource
  externalSourceType
  icon
  id
  name
  requiredParents {
    id
    name
    type
  }
  suggestedChildren {
    id
    name
    type
  }
  type
}
fragment Prop on Prop {
  data
  id
}
fragment ActionType on ActionType {
  ...BaseType
}
fragment AppType on AppType {
  ...BaseType
}
fragment ArrayType on ArrayType {
  ...BaseType
  itemType {
    ... on IBaseType {
      id
      kind
      name
    }
  }
}
fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}
fragment CodeMirrorType on CodeMirrorType {
  ...BaseType
  language
}
fragment ElementType on ElementType {
  ...BaseType
  elementKind
}
fragment EnumTypeValue on EnumTypeValue {
  id
  key
  value
}
fragment EnumType on EnumType {
  allowedValues {
    ...EnumTypeValue
  }
  ...BaseType
}
fragment Field on Field {
  api {
    ... on InterfaceType {
      id
    }
  }
  defaultValues
  description
  fieldType {
    ... on IBaseType {
      __typename
      id
      kind
      name
    }
  }
  id
  key
  name
  nextSibling {
    id
  }
  prevSibling {
    id
  }
  validationRules
}
fragment InterfaceType on InterfaceType {
  ...BaseType
  fields {
    ...Field
  }
}
fragment LambdaType on LambdaType {
  ...BaseType
}
fragment PageType on PageType {
  ...BaseType
}
fragment PrimitiveType on PrimitiveType {
  ...BaseType
  primitiveKind
}
fragment ReactNodeType on ReactNodeType {
  ...BaseType
}
fragment RenderPropType on RenderPropType {
  ...BaseType
}
fragment RichTextType on RichTextType {
  ...BaseType
}
fragment Type on IBaseType {
  ...ActionType
  ...AppType
  ...ArrayType
  ...CodeMirrorType
  ...ElementType
  ...EnumType
  ...InterfaceType
  ...LambdaType
  ...PageType
  ...PrimitiveType
  ...ReactNodeType
  ...RenderPropType
  ...RichTextType
  ...UnionType
}
fragment UnionType on UnionType {
  ...BaseType
  typesOfUnionType {
    ... on IBaseType {
      ...BaseType
    }
  }
}`,
  { fragmentName: 'ElementProduction' },
) as unknown as TypedDocumentString<ElementProductionFragment, unknown>
export const PageProductionFragmentDoc = new TypedDocumentString(
  `
    fragment PageProduction on Page {
  app {
    id
  }
  elements {
    ...ElementProduction
  }
  id
  kind
  name
  pageContentContainer {
    id
  }
  redirect {
    id
  }
  rootElement {
    id
  }
  slug
  store {
    ...Store
  }
  urlPattern
}
    fragment BaseAction on BaseAction {
  __typename
  id
  name
  store {
    id
    name
  }
  type
}
fragment Action on BaseAction {
  ...BaseAction
  ... on CodeAction {
    ...CodeAction
  }
  ... on ApiAction {
    ...ApiAction
  }
}
fragment ApiAction on ApiAction {
  ...BaseAction
  config {
    data
    id
  }
  errorAction {
    ...BaseAction
  }
  resource {
    ...Resource
  }
  successAction {
    ...BaseAction
  }
}
fragment CodeAction on CodeAction {
  ...BaseAction
  code
}
fragment AtomProduction on Atom {
  __typename
  externalCssSource
  externalJsSource
  externalSourceType
  icon
  id
  name
  requiredParents {
    id
    name
    type
  }
  suggestedChildren {
    id
    name
    type
  }
  type
}
fragment ElementProduction on Element {
  __typename
  childMapperComponent {
    id
    name
  }
  childMapperPreviousSibling {
    id
  }
  childMapperPropKey
  dependantTypes {
    ...Type
  }
  firstChild {
    id
  }
  id
  name
  nextSibling {
    id
  }
  page {
    id
  }
  parentComponent {
    id
  }
  parentElement {
    id
  }
  postRenderActions {
    id
    type
  }
  preRenderActions {
    id
    type
  }
  prevSibling {
    id
  }
  props {
    ...Prop
  }
  renderForEachPropKey
  renderIfExpression
  renderType {
    ... on Atom {
      __typename
      ...AtomProduction
    }
    ... on Component {
      __typename
      id
    }
  }
  style
  tailwindClassNames
}
fragment Prop on Prop {
  data
  id
}
fragment Resource on Resource {
  config {
    ...Prop
  }
  id
  name
  type
  owner {
    id
  }
}
fragment Store on Store {
  actions {
    ...Action
  }
  api {
    ...InterfaceType
  }
  id
  name
}
fragment ActionType on ActionType {
  ...BaseType
}
fragment AppType on AppType {
  ...BaseType
}
fragment ArrayType on ArrayType {
  ...BaseType
  itemType {
    ... on IBaseType {
      id
      kind
      name
    }
  }
}
fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}
fragment CodeMirrorType on CodeMirrorType {
  ...BaseType
  language
}
fragment ElementType on ElementType {
  ...BaseType
  elementKind
}
fragment EnumTypeValue on EnumTypeValue {
  id
  key
  value
}
fragment EnumType on EnumType {
  allowedValues {
    ...EnumTypeValue
  }
  ...BaseType
}
fragment Field on Field {
  api {
    ... on InterfaceType {
      id
    }
  }
  defaultValues
  description
  fieldType {
    ... on IBaseType {
      __typename
      id
      kind
      name
    }
  }
  id
  key
  name
  nextSibling {
    id
  }
  prevSibling {
    id
  }
  validationRules
}
fragment InterfaceType on InterfaceType {
  ...BaseType
  fields {
    ...Field
  }
}
fragment LambdaType on LambdaType {
  ...BaseType
}
fragment PageType on PageType {
  ...BaseType
}
fragment PrimitiveType on PrimitiveType {
  ...BaseType
  primitiveKind
}
fragment ReactNodeType on ReactNodeType {
  ...BaseType
}
fragment RenderPropType on RenderPropType {
  ...BaseType
}
fragment RichTextType on RichTextType {
  ...BaseType
}
fragment Type on IBaseType {
  ...ActionType
  ...AppType
  ...ArrayType
  ...CodeMirrorType
  ...ElementType
  ...EnumType
  ...InterfaceType
  ...LambdaType
  ...PageType
  ...PrimitiveType
  ...ReactNodeType
  ...RenderPropType
  ...RichTextType
  ...UnionType
}
fragment UnionType on UnionType {
  ...BaseType
  typesOfUnionType {
    ... on IBaseType {
      ...BaseType
    }
  }
}`,
  { fragmentName: 'PageProduction' },
) as unknown as TypedDocumentString<PageProductionFragment, unknown>
export const AppProductionFragmentDoc = new TypedDocumentString(
  `
    fragment AppProduction on App {
  id
  name
  owner {
    ...Owner
  }
  pages(where: {OR: [{urlPattern: $pageUrlPattern}, {kind: Provider}]}) {
    ...PageProduction
  }
  slug
}
    fragment BaseAction on BaseAction {
  __typename
  id
  name
  store {
    id
    name
  }
  type
}
fragment Action on BaseAction {
  ...BaseAction
  ... on CodeAction {
    ...CodeAction
  }
  ... on ApiAction {
    ...ApiAction
  }
}
fragment ApiAction on ApiAction {
  ...BaseAction
  config {
    data
    id
  }
  errorAction {
    ...BaseAction
  }
  resource {
    ...Resource
  }
  successAction {
    ...BaseAction
  }
}
fragment CodeAction on CodeAction {
  ...BaseAction
  code
}
fragment AtomProduction on Atom {
  __typename
  externalCssSource
  externalJsSource
  externalSourceType
  icon
  id
  name
  requiredParents {
    id
    name
    type
  }
  suggestedChildren {
    id
    name
    type
  }
  type
}
fragment ElementProduction on Element {
  __typename
  childMapperComponent {
    id
    name
  }
  childMapperPreviousSibling {
    id
  }
  childMapperPropKey
  dependantTypes {
    ...Type
  }
  firstChild {
    id
  }
  id
  name
  nextSibling {
    id
  }
  page {
    id
  }
  parentComponent {
    id
  }
  parentElement {
    id
  }
  postRenderActions {
    id
    type
  }
  preRenderActions {
    id
    type
  }
  prevSibling {
    id
  }
  props {
    ...Prop
  }
  renderForEachPropKey
  renderIfExpression
  renderType {
    ... on Atom {
      __typename
      ...AtomProduction
    }
    ... on Component {
      __typename
      id
    }
  }
  style
  tailwindClassNames
}
fragment PageProduction on Page {
  app {
    id
  }
  elements {
    ...ElementProduction
  }
  id
  kind
  name
  pageContentContainer {
    id
  }
  redirect {
    id
  }
  rootElement {
    id
  }
  slug
  store {
    ...Store
  }
  urlPattern
}
fragment Prop on Prop {
  data
  id
}
fragment Resource on Resource {
  config {
    ...Prop
  }
  id
  name
  type
  owner {
    id
  }
}
fragment Store on Store {
  actions {
    ...Action
  }
  api {
    ...InterfaceType
  }
  id
  name
}
fragment ActionType on ActionType {
  ...BaseType
}
fragment AppType on AppType {
  ...BaseType
}
fragment ArrayType on ArrayType {
  ...BaseType
  itemType {
    ... on IBaseType {
      id
      kind
      name
    }
  }
}
fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}
fragment CodeMirrorType on CodeMirrorType {
  ...BaseType
  language
}
fragment ElementType on ElementType {
  ...BaseType
  elementKind
}
fragment EnumTypeValue on EnumTypeValue {
  id
  key
  value
}
fragment EnumType on EnumType {
  allowedValues {
    ...EnumTypeValue
  }
  ...BaseType
}
fragment Field on Field {
  api {
    ... on InterfaceType {
      id
    }
  }
  defaultValues
  description
  fieldType {
    ... on IBaseType {
      __typename
      id
      kind
      name
    }
  }
  id
  key
  name
  nextSibling {
    id
  }
  prevSibling {
    id
  }
  validationRules
}
fragment InterfaceType on InterfaceType {
  ...BaseType
  fields {
    ...Field
  }
}
fragment LambdaType on LambdaType {
  ...BaseType
}
fragment PageType on PageType {
  ...BaseType
}
fragment PrimitiveType on PrimitiveType {
  ...BaseType
  primitiveKind
}
fragment ReactNodeType on ReactNodeType {
  ...BaseType
}
fragment RenderPropType on RenderPropType {
  ...BaseType
}
fragment RichTextType on RichTextType {
  ...BaseType
}
fragment Type on IBaseType {
  ...ActionType
  ...AppType
  ...ArrayType
  ...CodeMirrorType
  ...ElementType
  ...EnumType
  ...InterfaceType
  ...LambdaType
  ...PageType
  ...PrimitiveType
  ...ReactNodeType
  ...RenderPropType
  ...RichTextType
  ...UnionType
}
fragment UnionType on UnionType {
  ...BaseType
  typesOfUnionType {
    ... on IBaseType {
      ...BaseType
    }
  }
}
fragment Owner on User {
  id
}`,
  { fragmentName: 'AppProduction' },
) as unknown as TypedDocumentString<AppProductionFragment, unknown>
export const AtomFragmentDoc = new TypedDocumentString(
  `
    fragment Atom on Atom {
  __typename
  api {
    ...InterfaceType
  }
  externalCssSource
  externalJsSource
  externalSourceType
  icon
  id
  name
  requiredParents {
    id
    name
    type
  }
  suggestedChildren {
    id
    name
    type
  }
  tags {
    ...TagPreview
  }
  type
  owner {
    id
  }
}
    fragment TagPreview on Tag {
  id
  name
  owner {
    id
  }
}
fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}
fragment Field on Field {
  api {
    ... on InterfaceType {
      id
    }
  }
  defaultValues
  description
  fieldType {
    ... on IBaseType {
      __typename
      id
      kind
      name
    }
  }
  id
  key
  name
  nextSibling {
    id
  }
  prevSibling {
    id
  }
  validationRules
}
fragment InterfaceType on InterfaceType {
  ...BaseType
  fields {
    ...Field
  }
}`,
  { fragmentName: 'Atom' },
) as unknown as TypedDocumentString<AtomFragment, unknown>
export const AuthGuardFragmentDoc = new TypedDocumentString(
  `
    fragment AuthGuard on AuthGuard {
  config {
    ...Prop
  }
  id
  name
  resource {
    ...Resource
  }
  responseTransformer
  owner {
    id
  }
}
    fragment Prop on Prop {
  data
  id
}
fragment Resource on Resource {
  config {
    ...Prop
  }
  id
  name
  type
  owner {
    id
  }
}`,
  { fragmentName: 'AuthGuard' },
) as unknown as TypedDocumentString<AuthGuardFragment, unknown>
export const ComponentFragmentDoc = new TypedDocumentString(
  `
    fragment Component on Component {
  __typename
  api {
    id
  }
  id
  name
  compositeKey
  owner {
    ...Owner
  }
  props {
    ...Prop
  }
  rootElement {
    id
  }
  store {
    ...Store
  }
}
    fragment BaseAction on BaseAction {
  __typename
  id
  name
  store {
    id
    name
  }
  type
}
fragment Action on BaseAction {
  ...BaseAction
  ... on CodeAction {
    ...CodeAction
  }
  ... on ApiAction {
    ...ApiAction
  }
}
fragment ApiAction on ApiAction {
  ...BaseAction
  config {
    data
    id
  }
  errorAction {
    ...BaseAction
  }
  resource {
    ...Resource
  }
  successAction {
    ...BaseAction
  }
}
fragment CodeAction on CodeAction {
  ...BaseAction
  code
}
fragment Prop on Prop {
  data
  id
}
fragment Resource on Resource {
  config {
    ...Prop
  }
  id
  name
  type
  owner {
    id
  }
}
fragment Store on Store {
  actions {
    ...Action
  }
  api {
    ...InterfaceType
  }
  id
  name
}
fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}
fragment Field on Field {
  api {
    ... on InterfaceType {
      id
    }
  }
  defaultValues
  description
  fieldType {
    ... on IBaseType {
      __typename
      id
      kind
      name
    }
  }
  id
  key
  name
  nextSibling {
    id
  }
  prevSibling {
    id
  }
  validationRules
}
fragment InterfaceType on InterfaceType {
  ...BaseType
  fields {
    ...Field
  }
}
fragment Owner on User {
  id
}`,
  { fragmentName: 'Component' },
) as unknown as TypedDocumentString<ComponentFragment, unknown>
export const ComponentBuilderFragmentDoc = new TypedDocumentString(
  `
    fragment ComponentBuilder on Component {
  __typename
  api {
    ...InterfaceType
  }
  elements {
    ...Element
  }
  id
  name
  compositeKey
  owner {
    ...Owner
  }
  props {
    ...Prop
  }
  rootElement {
    id
    name
  }
  store {
    ...Store
  }
}
    fragment BaseAction on BaseAction {
  __typename
  id
  name
  store {
    id
    name
  }
  type
}
fragment Action on BaseAction {
  ...BaseAction
  ... on CodeAction {
    ...CodeAction
  }
  ... on ApiAction {
    ...ApiAction
  }
}
fragment ApiAction on ApiAction {
  ...BaseAction
  config {
    data
    id
  }
  errorAction {
    ...BaseAction
  }
  resource {
    ...Resource
  }
  successAction {
    ...BaseAction
  }
}
fragment CodeAction on CodeAction {
  ...BaseAction
  code
}
fragment AtomBuilder on Atom {
  __typename
  api {
    ...InterfaceType
  }
  icon
  id
  name
  requiredParents {
    id
    name
    type
  }
  suggestedChildren {
    id
    name
    type
  }
  tags {
    ...TagPreview
  }
  type
  owner {
    id
  }
}
fragment Element on Element {
  __typename
  childMapperComponent {
    id
    name
  }
  childMapperPreviousSibling {
    id
  }
  childMapperPropKey
  dependantTypes {
    ...Type
  }
  firstChild {
    id
  }
  id
  name
  nextSibling {
    id
  }
  page {
    id
  }
  parentComponent {
    id
  }
  parentElement {
    id
  }
  postRenderActions {
    id
    type
  }
  preRenderActions {
    id
    type
  }
  prevSibling {
    id
  }
  props {
    ...Prop
  }
  renderForEachPropKey
  renderIfExpression
  renderType {
    ... on Atom {
      __typename
      ...AtomBuilder
    }
    ... on Component {
      __typename
      id
    }
  }
  style
  tailwindClassNames
  expanded
}
fragment Prop on Prop {
  data
  id
}
fragment Resource on Resource {
  config {
    ...Prop
  }
  id
  name
  type
  owner {
    id
  }
}
fragment Store on Store {
  actions {
    ...Action
  }
  api {
    ...InterfaceType
  }
  id
  name
}
fragment TagPreview on Tag {
  id
  name
  owner {
    id
  }
}
fragment ActionType on ActionType {
  ...BaseType
}
fragment AppType on AppType {
  ...BaseType
}
fragment ArrayType on ArrayType {
  ...BaseType
  itemType {
    ... on IBaseType {
      id
      kind
      name
    }
  }
}
fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}
fragment CodeMirrorType on CodeMirrorType {
  ...BaseType
  language
}
fragment ElementType on ElementType {
  ...BaseType
  elementKind
}
fragment EnumTypeValue on EnumTypeValue {
  id
  key
  value
}
fragment EnumType on EnumType {
  allowedValues {
    ...EnumTypeValue
  }
  ...BaseType
}
fragment Field on Field {
  api {
    ... on InterfaceType {
      id
    }
  }
  defaultValues
  description
  fieldType {
    ... on IBaseType {
      __typename
      id
      kind
      name
    }
  }
  id
  key
  name
  nextSibling {
    id
  }
  prevSibling {
    id
  }
  validationRules
}
fragment InterfaceType on InterfaceType {
  ...BaseType
  fields {
    ...Field
  }
}
fragment LambdaType on LambdaType {
  ...BaseType
}
fragment PageType on PageType {
  ...BaseType
}
fragment PrimitiveType on PrimitiveType {
  ...BaseType
  primitiveKind
}
fragment ReactNodeType on ReactNodeType {
  ...BaseType
}
fragment RenderPropType on RenderPropType {
  ...BaseType
}
fragment RichTextType on RichTextType {
  ...BaseType
}
fragment Type on IBaseType {
  ...ActionType
  ...AppType
  ...ArrayType
  ...CodeMirrorType
  ...ElementType
  ...EnumType
  ...InterfaceType
  ...LambdaType
  ...PageType
  ...PrimitiveType
  ...ReactNodeType
  ...RenderPropType
  ...RichTextType
  ...UnionType
}
fragment UnionType on UnionType {
  ...BaseType
  typesOfUnionType {
    ... on IBaseType {
      ...BaseType
    }
  }
}
fragment Owner on User {
  id
}`,
  { fragmentName: 'ComponentBuilder' },
) as unknown as TypedDocumentString<ComponentBuilderFragment, unknown>
export const ComponentProductionFragmentDoc = new TypedDocumentString(
  `
    fragment ComponentProduction on Component {
  id
  name
  compositeKey
  owner {
    ...Owner
  }
  props {
    ...Prop
  }
  rootElement {
    id
    name
  }
  store {
    ...Store
  }
}
    fragment BaseAction on BaseAction {
  __typename
  id
  name
  store {
    id
    name
  }
  type
}
fragment Action on BaseAction {
  ...BaseAction
  ... on CodeAction {
    ...CodeAction
  }
  ... on ApiAction {
    ...ApiAction
  }
}
fragment ApiAction on ApiAction {
  ...BaseAction
  config {
    data
    id
  }
  errorAction {
    ...BaseAction
  }
  resource {
    ...Resource
  }
  successAction {
    ...BaseAction
  }
}
fragment CodeAction on CodeAction {
  ...BaseAction
  code
}
fragment Prop on Prop {
  data
  id
}
fragment Resource on Resource {
  config {
    ...Prop
  }
  id
  name
  type
  owner {
    id
  }
}
fragment Store on Store {
  actions {
    ...Action
  }
  api {
    ...InterfaceType
  }
  id
  name
}
fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}
fragment Field on Field {
  api {
    ... on InterfaceType {
      id
    }
  }
  defaultValues
  description
  fieldType {
    ... on IBaseType {
      __typename
      id
      kind
      name
    }
  }
  id
  key
  name
  nextSibling {
    id
  }
  prevSibling {
    id
  }
  validationRules
}
fragment InterfaceType on InterfaceType {
  ...BaseType
  fields {
    ...Field
  }
}
fragment Owner on User {
  id
}`,
  { fragmentName: 'ComponentProduction' },
) as unknown as TypedDocumentString<ComponentProductionFragment, unknown>
export const HookPropFragmentDoc = new TypedDocumentString(
  `
    fragment HookProp on Prop {
  data
  id
}
    `,
  { fragmentName: 'HookProp' },
) as unknown as TypedDocumentString<HookPropFragment, unknown>
export const HookFragmentDoc = new TypedDocumentString(
  `
    fragment Hook on Hook {
  config {
    ...HookProp
  }
  element {
    id
    name
  }
  id
  type
}
    fragment HookProp on Prop {
  data
  id
}`,
  { fragmentName: 'Hook' },
) as unknown as TypedDocumentString<HookFragment, unknown>
export const RedirectFragmentDoc = new TypedDocumentString(
  `
    fragment Redirect on Redirect {
  authGuard {
    id
  }
  id
  source {
    id
  }
  targetPage {
    id
  }
  targetType
  targetUrl
}
    `,
  { fragmentName: 'Redirect' },
) as unknown as TypedDocumentString<RedirectFragment, unknown>
export const ProductionStoreFragmentDoc = new TypedDocumentString(
  `
    fragment ProductionStore on Store {
  actions {
    ...Action
  }
  id
  name
}
    fragment BaseAction on BaseAction {
  __typename
  id
  name
  store {
    id
    name
  }
  type
}
fragment Action on BaseAction {
  ...BaseAction
  ... on CodeAction {
    ...CodeAction
  }
  ... on ApiAction {
    ...ApiAction
  }
}
fragment ApiAction on ApiAction {
  ...BaseAction
  config {
    data
    id
  }
  errorAction {
    ...BaseAction
  }
  resource {
    ...Resource
  }
  successAction {
    ...BaseAction
  }
}
fragment CodeAction on CodeAction {
  ...BaseAction
  code
}
fragment Prop on Prop {
  data
  id
}
fragment Resource on Resource {
  config {
    ...Prop
  }
  id
  name
  type
  owner {
    id
  }
}`,
  { fragmentName: 'ProductionStore' },
) as unknown as TypedDocumentString<ProductionStoreFragment, unknown>
export const TagFragmentDoc = new TypedDocumentString(
  `
    fragment Tag on Tag {
  children {
    id
    name
    owner {
      id
    }
  }
  descendants {
    id
    name
  }
  id
  name
  owner {
    id
  }
  parent {
    id
  }
}
    `,
  { fragmentName: 'Tag' },
) as unknown as TypedDocumentString<TagFragment, unknown>
export const PreferenceFragmentDoc = new TypedDocumentString(
  `
    fragment Preference on Preference {
  id
  builderBreakpointType
  builderWidth
  owner {
    id
  }
}
    `,
  { fragmentName: 'Preference' },
) as unknown as TypedDocumentString<PreferenceFragment, unknown>
export const UserFragmentDoc = new TypedDocumentString(
  `
    fragment User on User {
  apps {
    id
  }
  auth0Id
  email
  id
  preferences {
    ...Preference
  }
  roles
  username
}
    fragment Preference on Preference {
  id
  builderBreakpointType
  builderWidth
  owner {
    id
  }
}`,
  { fragmentName: 'User' },
) as unknown as TypedDocumentString<UserFragment, unknown>
export const DomainCreatedDocument = new TypedDocumentString(`
    subscription DomainCreated {
  domainCreated {
    createdDomain {
      id
      name
    }
    event
    timestamp
  }
}
    `) as unknown as TypedDocumentString<
  DomainCreatedSubscription,
  DomainCreatedSubscriptionVariables
>
export const DomainUpdatedDocument = new TypedDocumentString(`
    subscription DomainUpdated {
  domainUpdated {
    event
    timestamp
    updatedDomain {
      id
      name
    }
  }
}
    `) as unknown as TypedDocumentString<
  DomainUpdatedSubscription,
  DomainUpdatedSubscriptionVariables
>
export const DomainDeletedDocument = new TypedDocumentString(`
    subscription DomainDeleted {
  domainDeleted {
    deletedDomain {
      id
      name
    }
    event
    timestamp
  }
}
    `) as unknown as TypedDocumentString<
  DomainDeletedSubscription,
  DomainDeletedSubscriptionVariables
>
export const GetAppBuilderDocument = new TypedDocumentString(`
    query GetAppBuilder($appId: ID!, $pageIds: [ID!]) {
  actionTypes {
    ...ActionType
  }
  apps(where: {id: $appId}) {
    ...AppBuilder
  }
  atoms(where: {type: ReactFragment}) {
    ...AtomBuilder
  }
  authGuards {
    ...AuthGuard
  }
  codeMirrorTypes {
    ...CodeMirrorType
  }
  components {
    ...ComponentBuilder
  }
  primitiveTypes {
    ...PrimitiveType
  }
  reactNodeTypes {
    ...ReactNodeType
  }
  redirects(where: {source: {app: {id: $appId}}}) {
    ...Redirect
  }
  renderPropTypes {
    ...RenderPropType
  }
  resources {
    ...Resource
  }
  richTextTypes {
    ...RichTextType
  }
}
    fragment BaseAction on BaseAction {
  __typename
  id
  name
  store {
    id
    name
  }
  type
}
fragment Action on BaseAction {
  ...BaseAction
  ... on CodeAction {
    ...CodeAction
  }
  ... on ApiAction {
    ...ApiAction
  }
}
fragment ApiAction on ApiAction {
  ...BaseAction
  config {
    data
    id
  }
  errorAction {
    ...BaseAction
  }
  resource {
    ...Resource
  }
  successAction {
    ...BaseAction
  }
}
fragment CodeAction on CodeAction {
  ...BaseAction
  code
}
fragment AppBuilder on App {
  id
  name
  owner {
    ...Owner
  }
  pages(
    where: {OR: [{id_IN: $pageIds}, {kind: Provider}, {kind: NotFound}, {kind: InternalServerError}, {kind: Regular}]}
  ) {
    ...PageDevelopment
  }
  slug
}
fragment AtomBuilder on Atom {
  __typename
  api {
    ...InterfaceType
  }
  icon
  id
  name
  requiredParents {
    id
    name
    type
  }
  suggestedChildren {
    id
    name
    type
  }
  tags {
    ...TagPreview
  }
  type
  owner {
    id
  }
}
fragment AuthGuard on AuthGuard {
  config {
    ...Prop
  }
  id
  name
  resource {
    ...Resource
  }
  responseTransformer
  owner {
    id
  }
}
fragment ComponentBuilder on Component {
  __typename
  api {
    ...InterfaceType
  }
  elements {
    ...Element
  }
  id
  name
  compositeKey
  owner {
    ...Owner
  }
  props {
    ...Prop
  }
  rootElement {
    id
    name
  }
  store {
    ...Store
  }
}
fragment Element on Element {
  __typename
  childMapperComponent {
    id
    name
  }
  childMapperPreviousSibling {
    id
  }
  childMapperPropKey
  dependantTypes {
    ...Type
  }
  firstChild {
    id
  }
  id
  name
  nextSibling {
    id
  }
  page {
    id
  }
  parentComponent {
    id
  }
  parentElement {
    id
  }
  postRenderActions {
    id
    type
  }
  preRenderActions {
    id
    type
  }
  prevSibling {
    id
  }
  props {
    ...Prop
  }
  renderForEachPropKey
  renderIfExpression
  renderType {
    ... on Atom {
      __typename
      ...AtomBuilder
    }
    ... on Component {
      __typename
      id
    }
  }
  style
  tailwindClassNames
  expanded
}
fragment PageDevelopment on Page {
  app {
    id
  }
  elements {
    ...Element
  }
  id
  kind
  name
  pageContentContainer {
    id
  }
  redirect {
    id
  }
  rootElement {
    id
  }
  store {
    ...Store
  }
  urlPattern
}
fragment Prop on Prop {
  data
  id
}
fragment Redirect on Redirect {
  authGuard {
    id
  }
  id
  source {
    id
  }
  targetPage {
    id
  }
  targetType
  targetUrl
}
fragment Resource on Resource {
  config {
    ...Prop
  }
  id
  name
  type
  owner {
    id
  }
}
fragment Store on Store {
  actions {
    ...Action
  }
  api {
    ...InterfaceType
  }
  id
  name
}
fragment TagPreview on Tag {
  id
  name
  owner {
    id
  }
}
fragment ActionType on ActionType {
  ...BaseType
}
fragment AppType on AppType {
  ...BaseType
}
fragment ArrayType on ArrayType {
  ...BaseType
  itemType {
    ... on IBaseType {
      id
      kind
      name
    }
  }
}
fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}
fragment CodeMirrorType on CodeMirrorType {
  ...BaseType
  language
}
fragment ElementType on ElementType {
  ...BaseType
  elementKind
}
fragment EnumTypeValue on EnumTypeValue {
  id
  key
  value
}
fragment EnumType on EnumType {
  allowedValues {
    ...EnumTypeValue
  }
  ...BaseType
}
fragment Field on Field {
  api {
    ... on InterfaceType {
      id
    }
  }
  defaultValues
  description
  fieldType {
    ... on IBaseType {
      __typename
      id
      kind
      name
    }
  }
  id
  key
  name
  nextSibling {
    id
  }
  prevSibling {
    id
  }
  validationRules
}
fragment InterfaceType on InterfaceType {
  ...BaseType
  fields {
    ...Field
  }
}
fragment LambdaType on LambdaType {
  ...BaseType
}
fragment PageType on PageType {
  ...BaseType
}
fragment PrimitiveType on PrimitiveType {
  ...BaseType
  primitiveKind
}
fragment ReactNodeType on ReactNodeType {
  ...BaseType
}
fragment RenderPropType on RenderPropType {
  ...BaseType
}
fragment RichTextType on RichTextType {
  ...BaseType
}
fragment Type on IBaseType {
  ...ActionType
  ...AppType
  ...ArrayType
  ...CodeMirrorType
  ...ElementType
  ...EnumType
  ...InterfaceType
  ...LambdaType
  ...PageType
  ...PrimitiveType
  ...ReactNodeType
  ...RenderPropType
  ...RichTextType
  ...UnionType
}
fragment UnionType on UnionType {
  ...BaseType
  typesOfUnionType {
    ... on IBaseType {
      ...BaseType
    }
  }
}
fragment Owner on User {
  id
}`) as unknown as TypedDocumentString<
  GetAppBuilderQuery,
  GetAppBuilderQueryVariables
>
export const GetSelectAtomOptionsDocument = new TypedDocumentString(`
    query GetSelectAtomOptions {
  atoms {
    __typename
    id
    name
    requiredParents {
      id
      type
    }
    type
  }
}
    `) as unknown as TypedDocumentString<
  GetSelectAtomOptionsQuery,
  GetSelectAtomOptionsQueryVariables
>
export const GetAuthGuardsDocument = new TypedDocumentString(`
    query GetAuthGuards($options: AuthGuardOptions, $where: AuthGuardWhere) {
  aggregate: authGuardsAggregate(where: $where) {
    count
  }
  items: authGuards(options: $options, where: $where) {
    ...AuthGuard
  }
}
    fragment AuthGuard on AuthGuard {
  config {
    ...Prop
  }
  id
  name
  resource {
    ...Resource
  }
  responseTransformer
  owner {
    id
  }
}
fragment Prop on Prop {
  data
  id
}
fragment Resource on Resource {
  config {
    ...Prop
  }
  id
  name
  type
  owner {
    id
  }
}`) as unknown as TypedDocumentString<
  GetAuthGuardsQuery,
  GetAuthGuardsQueryVariables
>
export const CreateAuthGuardsDocument = new TypedDocumentString(`
    mutation CreateAuthGuards($input: [AuthGuardCreateInput!]!) {
  createAuthGuards(input: $input) {
    authGuards {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  CreateAuthGuardsMutation,
  CreateAuthGuardsMutationVariables
>
export const UpdateAuthGuardDocument = new TypedDocumentString(`
    mutation UpdateAuthGuard($where: AuthGuardWhere, $update: AuthGuardUpdateInput) {
  updateAuthGuards(update: $update, where: $where) {
    authGuards {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  UpdateAuthGuardMutation,
  UpdateAuthGuardMutationVariables
>
export const DeleteAuthGuardsDocument = new TypedDocumentString(`
    mutation DeleteAuthGuards($where: AuthGuardWhere, $delete: AuthGuardDeleteInput) {
  deleteAuthGuards(where: $where, delete: $delete) {
    nodesDeleted
  }
}
    `) as unknown as TypedDocumentString<
  DeleteAuthGuardsMutation,
  DeleteAuthGuardsMutationVariables
>
export const GetComponentBuilderDocument = new TypedDocumentString(`
    query GetComponentBuilder {
  actionTypes {
    ...ActionType
  }
  atoms(where: {type: ReactFragment}) {
    ...AtomBuilder
  }
  codeMirrorTypes {
    ...CodeMirrorType
  }
  components {
    ...ComponentBuilder
  }
  primitiveTypes {
    ...PrimitiveType
  }
  reactNodeTypes {
    ...ReactNodeType
  }
  renderPropTypes {
    ...RenderPropType
  }
  resources {
    ...Resource
  }
  richTextTypes {
    ...RichTextType
  }
}
    fragment BaseAction on BaseAction {
  __typename
  id
  name
  store {
    id
    name
  }
  type
}
fragment Action on BaseAction {
  ...BaseAction
  ... on CodeAction {
    ...CodeAction
  }
  ... on ApiAction {
    ...ApiAction
  }
}
fragment ApiAction on ApiAction {
  ...BaseAction
  config {
    data
    id
  }
  errorAction {
    ...BaseAction
  }
  resource {
    ...Resource
  }
  successAction {
    ...BaseAction
  }
}
fragment CodeAction on CodeAction {
  ...BaseAction
  code
}
fragment AtomBuilder on Atom {
  __typename
  api {
    ...InterfaceType
  }
  icon
  id
  name
  requiredParents {
    id
    name
    type
  }
  suggestedChildren {
    id
    name
    type
  }
  tags {
    ...TagPreview
  }
  type
  owner {
    id
  }
}
fragment ComponentBuilder on Component {
  __typename
  api {
    ...InterfaceType
  }
  elements {
    ...Element
  }
  id
  name
  compositeKey
  owner {
    ...Owner
  }
  props {
    ...Prop
  }
  rootElement {
    id
    name
  }
  store {
    ...Store
  }
}
fragment Element on Element {
  __typename
  childMapperComponent {
    id
    name
  }
  childMapperPreviousSibling {
    id
  }
  childMapperPropKey
  dependantTypes {
    ...Type
  }
  firstChild {
    id
  }
  id
  name
  nextSibling {
    id
  }
  page {
    id
  }
  parentComponent {
    id
  }
  parentElement {
    id
  }
  postRenderActions {
    id
    type
  }
  preRenderActions {
    id
    type
  }
  prevSibling {
    id
  }
  props {
    ...Prop
  }
  renderForEachPropKey
  renderIfExpression
  renderType {
    ... on Atom {
      __typename
      ...AtomBuilder
    }
    ... on Component {
      __typename
      id
    }
  }
  style
  tailwindClassNames
  expanded
}
fragment Prop on Prop {
  data
  id
}
fragment Resource on Resource {
  config {
    ...Prop
  }
  id
  name
  type
  owner {
    id
  }
}
fragment Store on Store {
  actions {
    ...Action
  }
  api {
    ...InterfaceType
  }
  id
  name
}
fragment TagPreview on Tag {
  id
  name
  owner {
    id
  }
}
fragment ActionType on ActionType {
  ...BaseType
}
fragment AppType on AppType {
  ...BaseType
}
fragment ArrayType on ArrayType {
  ...BaseType
  itemType {
    ... on IBaseType {
      id
      kind
      name
    }
  }
}
fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}
fragment CodeMirrorType on CodeMirrorType {
  ...BaseType
  language
}
fragment ElementType on ElementType {
  ...BaseType
  elementKind
}
fragment EnumTypeValue on EnumTypeValue {
  id
  key
  value
}
fragment EnumType on EnumType {
  allowedValues {
    ...EnumTypeValue
  }
  ...BaseType
}
fragment Field on Field {
  api {
    ... on InterfaceType {
      id
    }
  }
  defaultValues
  description
  fieldType {
    ... on IBaseType {
      __typename
      id
      kind
      name
    }
  }
  id
  key
  name
  nextSibling {
    id
  }
  prevSibling {
    id
  }
  validationRules
}
fragment InterfaceType on InterfaceType {
  ...BaseType
  fields {
    ...Field
  }
}
fragment LambdaType on LambdaType {
  ...BaseType
}
fragment PageType on PageType {
  ...BaseType
}
fragment PrimitiveType on PrimitiveType {
  ...BaseType
  primitiveKind
}
fragment ReactNodeType on ReactNodeType {
  ...BaseType
}
fragment RenderPropType on RenderPropType {
  ...BaseType
}
fragment RichTextType on RichTextType {
  ...BaseType
}
fragment Type on IBaseType {
  ...ActionType
  ...AppType
  ...ArrayType
  ...CodeMirrorType
  ...ElementType
  ...EnumType
  ...InterfaceType
  ...LambdaType
  ...PageType
  ...PrimitiveType
  ...ReactNodeType
  ...RenderPropType
  ...RichTextType
  ...UnionType
}
fragment UnionType on UnionType {
  ...BaseType
  typesOfUnionType {
    ... on IBaseType {
      ...BaseType
    }
  }
}
fragment Owner on User {
  id
}`) as unknown as TypedDocumentString<
  GetComponentBuilderQuery,
  GetComponentBuilderQueryVariables
>
export const CreateComponentsDocument = new TypedDocumentString(`
    mutation CreateComponents($input: [ComponentCreateInput!]!) {
  createComponents(input: $input) {
    components {
      id
      store {
        id
      }
    }
  }
}
    `) as unknown as TypedDocumentString<
  CreateComponentsMutation,
  CreateComponentsMutationVariables
>
export const DeleteComponentsDocument = new TypedDocumentString(`
    mutation DeleteComponents($where: ComponentWhere, $delete: ComponentDeleteInput) {
  deleteComponents(delete: $delete, where: $where) {
    nodesDeleted
  }
}
    `) as unknown as TypedDocumentString<
  DeleteComponentsMutation,
  DeleteComponentsMutationVariables
>
export const UpdateComponentsDocument = new TypedDocumentString(`
    mutation UpdateComponents($where: ComponentWhere, $update: ComponentUpdateInput) {
  updateComponents(update: $update, where: $where) {
    components {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  UpdateComponentsMutation,
  UpdateComponentsMutationVariables
>
export const ComponentListDocument = new TypedDocumentString(`
    query ComponentList($options: ComponentOptions, $where: ComponentWhere) {
  aggregate: componentsAggregate(where: $where) {
    count
  }
  items: components(options: $options, where: $where) {
    ...Component
  }
}
    fragment BaseAction on BaseAction {
  __typename
  id
  name
  store {
    id
    name
  }
  type
}
fragment Action on BaseAction {
  ...BaseAction
  ... on CodeAction {
    ...CodeAction
  }
  ... on ApiAction {
    ...ApiAction
  }
}
fragment ApiAction on ApiAction {
  ...BaseAction
  config {
    data
    id
  }
  errorAction {
    ...BaseAction
  }
  resource {
    ...Resource
  }
  successAction {
    ...BaseAction
  }
}
fragment CodeAction on CodeAction {
  ...BaseAction
  code
}
fragment Component on Component {
  __typename
  api {
    id
  }
  id
  name
  compositeKey
  owner {
    ...Owner
  }
  props {
    ...Prop
  }
  rootElement {
    id
  }
  store {
    ...Store
  }
}
fragment Prop on Prop {
  data
  id
}
fragment Resource on Resource {
  config {
    ...Prop
  }
  id
  name
  type
  owner {
    id
  }
}
fragment Store on Store {
  actions {
    ...Action
  }
  api {
    ...InterfaceType
  }
  id
  name
}
fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}
fragment Field on Field {
  api {
    ... on InterfaceType {
      id
    }
  }
  defaultValues
  description
  fieldType {
    ... on IBaseType {
      __typename
      id
      kind
      name
    }
  }
  id
  key
  name
  nextSibling {
    id
  }
  prevSibling {
    id
  }
  validationRules
}
fragment InterfaceType on InterfaceType {
  ...BaseType
  fields {
    ...Field
  }
}
fragment Owner on User {
  id
}`) as unknown as TypedDocumentString<
  ComponentListQuery,
  ComponentListQueryVariables
>
export const DomainListDocument = new TypedDocumentString(`
    query DomainList($options: DomainOptions, $where: DomainWhere) {
  aggregate: domainsAggregate(where: $where) {
    count
  }
  items: domains(options: $options, where: $where) {
    ...Domain
  }
}
    fragment Domain on Domain {
  app {
    id
  }
  domainConfig {
    misconfigured
  }
  id
  name
}`) as unknown as TypedDocumentString<DomainListQuery, DomainListQueryVariables>
export const CreateDomainsDocument = new TypedDocumentString(`
    mutation CreateDomains($input: [DomainCreateInput!]!) {
  createDomains(input: $input) {
    domains {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  CreateDomainsMutation,
  CreateDomainsMutationVariables
>
export const UpdateDomainsDocument = new TypedDocumentString(`
    mutation UpdateDomains($where: DomainWhere!, $update: DomainUpdateInput!) {
  updateDomains(update: $update, where: $where) {
    domains {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  UpdateDomainsMutation,
  UpdateDomainsMutationVariables
>
export const DeleteDomainsDocument = new TypedDocumentString(`
    mutation DeleteDomains($where: DomainWhere!) {
  deleteDomains(where: $where) {
    nodesDeleted
  }
}
    `) as unknown as TypedDocumentString<
  DeleteDomainsMutation,
  DeleteDomainsMutationVariables
>
export const CreateElementsDocument = new TypedDocumentString(`
    mutation CreateElements($input: [ElementCreateInput!]!) {
  createElements(input: $input) {
    elements {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  CreateElementsMutation,
  CreateElementsMutationVariables
>
export const DeleteElementsDocument = new TypedDocumentString(`
    mutation DeleteElements($where: ElementWhere!, $delete: ElementDeleteInput) {
  deleteElements(delete: $delete, where: $where) {
    nodesDeleted
  }
}
    `) as unknown as TypedDocumentString<
  DeleteElementsMutation,
  DeleteElementsMutationVariables
>
export const UpdateElementsDocument = new TypedDocumentString(`
    mutation UpdateElements($where: ElementWhere, $update: ElementUpdateInput) {
  updateElements(update: $update, where: $where) {
    elements {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  UpdateElementsMutation,
  UpdateElementsMutationVariables
>
export const ElementListDocument = new TypedDocumentString(`
    query ElementList($options: ElementOptions, $where: ElementWhere) {
  aggregate: elementsAggregate(where: $where) {
    count
  }
  items: elements(options: $options, where: $where) {
    ...Element
  }
}
    fragment AtomBuilder on Atom {
  __typename
  api {
    ...InterfaceType
  }
  icon
  id
  name
  requiredParents {
    id
    name
    type
  }
  suggestedChildren {
    id
    name
    type
  }
  tags {
    ...TagPreview
  }
  type
  owner {
    id
  }
}
fragment Element on Element {
  __typename
  childMapperComponent {
    id
    name
  }
  childMapperPreviousSibling {
    id
  }
  childMapperPropKey
  dependantTypes {
    ...Type
  }
  firstChild {
    id
  }
  id
  name
  nextSibling {
    id
  }
  page {
    id
  }
  parentComponent {
    id
  }
  parentElement {
    id
  }
  postRenderActions {
    id
    type
  }
  preRenderActions {
    id
    type
  }
  prevSibling {
    id
  }
  props {
    ...Prop
  }
  renderForEachPropKey
  renderIfExpression
  renderType {
    ... on Atom {
      __typename
      ...AtomBuilder
    }
    ... on Component {
      __typename
      id
    }
  }
  style
  tailwindClassNames
  expanded
}
fragment Prop on Prop {
  data
  id
}
fragment TagPreview on Tag {
  id
  name
  owner {
    id
  }
}
fragment ActionType on ActionType {
  ...BaseType
}
fragment AppType on AppType {
  ...BaseType
}
fragment ArrayType on ArrayType {
  ...BaseType
  itemType {
    ... on IBaseType {
      id
      kind
      name
    }
  }
}
fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}
fragment CodeMirrorType on CodeMirrorType {
  ...BaseType
  language
}
fragment ElementType on ElementType {
  ...BaseType
  elementKind
}
fragment EnumTypeValue on EnumTypeValue {
  id
  key
  value
}
fragment EnumType on EnumType {
  allowedValues {
    ...EnumTypeValue
  }
  ...BaseType
}
fragment Field on Field {
  api {
    ... on InterfaceType {
      id
    }
  }
  defaultValues
  description
  fieldType {
    ... on IBaseType {
      __typename
      id
      kind
      name
    }
  }
  id
  key
  name
  nextSibling {
    id
  }
  prevSibling {
    id
  }
  validationRules
}
fragment InterfaceType on InterfaceType {
  ...BaseType
  fields {
    ...Field
  }
}
fragment LambdaType on LambdaType {
  ...BaseType
}
fragment PageType on PageType {
  ...BaseType
}
fragment PrimitiveType on PrimitiveType {
  ...BaseType
  primitiveKind
}
fragment ReactNodeType on ReactNodeType {
  ...BaseType
}
fragment RenderPropType on RenderPropType {
  ...BaseType
}
fragment RichTextType on RichTextType {
  ...BaseType
}
fragment Type on IBaseType {
  ...ActionType
  ...AppType
  ...ArrayType
  ...CodeMirrorType
  ...ElementType
  ...EnumType
  ...InterfaceType
  ...LambdaType
  ...PageType
  ...PrimitiveType
  ...ReactNodeType
  ...RenderPropType
  ...RichTextType
  ...UnionType
}
fragment UnionType on UnionType {
  ...BaseType
  typesOfUnionType {
    ... on IBaseType {
      ...BaseType
    }
  }
}`) as unknown as TypedDocumentString<
  ElementListQuery,
  ElementListQueryVariables
>
export const CreateHooksDocument = new TypedDocumentString(`
    mutation CreateHooks($input: [HookCreateInput!]!) {
  createHooks(input: $input) {
    hooks {
      ...Hook
    }
  }
}
    fragment HookProp on Prop {
  data
  id
}
fragment Hook on Hook {
  config {
    ...HookProp
  }
  element {
    id
    name
  }
  id
  type
}`) as unknown as TypedDocumentString<
  CreateHooksMutation,
  CreateHooksMutationVariables
>
export const DeleteHooksDocument = new TypedDocumentString(`
    mutation DeleteHooks($where: HookWhere!) {
  deleteHooks(where: $where) {
    nodesDeleted
  }
}
    `) as unknown as TypedDocumentString<
  DeleteHooksMutation,
  DeleteHooksMutationVariables
>
export const CreatePagesDocument = new TypedDocumentString(`
    mutation CreatePages($input: [PageCreateInput!]!) {
  createPages(input: $input) {
    pages {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  CreatePagesMutation,
  CreatePagesMutationVariables
>
export const DeletePagesDocument = new TypedDocumentString(`
    mutation DeletePages($where: PageWhere, $delete: PageDeleteInput) {
  deletePages(delete: $delete, where: $where) {
    nodesDeleted
  }
}
    `) as unknown as TypedDocumentString<
  DeletePagesMutation,
  DeletePagesMutationVariables
>
export const UpdatePagesDocument = new TypedDocumentString(`
    mutation UpdatePages($where: PageWhere, $update: PageUpdateInput) {
  updatePages(update: $update, where: $where) {
    pages {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  UpdatePagesMutation,
  UpdatePagesMutationVariables
>
export const PageListDocument = new TypedDocumentString(`
    query PageList($options: PageOptions, $where: PageWhere) {
  aggregate: pagesAggregate(where: $where) {
    count
  }
  items: pages(options: $options, where: $where) {
    ...Page
  }
}
    fragment BaseAction on BaseAction {
  __typename
  id
  name
  store {
    id
    name
  }
  type
}
fragment Action on BaseAction {
  ...BaseAction
  ... on CodeAction {
    ...CodeAction
  }
  ... on ApiAction {
    ...ApiAction
  }
}
fragment ApiAction on ApiAction {
  ...BaseAction
  config {
    data
    id
  }
  errorAction {
    ...BaseAction
  }
  resource {
    ...Resource
  }
  successAction {
    ...BaseAction
  }
}
fragment CodeAction on CodeAction {
  ...BaseAction
  code
}
fragment AtomBuilder on Atom {
  __typename
  api {
    ...InterfaceType
  }
  icon
  id
  name
  requiredParents {
    id
    name
    type
  }
  suggestedChildren {
    id
    name
    type
  }
  tags {
    ...TagPreview
  }
  type
  owner {
    id
  }
}
fragment Element on Element {
  __typename
  childMapperComponent {
    id
    name
  }
  childMapperPreviousSibling {
    id
  }
  childMapperPropKey
  dependantTypes {
    ...Type
  }
  firstChild {
    id
  }
  id
  name
  nextSibling {
    id
  }
  page {
    id
  }
  parentComponent {
    id
  }
  parentElement {
    id
  }
  postRenderActions {
    id
    type
  }
  preRenderActions {
    id
    type
  }
  prevSibling {
    id
  }
  props {
    ...Prop
  }
  renderForEachPropKey
  renderIfExpression
  renderType {
    ... on Atom {
      __typename
      ...AtomBuilder
    }
    ... on Component {
      __typename
      id
    }
  }
  style
  tailwindClassNames
  expanded
}
fragment Page on Page {
  app {
    id
  }
  elements {
    ...Element
  }
  id
  kind
  name
  pageContentContainer {
    id
  }
  redirect {
    id
  }
  rootElement {
    id
  }
  store {
    ...Store
  }
  urlPattern
}
fragment Prop on Prop {
  data
  id
}
fragment Resource on Resource {
  config {
    ...Prop
  }
  id
  name
  type
  owner {
    id
  }
}
fragment Store on Store {
  actions {
    ...Action
  }
  api {
    ...InterfaceType
  }
  id
  name
}
fragment TagPreview on Tag {
  id
  name
  owner {
    id
  }
}
fragment ActionType on ActionType {
  ...BaseType
}
fragment AppType on AppType {
  ...BaseType
}
fragment ArrayType on ArrayType {
  ...BaseType
  itemType {
    ... on IBaseType {
      id
      kind
      name
    }
  }
}
fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}
fragment CodeMirrorType on CodeMirrorType {
  ...BaseType
  language
}
fragment ElementType on ElementType {
  ...BaseType
  elementKind
}
fragment EnumTypeValue on EnumTypeValue {
  id
  key
  value
}
fragment EnumType on EnumType {
  allowedValues {
    ...EnumTypeValue
  }
  ...BaseType
}
fragment Field on Field {
  api {
    ... on InterfaceType {
      id
    }
  }
  defaultValues
  description
  fieldType {
    ... on IBaseType {
      __typename
      id
      kind
      name
    }
  }
  id
  key
  name
  nextSibling {
    id
  }
  prevSibling {
    id
  }
  validationRules
}
fragment InterfaceType on InterfaceType {
  ...BaseType
  fields {
    ...Field
  }
}
fragment LambdaType on LambdaType {
  ...BaseType
}
fragment PageType on PageType {
  ...BaseType
}
fragment PrimitiveType on PrimitiveType {
  ...BaseType
  primitiveKind
}
fragment ReactNodeType on ReactNodeType {
  ...BaseType
}
fragment RenderPropType on RenderPropType {
  ...BaseType
}
fragment RichTextType on RichTextType {
  ...BaseType
}
fragment Type on IBaseType {
  ...ActionType
  ...AppType
  ...ArrayType
  ...CodeMirrorType
  ...ElementType
  ...EnumType
  ...InterfaceType
  ...LambdaType
  ...PageType
  ...PrimitiveType
  ...ReactNodeType
  ...RenderPropType
  ...RichTextType
  ...UnionType
}
fragment UnionType on UnionType {
  ...BaseType
  typesOfUnionType {
    ... on IBaseType {
      ...BaseType
    }
  }
}`) as unknown as TypedDocumentString<PageListQuery, PageListQueryVariables>
export const GetRenderedPageDocument = new TypedDocumentString(`
    query GetRenderedPage($pageId: ID!) {
  pages(where: {id: $pageId}) {
    ...PageDevelopment
  }
}
    fragment BaseAction on BaseAction {
  __typename
  id
  name
  store {
    id
    name
  }
  type
}
fragment Action on BaseAction {
  ...BaseAction
  ... on CodeAction {
    ...CodeAction
  }
  ... on ApiAction {
    ...ApiAction
  }
}
fragment ApiAction on ApiAction {
  ...BaseAction
  config {
    data
    id
  }
  errorAction {
    ...BaseAction
  }
  resource {
    ...Resource
  }
  successAction {
    ...BaseAction
  }
}
fragment CodeAction on CodeAction {
  ...BaseAction
  code
}
fragment AtomBuilder on Atom {
  __typename
  api {
    ...InterfaceType
  }
  icon
  id
  name
  requiredParents {
    id
    name
    type
  }
  suggestedChildren {
    id
    name
    type
  }
  tags {
    ...TagPreview
  }
  type
  owner {
    id
  }
}
fragment Element on Element {
  __typename
  childMapperComponent {
    id
    name
  }
  childMapperPreviousSibling {
    id
  }
  childMapperPropKey
  dependantTypes {
    ...Type
  }
  firstChild {
    id
  }
  id
  name
  nextSibling {
    id
  }
  page {
    id
  }
  parentComponent {
    id
  }
  parentElement {
    id
  }
  postRenderActions {
    id
    type
  }
  preRenderActions {
    id
    type
  }
  prevSibling {
    id
  }
  props {
    ...Prop
  }
  renderForEachPropKey
  renderIfExpression
  renderType {
    ... on Atom {
      __typename
      ...AtomBuilder
    }
    ... on Component {
      __typename
      id
    }
  }
  style
  tailwindClassNames
  expanded
}
fragment PageDevelopment on Page {
  app {
    id
  }
  elements {
    ...Element
  }
  id
  kind
  name
  pageContentContainer {
    id
  }
  redirect {
    id
  }
  rootElement {
    id
  }
  store {
    ...Store
  }
  urlPattern
}
fragment Prop on Prop {
  data
  id
}
fragment Resource on Resource {
  config {
    ...Prop
  }
  id
  name
  type
  owner {
    id
  }
}
fragment Store on Store {
  actions {
    ...Action
  }
  api {
    ...InterfaceType
  }
  id
  name
}
fragment TagPreview on Tag {
  id
  name
  owner {
    id
  }
}
fragment ActionType on ActionType {
  ...BaseType
}
fragment AppType on AppType {
  ...BaseType
}
fragment ArrayType on ArrayType {
  ...BaseType
  itemType {
    ... on IBaseType {
      id
      kind
      name
    }
  }
}
fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}
fragment CodeMirrorType on CodeMirrorType {
  ...BaseType
  language
}
fragment ElementType on ElementType {
  ...BaseType
  elementKind
}
fragment EnumTypeValue on EnumTypeValue {
  id
  key
  value
}
fragment EnumType on EnumType {
  allowedValues {
    ...EnumTypeValue
  }
  ...BaseType
}
fragment Field on Field {
  api {
    ... on InterfaceType {
      id
    }
  }
  defaultValues
  description
  fieldType {
    ... on IBaseType {
      __typename
      id
      kind
      name
    }
  }
  id
  key
  name
  nextSibling {
    id
  }
  prevSibling {
    id
  }
  validationRules
}
fragment InterfaceType on InterfaceType {
  ...BaseType
  fields {
    ...Field
  }
}
fragment LambdaType on LambdaType {
  ...BaseType
}
fragment PageType on PageType {
  ...BaseType
}
fragment PrimitiveType on PrimitiveType {
  ...BaseType
  primitiveKind
}
fragment ReactNodeType on ReactNodeType {
  ...BaseType
}
fragment RenderPropType on RenderPropType {
  ...BaseType
}
fragment RichTextType on RichTextType {
  ...BaseType
}
fragment Type on IBaseType {
  ...ActionType
  ...AppType
  ...ArrayType
  ...CodeMirrorType
  ...ElementType
  ...EnumType
  ...InterfaceType
  ...LambdaType
  ...PageType
  ...PrimitiveType
  ...ReactNodeType
  ...RenderPropType
  ...RichTextType
  ...UnionType
}
fragment UnionType on UnionType {
  ...BaseType
  typesOfUnionType {
    ... on IBaseType {
      ...BaseType
    }
  }
}`) as unknown as TypedDocumentString<
  GetRenderedPageQuery,
  GetRenderedPageQueryVariables
>
export const CreatePreferencesDocument = new TypedDocumentString(`
    mutation CreatePreferences($input: [PreferenceCreateInput!]!) {
  createPreferences(input: $input) {
    info {
      nodesCreated
      relationshipsCreated
    }
    preferences {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  CreatePreferencesMutation,
  CreatePreferencesMutationVariables
>
export const DeletePreferencesDocument = new TypedDocumentString(`
    mutation DeletePreferences($where: PreferenceWhere, $delete: PreferenceDeleteInput) {
  deletePreferences(delete: $delete, where: $where) {
    nodesDeleted
  }
}
    `) as unknown as TypedDocumentString<
  DeletePreferencesMutation,
  DeletePreferencesMutationVariables
>
export const GetPreferencesDocument = new TypedDocumentString(`
    query GetPreferences($where: PreferenceWhere, $options: PreferenceOptions) {
  aggregate: preferencesAggregate(where: $where) {
    count
  }
  items: preferences(options: $options, where: $where) {
    ...Preference
  }
}
    fragment Preference on Preference {
  id
  builderBreakpointType
  builderWidth
  owner {
    id
  }
}`) as unknown as TypedDocumentString<
  GetPreferencesQuery,
  GetPreferencesQueryVariables
>
export const UpdatePreferencesDocument = new TypedDocumentString(`
    mutation UpdatePreferences($where: PreferenceWhere, $update: PreferenceUpdateInput) {
  updatePreferences(update: $update, where: $where) {
    preferences {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  UpdatePreferencesMutation,
  UpdatePreferencesMutationVariables
>
export const CreatePropsDocument = new TypedDocumentString(`
    mutation CreateProps($input: [PropCreateInput!]!) {
  createProps(input: $input) {
    props {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  CreatePropsMutation,
  CreatePropsMutationVariables
>
export const UpdatePropsDocument = new TypedDocumentString(`
    mutation UpdateProps($where: PropWhere, $update: PropUpdateInput) {
  updateProps(update: $update, where: $where) {
    props {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  UpdatePropsMutation,
  UpdatePropsMutationVariables
>
export const DeletePropsDocument = new TypedDocumentString(`
    mutation DeleteProps($where: PropWhere!) {
  deleteProps(where: $where) {
    nodesDeleted
  }
}
    `) as unknown as TypedDocumentString<
  DeletePropsMutation,
  DeletePropsMutationVariables
>
export const GetPropsDocument = new TypedDocumentString(`
    query GetProps($options: PropOptions, $where: PropWhere) {
  aggregate: propsAggregate(where: $where) {
    count
  }
  items: props(options: $options, where: $where) {
    ...Prop
  }
}
    fragment Prop on Prop {
  data
  id
}`) as unknown as TypedDocumentString<GetPropsQuery, GetPropsQueryVariables>
export const CreateRedirectsDocument = new TypedDocumentString(`
    mutation CreateRedirects($input: [RedirectCreateInput!]!) {
  createRedirects(input: $input) {
    redirects {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  CreateRedirectsMutation,
  CreateRedirectsMutationVariables
>
export const DeleteRedirectsDocument = new TypedDocumentString(`
    mutation DeleteRedirects($where: RedirectWhere, $delete: RedirectDeleteInput) {
  deleteRedirects(delete: $delete, where: $where) {
    nodesDeleted
  }
}
    `) as unknown as TypedDocumentString<
  DeleteRedirectsMutation,
  DeleteRedirectsMutationVariables
>
export const UpdateRedirectsDocument = new TypedDocumentString(`
    mutation UpdateRedirects($where: RedirectWhere, $update: RedirectUpdateInput) {
  updateRedirects(update: $update, where: $where) {
    redirects {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  UpdateRedirectsMutation,
  UpdateRedirectsMutationVariables
>
export const GetRedirectsDocument = new TypedDocumentString(`
    query GetRedirects($options: RedirectOptions, $where: RedirectWhere) {
  aggregate: redirectsAggregate(where: $where) {
    count
  }
  items: redirects(options: $options, where: $where) {
    ...Redirect
  }
}
    fragment Redirect on Redirect {
  authGuard {
    id
  }
  id
  source {
    id
  }
  targetPage {
    id
  }
  targetType
  targetUrl
}`) as unknown as TypedDocumentString<
  GetRedirectsQuery,
  GetRedirectsQueryVariables
>
export const ResourceListDocument = new TypedDocumentString(`
    query ResourceList($options: ResourceOptions, $where: ResourceWhere) {
  aggregate: resourcesAggregate(where: $where) {
    count
  }
  items: resources(options: $options, where: $where) {
    ...Resource
  }
}
    fragment Prop on Prop {
  data
  id
}
fragment Resource on Resource {
  config {
    ...Prop
  }
  id
  name
  type
  owner {
    id
  }
}`) as unknown as TypedDocumentString<
  ResourceListQuery,
  ResourceListQueryVariables
>
export const CreateResourcesDocument = new TypedDocumentString(`
    mutation CreateResources($input: [ResourceCreateInput!]!) {
  createResources(input: $input) {
    resources {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  CreateResourcesMutation,
  CreateResourcesMutationVariables
>
export const UpdateResourceDocument = new TypedDocumentString(`
    mutation UpdateResource($where: ResourceWhere, $update: ResourceUpdateInput) {
  updateResources(update: $update, where: $where) {
    resources {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  UpdateResourceMutation,
  UpdateResourceMutationVariables
>
export const DeleteResourcesDocument = new TypedDocumentString(`
    mutation DeleteResources($where: ResourceWhere, $delete: ResourceDeleteInput) {
  deleteResources(where: $where, delete: $delete) {
    nodesDeleted
  }
}
    `) as unknown as TypedDocumentString<
  DeleteResourcesMutation,
  DeleteResourcesMutationVariables
>
export const CreateCodeActionsDocument = new TypedDocumentString(`
    mutation CreateCodeActions($input: [CodeActionCreateInput!]!) {
  createCodeActions(input: $input) {
    codeActions {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  CreateCodeActionsMutation,
  CreateCodeActionsMutationVariables
>
export const CreateApiActionsDocument = new TypedDocumentString(`
    mutation CreateApiActions($input: [ApiActionCreateInput!]!) {
  createApiActions(input: $input) {
    apiActions {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  CreateApiActionsMutation,
  CreateApiActionsMutationVariables
>
export const DeleteCodeActionsDocument = new TypedDocumentString(`
    mutation DeleteCodeActions($where: CodeActionWhere!, $delete: CodeActionDeleteInput) {
  deleteCodeActions(delete: $delete, where: $where) {
    nodesDeleted
    relationshipsDeleted
  }
}
    `) as unknown as TypedDocumentString<
  DeleteCodeActionsMutation,
  DeleteCodeActionsMutationVariables
>
export const DeleteApiActionsDocument = new TypedDocumentString(`
    mutation DeleteApiActions($where: ApiActionWhere!, $delete: ApiActionDeleteInput) {
  deleteApiActions(delete: $delete, where: $where) {
    nodesDeleted
    relationshipsDeleted
  }
}
    `) as unknown as TypedDocumentString<
  DeleteApiActionsMutation,
  DeleteApiActionsMutationVariables
>
export const GetActionsDocument = new TypedDocumentString(`
    query GetActions($codeActionWhere: CodeActionWhere, $apiActionWhere: ApiActionWhere) {
  apiActions(where: $apiActionWhere) {
    ...Action
  }
  codeActions(where: $codeActionWhere) {
    ...Action
  }
}
    fragment BaseAction on BaseAction {
  __typename
  id
  name
  store {
    id
    name
  }
  type
}
fragment Action on BaseAction {
  ...BaseAction
  ... on CodeAction {
    ...CodeAction
  }
  ... on ApiAction {
    ...ApiAction
  }
}
fragment ApiAction on ApiAction {
  ...BaseAction
  config {
    data
    id
  }
  errorAction {
    ...BaseAction
  }
  resource {
    ...Resource
  }
  successAction {
    ...BaseAction
  }
}
fragment CodeAction on CodeAction {
  ...BaseAction
  code
}
fragment Prop on Prop {
  data
  id
}
fragment Resource on Resource {
  config {
    ...Prop
  }
  id
  name
  type
  owner {
    id
  }
}`) as unknown as TypedDocumentString<GetActionsQuery, GetActionsQueryVariables>
export const CreateStoresDocument = new TypedDocumentString(`
    mutation CreateStores($input: [StoreCreateInput!]!) {
  createStores(input: $input) {
    info {
      nodesCreated
      relationshipsCreated
    }
    stores {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  CreateStoresMutation,
  CreateStoresMutationVariables
>
export const DeleteStoresDocument = new TypedDocumentString(`
    mutation DeleteStores($where: StoreWhere, $delete: StoreDeleteInput) {
  deleteStores(delete: $delete, where: $where) {
    nodesDeleted
  }
}
    `) as unknown as TypedDocumentString<
  DeleteStoresMutation,
  DeleteStoresMutationVariables
>
export const GetStoresDocument = new TypedDocumentString(`
    query GetStores($where: StoreWhere, $options: StoreOptions) {
  aggregate: storesAggregate(where: $where) {
    count
  }
  items: stores(options: $options, where: $where) {
    ...Store
  }
}
    fragment BaseAction on BaseAction {
  __typename
  id
  name
  store {
    id
    name
  }
  type
}
fragment Action on BaseAction {
  ...BaseAction
  ... on CodeAction {
    ...CodeAction
  }
  ... on ApiAction {
    ...ApiAction
  }
}
fragment ApiAction on ApiAction {
  ...BaseAction
  config {
    data
    id
  }
  errorAction {
    ...BaseAction
  }
  resource {
    ...Resource
  }
  successAction {
    ...BaseAction
  }
}
fragment CodeAction on CodeAction {
  ...BaseAction
  code
}
fragment Prop on Prop {
  data
  id
}
fragment Resource on Resource {
  config {
    ...Prop
  }
  id
  name
  type
  owner {
    id
  }
}
fragment Store on Store {
  actions {
    ...Action
  }
  api {
    ...InterfaceType
  }
  id
  name
}
fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}
fragment Field on Field {
  api {
    ... on InterfaceType {
      id
    }
  }
  defaultValues
  description
  fieldType {
    ... on IBaseType {
      __typename
      id
      kind
      name
    }
  }
  id
  key
  name
  nextSibling {
    id
  }
  prevSibling {
    id
  }
  validationRules
}
fragment InterfaceType on InterfaceType {
  ...BaseType
  fields {
    ...Field
  }
}`) as unknown as TypedDocumentString<GetStoresQuery, GetStoresQueryVariables>
export const UpdateStoresDocument = new TypedDocumentString(`
    mutation UpdateStores($where: StoreWhere, $update: StoreUpdateInput) {
  updateStores(update: $update, where: $where) {
    stores {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  UpdateStoresMutation,
  UpdateStoresMutationVariables
>
export const UpdateCodeActionsDocument = new TypedDocumentString(`
    mutation UpdateCodeActions($update: CodeActionUpdateInput, $where: CodeActionWhere) {
  updateCodeActions(update: $update, where: $where) {
    codeActions {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  UpdateCodeActionsMutation,
  UpdateCodeActionsMutationVariables
>
export const UpdateApiActionsDocument = new TypedDocumentString(`
    mutation UpdateApiActions($update: ApiActionUpdateInput, $where: ApiActionWhere) {
  updateApiActions(update: $update, where: $where) {
    apiActions {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  UpdateApiActionsMutation,
  UpdateApiActionsMutationVariables
>
export const CreateTagsDocument = new TypedDocumentString(`
    mutation CreateTags($input: [TagCreateInput!]!) {
  createTags(input: $input) {
    tags {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  CreateTagsMutation,
  CreateTagsMutationVariables
>
export const UpdateTagsDocument = new TypedDocumentString(`
    mutation UpdateTags($where: TagWhere!, $update: TagUpdateInput!) {
  updateTags(update: $update, where: $where) {
    tags {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  UpdateTagsMutation,
  UpdateTagsMutationVariables
>
export const DeleteTagsDocument = new TypedDocumentString(`
    mutation DeleteTags($where: TagWhere!) {
  deleteTags(where: $where) {
    nodesDeleted
  }
}
    `) as unknown as TypedDocumentString<
  DeleteTagsMutation,
  DeleteTagsMutationVariables
>
export const GetTagsDocument = new TypedDocumentString(`
    query GetTags($options: TagOptions, $where: TagWhere) {
  aggregate: tagsAggregate(where: $where) {
    count
  }
  items: tags(options: $options, where: $where) {
    ...Tag
  }
}
    fragment Tag on Tag {
  children {
    id
    name
    owner {
      id
    }
  }
  descendants {
    id
    name
  }
  id
  name
  owner {
    id
  }
  parent {
    id
  }
}`) as unknown as TypedDocumentString<GetTagsQuery, GetTagsQueryVariables>
export const CreatePrimitiveTypesDocument = new TypedDocumentString(`
    mutation CreatePrimitiveTypes($input: [PrimitiveTypeCreateInput!]!) {
  types: createPrimitiveTypes(input: $input) {
    types: primitiveTypes {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  CreatePrimitiveTypesMutation,
  CreatePrimitiveTypesMutationVariables
>
export const CreateArrayTypesDocument = new TypedDocumentString(`
    mutation CreateArrayTypes($input: [ArrayTypeCreateInput!]!) {
  types: createArrayTypes(input: $input) {
    types: arrayTypes {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  CreateArrayTypesMutation,
  CreateArrayTypesMutationVariables
>
export const CreateUnionTypesDocument = new TypedDocumentString(`
    mutation CreateUnionTypes($input: [UnionTypeCreateInput!]!) {
  types: createUnionTypes(input: $input) {
    types: unionTypes {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  CreateUnionTypesMutation,
  CreateUnionTypesMutationVariables
>
export const CreateInterfaceTypesDocument = new TypedDocumentString(`
    mutation CreateInterfaceTypes($input: [InterfaceTypeCreateInput!]!) {
  types: createInterfaceTypes(input: $input) {
    types: interfaceTypes {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  CreateInterfaceTypesMutation,
  CreateInterfaceTypesMutationVariables
>
export const CreateElementTypesDocument = new TypedDocumentString(`
    mutation CreateElementTypes($input: [ElementTypeCreateInput!]!) {
  types: createElementTypes(input: $input) {
    types: elementTypes {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  CreateElementTypesMutation,
  CreateElementTypesMutationVariables
>
export const CreateRenderPropTypesDocument = new TypedDocumentString(`
    mutation CreateRenderPropTypes($input: [RenderPropTypeCreateInput!]!) {
  types: createRenderPropTypes(input: $input) {
    types: renderPropTypes {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  CreateRenderPropTypesMutation,
  CreateRenderPropTypesMutationVariables
>
export const CreateReactNodeTypesDocument = new TypedDocumentString(`
    mutation CreateReactNodeTypes($input: [ReactNodeTypeCreateInput!]!) {
  types: createReactNodeTypes(input: $input) {
    types: reactNodeTypes {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  CreateReactNodeTypesMutation,
  CreateReactNodeTypesMutationVariables
>
export const CreateEnumTypesDocument = new TypedDocumentString(`
    mutation CreateEnumTypes($input: [EnumTypeCreateInput!]!) {
  types: createEnumTypes(input: $input) {
    types: enumTypes {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  CreateEnumTypesMutation,
  CreateEnumTypesMutationVariables
>
export const CreateLambdaTypesDocument = new TypedDocumentString(`
    mutation CreateLambdaTypes($input: [LambdaTypeCreateInput!]!) {
  types: createLambdaTypes(input: $input) {
    types: lambdaTypes {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  CreateLambdaTypesMutation,
  CreateLambdaTypesMutationVariables
>
export const CreatePageTypesDocument = new TypedDocumentString(`
    mutation CreatePageTypes($input: [PageTypeCreateInput!]!) {
  types: createPageTypes(input: $input) {
    types: pageTypes {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  CreatePageTypesMutation,
  CreatePageTypesMutationVariables
>
export const CreateAppTypesDocument = new TypedDocumentString(`
    mutation CreateAppTypes($input: [AppTypeCreateInput!]!) {
  types: createAppTypes(input: $input) {
    types: appTypes {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  CreateAppTypesMutation,
  CreateAppTypesMutationVariables
>
export const CreateRichTextTypesDocument = new TypedDocumentString(`
    mutation CreateRichTextTypes($input: [RichTextTypeCreateInput!]!) {
  types: createRichTextTypes(input: $input) {
    types: richTextTypes {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  CreateRichTextTypesMutation,
  CreateRichTextTypesMutationVariables
>
export const CreateActionTypesDocument = new TypedDocumentString(`
    mutation CreateActionTypes($input: [ActionTypeCreateInput!]!) {
  types: createActionTypes(input: $input) {
    types: actionTypes {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  CreateActionTypesMutation,
  CreateActionTypesMutationVariables
>
export const CreateCodeMirrorTypesDocument = new TypedDocumentString(`
    mutation CreateCodeMirrorTypes($input: [CodeMirrorTypeCreateInput!]!) {
  types: createCodeMirrorTypes(input: $input) {
    types: codeMirrorTypes {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  CreateCodeMirrorTypesMutation,
  CreateCodeMirrorTypesMutationVariables
>
export const DeletePrimitiveTypesDocument = new TypedDocumentString(`
    mutation DeletePrimitiveTypes($delete: PrimitiveTypeDeleteInput, $where: PrimitiveTypeWhere) {
  deletePrimitiveTypes(delete: $delete, where: $where) {
    nodesDeleted
    relationshipsDeleted
  }
}
    `) as unknown as TypedDocumentString<
  DeletePrimitiveTypesMutation,
  DeletePrimitiveTypesMutationVariables
>
export const DeleteArrayTypesDocument = new TypedDocumentString(`
    mutation DeleteArrayTypes($delete: ArrayTypeDeleteInput, $where: ArrayTypeWhere) {
  deleteArrayTypes(delete: $delete, where: $where) {
    nodesDeleted
    relationshipsDeleted
  }
}
    `) as unknown as TypedDocumentString<
  DeleteArrayTypesMutation,
  DeleteArrayTypesMutationVariables
>
export const DeleteReactNodeTypesDocument = new TypedDocumentString(`
    mutation DeleteReactNodeTypes($delete: ReactNodeTypeDeleteInput, $where: ReactNodeTypeWhere) {
  deleteReactNodeTypes(delete: $delete, where: $where) {
    nodesDeleted
    relationshipsDeleted
  }
}
    `) as unknown as TypedDocumentString<
  DeleteReactNodeTypesMutation,
  DeleteReactNodeTypesMutationVariables
>
export const DeleteUnionTypesDocument = new TypedDocumentString(`
    mutation DeleteUnionTypes($delete: UnionTypeDeleteInput, $where: UnionTypeWhere) {
  deleteUnionTypes(delete: $delete, where: $where) {
    nodesDeleted
    relationshipsDeleted
  }
}
    `) as unknown as TypedDocumentString<
  DeleteUnionTypesMutation,
  DeleteUnionTypesMutationVariables
>
export const DeleteInterfaceTypesDocument = new TypedDocumentString(`
    mutation DeleteInterfaceTypes($delete: InterfaceTypeDeleteInput, $where: InterfaceTypeWhere) {
  deleteInterfaceTypes(delete: $delete, where: $where) {
    nodesDeleted
    relationshipsDeleted
  }
}
    `) as unknown as TypedDocumentString<
  DeleteInterfaceTypesMutation,
  DeleteInterfaceTypesMutationVariables
>
export const DeleteElementTypesDocument = new TypedDocumentString(`
    mutation DeleteElementTypes($delete: ElementTypeDeleteInput, $where: ElementTypeWhere) {
  deleteElementTypes(delete: $delete, where: $where) {
    nodesDeleted
    relationshipsDeleted
  }
}
    `) as unknown as TypedDocumentString<
  DeleteElementTypesMutation,
  DeleteElementTypesMutationVariables
>
export const DeleteRenderPropTypesDocument = new TypedDocumentString(`
    mutation DeleteRenderPropTypes($delete: RenderPropTypeDeleteInput, $where: RenderPropTypeWhere) {
  deleteRenderPropTypes(delete: $delete, where: $where) {
    nodesDeleted
    relationshipsDeleted
  }
}
    `) as unknown as TypedDocumentString<
  DeleteRenderPropTypesMutation,
  DeleteRenderPropTypesMutationVariables
>
export const DeleteRichTextTypesDocument = new TypedDocumentString(`
    mutation DeleteRichTextTypes($delete: RichTextTypeDeleteInput, $where: RichTextTypeWhere) {
  deleteRichTextTypes(delete: $delete, where: $where) {
    nodesDeleted
    relationshipsDeleted
  }
}
    `) as unknown as TypedDocumentString<
  DeleteRichTextTypesMutation,
  DeleteRichTextTypesMutationVariables
>
export const DeleteEnumTypesDocument = new TypedDocumentString(`
    mutation DeleteEnumTypes($delete: EnumTypeDeleteInput, $where: EnumTypeWhere) {
  deleteEnumTypes(delete: $delete, where: $where) {
    nodesDeleted
    relationshipsDeleted
  }
  deleteEnumTypeValues(where: {enumTypeConnection: {node: $where}}) {
    nodesDeleted
  }
}
    `) as unknown as TypedDocumentString<
  DeleteEnumTypesMutation,
  DeleteEnumTypesMutationVariables
>
export const DeleteLambdaTypesDocument = new TypedDocumentString(`
    mutation DeleteLambdaTypes($delete: LambdaTypeDeleteInput, $where: LambdaTypeWhere) {
  deleteLambdaTypes(delete: $delete, where: $where) {
    nodesDeleted
    relationshipsDeleted
  }
}
    `) as unknown as TypedDocumentString<
  DeleteLambdaTypesMutation,
  DeleteLambdaTypesMutationVariables
>
export const DeletePageTypesDocument = new TypedDocumentString(`
    mutation DeletePageTypes($delete: PageTypeDeleteInput, $where: PageTypeWhere) {
  deletePageTypes(delete: $delete, where: $where) {
    nodesDeleted
    relationshipsDeleted
  }
}
    `) as unknown as TypedDocumentString<
  DeletePageTypesMutation,
  DeletePageTypesMutationVariables
>
export const DeleteAppTypesDocument = new TypedDocumentString(`
    mutation DeleteAppTypes($delete: AppTypeDeleteInput, $where: AppTypeWhere) {
  deleteAppTypes(delete: $delete, where: $where) {
    nodesDeleted
    relationshipsDeleted
  }
}
    `) as unknown as TypedDocumentString<
  DeleteAppTypesMutation,
  DeleteAppTypesMutationVariables
>
export const DeleteActionTypesDocument = new TypedDocumentString(`
    mutation DeleteActionTypes($delete: ActionTypeDeleteInput, $where: ActionTypeWhere) {
  deleteActionTypes(delete: $delete, where: $where) {
    nodesDeleted
    relationshipsDeleted
  }
}
    `) as unknown as TypedDocumentString<
  DeleteActionTypesMutation,
  DeleteActionTypesMutationVariables
>
export const DeleteCodeMirrorTypesDocument = new TypedDocumentString(`
    mutation DeleteCodeMirrorTypes($delete: CodeMirrorTypeDeleteInput, $where: CodeMirrorTypeWhere) {
  deleteCodeMirrorTypes(delete: $delete, where: $where) {
    nodesDeleted
    relationshipsDeleted
  }
}
    `) as unknown as TypedDocumentString<
  DeleteCodeMirrorTypesMutation,
  DeleteCodeMirrorTypesMutationVariables
>
export const GetBaseTypesDocument = new TypedDocumentString(`
    query GetBaseTypes($where: IBaseTypeWhere, $options: IBaseTypeOptions) {
  iBaseTypes(where: $where, options: $options) {
    ...BaseType
    ownerConnection {
      totalCount
    }
  }
}
    fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}`) as unknown as TypedDocumentString<
  GetBaseTypesQuery,
  GetBaseTypesQueryVariables
>
export const GetTypesDocument = new TypedDocumentString(`
    query GetTypes($ids: [ID!]) {
  actionTypes(where: {id_IN: $ids}) {
    ...Type
  }
  appTypes(where: {id_IN: $ids}) {
    ...Type
  }
  arrayTypes(where: {id_IN: $ids}) {
    ...Type
  }
  codeMirrorTypes(where: {id_IN: $ids}) {
    ...Type
  }
  elementTypes(where: {id_IN: $ids}) {
    ...Type
  }
  enumTypes(where: {id_IN: $ids}) {
    ...Type
  }
  interfaceTypes(where: {id_IN: $ids}) {
    ...Type
  }
  lambdaTypes(where: {id_IN: $ids}) {
    ...Type
  }
  pageTypes(where: {id_IN: $ids}) {
    ...Type
  }
  primitiveTypes(where: {id_IN: $ids}) {
    ...Type
  }
  reactNodeTypes(where: {id_IN: $ids}) {
    ...Type
  }
  renderPropTypes(where: {id_IN: $ids}) {
    ...Type
  }
  richTextTypes(where: {id_IN: $ids}) {
    ...Type
  }
  unionTypes(where: {id_IN: $ids}) {
    ...Type
  }
}
    fragment ActionType on ActionType {
  ...BaseType
}
fragment AppType on AppType {
  ...BaseType
}
fragment ArrayType on ArrayType {
  ...BaseType
  itemType {
    ... on IBaseType {
      id
      kind
      name
    }
  }
}
fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}
fragment CodeMirrorType on CodeMirrorType {
  ...BaseType
  language
}
fragment ElementType on ElementType {
  ...BaseType
  elementKind
}
fragment EnumTypeValue on EnumTypeValue {
  id
  key
  value
}
fragment EnumType on EnumType {
  allowedValues {
    ...EnumTypeValue
  }
  ...BaseType
}
fragment Field on Field {
  api {
    ... on InterfaceType {
      id
    }
  }
  defaultValues
  description
  fieldType {
    ... on IBaseType {
      __typename
      id
      kind
      name
    }
  }
  id
  key
  name
  nextSibling {
    id
  }
  prevSibling {
    id
  }
  validationRules
}
fragment InterfaceType on InterfaceType {
  ...BaseType
  fields {
    ...Field
  }
}
fragment LambdaType on LambdaType {
  ...BaseType
}
fragment PageType on PageType {
  ...BaseType
}
fragment PrimitiveType on PrimitiveType {
  ...BaseType
  primitiveKind
}
fragment ReactNodeType on ReactNodeType {
  ...BaseType
}
fragment RenderPropType on RenderPropType {
  ...BaseType
}
fragment RichTextType on RichTextType {
  ...BaseType
}
fragment Type on IBaseType {
  ...ActionType
  ...AppType
  ...ArrayType
  ...CodeMirrorType
  ...ElementType
  ...EnumType
  ...InterfaceType
  ...LambdaType
  ...PageType
  ...PrimitiveType
  ...ReactNodeType
  ...RenderPropType
  ...RichTextType
  ...UnionType
}
fragment UnionType on UnionType {
  ...BaseType
  typesOfUnionType {
    ... on IBaseType {
      ...BaseType
    }
  }
}`) as unknown as TypedDocumentString<GetTypesQuery, GetTypesQueryVariables>
export const GetDescendantsDocument = new TypedDocumentString(`
    query GetDescendants($ids: [ID!]) {
  arrayTypes(where: {id_IN: $ids}) {
    descendantTypesIds
  }
  interfaceTypes(where: {id_IN: $ids}) {
    descendantTypesIds
  }
  unionTypes(where: {id_IN: $ids}) {
    descendantTypesIds
  }
}
    `) as unknown as TypedDocumentString<
  GetDescendantsQuery,
  GetDescendantsQueryVariables
>
export const GetPrimitiveTypesDocument = new TypedDocumentString(`
    query GetPrimitiveTypes($options: PrimitiveTypeOptions, $where: PrimitiveTypeWhere) {
  types: primitiveTypes(options: $options, where: $where) {
    ...Type
  }
}
    fragment ActionType on ActionType {
  ...BaseType
}
fragment AppType on AppType {
  ...BaseType
}
fragment ArrayType on ArrayType {
  ...BaseType
  itemType {
    ... on IBaseType {
      id
      kind
      name
    }
  }
}
fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}
fragment CodeMirrorType on CodeMirrorType {
  ...BaseType
  language
}
fragment ElementType on ElementType {
  ...BaseType
  elementKind
}
fragment EnumTypeValue on EnumTypeValue {
  id
  key
  value
}
fragment EnumType on EnumType {
  allowedValues {
    ...EnumTypeValue
  }
  ...BaseType
}
fragment Field on Field {
  api {
    ... on InterfaceType {
      id
    }
  }
  defaultValues
  description
  fieldType {
    ... on IBaseType {
      __typename
      id
      kind
      name
    }
  }
  id
  key
  name
  nextSibling {
    id
  }
  prevSibling {
    id
  }
  validationRules
}
fragment InterfaceType on InterfaceType {
  ...BaseType
  fields {
    ...Field
  }
}
fragment LambdaType on LambdaType {
  ...BaseType
}
fragment PageType on PageType {
  ...BaseType
}
fragment PrimitiveType on PrimitiveType {
  ...BaseType
  primitiveKind
}
fragment ReactNodeType on ReactNodeType {
  ...BaseType
}
fragment RenderPropType on RenderPropType {
  ...BaseType
}
fragment RichTextType on RichTextType {
  ...BaseType
}
fragment Type on IBaseType {
  ...ActionType
  ...AppType
  ...ArrayType
  ...CodeMirrorType
  ...ElementType
  ...EnumType
  ...InterfaceType
  ...LambdaType
  ...PageType
  ...PrimitiveType
  ...ReactNodeType
  ...RenderPropType
  ...RichTextType
  ...UnionType
}
fragment UnionType on UnionType {
  ...BaseType
  typesOfUnionType {
    ... on IBaseType {
      ...BaseType
    }
  }
}`) as unknown as TypedDocumentString<
  GetPrimitiveTypesQuery,
  GetPrimitiveTypesQueryVariables
>
export const GetArrayTypesDocument = new TypedDocumentString(`
    query GetArrayTypes($options: ArrayTypeOptions, $where: ArrayTypeWhere) {
  types: arrayTypes(options: $options, where: $where) {
    ...Type
  }
}
    fragment ActionType on ActionType {
  ...BaseType
}
fragment AppType on AppType {
  ...BaseType
}
fragment ArrayType on ArrayType {
  ...BaseType
  itemType {
    ... on IBaseType {
      id
      kind
      name
    }
  }
}
fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}
fragment CodeMirrorType on CodeMirrorType {
  ...BaseType
  language
}
fragment ElementType on ElementType {
  ...BaseType
  elementKind
}
fragment EnumTypeValue on EnumTypeValue {
  id
  key
  value
}
fragment EnumType on EnumType {
  allowedValues {
    ...EnumTypeValue
  }
  ...BaseType
}
fragment Field on Field {
  api {
    ... on InterfaceType {
      id
    }
  }
  defaultValues
  description
  fieldType {
    ... on IBaseType {
      __typename
      id
      kind
      name
    }
  }
  id
  key
  name
  nextSibling {
    id
  }
  prevSibling {
    id
  }
  validationRules
}
fragment InterfaceType on InterfaceType {
  ...BaseType
  fields {
    ...Field
  }
}
fragment LambdaType on LambdaType {
  ...BaseType
}
fragment PageType on PageType {
  ...BaseType
}
fragment PrimitiveType on PrimitiveType {
  ...BaseType
  primitiveKind
}
fragment ReactNodeType on ReactNodeType {
  ...BaseType
}
fragment RenderPropType on RenderPropType {
  ...BaseType
}
fragment RichTextType on RichTextType {
  ...BaseType
}
fragment Type on IBaseType {
  ...ActionType
  ...AppType
  ...ArrayType
  ...CodeMirrorType
  ...ElementType
  ...EnumType
  ...InterfaceType
  ...LambdaType
  ...PageType
  ...PrimitiveType
  ...ReactNodeType
  ...RenderPropType
  ...RichTextType
  ...UnionType
}
fragment UnionType on UnionType {
  ...BaseType
  typesOfUnionType {
    ... on IBaseType {
      ...BaseType
    }
  }
}`) as unknown as TypedDocumentString<
  GetArrayTypesQuery,
  GetArrayTypesQueryVariables
>
export const GetUnionTypesDocument = new TypedDocumentString(`
    query GetUnionTypes($options: UnionTypeOptions, $where: UnionTypeWhere) {
  types: unionTypes(options: $options, where: $where) {
    ...Type
  }
}
    fragment ActionType on ActionType {
  ...BaseType
}
fragment AppType on AppType {
  ...BaseType
}
fragment ArrayType on ArrayType {
  ...BaseType
  itemType {
    ... on IBaseType {
      id
      kind
      name
    }
  }
}
fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}
fragment CodeMirrorType on CodeMirrorType {
  ...BaseType
  language
}
fragment ElementType on ElementType {
  ...BaseType
  elementKind
}
fragment EnumTypeValue on EnumTypeValue {
  id
  key
  value
}
fragment EnumType on EnumType {
  allowedValues {
    ...EnumTypeValue
  }
  ...BaseType
}
fragment Field on Field {
  api {
    ... on InterfaceType {
      id
    }
  }
  defaultValues
  description
  fieldType {
    ... on IBaseType {
      __typename
      id
      kind
      name
    }
  }
  id
  key
  name
  nextSibling {
    id
  }
  prevSibling {
    id
  }
  validationRules
}
fragment InterfaceType on InterfaceType {
  ...BaseType
  fields {
    ...Field
  }
}
fragment LambdaType on LambdaType {
  ...BaseType
}
fragment PageType on PageType {
  ...BaseType
}
fragment PrimitiveType on PrimitiveType {
  ...BaseType
  primitiveKind
}
fragment ReactNodeType on ReactNodeType {
  ...BaseType
}
fragment RenderPropType on RenderPropType {
  ...BaseType
}
fragment RichTextType on RichTextType {
  ...BaseType
}
fragment Type on IBaseType {
  ...ActionType
  ...AppType
  ...ArrayType
  ...CodeMirrorType
  ...ElementType
  ...EnumType
  ...InterfaceType
  ...LambdaType
  ...PageType
  ...PrimitiveType
  ...ReactNodeType
  ...RenderPropType
  ...RichTextType
  ...UnionType
}
fragment UnionType on UnionType {
  ...BaseType
  typesOfUnionType {
    ... on IBaseType {
      ...BaseType
    }
  }
}`) as unknown as TypedDocumentString<
  GetUnionTypesQuery,
  GetUnionTypesQueryVariables
>
export const GetInterfaceTypesDocument = new TypedDocumentString(`
    query GetInterfaceTypes($options: InterfaceTypeOptions, $where: InterfaceTypeWhere) {
  types: interfaceTypes(options: $options, where: $where) {
    ...Type
  }
}
    fragment ActionType on ActionType {
  ...BaseType
}
fragment AppType on AppType {
  ...BaseType
}
fragment ArrayType on ArrayType {
  ...BaseType
  itemType {
    ... on IBaseType {
      id
      kind
      name
    }
  }
}
fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}
fragment CodeMirrorType on CodeMirrorType {
  ...BaseType
  language
}
fragment ElementType on ElementType {
  ...BaseType
  elementKind
}
fragment EnumTypeValue on EnumTypeValue {
  id
  key
  value
}
fragment EnumType on EnumType {
  allowedValues {
    ...EnumTypeValue
  }
  ...BaseType
}
fragment Field on Field {
  api {
    ... on InterfaceType {
      id
    }
  }
  defaultValues
  description
  fieldType {
    ... on IBaseType {
      __typename
      id
      kind
      name
    }
  }
  id
  key
  name
  nextSibling {
    id
  }
  prevSibling {
    id
  }
  validationRules
}
fragment InterfaceType on InterfaceType {
  ...BaseType
  fields {
    ...Field
  }
}
fragment LambdaType on LambdaType {
  ...BaseType
}
fragment PageType on PageType {
  ...BaseType
}
fragment PrimitiveType on PrimitiveType {
  ...BaseType
  primitiveKind
}
fragment ReactNodeType on ReactNodeType {
  ...BaseType
}
fragment RenderPropType on RenderPropType {
  ...BaseType
}
fragment RichTextType on RichTextType {
  ...BaseType
}
fragment Type on IBaseType {
  ...ActionType
  ...AppType
  ...ArrayType
  ...CodeMirrorType
  ...ElementType
  ...EnumType
  ...InterfaceType
  ...LambdaType
  ...PageType
  ...PrimitiveType
  ...ReactNodeType
  ...RenderPropType
  ...RichTextType
  ...UnionType
}
fragment UnionType on UnionType {
  ...BaseType
  typesOfUnionType {
    ... on IBaseType {
      ...BaseType
    }
  }
}`) as unknown as TypedDocumentString<
  GetInterfaceTypesQuery,
  GetInterfaceTypesQueryVariables
>
export const GetElementTypesDocument = new TypedDocumentString(`
    query GetElementTypes($options: ElementTypeOptions, $where: ElementTypeWhere) {
  types: elementTypes(options: $options, where: $where) {
    ...Type
  }
}
    fragment ActionType on ActionType {
  ...BaseType
}
fragment AppType on AppType {
  ...BaseType
}
fragment ArrayType on ArrayType {
  ...BaseType
  itemType {
    ... on IBaseType {
      id
      kind
      name
    }
  }
}
fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}
fragment CodeMirrorType on CodeMirrorType {
  ...BaseType
  language
}
fragment ElementType on ElementType {
  ...BaseType
  elementKind
}
fragment EnumTypeValue on EnumTypeValue {
  id
  key
  value
}
fragment EnumType on EnumType {
  allowedValues {
    ...EnumTypeValue
  }
  ...BaseType
}
fragment Field on Field {
  api {
    ... on InterfaceType {
      id
    }
  }
  defaultValues
  description
  fieldType {
    ... on IBaseType {
      __typename
      id
      kind
      name
    }
  }
  id
  key
  name
  nextSibling {
    id
  }
  prevSibling {
    id
  }
  validationRules
}
fragment InterfaceType on InterfaceType {
  ...BaseType
  fields {
    ...Field
  }
}
fragment LambdaType on LambdaType {
  ...BaseType
}
fragment PageType on PageType {
  ...BaseType
}
fragment PrimitiveType on PrimitiveType {
  ...BaseType
  primitiveKind
}
fragment ReactNodeType on ReactNodeType {
  ...BaseType
}
fragment RenderPropType on RenderPropType {
  ...BaseType
}
fragment RichTextType on RichTextType {
  ...BaseType
}
fragment Type on IBaseType {
  ...ActionType
  ...AppType
  ...ArrayType
  ...CodeMirrorType
  ...ElementType
  ...EnumType
  ...InterfaceType
  ...LambdaType
  ...PageType
  ...PrimitiveType
  ...ReactNodeType
  ...RenderPropType
  ...RichTextType
  ...UnionType
}
fragment UnionType on UnionType {
  ...BaseType
  typesOfUnionType {
    ... on IBaseType {
      ...BaseType
    }
  }
}`) as unknown as TypedDocumentString<
  GetElementTypesQuery,
  GetElementTypesQueryVariables
>
export const GetRenderPropTypesDocument = new TypedDocumentString(`
    query GetRenderPropTypes($options: RenderPropTypeOptions, $where: RenderPropTypeWhere) {
  types: renderPropTypes(options: $options, where: $where) {
    ...Type
  }
}
    fragment ActionType on ActionType {
  ...BaseType
}
fragment AppType on AppType {
  ...BaseType
}
fragment ArrayType on ArrayType {
  ...BaseType
  itemType {
    ... on IBaseType {
      id
      kind
      name
    }
  }
}
fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}
fragment CodeMirrorType on CodeMirrorType {
  ...BaseType
  language
}
fragment ElementType on ElementType {
  ...BaseType
  elementKind
}
fragment EnumTypeValue on EnumTypeValue {
  id
  key
  value
}
fragment EnumType on EnumType {
  allowedValues {
    ...EnumTypeValue
  }
  ...BaseType
}
fragment Field on Field {
  api {
    ... on InterfaceType {
      id
    }
  }
  defaultValues
  description
  fieldType {
    ... on IBaseType {
      __typename
      id
      kind
      name
    }
  }
  id
  key
  name
  nextSibling {
    id
  }
  prevSibling {
    id
  }
  validationRules
}
fragment InterfaceType on InterfaceType {
  ...BaseType
  fields {
    ...Field
  }
}
fragment LambdaType on LambdaType {
  ...BaseType
}
fragment PageType on PageType {
  ...BaseType
}
fragment PrimitiveType on PrimitiveType {
  ...BaseType
  primitiveKind
}
fragment ReactNodeType on ReactNodeType {
  ...BaseType
}
fragment RenderPropType on RenderPropType {
  ...BaseType
}
fragment RichTextType on RichTextType {
  ...BaseType
}
fragment Type on IBaseType {
  ...ActionType
  ...AppType
  ...ArrayType
  ...CodeMirrorType
  ...ElementType
  ...EnumType
  ...InterfaceType
  ...LambdaType
  ...PageType
  ...PrimitiveType
  ...ReactNodeType
  ...RenderPropType
  ...RichTextType
  ...UnionType
}
fragment UnionType on UnionType {
  ...BaseType
  typesOfUnionType {
    ... on IBaseType {
      ...BaseType
    }
  }
}`) as unknown as TypedDocumentString<
  GetRenderPropTypesQuery,
  GetRenderPropTypesQueryVariables
>
export const GetReactNodeTypesDocument = new TypedDocumentString(`
    query GetReactNodeTypes($options: ReactNodeTypeOptions, $where: ReactNodeTypeWhere) {
  types: reactNodeTypes(options: $options, where: $where) {
    ...ReactNodeType
  }
}
    fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}
fragment ReactNodeType on ReactNodeType {
  ...BaseType
}`) as unknown as TypedDocumentString<
  GetReactNodeTypesQuery,
  GetReactNodeTypesQueryVariables
>
export const GetRichTextTypesDocument = new TypedDocumentString(`
    query GetRichTextTypes($options: RichTextTypeOptions, $where: RichTextTypeWhere) {
  types: richTextTypes(options: $options, where: $where) {
    ...RichTextType
  }
}
    fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}
fragment RichTextType on RichTextType {
  ...BaseType
}`) as unknown as TypedDocumentString<
  GetRichTextTypesQuery,
  GetRichTextTypesQueryVariables
>
export const GetEnumTypesDocument = new TypedDocumentString(`
    query GetEnumTypes($options: EnumTypeOptions, $where: EnumTypeWhere) {
  types: enumTypes(options: $options, where: $where) {
    ...Type
  }
}
    fragment ActionType on ActionType {
  ...BaseType
}
fragment AppType on AppType {
  ...BaseType
}
fragment ArrayType on ArrayType {
  ...BaseType
  itemType {
    ... on IBaseType {
      id
      kind
      name
    }
  }
}
fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}
fragment CodeMirrorType on CodeMirrorType {
  ...BaseType
  language
}
fragment ElementType on ElementType {
  ...BaseType
  elementKind
}
fragment EnumTypeValue on EnumTypeValue {
  id
  key
  value
}
fragment EnumType on EnumType {
  allowedValues {
    ...EnumTypeValue
  }
  ...BaseType
}
fragment Field on Field {
  api {
    ... on InterfaceType {
      id
    }
  }
  defaultValues
  description
  fieldType {
    ... on IBaseType {
      __typename
      id
      kind
      name
    }
  }
  id
  key
  name
  nextSibling {
    id
  }
  prevSibling {
    id
  }
  validationRules
}
fragment InterfaceType on InterfaceType {
  ...BaseType
  fields {
    ...Field
  }
}
fragment LambdaType on LambdaType {
  ...BaseType
}
fragment PageType on PageType {
  ...BaseType
}
fragment PrimitiveType on PrimitiveType {
  ...BaseType
  primitiveKind
}
fragment ReactNodeType on ReactNodeType {
  ...BaseType
}
fragment RenderPropType on RenderPropType {
  ...BaseType
}
fragment RichTextType on RichTextType {
  ...BaseType
}
fragment Type on IBaseType {
  ...ActionType
  ...AppType
  ...ArrayType
  ...CodeMirrorType
  ...ElementType
  ...EnumType
  ...InterfaceType
  ...LambdaType
  ...PageType
  ...PrimitiveType
  ...ReactNodeType
  ...RenderPropType
  ...RichTextType
  ...UnionType
}
fragment UnionType on UnionType {
  ...BaseType
  typesOfUnionType {
    ... on IBaseType {
      ...BaseType
    }
  }
}`) as unknown as TypedDocumentString<
  GetEnumTypesQuery,
  GetEnumTypesQueryVariables
>
export const GetLambdaTypesDocument = new TypedDocumentString(`
    query GetLambdaTypes($options: LambdaTypeOptions, $where: LambdaTypeWhere) {
  types: lambdaTypes(options: $options, where: $where) {
    ...Type
  }
}
    fragment ActionType on ActionType {
  ...BaseType
}
fragment AppType on AppType {
  ...BaseType
}
fragment ArrayType on ArrayType {
  ...BaseType
  itemType {
    ... on IBaseType {
      id
      kind
      name
    }
  }
}
fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}
fragment CodeMirrorType on CodeMirrorType {
  ...BaseType
  language
}
fragment ElementType on ElementType {
  ...BaseType
  elementKind
}
fragment EnumTypeValue on EnumTypeValue {
  id
  key
  value
}
fragment EnumType on EnumType {
  allowedValues {
    ...EnumTypeValue
  }
  ...BaseType
}
fragment Field on Field {
  api {
    ... on InterfaceType {
      id
    }
  }
  defaultValues
  description
  fieldType {
    ... on IBaseType {
      __typename
      id
      kind
      name
    }
  }
  id
  key
  name
  nextSibling {
    id
  }
  prevSibling {
    id
  }
  validationRules
}
fragment InterfaceType on InterfaceType {
  ...BaseType
  fields {
    ...Field
  }
}
fragment LambdaType on LambdaType {
  ...BaseType
}
fragment PageType on PageType {
  ...BaseType
}
fragment PrimitiveType on PrimitiveType {
  ...BaseType
  primitiveKind
}
fragment ReactNodeType on ReactNodeType {
  ...BaseType
}
fragment RenderPropType on RenderPropType {
  ...BaseType
}
fragment RichTextType on RichTextType {
  ...BaseType
}
fragment Type on IBaseType {
  ...ActionType
  ...AppType
  ...ArrayType
  ...CodeMirrorType
  ...ElementType
  ...EnumType
  ...InterfaceType
  ...LambdaType
  ...PageType
  ...PrimitiveType
  ...ReactNodeType
  ...RenderPropType
  ...RichTextType
  ...UnionType
}
fragment UnionType on UnionType {
  ...BaseType
  typesOfUnionType {
    ... on IBaseType {
      ...BaseType
    }
  }
}`) as unknown as TypedDocumentString<
  GetLambdaTypesQuery,
  GetLambdaTypesQueryVariables
>
export const GetPageTypesDocument = new TypedDocumentString(`
    query GetPageTypes($options: PageTypeOptions, $where: PageTypeWhere) {
  types: pageTypes(options: $options, where: $where) {
    ...Type
  }
}
    fragment ActionType on ActionType {
  ...BaseType
}
fragment AppType on AppType {
  ...BaseType
}
fragment ArrayType on ArrayType {
  ...BaseType
  itemType {
    ... on IBaseType {
      id
      kind
      name
    }
  }
}
fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}
fragment CodeMirrorType on CodeMirrorType {
  ...BaseType
  language
}
fragment ElementType on ElementType {
  ...BaseType
  elementKind
}
fragment EnumTypeValue on EnumTypeValue {
  id
  key
  value
}
fragment EnumType on EnumType {
  allowedValues {
    ...EnumTypeValue
  }
  ...BaseType
}
fragment Field on Field {
  api {
    ... on InterfaceType {
      id
    }
  }
  defaultValues
  description
  fieldType {
    ... on IBaseType {
      __typename
      id
      kind
      name
    }
  }
  id
  key
  name
  nextSibling {
    id
  }
  prevSibling {
    id
  }
  validationRules
}
fragment InterfaceType on InterfaceType {
  ...BaseType
  fields {
    ...Field
  }
}
fragment LambdaType on LambdaType {
  ...BaseType
}
fragment PageType on PageType {
  ...BaseType
}
fragment PrimitiveType on PrimitiveType {
  ...BaseType
  primitiveKind
}
fragment ReactNodeType on ReactNodeType {
  ...BaseType
}
fragment RenderPropType on RenderPropType {
  ...BaseType
}
fragment RichTextType on RichTextType {
  ...BaseType
}
fragment Type on IBaseType {
  ...ActionType
  ...AppType
  ...ArrayType
  ...CodeMirrorType
  ...ElementType
  ...EnumType
  ...InterfaceType
  ...LambdaType
  ...PageType
  ...PrimitiveType
  ...ReactNodeType
  ...RenderPropType
  ...RichTextType
  ...UnionType
}
fragment UnionType on UnionType {
  ...BaseType
  typesOfUnionType {
    ... on IBaseType {
      ...BaseType
    }
  }
}`) as unknown as TypedDocumentString<
  GetPageTypesQuery,
  GetPageTypesQueryVariables
>
export const GetAppTypesDocument = new TypedDocumentString(`
    query GetAppTypes($options: AppTypeOptions, $where: AppTypeWhere) {
  types: appTypes(options: $options, where: $where) {
    ...Type
  }
}
    fragment ActionType on ActionType {
  ...BaseType
}
fragment AppType on AppType {
  ...BaseType
}
fragment ArrayType on ArrayType {
  ...BaseType
  itemType {
    ... on IBaseType {
      id
      kind
      name
    }
  }
}
fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}
fragment CodeMirrorType on CodeMirrorType {
  ...BaseType
  language
}
fragment ElementType on ElementType {
  ...BaseType
  elementKind
}
fragment EnumTypeValue on EnumTypeValue {
  id
  key
  value
}
fragment EnumType on EnumType {
  allowedValues {
    ...EnumTypeValue
  }
  ...BaseType
}
fragment Field on Field {
  api {
    ... on InterfaceType {
      id
    }
  }
  defaultValues
  description
  fieldType {
    ... on IBaseType {
      __typename
      id
      kind
      name
    }
  }
  id
  key
  name
  nextSibling {
    id
  }
  prevSibling {
    id
  }
  validationRules
}
fragment InterfaceType on InterfaceType {
  ...BaseType
  fields {
    ...Field
  }
}
fragment LambdaType on LambdaType {
  ...BaseType
}
fragment PageType on PageType {
  ...BaseType
}
fragment PrimitiveType on PrimitiveType {
  ...BaseType
  primitiveKind
}
fragment ReactNodeType on ReactNodeType {
  ...BaseType
}
fragment RenderPropType on RenderPropType {
  ...BaseType
}
fragment RichTextType on RichTextType {
  ...BaseType
}
fragment Type on IBaseType {
  ...ActionType
  ...AppType
  ...ArrayType
  ...CodeMirrorType
  ...ElementType
  ...EnumType
  ...InterfaceType
  ...LambdaType
  ...PageType
  ...PrimitiveType
  ...ReactNodeType
  ...RenderPropType
  ...RichTextType
  ...UnionType
}
fragment UnionType on UnionType {
  ...BaseType
  typesOfUnionType {
    ... on IBaseType {
      ...BaseType
    }
  }
}`) as unknown as TypedDocumentString<
  GetAppTypesQuery,
  GetAppTypesQueryVariables
>
export const GetActionTypesDocument = new TypedDocumentString(`
    query GetActionTypes($options: ActionTypeOptions, $where: ActionTypeWhere) {
  types: actionTypes(options: $options, where: $where) {
    ...Type
  }
}
    fragment ActionType on ActionType {
  ...BaseType
}
fragment AppType on AppType {
  ...BaseType
}
fragment ArrayType on ArrayType {
  ...BaseType
  itemType {
    ... on IBaseType {
      id
      kind
      name
    }
  }
}
fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}
fragment CodeMirrorType on CodeMirrorType {
  ...BaseType
  language
}
fragment ElementType on ElementType {
  ...BaseType
  elementKind
}
fragment EnumTypeValue on EnumTypeValue {
  id
  key
  value
}
fragment EnumType on EnumType {
  allowedValues {
    ...EnumTypeValue
  }
  ...BaseType
}
fragment Field on Field {
  api {
    ... on InterfaceType {
      id
    }
  }
  defaultValues
  description
  fieldType {
    ... on IBaseType {
      __typename
      id
      kind
      name
    }
  }
  id
  key
  name
  nextSibling {
    id
  }
  prevSibling {
    id
  }
  validationRules
}
fragment InterfaceType on InterfaceType {
  ...BaseType
  fields {
    ...Field
  }
}
fragment LambdaType on LambdaType {
  ...BaseType
}
fragment PageType on PageType {
  ...BaseType
}
fragment PrimitiveType on PrimitiveType {
  ...BaseType
  primitiveKind
}
fragment ReactNodeType on ReactNodeType {
  ...BaseType
}
fragment RenderPropType on RenderPropType {
  ...BaseType
}
fragment RichTextType on RichTextType {
  ...BaseType
}
fragment Type on IBaseType {
  ...ActionType
  ...AppType
  ...ArrayType
  ...CodeMirrorType
  ...ElementType
  ...EnumType
  ...InterfaceType
  ...LambdaType
  ...PageType
  ...PrimitiveType
  ...ReactNodeType
  ...RenderPropType
  ...RichTextType
  ...UnionType
}
fragment UnionType on UnionType {
  ...BaseType
  typesOfUnionType {
    ... on IBaseType {
      ...BaseType
    }
  }
}`) as unknown as TypedDocumentString<
  GetActionTypesQuery,
  GetActionTypesQueryVariables
>
export const GetCodeMirrorTypesDocument = new TypedDocumentString(`
    query GetCodeMirrorTypes($options: CodeMirrorTypeOptions, $where: CodeMirrorTypeWhere) {
  types: codeMirrorTypes(options: $options, where: $where) {
    ...Type
  }
}
    fragment ActionType on ActionType {
  ...BaseType
}
fragment AppType on AppType {
  ...BaseType
}
fragment ArrayType on ArrayType {
  ...BaseType
  itemType {
    ... on IBaseType {
      id
      kind
      name
    }
  }
}
fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}
fragment CodeMirrorType on CodeMirrorType {
  ...BaseType
  language
}
fragment ElementType on ElementType {
  ...BaseType
  elementKind
}
fragment EnumTypeValue on EnumTypeValue {
  id
  key
  value
}
fragment EnumType on EnumType {
  allowedValues {
    ...EnumTypeValue
  }
  ...BaseType
}
fragment Field on Field {
  api {
    ... on InterfaceType {
      id
    }
  }
  defaultValues
  description
  fieldType {
    ... on IBaseType {
      __typename
      id
      kind
      name
    }
  }
  id
  key
  name
  nextSibling {
    id
  }
  prevSibling {
    id
  }
  validationRules
}
fragment InterfaceType on InterfaceType {
  ...BaseType
  fields {
    ...Field
  }
}
fragment LambdaType on LambdaType {
  ...BaseType
}
fragment PageType on PageType {
  ...BaseType
}
fragment PrimitiveType on PrimitiveType {
  ...BaseType
  primitiveKind
}
fragment ReactNodeType on ReactNodeType {
  ...BaseType
}
fragment RenderPropType on RenderPropType {
  ...BaseType
}
fragment RichTextType on RichTextType {
  ...BaseType
}
fragment Type on IBaseType {
  ...ActionType
  ...AppType
  ...ArrayType
  ...CodeMirrorType
  ...ElementType
  ...EnumType
  ...InterfaceType
  ...LambdaType
  ...PageType
  ...PrimitiveType
  ...ReactNodeType
  ...RenderPropType
  ...RichTextType
  ...UnionType
}
fragment UnionType on UnionType {
  ...BaseType
  typesOfUnionType {
    ... on IBaseType {
      ...BaseType
    }
  }
}`) as unknown as TypedDocumentString<
  GetCodeMirrorTypesQuery,
  GetCodeMirrorTypesQueryVariables
>
export const InterfaceForm_GetAppsDocument = new TypedDocumentString(`
    query InterfaceForm_GetApps($options: AppOptions, $where: AppWhere) {
  apps(options: $options, where: $where) {
    id
    name
  }
}
    `) as unknown as TypedDocumentString<
  InterfaceForm_GetAppsQuery,
  InterfaceForm_GetAppsQueryVariables
>
export const InterfaceForm_GetAtomsDocument = new TypedDocumentString(`
    query InterfaceForm_GetAtoms($options: AtomOptions, $where: AtomWhere) {
  atoms(options: $options, where: $where) {
    id
    name
    type
  }
}
    `) as unknown as TypedDocumentString<
  InterfaceForm_GetAtomsQuery,
  InterfaceForm_GetAtomsQueryVariables
>
export const InterfaceForm_GetActionsDocument = new TypedDocumentString(`
    query InterfaceForm_GetActions($appId: ID) {
  apiActions {
    id
    name
  }
  codeActions {
    id
    name
  }
}
    `) as unknown as TypedDocumentString<
  InterfaceForm_GetActionsQuery,
  InterfaceForm_GetActionsQueryVariables
>
export const InterfaceForm_GetStoresDocument = new TypedDocumentString(`
    query InterfaceForm_GetStores($options: StoreOptions, $where: StoreWhere) {
  stores(options: $options, where: $where) {
    id
    name
  }
}
    `) as unknown as TypedDocumentString<
  InterfaceForm_GetStoresQuery,
  InterfaceForm_GetStoresQueryVariables
>
export const InterfaceForm_GetResourceDocument = new TypedDocumentString(`
    query InterfaceForm_GetResource($options: ResourceOptions, $where: ResourceWhere) {
  resources(options: $options, where: $where) {
    id
    name
  }
}
    `) as unknown as TypedDocumentString<
  InterfaceForm_GetResourceQuery,
  InterfaceForm_GetResourceQueryVariables
>
export const InterfaceForm_GetPagesDocument = new TypedDocumentString(`
    query InterfaceForm_GetPages($options: PageOptions, $where: PageWhere) {
  pages(options: $options, where: $where) {
    id
    name
  }
}
    `) as unknown as TypedDocumentString<
  InterfaceForm_GetPagesQuery,
  InterfaceForm_GetPagesQueryVariables
>
export const IsTypeDescendantOfDocument = new TypedDocumentString(`
    query IsTypeDescendantOf($descendantTypeId: ID!, $parentTypeId: ID!) {
  isTypeDescendantOf(
    descendantTypeId: $descendantTypeId
    parentTypeId: $parentTypeId
  )
}
    `) as unknown as TypedDocumentString<
  IsTypeDescendantOfQuery,
  IsTypeDescendantOfQueryVariables
>
export const GetTypeReferencesDocument = new TypedDocumentString(`
    query GetTypeReferences($typeId: ID!) {
  getTypeReferences(typeId: $typeId) {
    label
    name
  }
}
    `) as unknown as TypedDocumentString<
  GetTypeReferencesQuery,
  GetTypeReferencesQueryVariables
>
export const UpdatePrimitiveTypesDocument = new TypedDocumentString(`
    mutation UpdatePrimitiveTypes($update: PrimitiveTypeUpdateInput, $where: PrimitiveTypeWhere) {
  types: updatePrimitiveTypes(update: $update, where: $where) {
    types: primitiveTypes {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  UpdatePrimitiveTypesMutation,
  UpdatePrimitiveTypesMutationVariables
>
export const UpdateArrayTypesDocument = new TypedDocumentString(`
    mutation UpdateArrayTypes($update: ArrayTypeUpdateInput, $where: ArrayTypeWhere) {
  types: updateArrayTypes(update: $update, where: $where) {
    types: arrayTypes {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  UpdateArrayTypesMutation,
  UpdateArrayTypesMutationVariables
>
export const UpdateUnionTypesDocument = new TypedDocumentString(`
    mutation UpdateUnionTypes($update: UnionTypeUpdateInput, $where: UnionTypeWhere) {
  types: updateUnionTypes(update: $update, where: $where) {
    types: unionTypes {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  UpdateUnionTypesMutation,
  UpdateUnionTypesMutationVariables
>
export const UpdateInterfaceTypesDocument = new TypedDocumentString(`
    mutation UpdateInterfaceTypes($update: InterfaceTypeUpdateInput, $where: InterfaceTypeWhere) {
  types: updateInterfaceTypes(update: $update, where: $where) {
    types: interfaceTypes {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  UpdateInterfaceTypesMutation,
  UpdateInterfaceTypesMutationVariables
>
export const UpdateReactNodeTypesDocument = new TypedDocumentString(`
    mutation UpdateReactNodeTypes($update: ReactNodeTypeUpdateInput, $where: ReactNodeTypeWhere) {
  types: updateReactNodeTypes(update: $update, where: $where) {
    types: reactNodeTypes {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  UpdateReactNodeTypesMutation,
  UpdateReactNodeTypesMutationVariables
>
export const UpdateElementTypesDocument = new TypedDocumentString(`
    mutation UpdateElementTypes($update: ElementTypeUpdateInput, $where: ElementTypeWhere) {
  types: updateElementTypes(update: $update, where: $where) {
    types: elementTypes {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  UpdateElementTypesMutation,
  UpdateElementTypesMutationVariables
>
export const UpdateRenderPropTypesDocument = new TypedDocumentString(`
    mutation UpdateRenderPropTypes($update: RenderPropTypeUpdateInput, $where: RenderPropTypeWhere) {
  types: updateRenderPropTypes(update: $update, where: $where) {
    types: renderPropTypes {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  UpdateRenderPropTypesMutation,
  UpdateRenderPropTypesMutationVariables
>
export const UpdateEnumTypesDocument = new TypedDocumentString(`
    mutation UpdateEnumTypes($update: EnumTypeUpdateInput, $where: EnumTypeWhere) {
  types: updateEnumTypes(update: $update, where: $where) {
    types: enumTypes {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  UpdateEnumTypesMutation,
  UpdateEnumTypesMutationVariables
>
export const UpdateLambdaTypesDocument = new TypedDocumentString(`
    mutation UpdateLambdaTypes($update: LambdaTypeUpdateInput, $where: LambdaTypeWhere) {
  types: updateLambdaTypes(update: $update, where: $where) {
    types: lambdaTypes {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  UpdateLambdaTypesMutation,
  UpdateLambdaTypesMutationVariables
>
export const UpdatePageTypesDocument = new TypedDocumentString(`
    mutation UpdatePageTypes($update: PageTypeUpdateInput, $where: PageTypeWhere) {
  types: updatePageTypes(update: $update, where: $where) {
    types: pageTypes {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  UpdatePageTypesMutation,
  UpdatePageTypesMutationVariables
>
export const UpdateAppTypesDocument = new TypedDocumentString(`
    mutation UpdateAppTypes($update: AppTypeUpdateInput, $where: AppTypeWhere) {
  types: updateAppTypes(update: $update, where: $where) {
    types: appTypes {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  UpdateAppTypesMutation,
  UpdateAppTypesMutationVariables
>
export const UpdateRichTextTypesDocument = new TypedDocumentString(`
    mutation UpdateRichTextTypes($update: RichTextTypeUpdateInput, $where: RichTextTypeWhere) {
  types: updateRichTextTypes(update: $update, where: $where) {
    types: richTextTypes {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  UpdateRichTextTypesMutation,
  UpdateRichTextTypesMutationVariables
>
export const UpdateActionTypesDocument = new TypedDocumentString(`
    mutation UpdateActionTypes($update: ActionTypeUpdateInput, $where: ActionTypeWhere) {
  types: updateActionTypes(update: $update, where: $where) {
    types: actionTypes {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  UpdateActionTypesMutation,
  UpdateActionTypesMutationVariables
>
export const UpdateCodeMirrorTypesDocument = new TypedDocumentString(`
    mutation UpdateCodeMirrorTypes($update: CodeMirrorTypeUpdateInput, $where: CodeMirrorTypeWhere) {
  types: updateCodeMirrorTypes(update: $update, where: $where) {
    types: codeMirrorTypes {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  UpdateCodeMirrorTypesMutation,
  UpdateCodeMirrorTypesMutationVariables
>
export const GetUsersDocument = new TypedDocumentString(`
    query GetUsers($where: UserWhere) {
  aggregate: usersAggregate(where: $where) {
    count
  }
  items: users(where: $where) {
    ...User
  }
}
    fragment Preference on Preference {
  id
  builderBreakpointType
  builderWidth
  owner {
    id
  }
}
fragment User on User {
  apps {
    id
  }
  auth0Id
  email
  id
  preferences {
    ...Preference
  }
  roles
  username
}`) as unknown as TypedDocumentString<GetUsersQuery, GetUsersQueryVariables>
export const CreateUserDocument = new TypedDocumentString(`
    mutation CreateUser($input: [UserCreateInput!]!) {
  createUsers(input: $input) {
    users {
      email
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  CreateUserMutation,
  CreateUserMutationVariables
>
export const DeleteUsersDocument = new TypedDocumentString(`
    mutation DeleteUsers($where: UserWhere!) {
  deleteUsers(where: $where) {
    nodesDeleted
  }
}
    `) as unknown as TypedDocumentString<
  DeleteUsersMutation,
  DeleteUsersMutationVariables
>
export const CreateAppsDocument = new TypedDocumentString(`
    mutation CreateApps($input: [AppCreateInput!]!) {
  createApps(input: $input) {
    apps {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  CreateAppsMutation,
  CreateAppsMutationVariables
>
export const UpdateAppsDocument = new TypedDocumentString(`
    mutation UpdateApps($where: AppWhere!, $update: AppUpdateInput!) {
  updateApps(update: $update, where: $where) {
    apps {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  UpdateAppsMutation,
  UpdateAppsMutationVariables
>
export const DeleteAppsDocument = new TypedDocumentString(`
    mutation DeleteApps($where: AppWhere!, $delete: AppDeleteInput) {
  deleteApps(delete: $delete, where: $where) {
    nodesDeleted
  }
}
    `) as unknown as TypedDocumentString<
  DeleteAppsMutation,
  DeleteAppsMutationVariables
>
export const AppListPreviewDocument = new TypedDocumentString(`
    query AppListPreview($options: AppOptions, $where: AppWhere) {
  aggregate: appsAggregate(where: $where) {
    count
  }
  items: apps(options: $options, where: $where) {
    ...AppPreview
  }
}
    fragment AppPreview on App {
  domains {
    ...Domain
  }
  id
  name
  owner {
    ...Owner
  }
  pages {
    ...PagePreview
  }
  slug
}
fragment Domain on Domain {
  app {
    id
  }
  domainConfig {
    misconfigured
  }
  id
  name
}
fragment PagePreview on Page {
  app {
    id
  }
  id
  kind
  name
  rootElement {
    id
  }
  elements {
    id
  }
  store {
    id
  }
  urlPattern
}
fragment Owner on User {
  id
}`) as unknown as TypedDocumentString<
  AppListPreviewQuery,
  AppListPreviewQueryVariables
>
export const AppListDocument = new TypedDocumentString(`
    query AppList($options: AppOptions, $where: AppWhere) {
  items: apps(options: $options, where: $where) {
    ...App
  }
  aggregate: appsAggregate(where: $where) {
    count
  }
  atoms(where: {type: ReactFragment}) {
    ...AtomBuilder
  }
}
    fragment BaseAction on BaseAction {
  __typename
  id
  name
  store {
    id
    name
  }
  type
}
fragment Action on BaseAction {
  ...BaseAction
  ... on CodeAction {
    ...CodeAction
  }
  ... on ApiAction {
    ...ApiAction
  }
}
fragment ApiAction on ApiAction {
  ...BaseAction
  config {
    data
    id
  }
  errorAction {
    ...BaseAction
  }
  resource {
    ...Resource
  }
  successAction {
    ...BaseAction
  }
}
fragment CodeAction on CodeAction {
  ...BaseAction
  code
}
fragment App on App {
  domains {
    ...Domain
  }
  id
  name
  owner {
    ...Owner
  }
  pages {
    ...Page
  }
  slug
}
fragment AtomBuilder on Atom {
  __typename
  api {
    ...InterfaceType
  }
  icon
  id
  name
  requiredParents {
    id
    name
    type
  }
  suggestedChildren {
    id
    name
    type
  }
  tags {
    ...TagPreview
  }
  type
  owner {
    id
  }
}
fragment Domain on Domain {
  app {
    id
  }
  domainConfig {
    misconfigured
  }
  id
  name
}
fragment Element on Element {
  __typename
  childMapperComponent {
    id
    name
  }
  childMapperPreviousSibling {
    id
  }
  childMapperPropKey
  dependantTypes {
    ...Type
  }
  firstChild {
    id
  }
  id
  name
  nextSibling {
    id
  }
  page {
    id
  }
  parentComponent {
    id
  }
  parentElement {
    id
  }
  postRenderActions {
    id
    type
  }
  preRenderActions {
    id
    type
  }
  prevSibling {
    id
  }
  props {
    ...Prop
  }
  renderForEachPropKey
  renderIfExpression
  renderType {
    ... on Atom {
      __typename
      ...AtomBuilder
    }
    ... on Component {
      __typename
      id
    }
  }
  style
  tailwindClassNames
  expanded
}
fragment Page on Page {
  app {
    id
  }
  elements {
    ...Element
  }
  id
  kind
  name
  pageContentContainer {
    id
  }
  redirect {
    id
  }
  rootElement {
    id
  }
  store {
    ...Store
  }
  urlPattern
}
fragment Prop on Prop {
  data
  id
}
fragment Resource on Resource {
  config {
    ...Prop
  }
  id
  name
  type
  owner {
    id
  }
}
fragment Store on Store {
  actions {
    ...Action
  }
  api {
    ...InterfaceType
  }
  id
  name
}
fragment TagPreview on Tag {
  id
  name
  owner {
    id
  }
}
fragment ActionType on ActionType {
  ...BaseType
}
fragment AppType on AppType {
  ...BaseType
}
fragment ArrayType on ArrayType {
  ...BaseType
  itemType {
    ... on IBaseType {
      id
      kind
      name
    }
  }
}
fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}
fragment CodeMirrorType on CodeMirrorType {
  ...BaseType
  language
}
fragment ElementType on ElementType {
  ...BaseType
  elementKind
}
fragment EnumTypeValue on EnumTypeValue {
  id
  key
  value
}
fragment EnumType on EnumType {
  allowedValues {
    ...EnumTypeValue
  }
  ...BaseType
}
fragment Field on Field {
  api {
    ... on InterfaceType {
      id
    }
  }
  defaultValues
  description
  fieldType {
    ... on IBaseType {
      __typename
      id
      kind
      name
    }
  }
  id
  key
  name
  nextSibling {
    id
  }
  prevSibling {
    id
  }
  validationRules
}
fragment InterfaceType on InterfaceType {
  ...BaseType
  fields {
    ...Field
  }
}
fragment LambdaType on LambdaType {
  ...BaseType
}
fragment PageType on PageType {
  ...BaseType
}
fragment PrimitiveType on PrimitiveType {
  ...BaseType
  primitiveKind
}
fragment ReactNodeType on ReactNodeType {
  ...BaseType
}
fragment RenderPropType on RenderPropType {
  ...BaseType
}
fragment RichTextType on RichTextType {
  ...BaseType
}
fragment Type on IBaseType {
  ...ActionType
  ...AppType
  ...ArrayType
  ...CodeMirrorType
  ...ElementType
  ...EnumType
  ...InterfaceType
  ...LambdaType
  ...PageType
  ...PrimitiveType
  ...ReactNodeType
  ...RenderPropType
  ...RichTextType
  ...UnionType
}
fragment UnionType on UnionType {
  ...BaseType
  typesOfUnionType {
    ... on IBaseType {
      ...BaseType
    }
  }
}
fragment Owner on User {
  id
}`) as unknown as TypedDocumentString<AppListQuery, AppListQueryVariables>
export const GetAppProductionDocument = new TypedDocumentString(`
    query GetAppProduction($domain: String!, $pageUrlPattern: String!) {
  apps(where: {domains_SOME: {name_IN: [$domain]}}) {
    ...AppProduction
  }
  atoms(where: {type: ReactFragment}) {
    ...AtomProduction
  }
  resources {
    ...Resource
  }
}
    fragment BaseAction on BaseAction {
  __typename
  id
  name
  store {
    id
    name
  }
  type
}
fragment Action on BaseAction {
  ...BaseAction
  ... on CodeAction {
    ...CodeAction
  }
  ... on ApiAction {
    ...ApiAction
  }
}
fragment ApiAction on ApiAction {
  ...BaseAction
  config {
    data
    id
  }
  errorAction {
    ...BaseAction
  }
  resource {
    ...Resource
  }
  successAction {
    ...BaseAction
  }
}
fragment CodeAction on CodeAction {
  ...BaseAction
  code
}
fragment AppProduction on App {
  id
  name
  owner {
    ...Owner
  }
  pages(where: {OR: [{urlPattern: $pageUrlPattern}, {kind: Provider}]}) {
    ...PageProduction
  }
  slug
}
fragment AtomProduction on Atom {
  __typename
  externalCssSource
  externalJsSource
  externalSourceType
  icon
  id
  name
  requiredParents {
    id
    name
    type
  }
  suggestedChildren {
    id
    name
    type
  }
  type
}
fragment ElementProduction on Element {
  __typename
  childMapperComponent {
    id
    name
  }
  childMapperPreviousSibling {
    id
  }
  childMapperPropKey
  dependantTypes {
    ...Type
  }
  firstChild {
    id
  }
  id
  name
  nextSibling {
    id
  }
  page {
    id
  }
  parentComponent {
    id
  }
  parentElement {
    id
  }
  postRenderActions {
    id
    type
  }
  preRenderActions {
    id
    type
  }
  prevSibling {
    id
  }
  props {
    ...Prop
  }
  renderForEachPropKey
  renderIfExpression
  renderType {
    ... on Atom {
      __typename
      ...AtomProduction
    }
    ... on Component {
      __typename
      id
    }
  }
  style
  tailwindClassNames
}
fragment PageProduction on Page {
  app {
    id
  }
  elements {
    ...ElementProduction
  }
  id
  kind
  name
  pageContentContainer {
    id
  }
  redirect {
    id
  }
  rootElement {
    id
  }
  slug
  store {
    ...Store
  }
  urlPattern
}
fragment Prop on Prop {
  data
  id
}
fragment Resource on Resource {
  config {
    ...Prop
  }
  id
  name
  type
  owner {
    id
  }
}
fragment Store on Store {
  actions {
    ...Action
  }
  api {
    ...InterfaceType
  }
  id
  name
}
fragment ActionType on ActionType {
  ...BaseType
}
fragment AppType on AppType {
  ...BaseType
}
fragment ArrayType on ArrayType {
  ...BaseType
  itemType {
    ... on IBaseType {
      id
      kind
      name
    }
  }
}
fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}
fragment CodeMirrorType on CodeMirrorType {
  ...BaseType
  language
}
fragment ElementType on ElementType {
  ...BaseType
  elementKind
}
fragment EnumTypeValue on EnumTypeValue {
  id
  key
  value
}
fragment EnumType on EnumType {
  allowedValues {
    ...EnumTypeValue
  }
  ...BaseType
}
fragment Field on Field {
  api {
    ... on InterfaceType {
      id
    }
  }
  defaultValues
  description
  fieldType {
    ... on IBaseType {
      __typename
      id
      kind
      name
    }
  }
  id
  key
  name
  nextSibling {
    id
  }
  prevSibling {
    id
  }
  validationRules
}
fragment InterfaceType on InterfaceType {
  ...BaseType
  fields {
    ...Field
  }
}
fragment LambdaType on LambdaType {
  ...BaseType
}
fragment PageType on PageType {
  ...BaseType
}
fragment PrimitiveType on PrimitiveType {
  ...BaseType
  primitiveKind
}
fragment ReactNodeType on ReactNodeType {
  ...BaseType
}
fragment RenderPropType on RenderPropType {
  ...BaseType
}
fragment RichTextType on RichTextType {
  ...BaseType
}
fragment Type on IBaseType {
  ...ActionType
  ...AppType
  ...ArrayType
  ...CodeMirrorType
  ...ElementType
  ...EnumType
  ...InterfaceType
  ...LambdaType
  ...PageType
  ...PrimitiveType
  ...ReactNodeType
  ...RenderPropType
  ...RichTextType
  ...UnionType
}
fragment UnionType on UnionType {
  ...BaseType
  typesOfUnionType {
    ... on IBaseType {
      ...BaseType
    }
  }
}
fragment Owner on User {
  id
}`) as unknown as TypedDocumentString<
  GetAppProductionQuery,
  GetAppProductionQueryVariables
>
export const CreateAtomsDocument = new TypedDocumentString(`
    mutation CreateAtoms($input: [AtomCreateInput!]!) {
  createAtoms(input: $input) {
    atoms {
      id
    }
    info {
      nodesCreated
      relationshipsCreated
    }
  }
}
    `) as unknown as TypedDocumentString<
  CreateAtomsMutation,
  CreateAtomsMutationVariables
>
export const DeleteAtomsDocument = new TypedDocumentString(`
    mutation DeleteAtoms($where: AtomWhere!, $delete: AtomDeleteInput) {
  deleteAtoms(where: $where, delete: $delete) {
    nodesDeleted
    relationshipsDeleted
  }
}
    `) as unknown as TypedDocumentString<
  DeleteAtomsMutation,
  DeleteAtomsMutationVariables
>
export const AtomListDocument = new TypedDocumentString(`
    query AtomList($where: AtomWhere, $options: AtomOptions) {
  aggregate: atomsAggregate(where: $where) {
    count
  }
  items: atoms(options: $options, where: $where) {
    ...Atom
  }
}
    fragment Atom on Atom {
  __typename
  api {
    ...InterfaceType
  }
  externalCssSource
  externalJsSource
  externalSourceType
  icon
  id
  name
  requiredParents {
    id
    name
    type
  }
  suggestedChildren {
    id
    name
    type
  }
  tags {
    ...TagPreview
  }
  type
  owner {
    id
  }
}
fragment TagPreview on Tag {
  id
  name
  owner {
    id
  }
}
fragment BaseType on IBaseType {
  __typename
  id
  kind
  name
  owner {
    id
  }
}
fragment Field on Field {
  api {
    ... on InterfaceType {
      id
    }
  }
  defaultValues
  description
  fieldType {
    ... on IBaseType {
      __typename
      id
      kind
      name
    }
  }
  id
  key
  name
  nextSibling {
    id
  }
  prevSibling {
    id
  }
  validationRules
}
fragment InterfaceType on InterfaceType {
  ...BaseType
  fields {
    ...Field
  }
}`) as unknown as TypedDocumentString<AtomListQuery, AtomListQueryVariables>
export const UpdateAtomsDocument = new TypedDocumentString(`
    mutation UpdateAtoms($where: AtomWhere, $update: AtomUpdateInput) {
  updateAtoms(update: $update, where: $where) {
    atoms {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  UpdateAtomsMutation,
  UpdateAtomsMutationVariables
>
export const CreateFieldsDocument = new TypedDocumentString(`
    mutation CreateFields($input: [FieldCreateInput!]!) {
  createFields(input: $input) {
    fields {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  CreateFieldsMutation,
  CreateFieldsMutationVariables
>
export const UpdateFieldsDocument = new TypedDocumentString(`
    mutation UpdateFields($where: FieldWhere!, $update: FieldUpdateInput!) {
  updateFields(update: $update, where: $where) {
    fields {
      id
    }
  }
}
    `) as unknown as TypedDocumentString<
  UpdateFieldsMutation,
  UpdateFieldsMutationVariables
>
export const DeleteFieldsDocument = new TypedDocumentString(`
    mutation DeleteFields($where: FieldWhere!) {
  deleteFields(where: $where) {
    nodesDeleted
  }
}
    `) as unknown as TypedDocumentString<
  DeleteFieldsMutation,
  DeleteFieldsMutationVariables
>
export const GetFieldsDocument = new TypedDocumentString(`
    query GetFields($where: FieldWhere, $options: FieldOptions) {
  aggregate: fieldsAggregate(where: $where) {
    count
  }
  items: fields(options: $options, where: $where) {
    ...Field
  }
}
    fragment Field on Field {
  api {
    ... on InterfaceType {
      id
    }
  }
  defaultValues
  description
  fieldType {
    ... on IBaseType {
      __typename
      id
      kind
      name
    }
  }
  id
  key
  name
  nextSibling {
    id
  }
  prevSibling {
    id
  }
  validationRules
}`) as unknown as TypedDocumentString<GetFieldsQuery, GetFieldsQueryVariables>
