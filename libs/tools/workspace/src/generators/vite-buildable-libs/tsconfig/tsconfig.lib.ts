/* eslint-disable canonical/sort-keys */
import type { ProjectConfiguration, Tree } from '@nx/devkit'
import type { PackageJson, TsConfigJson } from 'type-fest'

import { joinPathFragments, readJson, updateJson, writeJson } from '@nx/devkit'

export const moveFilesInTsConfig = (
  tree: Tree,
  project: ProjectConfiguration,
) => {
  const tsconfigLibPath = `${project.root}/tsconfig.lib.json`
  const nxTypingCss = '@nx/react/typings/cssmodule.d.ts'
  const nxTypingImage = '@nx/react/typings/image.d.ts'
  const targetTypings = [nxTypingCss, nxTypingImage]

  // Apply the standardization logic directly
  updateJson(tree, tsconfigLibPath, (json: TsConfigJson) => {
    // Track which typings were found in files
    const foundTypings: Record<string, boolean> = {
      [nxTypingCss]: false,
      [nxTypingImage]: false,
    }

    // 1. Clean up 'files' array
    if (json.files && Array.isArray(json.files)) {
      const originalLength = json.files.length

      // Check for typings before filtering
      json.files.forEach((fileEntry: string) => {
        if (fileEntry.endsWith(nxTypingCss)) {
          foundTypings[nxTypingCss] = true
        }

        if (fileEntry.endsWith(nxTypingImage)) {
          foundTypings[nxTypingImage] = true
        }
      })

      json.files = json.files.filter(
        (fileEntry: string) =>
          !fileEntry.endsWith(nxTypingCss) &&
          !fileEntry.endsWith(nxTypingImage),
      )

      if (json.files.length !== originalLength) {
        if (json.files.length === 0) {
          delete json.files
        }
      }
    }

    // 2. Ensure and modify 'compilerOptions.types'
    if (!json.compilerOptions) {
      json.compilerOptions = {}
    }

    // Ensure compilerOptions is an object before accessing types
    if (typeof json.compilerOptions === 'object') {
      json.compilerOptions.rootDir = './src'
      json.compilerOptions.outDir = './dist'
      json.compilerOptions.tsBuildInfoFile = './dist/tsconfig.tsbuildinfo'

      if (!json.compilerOptions.types) {
        json.compilerOptions.types = []
      } else if (!Array.isArray(json.compilerOptions.types)) {
        console.warn(
          `Warning: 'compilerOptions.types' in ${tsconfigLibPath} is not an array. Skipping type addition.`,
        )

        // Don't modify further if types is not an array
        return json
      }

      // 3. Add target typings if they were found in files
      for (const typing of targetTypings) {
        if (
          foundTypings[typing] &&
          !json.compilerOptions.types.includes(typing)
        ) {
          json.compilerOptions.types.push(typing)
        }
      }
    }

    // 4. Update the include array
    if (json.include && Array.isArray(json.include)) {
      // Remove vite.config.ts if it exists
      json.include = json.include.filter((item) => item !== 'vite.config.ts')

      // Replace "**/*.ts" with "src/**/*.ts"
      json.include = json.include.map((pattern) => {
        if (pattern === '**/*.ts') {
          return 'src/**/*.ts'
        }

        return pattern
      })
    }

    return json
  })
}

/**
 * Removes the compilerOptions.module property from tsconfig.lib.json if it exists.
 * GENERATED BY CURSOR
 */
export const updateTsConfigForVite = (
  tree: Tree,
  projectConfig: ProjectConfiguration,
) => {
  const tsconfigPath = joinPathFragments(
    projectConfig.root,
    'tsconfig.lib.json',
  )

  if (!tree.exists(tsconfigPath)) {
    console.warn(
      `Tsconfig.lib.json not found at ${tsconfigPath}, skipping update.`,
    )

    return
  }

  const tsconfigJson = readJson(tree, tsconfigPath)

  if (tsconfigJson.compilerOptions?.module) {
    delete tsconfigJson.compilerOptions.module
    writeJson(tree, tsconfigPath, tsconfigJson)
    console.log(`Removed compilerOptions.module from: ${tsconfigPath}`)
  } else {
    console.log(
      `compilerOptions.module not found or already removed in: ${tsconfigPath}`,
    )
  }
}
