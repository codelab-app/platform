union AnyType =
    AppType
  | ArrayType
  | ElementType
  | EnumType
  | InterfaceType
  | LambdaType
  | MonacoType
  | PageType
  | PrimitiveType
  | RenderPropsType
  | UnionType

type App {
  id: ID!
  name: String!
  owner(options: UserOptions, where: UserWhere): [User]
  ownerAggregate(where: UserWhere): AppUserOwnerAggregationSelection
  ownerConnection(
    after: String
    first: Int
    sort: [AppOwnerConnectionSort!]
    where: AppOwnerConnectionWhere
  ): AppOwnerConnection!
  pages(options: PageOptions, where: PageWhere): [Page!]
  pagesAggregate(where: PageWhere): AppPagePagesAggregationSelection
  pagesConnection(
    after: String
    first: Int
    sort: [AppPagesConnectionSort!]
    where: AppPagesConnectionWhere
  ): AppPagesConnection!
}

type AppAggregateSelection {
  count: Int!
  id: IDAggregateSelection!
  name: StringAggregateSelection!
}

input AppConnectInput {
  owner: [AppOwnerConnectFieldInput!]
  pages: [AppPagesConnectFieldInput!]
}

input AppConnectOrCreateInput {
  owner: [AppOwnerConnectOrCreateFieldInput!]
  pages: [AppPagesConnectOrCreateFieldInput!]
}

input AppConnectOrCreateWhere {
  node: AppUniqueWhere!
}

input AppConnectWhere {
  node: AppWhere!
}

input AppCreateInput {
  name: String!
  owner: AppOwnerFieldInput
  pages: AppPagesFieldInput
}

input AppDeleteInput {
  owner: [AppOwnerDeleteFieldInput!]
  pages: [AppPagesDeleteFieldInput!]
}

input AppDisconnectInput {
  owner: [AppOwnerDisconnectFieldInput!]
  pages: [AppPagesDisconnectFieldInput!]
}

input AppOptions {
  limit: Int
  offset: Int

  """
  Specify one or more AppSort objects to sort Apps by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [AppSort]
}

input AppOwnerAggregateInput {
  AND: [AppOwnerAggregateInput!]
  OR: [AppOwnerAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: AppOwnerNodeAggregationWhereInput
}

input AppOwnerConnectFieldInput {
  connect: [UserConnectInput!]
  where: UserConnectWhere
}

input AppOwnerConnectOrCreateFieldInput {
  onCreate: AppOwnerConnectOrCreateFieldInputOnCreate!
  where: UserConnectOrCreateWhere!
}

input AppOwnerConnectOrCreateFieldInputOnCreate {
  node: UserCreateInput!
}

type AppOwnerConnection {
  edges: [AppOwnerRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input AppOwnerConnectionSort {
  node: UserSort
}

input AppOwnerConnectionWhere {
  AND: [AppOwnerConnectionWhere!]
  OR: [AppOwnerConnectionWhere!]
  node: UserWhere
  node_NOT: UserWhere
}

input AppOwnerCreateFieldInput {
  node: UserCreateInput!
}

input AppOwnerDeleteFieldInput {
  delete: UserDeleteInput
  where: AppOwnerConnectionWhere
}

input AppOwnerDisconnectFieldInput {
  disconnect: UserDisconnectInput
  where: AppOwnerConnectionWhere
}

input AppOwnerFieldInput {
  connect: [AppOwnerConnectFieldInput!]
  connectOrCreate: [AppOwnerConnectOrCreateFieldInput!]
  create: [AppOwnerCreateFieldInput!]
}

input AppOwnerNodeAggregationWhereInput {
  AND: [AppOwnerNodeAggregationWhereInput!]
  OR: [AppOwnerNodeAggregationWhereInput!]
  auth0Id_AVERAGE_EQUAL: Float
  auth0Id_AVERAGE_GT: Float
  auth0Id_AVERAGE_GTE: Float
  auth0Id_AVERAGE_LT: Float
  auth0Id_AVERAGE_LTE: Float
  auth0Id_EQUAL: String
  auth0Id_GT: Int
  auth0Id_GTE: Int
  auth0Id_LONGEST_EQUAL: Int
  auth0Id_LONGEST_GT: Int
  auth0Id_LONGEST_GTE: Int
  auth0Id_LONGEST_LT: Int
  auth0Id_LONGEST_LTE: Int
  auth0Id_LT: Int
  auth0Id_LTE: Int
  auth0Id_SHORTEST_EQUAL: Int
  auth0Id_SHORTEST_GT: Int
  auth0Id_SHORTEST_GTE: Int
  auth0Id_SHORTEST_LT: Int
  auth0Id_SHORTEST_LTE: Int
  email_AVERAGE_EQUAL: Float
  email_AVERAGE_GT: Float
  email_AVERAGE_GTE: Float
  email_AVERAGE_LT: Float
  email_AVERAGE_LTE: Float
  email_EQUAL: String
  email_GT: Int
  email_GTE: Int
  email_LONGEST_EQUAL: Int
  email_LONGEST_GT: Int
  email_LONGEST_GTE: Int
  email_LONGEST_LT: Int
  email_LONGEST_LTE: Int
  email_LT: Int
  email_LTE: Int
  email_SHORTEST_EQUAL: Int
  email_SHORTEST_GT: Int
  email_SHORTEST_GTE: Int
  email_SHORTEST_LT: Int
  email_SHORTEST_LTE: Int
  id_EQUAL: ID
}

type AppOwnerRelationship {
  cursor: String!
  node: User!
}

input AppOwnerUpdateConnectionInput {
  node: UserUpdateInput
}

input AppOwnerUpdateFieldInput {
  connect: [AppOwnerConnectFieldInput!]
  connectOrCreate: [AppOwnerConnectOrCreateFieldInput!]
  create: [AppOwnerCreateFieldInput!]
  delete: [AppOwnerDeleteFieldInput!]
  disconnect: [AppOwnerDisconnectFieldInput!]
  update: AppOwnerUpdateConnectionInput
  where: AppOwnerConnectionWhere
}

type AppPagePagesAggregationSelection {
  count: Int!
  node: AppPagePagesNodeAggregateSelection
}

type AppPagePagesNodeAggregateSelection {
  id: IDAggregateSelection!
  name: StringAggregateSelection!
}

input AppPagesAggregateInput {
  AND: [AppPagesAggregateInput!]
  OR: [AppPagesAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: AppPagesNodeAggregationWhereInput
}

input AppPagesConnectFieldInput {
  connect: [PageConnectInput!]
  where: PageConnectWhere
}

input AppPagesConnectOrCreateFieldInput {
  onCreate: AppPagesConnectOrCreateFieldInputOnCreate!
  where: PageConnectOrCreateWhere!
}

input AppPagesConnectOrCreateFieldInputOnCreate {
  node: PageCreateInput!
}

type AppPagesConnection {
  edges: [AppPagesRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input AppPagesConnectionSort {
  node: PageSort
}

input AppPagesConnectionWhere {
  AND: [AppPagesConnectionWhere!]
  OR: [AppPagesConnectionWhere!]
  node: PageWhere
  node_NOT: PageWhere
}

input AppPagesCreateFieldInput {
  node: PageCreateInput!
}

input AppPagesDeleteFieldInput {
  delete: PageDeleteInput
  where: AppPagesConnectionWhere
}

input AppPagesDisconnectFieldInput {
  disconnect: PageDisconnectInput
  where: AppPagesConnectionWhere
}

input AppPagesFieldInput {
  connect: [AppPagesConnectFieldInput!]
  connectOrCreate: [AppPagesConnectOrCreateFieldInput!]
  create: [AppPagesCreateFieldInput!]
}

input AppPagesNodeAggregationWhereInput {
  AND: [AppPagesNodeAggregationWhereInput!]
  OR: [AppPagesNodeAggregationWhereInput!]
  id_EQUAL: ID
  name_AVERAGE_EQUAL: Float
  name_AVERAGE_GT: Float
  name_AVERAGE_GTE: Float
  name_AVERAGE_LT: Float
  name_AVERAGE_LTE: Float
  name_EQUAL: String
  name_GT: Int
  name_GTE: Int
  name_LONGEST_EQUAL: Int
  name_LONGEST_GT: Int
  name_LONGEST_GTE: Int
  name_LONGEST_LT: Int
  name_LONGEST_LTE: Int
  name_LT: Int
  name_LTE: Int
  name_SHORTEST_EQUAL: Int
  name_SHORTEST_GT: Int
  name_SHORTEST_GTE: Int
  name_SHORTEST_LT: Int
  name_SHORTEST_LTE: Int
}

type AppPagesRelationship {
  cursor: String!
  node: Page!
}

input AppPagesUpdateConnectionInput {
  node: PageUpdateInput
}

input AppPagesUpdateFieldInput {
  connect: [AppPagesConnectFieldInput!]
  connectOrCreate: [AppPagesConnectOrCreateFieldInput!]
  create: [AppPagesCreateFieldInput!]
  delete: [AppPagesDeleteFieldInput!]
  disconnect: [AppPagesDisconnectFieldInput!]
  update: AppPagesUpdateConnectionInput
  where: AppPagesConnectionWhere
}

input AppRelationInput {
  owner: [AppOwnerCreateFieldInput!]
  pages: [AppPagesCreateFieldInput!]
}

"""
Fields to sort Apps by. The order in which sorts are applied is not guaranteed when specifying many fields in one AppSort object.
"""
input AppSort {
  id: SortDirection
  name: SortDirection
}

"""
Allows picking a app from the list of apps
"""
type AppType implements TypeBase {
  graph: TypeGraph!
  id: ID!
  name: String!
  owner(options: UserOptions, where: UserWhere): User
  ownerAggregate(where: UserWhere): AppTypeUserOwnerAggregationSelection
  ownerConnection(
    after: String
    first: Int
    sort: [TypeBaseOwnerConnectionSort!]
    where: TypeBaseOwnerConnectionWhere
  ): TypeBaseOwnerConnection!
}

type AppTypeAggregateSelection {
  count: Int!
  id: IDAggregateSelection!
  name: StringAggregateSelection!
}

input AppTypeConnectInput {
  owner: TypeBaseOwnerConnectFieldInput
}

input AppTypeConnectOrCreateInput {
  owner: TypeBaseOwnerConnectOrCreateFieldInput
}

input AppTypeCreateInput {
  name: String!
  owner: TypeBaseOwnerFieldInput
}

input AppTypeDeleteInput {
  owner: TypeBaseOwnerDeleteFieldInput
}

input AppTypeDisconnectInput {
  owner: TypeBaseOwnerDisconnectFieldInput
}

input AppTypeOptions {
  limit: Int
  offset: Int

  """
  Specify one or more AppTypeSort objects to sort AppTypes by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [AppTypeSort]
}

input AppTypeOwnerAggregateInput {
  AND: [AppTypeOwnerAggregateInput!]
  OR: [AppTypeOwnerAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: AppTypeOwnerNodeAggregationWhereInput
}

input AppTypeOwnerNodeAggregationWhereInput {
  AND: [AppTypeOwnerNodeAggregationWhereInput!]
  OR: [AppTypeOwnerNodeAggregationWhereInput!]
  auth0Id_AVERAGE_EQUAL: Float
  auth0Id_AVERAGE_GT: Float
  auth0Id_AVERAGE_GTE: Float
  auth0Id_AVERAGE_LT: Float
  auth0Id_AVERAGE_LTE: Float
  auth0Id_EQUAL: String
  auth0Id_GT: Int
  auth0Id_GTE: Int
  auth0Id_LONGEST_EQUAL: Int
  auth0Id_LONGEST_GT: Int
  auth0Id_LONGEST_GTE: Int
  auth0Id_LONGEST_LT: Int
  auth0Id_LONGEST_LTE: Int
  auth0Id_LT: Int
  auth0Id_LTE: Int
  auth0Id_SHORTEST_EQUAL: Int
  auth0Id_SHORTEST_GT: Int
  auth0Id_SHORTEST_GTE: Int
  auth0Id_SHORTEST_LT: Int
  auth0Id_SHORTEST_LTE: Int
  email_AVERAGE_EQUAL: Float
  email_AVERAGE_GT: Float
  email_AVERAGE_GTE: Float
  email_AVERAGE_LT: Float
  email_AVERAGE_LTE: Float
  email_EQUAL: String
  email_GT: Int
  email_GTE: Int
  email_LONGEST_EQUAL: Int
  email_LONGEST_GT: Int
  email_LONGEST_GTE: Int
  email_LONGEST_LT: Int
  email_LONGEST_LTE: Int
  email_LT: Int
  email_LTE: Int
  email_SHORTEST_EQUAL: Int
  email_SHORTEST_GT: Int
  email_SHORTEST_GTE: Int
  email_SHORTEST_LT: Int
  email_SHORTEST_LTE: Int
  id_EQUAL: ID
}

input AppTypeRelationInput {
  owner: TypeBaseOwnerCreateFieldInput
}

"""
Fields to sort AppTypes by. The order in which sorts are applied is not guaranteed when specifying many fields in one AppTypeSort object.
"""
input AppTypeSort {
  id: SortDirection
  name: SortDirection
}

input AppTypeUpdateInput {
  name: String
  owner: TypeBaseOwnerUpdateFieldInput
}

type AppTypeUserOwnerAggregationSelection {
  count: Int!
  node: AppTypeUserOwnerNodeAggregateSelection
}

type AppTypeUserOwnerNodeAggregateSelection {
  auth0Id: StringAggregateSelection!
  email: StringAggregateSelection!
  id: IDAggregateSelection!
}

input AppTypeWhere {
  AND: [AppTypeWhere!]
  OR: [AppTypeWhere!]
  id: ID
  id_CONTAINS: ID
  id_ENDS_WITH: ID
  id_IN: [ID]
  id_NOT: ID
  id_NOT_CONTAINS: ID
  id_NOT_ENDS_WITH: ID
  id_NOT_IN: [ID]
  id_NOT_STARTS_WITH: ID
  id_STARTS_WITH: ID
  name: String
  name_CONTAINS: String
  name_ENDS_WITH: String
  name_IN: [String]
  name_NOT: String
  name_NOT_CONTAINS: String
  name_NOT_ENDS_WITH: String
  name_NOT_IN: [String]
  name_NOT_STARTS_WITH: String
  name_STARTS_WITH: String
  owner: UserWhere
  ownerAggregate: AppTypeOwnerAggregateInput
  ownerConnection: TypeBaseOwnerConnectionWhere
  ownerConnection_NOT: TypeBaseOwnerConnectionWhere
  owner_NOT: UserWhere
}

input AppUniqueWhere {
  id: ID
}

input AppUpdateInput {
  name: String
  owner: [AppOwnerUpdateFieldInput!]
  pages: [AppPagesUpdateFieldInput!]
}

type AppUserOwnerAggregationSelection {
  count: Int!
  node: AppUserOwnerNodeAggregateSelection
}

type AppUserOwnerNodeAggregateSelection {
  auth0Id: StringAggregateSelection!
  email: StringAggregateSelection!
  id: IDAggregateSelection!
}

input AppWhere {
  AND: [AppWhere!]
  OR: [AppWhere!]
  id: ID
  id_CONTAINS: ID
  id_ENDS_WITH: ID
  id_IN: [ID]
  id_NOT: ID
  id_NOT_CONTAINS: ID
  id_NOT_ENDS_WITH: ID
  id_NOT_IN: [ID]
  id_NOT_STARTS_WITH: ID
  id_STARTS_WITH: ID
  name: String
  name_CONTAINS: String
  name_ENDS_WITH: String
  name_IN: [String]
  name_NOT: String
  name_NOT_CONTAINS: String
  name_NOT_ENDS_WITH: String
  name_NOT_IN: [String]
  name_NOT_STARTS_WITH: String
  name_STARTS_WITH: String
  owner: UserWhere
  ownerAggregate: AppOwnerAggregateInput
  ownerConnection: AppOwnerConnectionWhere
  ownerConnection_NOT: AppOwnerConnectionWhere
  owner_NOT: UserWhere
  pages: PageWhere
  pagesAggregate: AppPagesAggregateInput
  pagesConnection: AppPagesConnectionWhere
  pagesConnection_NOT: AppPagesConnectionWhere
  pages_NOT: PageWhere
}

"""
ArrayType Allows defining a variable number of items of a given type.
Contains a reference to another type which is the array item type.
"""
type ArrayType implements TypeBase {
  graph: TypeGraph!
  id: ID!
  itemType(options: QueryOptions, where: TypeBaseWhere): [TypeBase!]
  itemTypeConnection(
    where: ArrayTypeItemTypeConnectionWhere
  ): ArrayTypeItemTypeConnection!
  name: String!
  owner(options: UserOptions, where: UserWhere): User
  ownerAggregate(where: UserWhere): ArrayTypeUserOwnerAggregationSelection
  ownerConnection(
    after: String
    first: Int
    sort: [TypeBaseOwnerConnectionSort!]
    where: TypeBaseOwnerConnectionWhere
  ): TypeBaseOwnerConnection!
}

type ArrayTypeAggregateSelection {
  count: Int!
  id: IDAggregateSelection!
  name: StringAggregateSelection!
}

input ArrayTypeConnectInput {
  itemType: [ArrayTypeItemTypeConnectFieldInput!]
  owner: TypeBaseOwnerConnectFieldInput
}

input ArrayTypeConnectOrCreateInput {
  owner: TypeBaseOwnerConnectOrCreateFieldInput
}

input ArrayTypeCreateInput {
  itemType: ArrayTypeItemTypeFieldInput
  name: String!
  owner: TypeBaseOwnerFieldInput
}

input ArrayTypeDeleteInput {
  itemType: [ArrayTypeItemTypeDeleteFieldInput!]
  owner: TypeBaseOwnerDeleteFieldInput
}

input ArrayTypeDisconnectInput {
  itemType: [ArrayTypeItemTypeDisconnectFieldInput!]
  owner: TypeBaseOwnerDisconnectFieldInput
}

input ArrayTypeItemTypeConnectFieldInput {
  connect: TypeBaseConnectInput
  where: TypeBaseConnectWhere
}

type ArrayTypeItemTypeConnection {
  edges: [ArrayTypeItemTypeRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input ArrayTypeItemTypeConnectionWhere {
  AND: [ArrayTypeItemTypeConnectionWhere!]
  OR: [ArrayTypeItemTypeConnectionWhere!]
  node: TypeBaseWhere
  node_NOT: TypeBaseWhere
}

input ArrayTypeItemTypeCreateFieldInput {
  node: TypeBaseCreateInput!
}

input ArrayTypeItemTypeDeleteFieldInput {
  delete: TypeBaseDeleteInput
  where: ArrayTypeItemTypeConnectionWhere
}

input ArrayTypeItemTypeDisconnectFieldInput {
  disconnect: TypeBaseDisconnectInput
  where: ArrayTypeItemTypeConnectionWhere
}

input ArrayTypeItemTypeFieldInput {
  connect: [ArrayTypeItemTypeConnectFieldInput!]
  create: [ArrayTypeItemTypeCreateFieldInput!]
}

type ArrayTypeItemTypeRelationship {
  cursor: String!
  node: TypeBase!
}

input ArrayTypeItemTypeUpdateConnectionInput {
  node: TypeBaseUpdateInput
}

input ArrayTypeItemTypeUpdateFieldInput {
  connect: [ArrayTypeItemTypeConnectFieldInput!]
  create: [ArrayTypeItemTypeCreateFieldInput!]
  delete: [ArrayTypeItemTypeDeleteFieldInput!]
  disconnect: [ArrayTypeItemTypeDisconnectFieldInput!]
  update: ArrayTypeItemTypeUpdateConnectionInput
  where: ArrayTypeItemTypeConnectionWhere
}

input ArrayTypeOptions {
  limit: Int
  offset: Int

  """
  Specify one or more ArrayTypeSort objects to sort ArrayTypes by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [ArrayTypeSort]
}

input ArrayTypeOwnerAggregateInput {
  AND: [ArrayTypeOwnerAggregateInput!]
  OR: [ArrayTypeOwnerAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: ArrayTypeOwnerNodeAggregationWhereInput
}

input ArrayTypeOwnerNodeAggregationWhereInput {
  AND: [ArrayTypeOwnerNodeAggregationWhereInput!]
  OR: [ArrayTypeOwnerNodeAggregationWhereInput!]
  auth0Id_AVERAGE_EQUAL: Float
  auth0Id_AVERAGE_GT: Float
  auth0Id_AVERAGE_GTE: Float
  auth0Id_AVERAGE_LT: Float
  auth0Id_AVERAGE_LTE: Float
  auth0Id_EQUAL: String
  auth0Id_GT: Int
  auth0Id_GTE: Int
  auth0Id_LONGEST_EQUAL: Int
  auth0Id_LONGEST_GT: Int
  auth0Id_LONGEST_GTE: Int
  auth0Id_LONGEST_LT: Int
  auth0Id_LONGEST_LTE: Int
  auth0Id_LT: Int
  auth0Id_LTE: Int
  auth0Id_SHORTEST_EQUAL: Int
  auth0Id_SHORTEST_GT: Int
  auth0Id_SHORTEST_GTE: Int
  auth0Id_SHORTEST_LT: Int
  auth0Id_SHORTEST_LTE: Int
  email_AVERAGE_EQUAL: Float
  email_AVERAGE_GT: Float
  email_AVERAGE_GTE: Float
  email_AVERAGE_LT: Float
  email_AVERAGE_LTE: Float
  email_EQUAL: String
  email_GT: Int
  email_GTE: Int
  email_LONGEST_EQUAL: Int
  email_LONGEST_GT: Int
  email_LONGEST_GTE: Int
  email_LONGEST_LT: Int
  email_LONGEST_LTE: Int
  email_LT: Int
  email_LTE: Int
  email_SHORTEST_EQUAL: Int
  email_SHORTEST_GT: Int
  email_SHORTEST_GTE: Int
  email_SHORTEST_LT: Int
  email_SHORTEST_LTE: Int
  id_EQUAL: ID
}

input ArrayTypeRelationInput {
  itemType: [ArrayTypeItemTypeCreateFieldInput!]
  owner: TypeBaseOwnerCreateFieldInput
}

"""
Fields to sort ArrayTypes by. The order in which sorts are applied is not guaranteed when specifying many fields in one ArrayTypeSort object.
"""
input ArrayTypeSort {
  id: SortDirection
  name: SortDirection
}

input ArrayTypeUpdateInput {
  itemType: [ArrayTypeItemTypeUpdateFieldInput!]
  name: String
  owner: TypeBaseOwnerUpdateFieldInput
}

type ArrayTypeUserOwnerAggregationSelection {
  count: Int!
  node: ArrayTypeUserOwnerNodeAggregateSelection
}

type ArrayTypeUserOwnerNodeAggregateSelection {
  auth0Id: StringAggregateSelection!
  email: StringAggregateSelection!
  id: IDAggregateSelection!
}

input ArrayTypeWhere {
  AND: [ArrayTypeWhere!]
  OR: [ArrayTypeWhere!]
  id: ID
  id_CONTAINS: ID
  id_ENDS_WITH: ID
  id_IN: [ID]
  id_NOT: ID
  id_NOT_CONTAINS: ID
  id_NOT_ENDS_WITH: ID
  id_NOT_IN: [ID]
  id_NOT_STARTS_WITH: ID
  id_STARTS_WITH: ID
  itemTypeConnection: ArrayTypeItemTypeConnectionWhere
  itemTypeConnection_NOT: ArrayTypeItemTypeConnectionWhere
  name: String
  name_CONTAINS: String
  name_ENDS_WITH: String
  name_IN: [String]
  name_NOT: String
  name_NOT_CONTAINS: String
  name_NOT_ENDS_WITH: String
  name_NOT_IN: [String]
  name_NOT_STARTS_WITH: String
  name_STARTS_WITH: String
  owner: UserWhere
  ownerAggregate: ArrayTypeOwnerAggregateInput
  ownerConnection: TypeBaseOwnerConnectionWhere
  ownerConnection_NOT: TypeBaseOwnerConnectionWhere
  owner_NOT: UserWhere
}

type Atom {
  api(options: InterfaceTypeOptions, where: InterfaceTypeWhere): InterfaceType!
  apiAggregate(
    where: InterfaceTypeWhere
  ): AtomInterfaceTypeApiAggregationSelection
  apiConnection(
    after: String
    first: Int
    sort: [AtomApiConnectionSort!]
    where: AtomApiConnectionWhere
  ): AtomApiConnection!
  id: ID!
  name: String!
  tags(options: TagOptions, where: TagWhere): [Tag!]
  tagsAggregate(where: TagWhere): AtomTagTagsAggregationSelection
  tagsConnection(
    after: String
    first: Int
    sort: [AtomTagsConnectionSort!]
    where: AtomTagsConnectionWhere
  ): AtomTagsConnection!
  type: AtomType!
}

type AtomAggregateSelection {
  count: Int!
  id: IDAggregateSelection!
  name: StringAggregateSelection!
}

input AtomApiAggregateInput {
  AND: [AtomApiAggregateInput!]
  OR: [AtomApiAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: AtomApiNodeAggregationWhereInput
}

input AtomApiConnectFieldInput {
  connect: InterfaceTypeConnectInput
  where: InterfaceTypeConnectWhere
}

input AtomApiConnectOrCreateFieldInput {
  onCreate: AtomApiConnectOrCreateFieldInputOnCreate!
  where: InterfaceTypeConnectOrCreateWhere!
}

input AtomApiConnectOrCreateFieldInputOnCreate {
  node: InterfaceTypeCreateInput!
}

type AtomApiConnection {
  edges: [AtomApiRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input AtomApiConnectionSort {
  node: InterfaceTypeSort
}

input AtomApiConnectionWhere {
  AND: [AtomApiConnectionWhere!]
  OR: [AtomApiConnectionWhere!]
  node: InterfaceTypeWhere
  node_NOT: InterfaceTypeWhere
}

input AtomApiCreateFieldInput {
  node: InterfaceTypeCreateInput!
}

input AtomApiDeleteFieldInput {
  delete: InterfaceTypeDeleteInput
  where: AtomApiConnectionWhere
}

input AtomApiDisconnectFieldInput {
  disconnect: InterfaceTypeDisconnectInput
  where: AtomApiConnectionWhere
}

input AtomApiFieldInput {
  connect: AtomApiConnectFieldInput
  connectOrCreate: AtomApiConnectOrCreateFieldInput
  create: AtomApiCreateFieldInput
}

input AtomApiNodeAggregationWhereInput {
  AND: [AtomApiNodeAggregationWhereInput!]
  OR: [AtomApiNodeAggregationWhereInput!]
  id_EQUAL: ID
  name_AVERAGE_EQUAL: Float
  name_AVERAGE_GT: Float
  name_AVERAGE_GTE: Float
  name_AVERAGE_LT: Float
  name_AVERAGE_LTE: Float
  name_EQUAL: String
  name_GT: Int
  name_GTE: Int
  name_LONGEST_EQUAL: Int
  name_LONGEST_GT: Int
  name_LONGEST_GTE: Int
  name_LONGEST_LT: Int
  name_LONGEST_LTE: Int
  name_LT: Int
  name_LTE: Int
  name_SHORTEST_EQUAL: Int
  name_SHORTEST_GT: Int
  name_SHORTEST_GTE: Int
  name_SHORTEST_LT: Int
  name_SHORTEST_LTE: Int
}

type AtomApiRelationship {
  cursor: String!
  node: InterfaceType!
}

input AtomApiUpdateConnectionInput {
  node: InterfaceTypeUpdateInput
}

input AtomApiUpdateFieldInput {
  connect: AtomApiConnectFieldInput
  connectOrCreate: AtomApiConnectOrCreateFieldInput
  create: AtomApiCreateFieldInput
  delete: AtomApiDeleteFieldInput
  disconnect: AtomApiDisconnectFieldInput
  update: AtomApiUpdateConnectionInput
  where: AtomApiConnectionWhere
}

input AtomConnectInput {
  api: AtomApiConnectFieldInput
  tags: [AtomTagsConnectFieldInput!]
}

input AtomConnectOrCreateInput {
  api: AtomApiConnectOrCreateFieldInput
  tags: [AtomTagsConnectOrCreateFieldInput!]
}

input AtomConnectOrCreateWhere {
  node: AtomUniqueWhere!
}

input AtomConnectWhere {
  node: AtomWhere!
}

input AtomCreateInput {
  api: AtomApiFieldInput
  name: String!
  tags: AtomTagsFieldInput
  type: AtomType!
}

input AtomDeleteInput {
  api: AtomApiDeleteFieldInput
  tags: [AtomTagsDeleteFieldInput!]
}

input AtomDisconnectInput {
  api: AtomApiDisconnectFieldInput
  tags: [AtomTagsDisconnectFieldInput!]
}

type AtomInterfaceTypeApiAggregationSelection {
  count: Int!
  node: AtomInterfaceTypeApiNodeAggregateSelection
}

type AtomInterfaceTypeApiNodeAggregateSelection {
  id: IDAggregateSelection!
  name: StringAggregateSelection!
}

input AtomOptions {
  limit: Int
  offset: Int

  """
  Specify one or more AtomSort objects to sort Atoms by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [AtomSort]
}

input AtomRelationInput {
  api: AtomApiCreateFieldInput
  tags: [AtomTagsCreateFieldInput!]
}

"""
Fields to sort Atoms by. The order in which sorts are applied is not guaranteed when specifying many fields in one AtomSort object.
"""
input AtomSort {
  id: SortDirection
  name: SortDirection
  type: SortDirection
}

type AtomTagTagsAggregationSelection {
  count: Int!
  node: AtomTagTagsNodeAggregateSelection
}

type AtomTagTagsNodeAggregateSelection {
  id: IDAggregateSelection!
  name: StringAggregateSelection!
}

input AtomTagsAggregateInput {
  AND: [AtomTagsAggregateInput!]
  OR: [AtomTagsAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: AtomTagsNodeAggregationWhereInput
}

input AtomTagsConnectFieldInput {
  connect: [TagConnectInput!]
  where: TagConnectWhere
}

input AtomTagsConnectOrCreateFieldInput {
  onCreate: AtomTagsConnectOrCreateFieldInputOnCreate!
  where: TagConnectOrCreateWhere!
}

input AtomTagsConnectOrCreateFieldInputOnCreate {
  node: TagCreateInput!
}

type AtomTagsConnection {
  edges: [AtomTagsRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input AtomTagsConnectionSort {
  node: TagSort
}

input AtomTagsConnectionWhere {
  AND: [AtomTagsConnectionWhere!]
  OR: [AtomTagsConnectionWhere!]
  node: TagWhere
  node_NOT: TagWhere
}

input AtomTagsCreateFieldInput {
  node: TagCreateInput!
}

input AtomTagsDeleteFieldInput {
  delete: TagDeleteInput
  where: AtomTagsConnectionWhere
}

input AtomTagsDisconnectFieldInput {
  disconnect: TagDisconnectInput
  where: AtomTagsConnectionWhere
}

input AtomTagsFieldInput {
  connect: [AtomTagsConnectFieldInput!]
  connectOrCreate: [AtomTagsConnectOrCreateFieldInput!]
  create: [AtomTagsCreateFieldInput!]
}

input AtomTagsNodeAggregationWhereInput {
  AND: [AtomTagsNodeAggregationWhereInput!]
  OR: [AtomTagsNodeAggregationWhereInput!]
  id_EQUAL: ID
  name_AVERAGE_EQUAL: Float
  name_AVERAGE_GT: Float
  name_AVERAGE_GTE: Float
  name_AVERAGE_LT: Float
  name_AVERAGE_LTE: Float
  name_EQUAL: String
  name_GT: Int
  name_GTE: Int
  name_LONGEST_EQUAL: Int
  name_LONGEST_GT: Int
  name_LONGEST_GTE: Int
  name_LONGEST_LT: Int
  name_LONGEST_LTE: Int
  name_LT: Int
  name_LTE: Int
  name_SHORTEST_EQUAL: Int
  name_SHORTEST_GT: Int
  name_SHORTEST_GTE: Int
  name_SHORTEST_LT: Int
  name_SHORTEST_LTE: Int
}

type AtomTagsRelationship {
  cursor: String!
  node: Tag!
}

input AtomTagsUpdateConnectionInput {
  node: TagUpdateInput
}

input AtomTagsUpdateFieldInput {
  connect: [AtomTagsConnectFieldInput!]
  connectOrCreate: [AtomTagsConnectOrCreateFieldInput!]
  create: [AtomTagsCreateFieldInput!]
  delete: [AtomTagsDeleteFieldInput!]
  disconnect: [AtomTagsDisconnectFieldInput!]
  update: AtomTagsUpdateConnectionInput
  where: AtomTagsConnectionWhere
}

enum AtomType {
  AntDesignAffix
  AntDesignAlert
  AntDesignAnchor
  AntDesignAnchorLink
  AntDesignAutoComplete
  AntDesignAvatar
  AntDesignBackTop
  AntDesignBadge
  AntDesignBreadcrumb
  AntDesignBreadcrumbItem
  AntDesignButton
  AntDesignCalendar
  AntDesignCard
  AntDesignCardGrid
  AntDesignCardMeta
  AntDesignCarousel
  AntDesignCascader
  AntDesignCheckbox
  AntDesignCollapse
  AntDesignCollapsePanel
  AntDesignComment
  AntDesignConfigProvider
  AntDesignDatePicker
  AntDesignDescriptions
  AntDesignDescriptionsItem
  AntDesignDivider
  AntDesignDrawer
  AntDesignDropdown
  AntDesignEmpty
  AntDesignForm
  AntDesignFormItem
  AntDesignFormItemHook
  AntDesignFormList
  AntDesignGridCol
  AntDesignGridRow
  AntDesignIcon
  AntDesignImage
  AntDesignInput
  AntDesignInputNumber
  AntDesignLayout
  AntDesignLayoutContent
  AntDesignLayoutFooter
  AntDesignLayoutHeader
  AntDesignLayoutSider
  AntDesignList
  AntDesignListItem
  AntDesignListItemMeta
  AntDesignMapper
  AntDesignMentions
  AntDesignMentionsOption
  AntDesignMenu
  AntDesignMenuItem
  AntDesignMenuItemGroup
  AntDesignMenuSubMenu
  AntDesignModal
  AntDesignPageContainer
  AntDesignPageHeader
  AntDesignPagination
  AntDesignPopconfirm
  AntDesignPopover
  AntDesignProgress
  AntDesignProvider
  AntDesignRadio
  AntDesignRadioGroup
  AntDesignRate
  AntDesignRenderComponent
  AntDesignRenderContainer
  AntDesignResult
  AntDesignRglContainer
  AntDesignRglItem
  AntDesignRglResponsiveContainer
  AntDesignSelect
  AntDesignSelectOption
  AntDesignSkeleton
  AntDesignSlider
  AntDesignSpace
  AntDesignSpin
  AntDesignStatistic
  AntDesignSteps
  AntDesignStepsStep
  AntDesignSwitch
  AntDesignTable
  AntDesignTabs
  AntDesignTabsTabPane
  AntDesignTag
  AntDesignTimePicker
  AntDesignTimeline
  AntDesignTimelineItem
  AntDesignTooltip
  AntDesignTransfer
  AntDesignTree
  AntDesignTreeNode
  AntDesignTreeSelect
  AntDesignTypography
  AntDesignTypographyParagraph
  AntDesignTypographyText
  AntDesignTypographyTitle
  AntDesignUpload
  HookGraphqlMutation
  HookGraphqlQuery
  HookQueryConfig
  HookQueryLambda
  HookQueryPage
  HookQueryPages
  HookRecoilState
  HookRouter
  HtmlA
  HtmlArea
  HtmlAside
  HtmlAudio
  HtmlBase
  HtmlBr
  HtmlButton
  HtmlCanvas
  HtmlCode
  HtmlDList
  HtmlData
  HtmlDatalist
  HtmlDetails
  HtmlDialog
  HtmlDiv
  HtmlEm
  HtmlEmbed
  HtmlFieldset
  HtmlFont
  HtmlFooter
  HtmlForm
  HtmlFrame
  HtmlFrameset
  HtmlH1
  HtmlH2
  HtmlH3
  HtmlH4
  HtmlH5
  HtmlH6
  HtmlHead
  HtmlHeader
  HtmlHr
  HtmlI
  HtmlIframe
  HtmlImage
  HtmlInput
  HtmlLabel
  HtmlLegend
  HtmlLi
  HtmlLink
  HtmlMain
  HtmlMap
  HtmlMeta
  HtmlMeter
  HtmlNav
  HtmlOList
  HtmlObject
  HtmlOptgroup
  HtmlOption
  HtmlOutput
  HtmlP
  HtmlParam
  HtmlPicture
  HtmlPre
  HtmlProgress
  HtmlQuote
  HtmlS
  HtmlSection
  HtmlSelect
  HtmlSmall
  HtmlSource
  HtmlSpan
  HtmlStrong
  HtmlStyle
  HtmlSub
  HtmlSup
  HtmlTable
  HtmlTableCaption
  HtmlTableCell
  HtmlTableCol
  HtmlTableRow
  HtmlTemplate
  HtmlTextarea
  HtmlTime
  HtmlTitle
  HtmlTrack
  HtmlUList
  HtmlVideo
  MuiAccordion
  MuiAccordionActions
  MuiAccordionDetails
  MuiAccordionSummary
  MuiAlert
  MuiAlertTitle
  MuiAppBar
  MuiAutocomplete
  MuiAvatar
  MuiAvatarGroup
  MuiBackdrop
  MuiBackdropUnstyled
  MuiBadge
  MuiBadgeUnstyled
  MuiBottomNavigation
  MuiBottomNavigationAction
  MuiBox
  MuiBreadcrumbs
  MuiButton
  MuiButtonBase
  MuiButtonGroup
  MuiButtonUnstyled
  MuiCalendarPicker
  MuiCalendarPickerSkeleton
  MuiCard
  MuiCardActionArea
  MuiCardActions
  MuiCardContent
  MuiCardHeader
  MuiCardMedia
  MuiCheckbox
  MuiChip
  MuiCircularProgress
  MuiClickAwayListener
  MuiClockPicker
  MuiCollapse
  MuiContainer
  MuiCssBaseline
  MuiDataGrid
  MuiDatePicker
  MuiDateRangePicker
  MuiDateRangePickerDay
  MuiDateTimePicker
  MuiDesktopDatePicker
  MuiDesktopDateRangePicker
  MuiDesktopDateTimePicker
  MuiDesktopTimePicker
  MuiDialog
  MuiDialogActions
  MuiDialogContent
  MuiDialogContentText
  MuiDialogTitle
  MuiDivider
  MuiDrawer
  MuiFab
  MuiFade
  MuiFilledInput
  MuiFormControl
  MuiFormControlLabel
  MuiFormControlUnstyled
  MuiFormGroup
  MuiFormHelperText
  MuiFormLabel
  MuiGlobalStyles
  MuiGrid
  MuiGridColDef
  MuiGrow
  MuiHidden
  MuiIcon
  MuiIconButton
  MuiImageList
  MuiImageListItem
  MuiImageListItemBar
  MuiInput
  MuiInputAdornment
  MuiInputBase
  MuiInputLabel
  MuiLinearProgress
  MuiLink
  MuiList
  MuiListItem
  MuiListItemAvatar
  MuiListItemButton
  MuiListItemIcon
  MuiListItemSecondaryAction
  MuiListItemText
  MuiListSubheader
  MuiLoadingButton
  MuiMasonry
  MuiMasonryItem
  MuiMenu
  MuiMenuItem
  MuiMenuList
  MuiMobileDatePicker
  MuiMobileDateRangePicker
  MuiMobileDateTimePicker
  MuiMobileStepper
  MuiMobileTimePicker
  MuiModal
  MuiModalUnstyled
  MuiMonthPicker
  MuiNativeSelect
  MuiNoSsr
  MuiOutlinedInput
  MuiPagination
  MuiPaginationItem
  MuiPaper
  MuiPickersDay
  MuiPopover
  MuiPopper
  MuiPortal
  MuiRadio
  MuiRadioGroup
  MuiRating
  MuiScopedCssBaseline
  MuiSelect
  MuiSkeleton
  MuiSlide
  MuiSlider
  MuiSliderUnstyled
  MuiSnackbar
  MuiSnackbarContent
  MuiSpeedDial
  MuiSpeedDialAction
  MuiSpeedDialIcon
  MuiStack
  MuiStaticDatePicker
  MuiStaticDateRangePicker
  MuiStaticDateTimePicker
  MuiStaticTimePicker
  MuiStep
  MuiStepButton
  MuiStepConnector
  MuiStepContent
  MuiStepIcon
  MuiStepLabel
  MuiStepper
  MuiSvgIcon
  MuiSwipeableDrawer
  MuiSwitch
  MuiSwitchUnstyled
  MuiTab
  MuiTabContext
  MuiTabList
  MuiTabPanel
  MuiTabScrollButton
  MuiTable
  MuiTableBody
  MuiTableCell
  MuiTableContainer
  MuiTableFooter
  MuiTableHead
  MuiTablePagination
  MuiTableRow
  MuiTableSortLabel
  MuiTabs
  MuiTextField
  MuiTextareaAutosize
  MuiTimePicker
  MuiTimeline
  MuiTimelineConnector
  MuiTimelineContent
  MuiTimelineDot
  MuiTimelineItem
  MuiTimelineOppositeContent
  MuiTimelineSeparator
  MuiToggleButton
  MuiToggleButtonGroup
  MuiToolbar
  MuiTooltip
  MuiTreeItem
  MuiTreeView
  MuiTypography
  MuiUnstableTrapFocus
  MuiYearPicker
  MuiZoom
  Query
  ReactFragment
  State
  Text
  TextList
}

input AtomUniqueWhere {
  id: ID
  name: String
}

input AtomUpdateInput {
  api: AtomApiUpdateFieldInput
  name: String
  tags: [AtomTagsUpdateFieldInput!]
  type: AtomType
}

input AtomWhere {
  AND: [AtomWhere!]
  OR: [AtomWhere!]
  api: InterfaceTypeWhere
  apiAggregate: AtomApiAggregateInput
  apiConnection: AtomApiConnectionWhere
  apiConnection_NOT: AtomApiConnectionWhere
  api_NOT: InterfaceTypeWhere
  id: ID
  id_CONTAINS: ID
  id_ENDS_WITH: ID
  id_IN: [ID]
  id_NOT: ID
  id_NOT_CONTAINS: ID
  id_NOT_ENDS_WITH: ID
  id_NOT_IN: [ID]
  id_NOT_STARTS_WITH: ID
  id_STARTS_WITH: ID
  name: String
  name_CONTAINS: String
  name_ENDS_WITH: String
  name_IN: [String]
  name_NOT: String
  name_NOT_CONTAINS: String
  name_NOT_ENDS_WITH: String
  name_NOT_IN: [String]
  name_NOT_STARTS_WITH: String
  name_STARTS_WITH: String
  tags: TagWhere
  tagsAggregate: AtomTagsAggregateInput
  tagsConnection: AtomTagsConnectionWhere
  tagsConnection_NOT: AtomTagsConnectionWhere
  tags_NOT: TagWhere
  type: AtomType
  type_IN: [AtomType]
  type_NOT: AtomType
  type_NOT_IN: [AtomType]
}

type CreateAppTypesMutationResponse {
  appTypes: [AppType!]!
  info: CreateInfo!
}

type CreateAppsMutationResponse {
  apps: [App!]!
  info: CreateInfo!
}

type CreateArrayTypesMutationResponse {
  arrayTypes: [ArrayType!]!
  info: CreateInfo!
}

type CreateAtomsMutationResponse {
  atoms: [Atom!]!
  info: CreateInfo!
}

type CreateCreateInfosMutationResponse {
  createInfos: [CreateInfo!]!
  info: CreateInfo!
}

type CreateDeleteFieldResponsesMutationResponse {
  deleteFieldResponses: [DeleteFieldResponse!]!
  info: CreateInfo!
}

type CreateEdgesMutationResponse {
  edges: [Edge!]!
  info: CreateInfo!
}

type CreateElementTypesMutationResponse {
  elementTypes: [ElementType!]!
  info: CreateInfo!
}

type CreateElementsMutationResponse {
  elements: [Element!]!
  info: CreateInfo!
}

type CreateEnumTypeValuesMutationResponse {
  enumTypeValues: [EnumTypeValue!]!
  info: CreateInfo!
}

type CreateEnumTypesMutationResponse {
  enumTypes: [EnumType!]!
  info: CreateInfo!
}

type CreateHooksMutationResponse {
  hooks: [Hook!]!
  info: CreateInfo!
}

type CreateImportAtomsMutationResponsesMutationResponse {
  importAtomsMutationResponses: [ImportAtomsMutationResponse!]!
  info: CreateInfo!
}

type CreateInfo {
  bookmark: String
  nodesCreated: Int!
  relationshipsCreated: Int!
}

type CreateInfoAggregateSelection {
  bookmark: StringAggregateSelection!
  count: Int!
  nodesCreated: IntAggregateSelection!
  relationshipsCreated: IntAggregateSelection!
}

input CreateInfoCreateInput {
  bookmark: String
  nodesCreated: Int!
  relationshipsCreated: Int!
}

input CreateInfoOptions {
  limit: Int
  offset: Int

  """
  Specify one or more CreateInfoSort objects to sort CreateInfos by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [CreateInfoSort]
}

"""
Fields to sort CreateInfos by. The order in which sorts are applied is not guaranteed when specifying many fields in one CreateInfoSort object.
"""
input CreateInfoSort {
  bookmark: SortDirection
  nodesCreated: SortDirection
  relationshipsCreated: SortDirection
}

input CreateInfoUpdateInput {
  bookmark: String
  nodesCreated: Int
  relationshipsCreated: Int
}

input CreateInfoWhere {
  AND: [CreateInfoWhere!]
  OR: [CreateInfoWhere!]
  bookmark: String
  bookmark_CONTAINS: String
  bookmark_ENDS_WITH: String
  bookmark_IN: [String]
  bookmark_NOT: String
  bookmark_NOT_CONTAINS: String
  bookmark_NOT_ENDS_WITH: String
  bookmark_NOT_IN: [String]
  bookmark_NOT_STARTS_WITH: String
  bookmark_STARTS_WITH: String
  nodesCreated: Int
  nodesCreated_GT: Int
  nodesCreated_GTE: Int
  nodesCreated_IN: [Int]
  nodesCreated_LT: Int
  nodesCreated_LTE: Int
  nodesCreated_NOT: Int
  nodesCreated_NOT_IN: [Int]
  relationshipsCreated: Int
  relationshipsCreated_GT: Int
  relationshipsCreated_GTE: Int
  relationshipsCreated_IN: [Int]
  relationshipsCreated_LT: Int
  relationshipsCreated_LTE: Int
  relationshipsCreated_NOT: Int
  relationshipsCreated_NOT_IN: [Int]
}

type CreateInterfaceTypesMutationResponse {
  info: CreateInfo!
  interfaceTypes: [InterfaceType!]!
}

type CreateLambdaTypesMutationResponse {
  info: CreateInfo!
  lambdaTypes: [LambdaType!]!
}

type CreateMonacoTypesMutationResponse {
  info: CreateInfo!
  monacoTypes: [MonacoType!]!
}

type CreatePageTypesMutationResponse {
  info: CreateInfo!
  pageTypes: [PageType!]!
}

type CreatePagesMutationResponse {
  info: CreateInfo!
  pages: [Page!]!
}

type CreatePrimitiveTypesMutationResponse {
  info: CreateInfo!
  primitiveTypes: [PrimitiveType!]!
}

type CreatePropMapBindingsMutationResponse {
  info: CreateInfo!
  propMapBindings: [PropMapBinding!]!
}

type CreatePropsMutationResponse {
  info: CreateInfo!
  props: [Prop!]!
}

type CreateReactNodeTypesMutationResponse {
  info: CreateInfo!
  reactNodeTypes: [ReactNodeType!]!
}

type CreateRenderPropsTypesMutationResponse {
  info: CreateInfo!
  renderPropsTypes: [RenderPropsType!]!
}

type CreateTagEdgesMutationResponse {
  info: CreateInfo!
  tagEdges: [TagEdge!]!
}

type CreateTagsMutationResponse {
  info: CreateInfo!
  tags: [Tag!]!
}

type CreateTypeReferencesMutationResponse {
  info: CreateInfo!
  typeReferences: [TypeReference!]!
}

type CreateUnionTypesMutationResponse {
  info: CreateInfo!
  unionTypes: [UnionType!]!
}

type DeleteElementsInfo {
  deletedIds: [String!]
  nodesDeleted: Int!
  relationshipsDeleted: Int!
}

input DeleteFieldInput {
  interfaceId: ID!
  key: String!
}

type DeleteFieldResponse {
  deletedEdgesCount: Int!
}

type DeleteFieldResponseAggregateSelection {
  count: Int!
  deletedEdgesCount: IntAggregateSelection!
}

input DeleteFieldResponseCreateInput {
  deletedEdgesCount: Int!
}

input DeleteFieldResponseOptions {
  limit: Int
  offset: Int

  """
  Specify one or more DeleteFieldResponseSort objects to sort DeleteFieldResponses by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [DeleteFieldResponseSort]
}

"""
Fields to sort DeleteFieldResponses by. The order in which sorts are applied is not guaranteed when specifying many fields in one DeleteFieldResponseSort object.
"""
input DeleteFieldResponseSort {
  deletedEdgesCount: SortDirection
}

input DeleteFieldResponseUpdateInput {
  deletedEdgesCount: Int
}

input DeleteFieldResponseWhere {
  AND: [DeleteFieldResponseWhere!]
  OR: [DeleteFieldResponseWhere!]
  deletedEdgesCount: Int
  deletedEdgesCount_GT: Int
  deletedEdgesCount_GTE: Int
  deletedEdgesCount_IN: [Int]
  deletedEdgesCount_LT: Int
  deletedEdgesCount_LTE: Int
  deletedEdgesCount_NOT: Int
  deletedEdgesCount_NOT_IN: [Int]
}

type DeleteInfo {
  bookmark: String
  nodesDeleted: Int!
  relationshipsDeleted: Int!
}

input DuplicateElementInput {
  elementId: String!
}

type DuplicateElementMutationResponse {
  elements: [Element!]!
}

"""
Simplest implementation of an IEdge with no additional fields
"""
type Edge implements IEdge {
  source: String!
  target: String!
}

type EdgeAggregateSelection {
  count: Int!
  source: StringAggregateSelection!
  target: StringAggregateSelection!
}

input EdgeCreateInput {
  source: String!
  target: String!
}

input EdgeOptions {
  limit: Int
  offset: Int

  """
  Specify one or more EdgeSort objects to sort Edges by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [EdgeSort]
}

"""
Fields to sort Edges by. The order in which sorts are applied is not guaranteed when specifying many fields in one EdgeSort object.
"""
input EdgeSort {
  source: SortDirection
  target: SortDirection
}

input EdgeUpdateInput {
  source: String
  target: String
}

input EdgeWhere {
  AND: [EdgeWhere!]
  OR: [EdgeWhere!]
  source: String
  source_CONTAINS: String
  source_ENDS_WITH: String
  source_IN: [String]
  source_NOT: String
  source_NOT_CONTAINS: String
  source_NOT_ENDS_WITH: String
  source_NOT_IN: [String]
  source_NOT_STARTS_WITH: String
  source_STARTS_WITH: String
  target: String
  target_CONTAINS: String
  target_ENDS_WITH: String
  target_IN: [String]
  target_NOT: String
  target_NOT_CONTAINS: String
  target_NOT_ENDS_WITH: String
  target_NOT_IN: [String]
  target_NOT_STARTS_WITH: String
  target_STARTS_WITH: String
}

type Element {
  atom(options: AtomOptions, where: AtomWhere): Atom
  atomAggregate(where: AtomWhere): ElementAtomAtomAggregationSelection
  atomConnection(
    after: String
    first: Int
    sort: [ElementAtomConnectionSort!]
    where: ElementAtomConnectionWhere
  ): ElementAtomConnection!
  children(options: ElementOptions, where: ElementWhere): [Element!]
  childrenAggregate(
    where: ElementWhere
  ): ElementElementChildrenAggregationSelection
  childrenConnection(
    after: String
    first: Int
    sort: [ElementChildrenConnectionSort!]
    where: ElementChildrenConnectionWhere
  ): ElementChildrenConnection!
  componentTag(options: TagOptions, where: TagWhere): Tag
  componentTagAggregate(
    where: TagWhere
  ): ElementTagComponentTagAggregationSelection
  componentTagConnection(
    after: String
    first: Int
    sort: [ElementComponentTagConnectionSort!]
    where: ElementComponentTagConnectionWhere
  ): ElementComponentTagConnection!
  css: String
  hooks(options: HookOptions, where: HookWhere): [Hook!]
  hooksAggregate(where: HookWhere): ElementHookHooksAggregationSelection
  hooksConnection(
    after: String
    first: Int
    sort: [ElementHooksConnectionSort!]
    where: ElementHooksConnectionWhere
  ): ElementHooksConnection!
  id: ID!
  instanceOfComponent(options: ElementOptions, where: ElementWhere): Element
  instanceOfComponentAggregate(
    where: ElementWhere
  ): ElementElementInstanceOfComponentAggregationSelection
  instanceOfComponentConnection(
    after: String
    first: Int
    sort: [ElementInstanceOfComponentConnectionSort!]
    where: ElementInstanceOfComponentConnectionWhere
  ): ElementInstanceOfComponentConnection!
  name: String
  parentElement(options: ElementOptions, where: ElementWhere): Element
  parentElementAggregate(
    where: ElementWhere
  ): ElementElementParentElementAggregationSelection
  parentElementConnection(
    after: String
    first: Int
    sort: [ElementParentElementConnectionSort!]
    where: ElementParentElementConnectionWhere
  ): ElementParentElementConnection!
  propMapBindings(
    options: PropMapBindingOptions
    where: PropMapBindingWhere
  ): [PropMapBinding!]
  propMapBindingsAggregate(
    where: PropMapBindingWhere
  ): ElementPropMapBindingPropMapBindingsAggregationSelection
  propMapBindingsConnection(
    after: String
    first: Int
    sort: [ElementPropMapBindingsConnectionSort!]
    where: ElementPropMapBindingsConnectionWhere
  ): ElementPropMapBindingsConnection!
  propTransformationJs: String
  props(options: PropOptions, where: PropWhere): Prop
  propsAggregate(where: PropWhere): ElementPropPropsAggregationSelection
  propsConnection(
    after: String
    first: Int
    sort: [ElementPropsConnectionSort!]
    where: ElementPropsConnectionWhere
  ): ElementPropsConnection!
  renderForEachPropKey: String
  renderIfPropKey: String
}

type ElementAggregateSelection {
  count: Int!
  css: StringAggregateSelection!
  id: IDAggregateSelection!
  name: StringAggregateSelection!
  propTransformationJs: StringAggregateSelection!
  renderForEachPropKey: StringAggregateSelection!
  renderIfPropKey: StringAggregateSelection!
}

input ElementAtomAggregateInput {
  AND: [ElementAtomAggregateInput!]
  OR: [ElementAtomAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: ElementAtomNodeAggregationWhereInput
}

type ElementAtomAtomAggregationSelection {
  count: Int!
  node: ElementAtomAtomNodeAggregateSelection
}

type ElementAtomAtomNodeAggregateSelection {
  id: IDAggregateSelection!
  name: StringAggregateSelection!
}

input ElementAtomConnectFieldInput {
  connect: AtomConnectInput
  where: AtomConnectWhere
}

input ElementAtomConnectOrCreateFieldInput {
  onCreate: ElementAtomConnectOrCreateFieldInputOnCreate!
  where: AtomConnectOrCreateWhere!
}

input ElementAtomConnectOrCreateFieldInputOnCreate {
  node: AtomCreateInput!
}

type ElementAtomConnection {
  edges: [ElementAtomRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input ElementAtomConnectionSort {
  node: AtomSort
}

input ElementAtomConnectionWhere {
  AND: [ElementAtomConnectionWhere!]
  OR: [ElementAtomConnectionWhere!]
  node: AtomWhere
  node_NOT: AtomWhere
}

input ElementAtomCreateFieldInput {
  node: AtomCreateInput!
}

input ElementAtomDeleteFieldInput {
  delete: AtomDeleteInput
  where: ElementAtomConnectionWhere
}

input ElementAtomDisconnectFieldInput {
  disconnect: AtomDisconnectInput
  where: ElementAtomConnectionWhere
}

input ElementAtomFieldInput {
  connect: ElementAtomConnectFieldInput
  connectOrCreate: ElementAtomConnectOrCreateFieldInput
  create: ElementAtomCreateFieldInput
}

input ElementAtomNodeAggregationWhereInput {
  AND: [ElementAtomNodeAggregationWhereInput!]
  OR: [ElementAtomNodeAggregationWhereInput!]
  id_EQUAL: ID
  name_AVERAGE_EQUAL: Float
  name_AVERAGE_GT: Float
  name_AVERAGE_GTE: Float
  name_AVERAGE_LT: Float
  name_AVERAGE_LTE: Float
  name_EQUAL: String
  name_GT: Int
  name_GTE: Int
  name_LONGEST_EQUAL: Int
  name_LONGEST_GT: Int
  name_LONGEST_GTE: Int
  name_LONGEST_LT: Int
  name_LONGEST_LTE: Int
  name_LT: Int
  name_LTE: Int
  name_SHORTEST_EQUAL: Int
  name_SHORTEST_GT: Int
  name_SHORTEST_GTE: Int
  name_SHORTEST_LT: Int
  name_SHORTEST_LTE: Int
}

type ElementAtomRelationship {
  cursor: String!
  node: Atom!
}

input ElementAtomUpdateConnectionInput {
  node: AtomUpdateInput
}

input ElementAtomUpdateFieldInput {
  connect: ElementAtomConnectFieldInput
  connectOrCreate: ElementAtomConnectOrCreateFieldInput
  create: ElementAtomCreateFieldInput
  delete: ElementAtomDeleteFieldInput
  disconnect: ElementAtomDisconnectFieldInput
  update: ElementAtomUpdateConnectionInput
  where: ElementAtomConnectionWhere
}

input ElementChildrenAggregateInput {
  AND: [ElementChildrenAggregateInput!]
  OR: [ElementChildrenAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  edge: ElementChildrenEdgeAggregationWhereInput
  node: ElementChildrenNodeAggregationWhereInput
}

input ElementChildrenConnectFieldInput {
  connect: [ElementConnectInput!]
  edge: ParentOfElementCreateInput
  where: ElementConnectWhere
}

input ElementChildrenConnectOrCreateFieldInput {
  onCreate: ElementChildrenConnectOrCreateFieldInputOnCreate!
  where: ElementConnectOrCreateWhere!
}

input ElementChildrenConnectOrCreateFieldInputOnCreate {
  edge: ParentOfElementCreateInput
  node: ElementCreateInput!
}

type ElementChildrenConnection {
  edges: [ElementChildrenRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input ElementChildrenConnectionSort {
  edge: ParentOfElementSort
  node: ElementSort
}

input ElementChildrenConnectionWhere {
  AND: [ElementChildrenConnectionWhere!]
  OR: [ElementChildrenConnectionWhere!]
  edge: ParentOfElementWhere
  edge_NOT: ParentOfElementWhere
  node: ElementWhere
  node_NOT: ElementWhere
}

input ElementChildrenCreateFieldInput {
  edge: ParentOfElementCreateInput
  node: ElementCreateInput!
}

input ElementChildrenDeleteFieldInput {
  delete: ElementDeleteInput
  where: ElementChildrenConnectionWhere
}

input ElementChildrenDisconnectFieldInput {
  disconnect: ElementDisconnectInput
  where: ElementChildrenConnectionWhere
}

input ElementChildrenEdgeAggregationWhereInput {
  AND: [ElementChildrenEdgeAggregationWhereInput!]
  OR: [ElementChildrenEdgeAggregationWhereInput!]
  order_AVERAGE_EQUAL: Float
  order_AVERAGE_GT: Float
  order_AVERAGE_GTE: Float
  order_AVERAGE_LT: Float
  order_AVERAGE_LTE: Float
  order_EQUAL: Int
  order_GT: Int
  order_GTE: Int
  order_LT: Int
  order_LTE: Int
  order_MAX_EQUAL: Int
  order_MAX_GT: Int
  order_MAX_GTE: Int
  order_MAX_LT: Int
  order_MAX_LTE: Int
  order_MIN_EQUAL: Int
  order_MIN_GT: Int
  order_MIN_GTE: Int
  order_MIN_LT: Int
  order_MIN_LTE: Int
  order_SUM_EQUAL: Int
  order_SUM_GT: Int
  order_SUM_GTE: Int
  order_SUM_LT: Int
  order_SUM_LTE: Int
}

input ElementChildrenFieldInput {
  connect: [ElementChildrenConnectFieldInput!]
  connectOrCreate: [ElementChildrenConnectOrCreateFieldInput!]
  create: [ElementChildrenCreateFieldInput!]
}

input ElementChildrenNodeAggregationWhereInput {
  AND: [ElementChildrenNodeAggregationWhereInput!]
  OR: [ElementChildrenNodeAggregationWhereInput!]
  css_AVERAGE_EQUAL: Float
  css_AVERAGE_GT: Float
  css_AVERAGE_GTE: Float
  css_AVERAGE_LT: Float
  css_AVERAGE_LTE: Float
  css_EQUAL: String
  css_GT: Int
  css_GTE: Int
  css_LONGEST_EQUAL: Int
  css_LONGEST_GT: Int
  css_LONGEST_GTE: Int
  css_LONGEST_LT: Int
  css_LONGEST_LTE: Int
  css_LT: Int
  css_LTE: Int
  css_SHORTEST_EQUAL: Int
  css_SHORTEST_GT: Int
  css_SHORTEST_GTE: Int
  css_SHORTEST_LT: Int
  css_SHORTEST_LTE: Int
  id_EQUAL: ID
  name_AVERAGE_EQUAL: Float
  name_AVERAGE_GT: Float
  name_AVERAGE_GTE: Float
  name_AVERAGE_LT: Float
  name_AVERAGE_LTE: Float
  name_EQUAL: String
  name_GT: Int
  name_GTE: Int
  name_LONGEST_EQUAL: Int
  name_LONGEST_GT: Int
  name_LONGEST_GTE: Int
  name_LONGEST_LT: Int
  name_LONGEST_LTE: Int
  name_LT: Int
  name_LTE: Int
  name_SHORTEST_EQUAL: Int
  name_SHORTEST_GT: Int
  name_SHORTEST_GTE: Int
  name_SHORTEST_LT: Int
  name_SHORTEST_LTE: Int
  propTransformationJs_AVERAGE_EQUAL: Float
  propTransformationJs_AVERAGE_GT: Float
  propTransformationJs_AVERAGE_GTE: Float
  propTransformationJs_AVERAGE_LT: Float
  propTransformationJs_AVERAGE_LTE: Float
  propTransformationJs_EQUAL: String
  propTransformationJs_GT: Int
  propTransformationJs_GTE: Int
  propTransformationJs_LONGEST_EQUAL: Int
  propTransformationJs_LONGEST_GT: Int
  propTransformationJs_LONGEST_GTE: Int
  propTransformationJs_LONGEST_LT: Int
  propTransformationJs_LONGEST_LTE: Int
  propTransformationJs_LT: Int
  propTransformationJs_LTE: Int
  propTransformationJs_SHORTEST_EQUAL: Int
  propTransformationJs_SHORTEST_GT: Int
  propTransformationJs_SHORTEST_GTE: Int
  propTransformationJs_SHORTEST_LT: Int
  propTransformationJs_SHORTEST_LTE: Int
  renderForEachPropKey_AVERAGE_EQUAL: Float
  renderForEachPropKey_AVERAGE_GT: Float
  renderForEachPropKey_AVERAGE_GTE: Float
  renderForEachPropKey_AVERAGE_LT: Float
  renderForEachPropKey_AVERAGE_LTE: Float
  renderForEachPropKey_EQUAL: String
  renderForEachPropKey_GT: Int
  renderForEachPropKey_GTE: Int
  renderForEachPropKey_LONGEST_EQUAL: Int
  renderForEachPropKey_LONGEST_GT: Int
  renderForEachPropKey_LONGEST_GTE: Int
  renderForEachPropKey_LONGEST_LT: Int
  renderForEachPropKey_LONGEST_LTE: Int
  renderForEachPropKey_LT: Int
  renderForEachPropKey_LTE: Int
  renderForEachPropKey_SHORTEST_EQUAL: Int
  renderForEachPropKey_SHORTEST_GT: Int
  renderForEachPropKey_SHORTEST_GTE: Int
  renderForEachPropKey_SHORTEST_LT: Int
  renderForEachPropKey_SHORTEST_LTE: Int
  renderIfPropKey_AVERAGE_EQUAL: Float
  renderIfPropKey_AVERAGE_GT: Float
  renderIfPropKey_AVERAGE_GTE: Float
  renderIfPropKey_AVERAGE_LT: Float
  renderIfPropKey_AVERAGE_LTE: Float
  renderIfPropKey_EQUAL: String
  renderIfPropKey_GT: Int
  renderIfPropKey_GTE: Int
  renderIfPropKey_LONGEST_EQUAL: Int
  renderIfPropKey_LONGEST_GT: Int
  renderIfPropKey_LONGEST_GTE: Int
  renderIfPropKey_LONGEST_LT: Int
  renderIfPropKey_LONGEST_LTE: Int
  renderIfPropKey_LT: Int
  renderIfPropKey_LTE: Int
  renderIfPropKey_SHORTEST_EQUAL: Int
  renderIfPropKey_SHORTEST_GT: Int
  renderIfPropKey_SHORTEST_GTE: Int
  renderIfPropKey_SHORTEST_LT: Int
  renderIfPropKey_SHORTEST_LTE: Int
}

type ElementChildrenRelationship implements ParentOfElement {
  cursor: String!
  node: Element!
  order: Int
}

input ElementChildrenUpdateConnectionInput {
  edge: ParentOfElementUpdateInput
  node: ElementUpdateInput
}

input ElementChildrenUpdateFieldInput {
  connect: [ElementChildrenConnectFieldInput!]
  connectOrCreate: [ElementChildrenConnectOrCreateFieldInput!]
  create: [ElementChildrenCreateFieldInput!]
  delete: [ElementChildrenDeleteFieldInput!]
  disconnect: [ElementChildrenDisconnectFieldInput!]
  update: ElementChildrenUpdateConnectionInput
  where: ElementChildrenConnectionWhere
}

input ElementComponentTagAggregateInput {
  AND: [ElementComponentTagAggregateInput!]
  OR: [ElementComponentTagAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: ElementComponentTagNodeAggregationWhereInput
}

input ElementComponentTagConnectFieldInput {
  connect: TagConnectInput
  where: TagConnectWhere
}

input ElementComponentTagConnectOrCreateFieldInput {
  onCreate: ElementComponentTagConnectOrCreateFieldInputOnCreate!
  where: TagConnectOrCreateWhere!
}

input ElementComponentTagConnectOrCreateFieldInputOnCreate {
  node: TagCreateInput!
}

type ElementComponentTagConnection {
  edges: [ElementComponentTagRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input ElementComponentTagConnectionSort {
  node: TagSort
}

input ElementComponentTagConnectionWhere {
  AND: [ElementComponentTagConnectionWhere!]
  OR: [ElementComponentTagConnectionWhere!]
  node: TagWhere
  node_NOT: TagWhere
}

input ElementComponentTagCreateFieldInput {
  node: TagCreateInput!
}

input ElementComponentTagDeleteFieldInput {
  delete: TagDeleteInput
  where: ElementComponentTagConnectionWhere
}

input ElementComponentTagDisconnectFieldInput {
  disconnect: TagDisconnectInput
  where: ElementComponentTagConnectionWhere
}

input ElementComponentTagFieldInput {
  connect: ElementComponentTagConnectFieldInput
  connectOrCreate: ElementComponentTagConnectOrCreateFieldInput
  create: ElementComponentTagCreateFieldInput
}

input ElementComponentTagNodeAggregationWhereInput {
  AND: [ElementComponentTagNodeAggregationWhereInput!]
  OR: [ElementComponentTagNodeAggregationWhereInput!]
  id_EQUAL: ID
  name_AVERAGE_EQUAL: Float
  name_AVERAGE_GT: Float
  name_AVERAGE_GTE: Float
  name_AVERAGE_LT: Float
  name_AVERAGE_LTE: Float
  name_EQUAL: String
  name_GT: Int
  name_GTE: Int
  name_LONGEST_EQUAL: Int
  name_LONGEST_GT: Int
  name_LONGEST_GTE: Int
  name_LONGEST_LT: Int
  name_LONGEST_LTE: Int
  name_LT: Int
  name_LTE: Int
  name_SHORTEST_EQUAL: Int
  name_SHORTEST_GT: Int
  name_SHORTEST_GTE: Int
  name_SHORTEST_LT: Int
  name_SHORTEST_LTE: Int
}

type ElementComponentTagRelationship {
  cursor: String!
  node: Tag!
}

input ElementComponentTagUpdateConnectionInput {
  node: TagUpdateInput
}

input ElementComponentTagUpdateFieldInput {
  connect: ElementComponentTagConnectFieldInput
  connectOrCreate: ElementComponentTagConnectOrCreateFieldInput
  create: ElementComponentTagCreateFieldInput
  delete: ElementComponentTagDeleteFieldInput
  disconnect: ElementComponentTagDisconnectFieldInput
  update: ElementComponentTagUpdateConnectionInput
  where: ElementComponentTagConnectionWhere
}

input ElementConnectInput {
  atom: ElementAtomConnectFieldInput
  children: [ElementChildrenConnectFieldInput!]
  componentTag: ElementComponentTagConnectFieldInput
  hooks: [ElementHooksConnectFieldInput!]
  instanceOfComponent: ElementInstanceOfComponentConnectFieldInput
  parentElement: ElementParentElementConnectFieldInput
  propMapBindings: [ElementPropMapBindingsConnectFieldInput!]
  props: ElementPropsConnectFieldInput
}

input ElementConnectOrCreateInput {
  atom: ElementAtomConnectOrCreateFieldInput
  children: [ElementChildrenConnectOrCreateFieldInput!]
  componentTag: ElementComponentTagConnectOrCreateFieldInput
  hooks: [ElementHooksConnectOrCreateFieldInput!]
  instanceOfComponent: ElementInstanceOfComponentConnectOrCreateFieldInput
  parentElement: ElementParentElementConnectOrCreateFieldInput
  propMapBindings: [ElementPropMapBindingsConnectOrCreateFieldInput!]
  props: ElementPropsConnectOrCreateFieldInput
}

input ElementConnectOrCreateWhere {
  node: ElementUniqueWhere!
}

input ElementConnectWhere {
  node: ElementWhere!
}

input ElementCreateInput {
  atom: ElementAtomFieldInput
  children: ElementChildrenFieldInput
  componentTag: ElementComponentTagFieldInput
  css: String
  hooks: ElementHooksFieldInput
  instanceOfComponent: ElementInstanceOfComponentFieldInput
  name: String
  parentElement: ElementParentElementFieldInput
  propMapBindings: ElementPropMapBindingsFieldInput
  propTransformationJs: String
  props: ElementPropsFieldInput
  renderForEachPropKey: String
  renderIfPropKey: String
}

input ElementDeleteInput {
  atom: ElementAtomDeleteFieldInput
  children: [ElementChildrenDeleteFieldInput!]
  componentTag: ElementComponentTagDeleteFieldInput
  hooks: [ElementHooksDeleteFieldInput!]
  instanceOfComponent: ElementInstanceOfComponentDeleteFieldInput
  parentElement: ElementParentElementDeleteFieldInput
  propMapBindings: [ElementPropMapBindingsDeleteFieldInput!]
  props: ElementPropsDeleteFieldInput
}

input ElementDisconnectInput {
  atom: ElementAtomDisconnectFieldInput
  children: [ElementChildrenDisconnectFieldInput!]
  componentTag: ElementComponentTagDisconnectFieldInput
  hooks: [ElementHooksDisconnectFieldInput!]
  instanceOfComponent: ElementInstanceOfComponentDisconnectFieldInput
  parentElement: ElementParentElementDisconnectFieldInput
  propMapBindings: [ElementPropMapBindingsDisconnectFieldInput!]
  props: ElementPropsDisconnectFieldInput
}

type ElementEdge {
  order: Int
  source: String!
  target: String!
}

type ElementElementChildrenAggregationSelection {
  count: Int!
  edge: ElementElementChildrenEdgeAggregateSelection
  node: ElementElementChildrenNodeAggregateSelection
}

type ElementElementChildrenEdgeAggregateSelection {
  order: IntAggregateSelection!
}

type ElementElementChildrenNodeAggregateSelection {
  css: StringAggregateSelection!
  id: IDAggregateSelection!
  name: StringAggregateSelection!
  propTransformationJs: StringAggregateSelection!
  renderForEachPropKey: StringAggregateSelection!
  renderIfPropKey: StringAggregateSelection!
}

type ElementElementInstanceOfComponentAggregationSelection {
  count: Int!
  node: ElementElementInstanceOfComponentNodeAggregateSelection
}

type ElementElementInstanceOfComponentNodeAggregateSelection {
  css: StringAggregateSelection!
  id: IDAggregateSelection!
  name: StringAggregateSelection!
  propTransformationJs: StringAggregateSelection!
  renderForEachPropKey: StringAggregateSelection!
  renderIfPropKey: StringAggregateSelection!
}

type ElementElementParentElementAggregationSelection {
  count: Int!
  edge: ElementElementParentElementEdgeAggregateSelection
  node: ElementElementParentElementNodeAggregateSelection
}

type ElementElementParentElementEdgeAggregateSelection {
  order: IntAggregateSelection!
}

type ElementElementParentElementNodeAggregateSelection {
  css: StringAggregateSelection!
  id: IDAggregateSelection!
  name: StringAggregateSelection!
  propTransformationJs: StringAggregateSelection!
  renderForEachPropKey: StringAggregateSelection!
  renderIfPropKey: StringAggregateSelection!
}

type ElementGraph {
  edges: [ElementEdge!]!
  rootId: String
  vertices: [Element!]!
}

input ElementGraphInput {
  rootId: String!
}

type ElementHookHooksAggregationSelection {
  count: Int!
  node: ElementHookHooksNodeAggregateSelection
}

type ElementHookHooksNodeAggregateSelection {
  id: IDAggregateSelection!
}

input ElementHooksAggregateInput {
  AND: [ElementHooksAggregateInput!]
  OR: [ElementHooksAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: ElementHooksNodeAggregationWhereInput
}

input ElementHooksConnectFieldInput {
  connect: [HookConnectInput!]
  where: HookConnectWhere
}

input ElementHooksConnectOrCreateFieldInput {
  onCreate: ElementHooksConnectOrCreateFieldInputOnCreate!
  where: HookConnectOrCreateWhere!
}

input ElementHooksConnectOrCreateFieldInputOnCreate {
  node: HookCreateInput!
}

type ElementHooksConnection {
  edges: [ElementHooksRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input ElementHooksConnectionSort {
  node: HookSort
}

input ElementHooksConnectionWhere {
  AND: [ElementHooksConnectionWhere!]
  OR: [ElementHooksConnectionWhere!]
  node: HookWhere
  node_NOT: HookWhere
}

input ElementHooksCreateFieldInput {
  node: HookCreateInput!
}

input ElementHooksDeleteFieldInput {
  delete: HookDeleteInput
  where: ElementHooksConnectionWhere
}

input ElementHooksDisconnectFieldInput {
  disconnect: HookDisconnectInput
  where: ElementHooksConnectionWhere
}

input ElementHooksFieldInput {
  connect: [ElementHooksConnectFieldInput!]
  connectOrCreate: [ElementHooksConnectOrCreateFieldInput!]
  create: [ElementHooksCreateFieldInput!]
}

input ElementHooksNodeAggregationWhereInput {
  AND: [ElementHooksNodeAggregationWhereInput!]
  OR: [ElementHooksNodeAggregationWhereInput!]
  id_EQUAL: ID
}

type ElementHooksRelationship {
  cursor: String!
  node: Hook!
}

input ElementHooksUpdateConnectionInput {
  node: HookUpdateInput
}

input ElementHooksUpdateFieldInput {
  connect: [ElementHooksConnectFieldInput!]
  connectOrCreate: [ElementHooksConnectOrCreateFieldInput!]
  create: [ElementHooksCreateFieldInput!]
  delete: [ElementHooksDeleteFieldInput!]
  disconnect: [ElementHooksDisconnectFieldInput!]
  update: ElementHooksUpdateConnectionInput
  where: ElementHooksConnectionWhere
}

input ElementInstanceOfComponentAggregateInput {
  AND: [ElementInstanceOfComponentAggregateInput!]
  OR: [ElementInstanceOfComponentAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: ElementInstanceOfComponentNodeAggregationWhereInput
}

input ElementInstanceOfComponentConnectFieldInput {
  connect: ElementConnectInput
  where: ElementConnectWhere
}

input ElementInstanceOfComponentConnectOrCreateFieldInput {
  onCreate: ElementInstanceOfComponentConnectOrCreateFieldInputOnCreate!
  where: ElementConnectOrCreateWhere!
}

input ElementInstanceOfComponentConnectOrCreateFieldInputOnCreate {
  node: ElementCreateInput!
}

type ElementInstanceOfComponentConnection {
  edges: [ElementInstanceOfComponentRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input ElementInstanceOfComponentConnectionSort {
  node: ElementSort
}

input ElementInstanceOfComponentConnectionWhere {
  AND: [ElementInstanceOfComponentConnectionWhere!]
  OR: [ElementInstanceOfComponentConnectionWhere!]
  node: ElementWhere
  node_NOT: ElementWhere
}

input ElementInstanceOfComponentCreateFieldInput {
  node: ElementCreateInput!
}

input ElementInstanceOfComponentDeleteFieldInput {
  delete: ElementDeleteInput
  where: ElementInstanceOfComponentConnectionWhere
}

input ElementInstanceOfComponentDisconnectFieldInput {
  disconnect: ElementDisconnectInput
  where: ElementInstanceOfComponentConnectionWhere
}

input ElementInstanceOfComponentFieldInput {
  connect: ElementInstanceOfComponentConnectFieldInput
  connectOrCreate: ElementInstanceOfComponentConnectOrCreateFieldInput
  create: ElementInstanceOfComponentCreateFieldInput
}

input ElementInstanceOfComponentNodeAggregationWhereInput {
  AND: [ElementInstanceOfComponentNodeAggregationWhereInput!]
  OR: [ElementInstanceOfComponentNodeAggregationWhereInput!]
  css_AVERAGE_EQUAL: Float
  css_AVERAGE_GT: Float
  css_AVERAGE_GTE: Float
  css_AVERAGE_LT: Float
  css_AVERAGE_LTE: Float
  css_EQUAL: String
  css_GT: Int
  css_GTE: Int
  css_LONGEST_EQUAL: Int
  css_LONGEST_GT: Int
  css_LONGEST_GTE: Int
  css_LONGEST_LT: Int
  css_LONGEST_LTE: Int
  css_LT: Int
  css_LTE: Int
  css_SHORTEST_EQUAL: Int
  css_SHORTEST_GT: Int
  css_SHORTEST_GTE: Int
  css_SHORTEST_LT: Int
  css_SHORTEST_LTE: Int
  id_EQUAL: ID
  name_AVERAGE_EQUAL: Float
  name_AVERAGE_GT: Float
  name_AVERAGE_GTE: Float
  name_AVERAGE_LT: Float
  name_AVERAGE_LTE: Float
  name_EQUAL: String
  name_GT: Int
  name_GTE: Int
  name_LONGEST_EQUAL: Int
  name_LONGEST_GT: Int
  name_LONGEST_GTE: Int
  name_LONGEST_LT: Int
  name_LONGEST_LTE: Int
  name_LT: Int
  name_LTE: Int
  name_SHORTEST_EQUAL: Int
  name_SHORTEST_GT: Int
  name_SHORTEST_GTE: Int
  name_SHORTEST_LT: Int
  name_SHORTEST_LTE: Int
  propTransformationJs_AVERAGE_EQUAL: Float
  propTransformationJs_AVERAGE_GT: Float
  propTransformationJs_AVERAGE_GTE: Float
  propTransformationJs_AVERAGE_LT: Float
  propTransformationJs_AVERAGE_LTE: Float
  propTransformationJs_EQUAL: String
  propTransformationJs_GT: Int
  propTransformationJs_GTE: Int
  propTransformationJs_LONGEST_EQUAL: Int
  propTransformationJs_LONGEST_GT: Int
  propTransformationJs_LONGEST_GTE: Int
  propTransformationJs_LONGEST_LT: Int
  propTransformationJs_LONGEST_LTE: Int
  propTransformationJs_LT: Int
  propTransformationJs_LTE: Int
  propTransformationJs_SHORTEST_EQUAL: Int
  propTransformationJs_SHORTEST_GT: Int
  propTransformationJs_SHORTEST_GTE: Int
  propTransformationJs_SHORTEST_LT: Int
  propTransformationJs_SHORTEST_LTE: Int
  renderForEachPropKey_AVERAGE_EQUAL: Float
  renderForEachPropKey_AVERAGE_GT: Float
  renderForEachPropKey_AVERAGE_GTE: Float
  renderForEachPropKey_AVERAGE_LT: Float
  renderForEachPropKey_AVERAGE_LTE: Float
  renderForEachPropKey_EQUAL: String
  renderForEachPropKey_GT: Int
  renderForEachPropKey_GTE: Int
  renderForEachPropKey_LONGEST_EQUAL: Int
  renderForEachPropKey_LONGEST_GT: Int
  renderForEachPropKey_LONGEST_GTE: Int
  renderForEachPropKey_LONGEST_LT: Int
  renderForEachPropKey_LONGEST_LTE: Int
  renderForEachPropKey_LT: Int
  renderForEachPropKey_LTE: Int
  renderForEachPropKey_SHORTEST_EQUAL: Int
  renderForEachPropKey_SHORTEST_GT: Int
  renderForEachPropKey_SHORTEST_GTE: Int
  renderForEachPropKey_SHORTEST_LT: Int
  renderForEachPropKey_SHORTEST_LTE: Int
  renderIfPropKey_AVERAGE_EQUAL: Float
  renderIfPropKey_AVERAGE_GT: Float
  renderIfPropKey_AVERAGE_GTE: Float
  renderIfPropKey_AVERAGE_LT: Float
  renderIfPropKey_AVERAGE_LTE: Float
  renderIfPropKey_EQUAL: String
  renderIfPropKey_GT: Int
  renderIfPropKey_GTE: Int
  renderIfPropKey_LONGEST_EQUAL: Int
  renderIfPropKey_LONGEST_GT: Int
  renderIfPropKey_LONGEST_GTE: Int
  renderIfPropKey_LONGEST_LT: Int
  renderIfPropKey_LONGEST_LTE: Int
  renderIfPropKey_LT: Int
  renderIfPropKey_LTE: Int
  renderIfPropKey_SHORTEST_EQUAL: Int
  renderIfPropKey_SHORTEST_GT: Int
  renderIfPropKey_SHORTEST_GTE: Int
  renderIfPropKey_SHORTEST_LT: Int
  renderIfPropKey_SHORTEST_LTE: Int
}

type ElementInstanceOfComponentRelationship {
  cursor: String!
  node: Element!
}

input ElementInstanceOfComponentUpdateConnectionInput {
  node: ElementUpdateInput
}

input ElementInstanceOfComponentUpdateFieldInput {
  connect: ElementInstanceOfComponentConnectFieldInput
  connectOrCreate: ElementInstanceOfComponentConnectOrCreateFieldInput
  create: ElementInstanceOfComponentCreateFieldInput
  delete: ElementInstanceOfComponentDeleteFieldInput
  disconnect: ElementInstanceOfComponentDisconnectFieldInput
  update: ElementInstanceOfComponentUpdateConnectionInput
  where: ElementInstanceOfComponentConnectionWhere
}

input ElementOptions {
  limit: Int
  offset: Int

  """
  Specify one or more ElementSort objects to sort Elements by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [ElementSort]
}

input ElementParentElementAggregateInput {
  AND: [ElementParentElementAggregateInput!]
  OR: [ElementParentElementAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  edge: ElementParentElementEdgeAggregationWhereInput
  node: ElementParentElementNodeAggregationWhereInput
}

input ElementParentElementConnectFieldInput {
  connect: ElementConnectInput
  edge: ParentOfElementCreateInput
  where: ElementConnectWhere
}

input ElementParentElementConnectOrCreateFieldInput {
  onCreate: ElementParentElementConnectOrCreateFieldInputOnCreate!
  where: ElementConnectOrCreateWhere!
}

input ElementParentElementConnectOrCreateFieldInputOnCreate {
  edge: ParentOfElementCreateInput
  node: ElementCreateInput!
}

type ElementParentElementConnection {
  edges: [ElementParentElementRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input ElementParentElementConnectionSort {
  edge: ParentOfElementSort
  node: ElementSort
}

input ElementParentElementConnectionWhere {
  AND: [ElementParentElementConnectionWhere!]
  OR: [ElementParentElementConnectionWhere!]
  edge: ParentOfElementWhere
  edge_NOT: ParentOfElementWhere
  node: ElementWhere
  node_NOT: ElementWhere
}

input ElementParentElementCreateFieldInput {
  edge: ParentOfElementCreateInput
  node: ElementCreateInput!
}

input ElementParentElementDeleteFieldInput {
  delete: ElementDeleteInput
  where: ElementParentElementConnectionWhere
}

input ElementParentElementDisconnectFieldInput {
  disconnect: ElementDisconnectInput
  where: ElementParentElementConnectionWhere
}

input ElementParentElementEdgeAggregationWhereInput {
  AND: [ElementParentElementEdgeAggregationWhereInput!]
  OR: [ElementParentElementEdgeAggregationWhereInput!]
  order_AVERAGE_EQUAL: Float
  order_AVERAGE_GT: Float
  order_AVERAGE_GTE: Float
  order_AVERAGE_LT: Float
  order_AVERAGE_LTE: Float
  order_EQUAL: Int
  order_GT: Int
  order_GTE: Int
  order_LT: Int
  order_LTE: Int
  order_MAX_EQUAL: Int
  order_MAX_GT: Int
  order_MAX_GTE: Int
  order_MAX_LT: Int
  order_MAX_LTE: Int
  order_MIN_EQUAL: Int
  order_MIN_GT: Int
  order_MIN_GTE: Int
  order_MIN_LT: Int
  order_MIN_LTE: Int
  order_SUM_EQUAL: Int
  order_SUM_GT: Int
  order_SUM_GTE: Int
  order_SUM_LT: Int
  order_SUM_LTE: Int
}

input ElementParentElementFieldInput {
  connect: ElementParentElementConnectFieldInput
  connectOrCreate: ElementParentElementConnectOrCreateFieldInput
  create: ElementParentElementCreateFieldInput
}

input ElementParentElementNodeAggregationWhereInput {
  AND: [ElementParentElementNodeAggregationWhereInput!]
  OR: [ElementParentElementNodeAggregationWhereInput!]
  css_AVERAGE_EQUAL: Float
  css_AVERAGE_GT: Float
  css_AVERAGE_GTE: Float
  css_AVERAGE_LT: Float
  css_AVERAGE_LTE: Float
  css_EQUAL: String
  css_GT: Int
  css_GTE: Int
  css_LONGEST_EQUAL: Int
  css_LONGEST_GT: Int
  css_LONGEST_GTE: Int
  css_LONGEST_LT: Int
  css_LONGEST_LTE: Int
  css_LT: Int
  css_LTE: Int
  css_SHORTEST_EQUAL: Int
  css_SHORTEST_GT: Int
  css_SHORTEST_GTE: Int
  css_SHORTEST_LT: Int
  css_SHORTEST_LTE: Int
  id_EQUAL: ID
  name_AVERAGE_EQUAL: Float
  name_AVERAGE_GT: Float
  name_AVERAGE_GTE: Float
  name_AVERAGE_LT: Float
  name_AVERAGE_LTE: Float
  name_EQUAL: String
  name_GT: Int
  name_GTE: Int
  name_LONGEST_EQUAL: Int
  name_LONGEST_GT: Int
  name_LONGEST_GTE: Int
  name_LONGEST_LT: Int
  name_LONGEST_LTE: Int
  name_LT: Int
  name_LTE: Int
  name_SHORTEST_EQUAL: Int
  name_SHORTEST_GT: Int
  name_SHORTEST_GTE: Int
  name_SHORTEST_LT: Int
  name_SHORTEST_LTE: Int
  propTransformationJs_AVERAGE_EQUAL: Float
  propTransformationJs_AVERAGE_GT: Float
  propTransformationJs_AVERAGE_GTE: Float
  propTransformationJs_AVERAGE_LT: Float
  propTransformationJs_AVERAGE_LTE: Float
  propTransformationJs_EQUAL: String
  propTransformationJs_GT: Int
  propTransformationJs_GTE: Int
  propTransformationJs_LONGEST_EQUAL: Int
  propTransformationJs_LONGEST_GT: Int
  propTransformationJs_LONGEST_GTE: Int
  propTransformationJs_LONGEST_LT: Int
  propTransformationJs_LONGEST_LTE: Int
  propTransformationJs_LT: Int
  propTransformationJs_LTE: Int
  propTransformationJs_SHORTEST_EQUAL: Int
  propTransformationJs_SHORTEST_GT: Int
  propTransformationJs_SHORTEST_GTE: Int
  propTransformationJs_SHORTEST_LT: Int
  propTransformationJs_SHORTEST_LTE: Int
  renderForEachPropKey_AVERAGE_EQUAL: Float
  renderForEachPropKey_AVERAGE_GT: Float
  renderForEachPropKey_AVERAGE_GTE: Float
  renderForEachPropKey_AVERAGE_LT: Float
  renderForEachPropKey_AVERAGE_LTE: Float
  renderForEachPropKey_EQUAL: String
  renderForEachPropKey_GT: Int
  renderForEachPropKey_GTE: Int
  renderForEachPropKey_LONGEST_EQUAL: Int
  renderForEachPropKey_LONGEST_GT: Int
  renderForEachPropKey_LONGEST_GTE: Int
  renderForEachPropKey_LONGEST_LT: Int
  renderForEachPropKey_LONGEST_LTE: Int
  renderForEachPropKey_LT: Int
  renderForEachPropKey_LTE: Int
  renderForEachPropKey_SHORTEST_EQUAL: Int
  renderForEachPropKey_SHORTEST_GT: Int
  renderForEachPropKey_SHORTEST_GTE: Int
  renderForEachPropKey_SHORTEST_LT: Int
  renderForEachPropKey_SHORTEST_LTE: Int
  renderIfPropKey_AVERAGE_EQUAL: Float
  renderIfPropKey_AVERAGE_GT: Float
  renderIfPropKey_AVERAGE_GTE: Float
  renderIfPropKey_AVERAGE_LT: Float
  renderIfPropKey_AVERAGE_LTE: Float
  renderIfPropKey_EQUAL: String
  renderIfPropKey_GT: Int
  renderIfPropKey_GTE: Int
  renderIfPropKey_LONGEST_EQUAL: Int
  renderIfPropKey_LONGEST_GT: Int
  renderIfPropKey_LONGEST_GTE: Int
  renderIfPropKey_LONGEST_LT: Int
  renderIfPropKey_LONGEST_LTE: Int
  renderIfPropKey_LT: Int
  renderIfPropKey_LTE: Int
  renderIfPropKey_SHORTEST_EQUAL: Int
  renderIfPropKey_SHORTEST_GT: Int
  renderIfPropKey_SHORTEST_GTE: Int
  renderIfPropKey_SHORTEST_LT: Int
  renderIfPropKey_SHORTEST_LTE: Int
}

type ElementParentElementRelationship implements ParentOfElement {
  cursor: String!
  node: Element!
  order: Int
}

input ElementParentElementUpdateConnectionInput {
  edge: ParentOfElementUpdateInput
  node: ElementUpdateInput
}

input ElementParentElementUpdateFieldInput {
  connect: ElementParentElementConnectFieldInput
  connectOrCreate: ElementParentElementConnectOrCreateFieldInput
  create: ElementParentElementCreateFieldInput
  delete: ElementParentElementDeleteFieldInput
  disconnect: ElementParentElementDisconnectFieldInput
  update: ElementParentElementUpdateConnectionInput
  where: ElementParentElementConnectionWhere
}

type ElementPropMapBindingPropMapBindingsAggregationSelection {
  count: Int!
  node: ElementPropMapBindingPropMapBindingsNodeAggregateSelection
}

type ElementPropMapBindingPropMapBindingsNodeAggregateSelection {
  id: IDAggregateSelection!
  sourceKey: StringAggregateSelection!
  targetKey: StringAggregateSelection!
}

input ElementPropMapBindingsAggregateInput {
  AND: [ElementPropMapBindingsAggregateInput!]
  OR: [ElementPropMapBindingsAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: ElementPropMapBindingsNodeAggregationWhereInput
}

input ElementPropMapBindingsConnectFieldInput {
  connect: [PropMapBindingConnectInput!]
  where: PropMapBindingConnectWhere
}

input ElementPropMapBindingsConnectOrCreateFieldInput {
  onCreate: ElementPropMapBindingsConnectOrCreateFieldInputOnCreate!
  where: PropMapBindingConnectOrCreateWhere!
}

input ElementPropMapBindingsConnectOrCreateFieldInputOnCreate {
  node: PropMapBindingCreateInput!
}

type ElementPropMapBindingsConnection {
  edges: [ElementPropMapBindingsRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input ElementPropMapBindingsConnectionSort {
  node: PropMapBindingSort
}

input ElementPropMapBindingsConnectionWhere {
  AND: [ElementPropMapBindingsConnectionWhere!]
  OR: [ElementPropMapBindingsConnectionWhere!]
  node: PropMapBindingWhere
  node_NOT: PropMapBindingWhere
}

input ElementPropMapBindingsCreateFieldInput {
  node: PropMapBindingCreateInput!
}

input ElementPropMapBindingsDeleteFieldInput {
  delete: PropMapBindingDeleteInput
  where: ElementPropMapBindingsConnectionWhere
}

input ElementPropMapBindingsDisconnectFieldInput {
  disconnect: PropMapBindingDisconnectInput
  where: ElementPropMapBindingsConnectionWhere
}

input ElementPropMapBindingsFieldInput {
  connect: [ElementPropMapBindingsConnectFieldInput!]
  connectOrCreate: [ElementPropMapBindingsConnectOrCreateFieldInput!]
  create: [ElementPropMapBindingsCreateFieldInput!]
}

input ElementPropMapBindingsNodeAggregationWhereInput {
  AND: [ElementPropMapBindingsNodeAggregationWhereInput!]
  OR: [ElementPropMapBindingsNodeAggregationWhereInput!]
  id_EQUAL: ID
  sourceKey_AVERAGE_EQUAL: Float
  sourceKey_AVERAGE_GT: Float
  sourceKey_AVERAGE_GTE: Float
  sourceKey_AVERAGE_LT: Float
  sourceKey_AVERAGE_LTE: Float
  sourceKey_EQUAL: String
  sourceKey_GT: Int
  sourceKey_GTE: Int
  sourceKey_LONGEST_EQUAL: Int
  sourceKey_LONGEST_GT: Int
  sourceKey_LONGEST_GTE: Int
  sourceKey_LONGEST_LT: Int
  sourceKey_LONGEST_LTE: Int
  sourceKey_LT: Int
  sourceKey_LTE: Int
  sourceKey_SHORTEST_EQUAL: Int
  sourceKey_SHORTEST_GT: Int
  sourceKey_SHORTEST_GTE: Int
  sourceKey_SHORTEST_LT: Int
  sourceKey_SHORTEST_LTE: Int
  targetKey_AVERAGE_EQUAL: Float
  targetKey_AVERAGE_GT: Float
  targetKey_AVERAGE_GTE: Float
  targetKey_AVERAGE_LT: Float
  targetKey_AVERAGE_LTE: Float
  targetKey_EQUAL: String
  targetKey_GT: Int
  targetKey_GTE: Int
  targetKey_LONGEST_EQUAL: Int
  targetKey_LONGEST_GT: Int
  targetKey_LONGEST_GTE: Int
  targetKey_LONGEST_LT: Int
  targetKey_LONGEST_LTE: Int
  targetKey_LT: Int
  targetKey_LTE: Int
  targetKey_SHORTEST_EQUAL: Int
  targetKey_SHORTEST_GT: Int
  targetKey_SHORTEST_GTE: Int
  targetKey_SHORTEST_LT: Int
  targetKey_SHORTEST_LTE: Int
}

type ElementPropMapBindingsRelationship {
  cursor: String!
  node: PropMapBinding!
}

input ElementPropMapBindingsUpdateConnectionInput {
  node: PropMapBindingUpdateInput
}

input ElementPropMapBindingsUpdateFieldInput {
  connect: [ElementPropMapBindingsConnectFieldInput!]
  connectOrCreate: [ElementPropMapBindingsConnectOrCreateFieldInput!]
  create: [ElementPropMapBindingsCreateFieldInput!]
  delete: [ElementPropMapBindingsDeleteFieldInput!]
  disconnect: [ElementPropMapBindingsDisconnectFieldInput!]
  update: ElementPropMapBindingsUpdateConnectionInput
  where: ElementPropMapBindingsConnectionWhere
}

type ElementPropPropsAggregationSelection {
  count: Int!
  node: ElementPropPropsNodeAggregateSelection
}

type ElementPropPropsNodeAggregateSelection {
  data: StringAggregateSelection!
  id: IDAggregateSelection!
}

input ElementPropsAggregateInput {
  AND: [ElementPropsAggregateInput!]
  OR: [ElementPropsAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: ElementPropsNodeAggregationWhereInput
}

input ElementPropsConnectFieldInput {
  where: PropConnectWhere
}

input ElementPropsConnectOrCreateFieldInput {
  onCreate: ElementPropsConnectOrCreateFieldInputOnCreate!
  where: PropConnectOrCreateWhere!
}

input ElementPropsConnectOrCreateFieldInputOnCreate {
  node: PropCreateInput!
}

type ElementPropsConnection {
  edges: [ElementPropsRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input ElementPropsConnectionSort {
  node: PropSort
}

input ElementPropsConnectionWhere {
  AND: [ElementPropsConnectionWhere!]
  OR: [ElementPropsConnectionWhere!]
  node: PropWhere
  node_NOT: PropWhere
}

input ElementPropsCreateFieldInput {
  node: PropCreateInput!
}

input ElementPropsDeleteFieldInput {
  where: ElementPropsConnectionWhere
}

input ElementPropsDisconnectFieldInput {
  where: ElementPropsConnectionWhere
}

input ElementPropsFieldInput {
  connect: ElementPropsConnectFieldInput
  connectOrCreate: ElementPropsConnectOrCreateFieldInput
  create: ElementPropsCreateFieldInput
}

input ElementPropsNodeAggregationWhereInput {
  AND: [ElementPropsNodeAggregationWhereInput!]
  OR: [ElementPropsNodeAggregationWhereInput!]
  data_AVERAGE_EQUAL: Float
  data_AVERAGE_GT: Float
  data_AVERAGE_GTE: Float
  data_AVERAGE_LT: Float
  data_AVERAGE_LTE: Float
  data_EQUAL: String
  data_GT: Int
  data_GTE: Int
  data_LONGEST_EQUAL: Int
  data_LONGEST_GT: Int
  data_LONGEST_GTE: Int
  data_LONGEST_LT: Int
  data_LONGEST_LTE: Int
  data_LT: Int
  data_LTE: Int
  data_SHORTEST_EQUAL: Int
  data_SHORTEST_GT: Int
  data_SHORTEST_GTE: Int
  data_SHORTEST_LT: Int
  data_SHORTEST_LTE: Int
  id_EQUAL: ID
}

type ElementPropsRelationship {
  cursor: String!
  node: Prop!
}

input ElementPropsUpdateConnectionInput {
  node: PropUpdateInput
}

input ElementPropsUpdateFieldInput {
  connect: ElementPropsConnectFieldInput
  connectOrCreate: ElementPropsConnectOrCreateFieldInput
  create: ElementPropsCreateFieldInput
  delete: ElementPropsDeleteFieldInput
  disconnect: ElementPropsDisconnectFieldInput
  update: ElementPropsUpdateConnectionInput
  where: ElementPropsConnectionWhere
}

input ElementRelationInput {
  atom: ElementAtomCreateFieldInput
  children: [ElementChildrenCreateFieldInput!]
  componentTag: ElementComponentTagCreateFieldInput
  hooks: [ElementHooksCreateFieldInput!]
  instanceOfComponent: ElementInstanceOfComponentCreateFieldInput
  parentElement: ElementParentElementCreateFieldInput
  propMapBindings: [ElementPropMapBindingsCreateFieldInput!]
  props: ElementPropsCreateFieldInput
}

"""
Fields to sort Elements by. The order in which sorts are applied is not guaranteed when specifying many fields in one ElementSort object.
"""
input ElementSort {
  css: SortDirection
  id: SortDirection
  name: SortDirection
  propTransformationJs: SortDirection
  renderForEachPropKey: SortDirection
  renderIfPropKey: SortDirection
}

type ElementTagComponentTagAggregationSelection {
  count: Int!
  node: ElementTagComponentTagNodeAggregateSelection
}

type ElementTagComponentTagNodeAggregateSelection {
  id: IDAggregateSelection!
  name: StringAggregateSelection!
}

"""
Allows picking an element from the current tree
Is passed to the rendered element as a React node
Prop values for this type have the shape of TypedValue in order to
be distinguished from other element types.
Comparison between different element types:
- RenderPropsType: Component select box, results it '(props) => ReactNode' value
- ReactNodeType: Component select box, results it 'ReactNode' value
- ElementType: Current tree element select box, results it 'ReactNod' value
"""
type ElementType implements TypeBase {
  """
  Allows scoping the type of element to only descendants, children or all elements
  """
  elementKind: ElementTypeKind!
  graph: TypeGraph!
  id: ID!
  name: String!
  owner(options: UserOptions, where: UserWhere): User
  ownerAggregate(where: UserWhere): ElementTypeUserOwnerAggregationSelection
  ownerConnection(
    after: String
    first: Int
    sort: [TypeBaseOwnerConnectionSort!]
    where: TypeBaseOwnerConnectionWhere
  ): TypeBaseOwnerConnection!
}

type ElementTypeAggregateSelection {
  count: Int!
  id: IDAggregateSelection!
  name: StringAggregateSelection!
}

input ElementTypeConnectInput {
  owner: TypeBaseOwnerConnectFieldInput
}

input ElementTypeConnectOrCreateInput {
  owner: TypeBaseOwnerConnectOrCreateFieldInput
}

input ElementTypeCreateInput {
  elementKind: ElementTypeKind!
  name: String!
  owner: TypeBaseOwnerFieldInput
}

input ElementTypeDeleteInput {
  owner: TypeBaseOwnerDeleteFieldInput
}

input ElementTypeDisconnectInput {
  owner: TypeBaseOwnerDisconnectFieldInput
}

enum ElementTypeKind {
  """
  Pick any element in the current tree
  """
  AllElements

  """
  Pick any element from the children of the current element
  """
  ChildrenOnly

  """
  Pick any element from the descendants of the current element
  """
  DescendantsOnly
}

input ElementTypeOptions {
  limit: Int
  offset: Int

  """
  Specify one or more ElementTypeSort objects to sort ElementTypes by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [ElementTypeSort]
}

input ElementTypeOwnerAggregateInput {
  AND: [ElementTypeOwnerAggregateInput!]
  OR: [ElementTypeOwnerAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: ElementTypeOwnerNodeAggregationWhereInput
}

input ElementTypeOwnerNodeAggregationWhereInput {
  AND: [ElementTypeOwnerNodeAggregationWhereInput!]
  OR: [ElementTypeOwnerNodeAggregationWhereInput!]
  auth0Id_AVERAGE_EQUAL: Float
  auth0Id_AVERAGE_GT: Float
  auth0Id_AVERAGE_GTE: Float
  auth0Id_AVERAGE_LT: Float
  auth0Id_AVERAGE_LTE: Float
  auth0Id_EQUAL: String
  auth0Id_GT: Int
  auth0Id_GTE: Int
  auth0Id_LONGEST_EQUAL: Int
  auth0Id_LONGEST_GT: Int
  auth0Id_LONGEST_GTE: Int
  auth0Id_LONGEST_LT: Int
  auth0Id_LONGEST_LTE: Int
  auth0Id_LT: Int
  auth0Id_LTE: Int
  auth0Id_SHORTEST_EQUAL: Int
  auth0Id_SHORTEST_GT: Int
  auth0Id_SHORTEST_GTE: Int
  auth0Id_SHORTEST_LT: Int
  auth0Id_SHORTEST_LTE: Int
  email_AVERAGE_EQUAL: Float
  email_AVERAGE_GT: Float
  email_AVERAGE_GTE: Float
  email_AVERAGE_LT: Float
  email_AVERAGE_LTE: Float
  email_EQUAL: String
  email_GT: Int
  email_GTE: Int
  email_LONGEST_EQUAL: Int
  email_LONGEST_GT: Int
  email_LONGEST_GTE: Int
  email_LONGEST_LT: Int
  email_LONGEST_LTE: Int
  email_LT: Int
  email_LTE: Int
  email_SHORTEST_EQUAL: Int
  email_SHORTEST_GT: Int
  email_SHORTEST_GTE: Int
  email_SHORTEST_LT: Int
  email_SHORTEST_LTE: Int
  id_EQUAL: ID
}

input ElementTypeRelationInput {
  owner: TypeBaseOwnerCreateFieldInput
}

"""
Fields to sort ElementTypes by. The order in which sorts are applied is not guaranteed when specifying many fields in one ElementTypeSort object.
"""
input ElementTypeSort {
  elementKind: SortDirection
  id: SortDirection
  name: SortDirection
}

input ElementTypeUpdateInput {
  elementKind: ElementTypeKind
  name: String
  owner: TypeBaseOwnerUpdateFieldInput
}

type ElementTypeUserOwnerAggregationSelection {
  count: Int!
  node: ElementTypeUserOwnerNodeAggregateSelection
}

type ElementTypeUserOwnerNodeAggregateSelection {
  auth0Id: StringAggregateSelection!
  email: StringAggregateSelection!
  id: IDAggregateSelection!
}

input ElementTypeWhere {
  AND: [ElementTypeWhere!]
  OR: [ElementTypeWhere!]
  elementKind: ElementTypeKind
  elementKind_IN: [ElementTypeKind]
  elementKind_NOT: ElementTypeKind
  elementKind_NOT_IN: [ElementTypeKind]
  id: ID
  id_CONTAINS: ID
  id_ENDS_WITH: ID
  id_IN: [ID]
  id_NOT: ID
  id_NOT_CONTAINS: ID
  id_NOT_ENDS_WITH: ID
  id_NOT_IN: [ID]
  id_NOT_STARTS_WITH: ID
  id_STARTS_WITH: ID
  name: String
  name_CONTAINS: String
  name_ENDS_WITH: String
  name_IN: [String]
  name_NOT: String
  name_NOT_CONTAINS: String
  name_NOT_ENDS_WITH: String
  name_NOT_IN: [String]
  name_NOT_STARTS_WITH: String
  name_STARTS_WITH: String
  owner: UserWhere
  ownerAggregate: ElementTypeOwnerAggregateInput
  ownerConnection: TypeBaseOwnerConnectionWhere
  ownerConnection_NOT: TypeBaseOwnerConnectionWhere
  owner_NOT: UserWhere
}

input ElementUniqueWhere {
  id: ID
}

input ElementUpdateInput {
  atom: ElementAtomUpdateFieldInput
  children: [ElementChildrenUpdateFieldInput!]
  componentTag: ElementComponentTagUpdateFieldInput
  css: String
  hooks: [ElementHooksUpdateFieldInput!]
  instanceOfComponent: ElementInstanceOfComponentUpdateFieldInput
  name: String
  parentElement: ElementParentElementUpdateFieldInput
  propMapBindings: [ElementPropMapBindingsUpdateFieldInput!]
  propTransformationJs: String
  props: ElementPropsUpdateFieldInput
  renderForEachPropKey: String
  renderIfPropKey: String
}

input ElementWhere {
  AND: [ElementWhere!]
  OR: [ElementWhere!]
  atom: AtomWhere
  atomAggregate: ElementAtomAggregateInput
  atomConnection: ElementAtomConnectionWhere
  atomConnection_NOT: ElementAtomConnectionWhere
  atom_NOT: AtomWhere
  children: ElementWhere
  childrenAggregate: ElementChildrenAggregateInput
  childrenConnection: ElementChildrenConnectionWhere
  childrenConnection_NOT: ElementChildrenConnectionWhere
  children_NOT: ElementWhere
  componentTag: TagWhere
  componentTagAggregate: ElementComponentTagAggregateInput
  componentTagConnection: ElementComponentTagConnectionWhere
  componentTagConnection_NOT: ElementComponentTagConnectionWhere
  componentTag_NOT: TagWhere
  css: String
  css_CONTAINS: String
  css_ENDS_WITH: String
  css_IN: [String]
  css_NOT: String
  css_NOT_CONTAINS: String
  css_NOT_ENDS_WITH: String
  css_NOT_IN: [String]
  css_NOT_STARTS_WITH: String
  css_STARTS_WITH: String
  hooks: HookWhere
  hooksAggregate: ElementHooksAggregateInput
  hooksConnection: ElementHooksConnectionWhere
  hooksConnection_NOT: ElementHooksConnectionWhere
  hooks_NOT: HookWhere
  id: ID
  id_CONTAINS: ID
  id_ENDS_WITH: ID
  id_IN: [ID]
  id_NOT: ID
  id_NOT_CONTAINS: ID
  id_NOT_ENDS_WITH: ID
  id_NOT_IN: [ID]
  id_NOT_STARTS_WITH: ID
  id_STARTS_WITH: ID
  instanceOfComponent: ElementWhere
  instanceOfComponentAggregate: ElementInstanceOfComponentAggregateInput
  instanceOfComponentConnection: ElementInstanceOfComponentConnectionWhere
  instanceOfComponentConnection_NOT: ElementInstanceOfComponentConnectionWhere
  instanceOfComponent_NOT: ElementWhere
  name: String
  name_CONTAINS: String
  name_ENDS_WITH: String
  name_IN: [String]
  name_NOT: String
  name_NOT_CONTAINS: String
  name_NOT_ENDS_WITH: String
  name_NOT_IN: [String]
  name_NOT_STARTS_WITH: String
  name_STARTS_WITH: String
  parentElement: ElementWhere
  parentElementAggregate: ElementParentElementAggregateInput
  parentElementConnection: ElementParentElementConnectionWhere
  parentElementConnection_NOT: ElementParentElementConnectionWhere
  parentElement_NOT: ElementWhere
  propMapBindings: PropMapBindingWhere
  propMapBindingsAggregate: ElementPropMapBindingsAggregateInput
  propMapBindingsConnection: ElementPropMapBindingsConnectionWhere
  propMapBindingsConnection_NOT: ElementPropMapBindingsConnectionWhere
  propMapBindings_NOT: PropMapBindingWhere
  propTransformationJs: String
  propTransformationJs_CONTAINS: String
  propTransformationJs_ENDS_WITH: String
  propTransformationJs_IN: [String]
  propTransformationJs_NOT: String
  propTransformationJs_NOT_CONTAINS: String
  propTransformationJs_NOT_ENDS_WITH: String
  propTransformationJs_NOT_IN: [String]
  propTransformationJs_NOT_STARTS_WITH: String
  propTransformationJs_STARTS_WITH: String
  props: PropWhere
  propsAggregate: ElementPropsAggregateInput
  propsConnection: ElementPropsConnectionWhere
  propsConnection_NOT: ElementPropsConnectionWhere
  props_NOT: PropWhere
  renderForEachPropKey: String
  renderForEachPropKey_CONTAINS: String
  renderForEachPropKey_ENDS_WITH: String
  renderForEachPropKey_IN: [String]
  renderForEachPropKey_NOT: String
  renderForEachPropKey_NOT_CONTAINS: String
  renderForEachPropKey_NOT_ENDS_WITH: String
  renderForEachPropKey_NOT_IN: [String]
  renderForEachPropKey_NOT_STARTS_WITH: String
  renderForEachPropKey_STARTS_WITH: String
  renderIfPropKey: String
  renderIfPropKey_CONTAINS: String
  renderIfPropKey_ENDS_WITH: String
  renderIfPropKey_IN: [String]
  renderIfPropKey_NOT: String
  renderIfPropKey_NOT_CONTAINS: String
  renderIfPropKey_NOT_ENDS_WITH: String
  renderIfPropKey_NOT_IN: [String]
  renderIfPropKey_NOT_STARTS_WITH: String
  renderIfPropKey_STARTS_WITH: String
}

"""
Allows choosing one of a set of allowed values.
The value gets passed to the render pipe as a Enum Type Value id.
The actual value must be de-referenced by the id.
"""
type EnumType implements TypeBase {
  allowedValues(
    options: EnumTypeValueOptions
    where: EnumTypeValueWhere
  ): [EnumTypeValue!]
  allowedValuesAggregate(
    where: EnumTypeValueWhere
  ): EnumTypeEnumTypeValueAllowedValuesAggregationSelection
  allowedValuesConnection(
    after: String
    first: Int
    sort: [EnumTypeAllowedValuesConnectionSort!]
    where: EnumTypeAllowedValuesConnectionWhere
  ): EnumTypeAllowedValuesConnection!
  graph: TypeGraph!
  id: ID!
  name: String!
  owner(options: UserOptions, where: UserWhere): User
  ownerAggregate(where: UserWhere): EnumTypeUserOwnerAggregationSelection
  ownerConnection(
    after: String
    first: Int
    sort: [TypeBaseOwnerConnectionSort!]
    where: TypeBaseOwnerConnectionWhere
  ): TypeBaseOwnerConnection!
}

type EnumTypeAggregateSelection {
  count: Int!
  id: IDAggregateSelection!
  name: StringAggregateSelection!
}

input EnumTypeAllowedValuesAggregateInput {
  AND: [EnumTypeAllowedValuesAggregateInput!]
  OR: [EnumTypeAllowedValuesAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: EnumTypeAllowedValuesNodeAggregationWhereInput
}

input EnumTypeAllowedValuesConnectFieldInput {
  connect: [EnumTypeValueConnectInput!]
  where: EnumTypeValueConnectWhere
}

type EnumTypeAllowedValuesConnection {
  edges: [EnumTypeAllowedValuesRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input EnumTypeAllowedValuesConnectionSort {
  node: EnumTypeValueSort
}

input EnumTypeAllowedValuesConnectionWhere {
  AND: [EnumTypeAllowedValuesConnectionWhere!]
  OR: [EnumTypeAllowedValuesConnectionWhere!]
  node: EnumTypeValueWhere
  node_NOT: EnumTypeValueWhere
}

input EnumTypeAllowedValuesCreateFieldInput {
  node: EnumTypeValueCreateInput!
}

input EnumTypeAllowedValuesDeleteFieldInput {
  delete: EnumTypeValueDeleteInput
  where: EnumTypeAllowedValuesConnectionWhere
}

input EnumTypeAllowedValuesDisconnectFieldInput {
  disconnect: EnumTypeValueDisconnectInput
  where: EnumTypeAllowedValuesConnectionWhere
}

input EnumTypeAllowedValuesFieldInput {
  connect: [EnumTypeAllowedValuesConnectFieldInput!]
  create: [EnumTypeAllowedValuesCreateFieldInput!]
}

input EnumTypeAllowedValuesNodeAggregationWhereInput {
  AND: [EnumTypeAllowedValuesNodeAggregationWhereInput!]
  OR: [EnumTypeAllowedValuesNodeAggregationWhereInput!]
  id_EQUAL: ID
  name_AVERAGE_EQUAL: Float
  name_AVERAGE_GT: Float
  name_AVERAGE_GTE: Float
  name_AVERAGE_LT: Float
  name_AVERAGE_LTE: Float
  name_EQUAL: String
  name_GT: Int
  name_GTE: Int
  name_LONGEST_EQUAL: Int
  name_LONGEST_GT: Int
  name_LONGEST_GTE: Int
  name_LONGEST_LT: Int
  name_LONGEST_LTE: Int
  name_LT: Int
  name_LTE: Int
  name_SHORTEST_EQUAL: Int
  name_SHORTEST_GT: Int
  name_SHORTEST_GTE: Int
  name_SHORTEST_LT: Int
  name_SHORTEST_LTE: Int
  value_AVERAGE_EQUAL: Float
  value_AVERAGE_GT: Float
  value_AVERAGE_GTE: Float
  value_AVERAGE_LT: Float
  value_AVERAGE_LTE: Float
  value_EQUAL: String
  value_GT: Int
  value_GTE: Int
  value_LONGEST_EQUAL: Int
  value_LONGEST_GT: Int
  value_LONGEST_GTE: Int
  value_LONGEST_LT: Int
  value_LONGEST_LTE: Int
  value_LT: Int
  value_LTE: Int
  value_SHORTEST_EQUAL: Int
  value_SHORTEST_GT: Int
  value_SHORTEST_GTE: Int
  value_SHORTEST_LT: Int
  value_SHORTEST_LTE: Int
}

type EnumTypeAllowedValuesRelationship {
  cursor: String!
  node: EnumTypeValue!
}

input EnumTypeAllowedValuesUpdateConnectionInput {
  node: EnumTypeValueUpdateInput
}

input EnumTypeAllowedValuesUpdateFieldInput {
  connect: [EnumTypeAllowedValuesConnectFieldInput!]
  create: [EnumTypeAllowedValuesCreateFieldInput!]
  delete: [EnumTypeAllowedValuesDeleteFieldInput!]
  disconnect: [EnumTypeAllowedValuesDisconnectFieldInput!]
  update: EnumTypeAllowedValuesUpdateConnectionInput
  where: EnumTypeAllowedValuesConnectionWhere
}

input EnumTypeConnectInput {
  allowedValues: [EnumTypeAllowedValuesConnectFieldInput!]
  owner: TypeBaseOwnerConnectFieldInput
}

input EnumTypeConnectOrCreateInput {
  owner: TypeBaseOwnerConnectOrCreateFieldInput
}

input EnumTypeConnectOrCreateWhere {
  node: EnumTypeUniqueWhere!
}

input EnumTypeConnectWhere {
  node: EnumTypeWhere!
}

input EnumTypeCreateInput {
  allowedValues: EnumTypeAllowedValuesFieldInput
  name: String!
  owner: TypeBaseOwnerFieldInput
}

input EnumTypeDeleteInput {
  allowedValues: [EnumTypeAllowedValuesDeleteFieldInput!]
  owner: TypeBaseOwnerDeleteFieldInput
}

input EnumTypeDisconnectInput {
  allowedValues: [EnumTypeAllowedValuesDisconnectFieldInput!]
  owner: TypeBaseOwnerDisconnectFieldInput
}

type EnumTypeEnumTypeValueAllowedValuesAggregationSelection {
  count: Int!
  node: EnumTypeEnumTypeValueAllowedValuesNodeAggregateSelection
}

type EnumTypeEnumTypeValueAllowedValuesNodeAggregateSelection {
  id: IDAggregateSelection!
  name: StringAggregateSelection!
  value: StringAggregateSelection!
}

input EnumTypeOptions {
  limit: Int
  offset: Int

  """
  Specify one or more EnumTypeSort objects to sort EnumTypes by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [EnumTypeSort]
}

input EnumTypeOwnerAggregateInput {
  AND: [EnumTypeOwnerAggregateInput!]
  OR: [EnumTypeOwnerAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: EnumTypeOwnerNodeAggregationWhereInput
}

input EnumTypeOwnerNodeAggregationWhereInput {
  AND: [EnumTypeOwnerNodeAggregationWhereInput!]
  OR: [EnumTypeOwnerNodeAggregationWhereInput!]
  auth0Id_AVERAGE_EQUAL: Float
  auth0Id_AVERAGE_GT: Float
  auth0Id_AVERAGE_GTE: Float
  auth0Id_AVERAGE_LT: Float
  auth0Id_AVERAGE_LTE: Float
  auth0Id_EQUAL: String
  auth0Id_GT: Int
  auth0Id_GTE: Int
  auth0Id_LONGEST_EQUAL: Int
  auth0Id_LONGEST_GT: Int
  auth0Id_LONGEST_GTE: Int
  auth0Id_LONGEST_LT: Int
  auth0Id_LONGEST_LTE: Int
  auth0Id_LT: Int
  auth0Id_LTE: Int
  auth0Id_SHORTEST_EQUAL: Int
  auth0Id_SHORTEST_GT: Int
  auth0Id_SHORTEST_GTE: Int
  auth0Id_SHORTEST_LT: Int
  auth0Id_SHORTEST_LTE: Int
  email_AVERAGE_EQUAL: Float
  email_AVERAGE_GT: Float
  email_AVERAGE_GTE: Float
  email_AVERAGE_LT: Float
  email_AVERAGE_LTE: Float
  email_EQUAL: String
  email_GT: Int
  email_GTE: Int
  email_LONGEST_EQUAL: Int
  email_LONGEST_GT: Int
  email_LONGEST_GTE: Int
  email_LONGEST_LT: Int
  email_LONGEST_LTE: Int
  email_LT: Int
  email_LTE: Int
  email_SHORTEST_EQUAL: Int
  email_SHORTEST_GT: Int
  email_SHORTEST_GTE: Int
  email_SHORTEST_LT: Int
  email_SHORTEST_LTE: Int
  id_EQUAL: ID
}

input EnumTypeRelationInput {
  allowedValues: [EnumTypeAllowedValuesCreateFieldInput!]
  owner: TypeBaseOwnerCreateFieldInput
}

"""
Fields to sort EnumTypes by. The order in which sorts are applied is not guaranteed when specifying many fields in one EnumTypeSort object.
"""
input EnumTypeSort {
  id: SortDirection
  name: SortDirection
}

input EnumTypeUniqueWhere {
  id: ID
}

input EnumTypeUpdateInput {
  allowedValues: [EnumTypeAllowedValuesUpdateFieldInput!]
  name: String
  owner: TypeBaseOwnerUpdateFieldInput
}

type EnumTypeUserOwnerAggregationSelection {
  count: Int!
  node: EnumTypeUserOwnerNodeAggregateSelection
}

type EnumTypeUserOwnerNodeAggregateSelection {
  auth0Id: StringAggregateSelection!
  email: StringAggregateSelection!
  id: IDAggregateSelection!
}

type EnumTypeValue {
  enumType(options: EnumTypeOptions, where: EnumTypeWhere): EnumType
  enumTypeAggregate(
    where: EnumTypeWhere
  ): EnumTypeValueEnumTypeEnumTypeAggregationSelection
  enumTypeConnection(
    after: String
    first: Int
    sort: [EnumTypeValueEnumTypeConnectionSort!]
    where: EnumTypeValueEnumTypeConnectionWhere
  ): EnumTypeValueEnumTypeConnection!
  id: ID!
  name: String
  value: String!
}

type EnumTypeValueAggregateSelection {
  count: Int!
  id: IDAggregateSelection!
  name: StringAggregateSelection!
  value: StringAggregateSelection!
}

input EnumTypeValueConnectInput {
  enumType: EnumTypeValueEnumTypeConnectFieldInput
}

input EnumTypeValueConnectOrCreateInput {
  enumType: EnumTypeValueEnumTypeConnectOrCreateFieldInput
}

input EnumTypeValueConnectWhere {
  node: EnumTypeValueWhere!
}

input EnumTypeValueCreateInput {
  enumType: EnumTypeValueEnumTypeFieldInput
  id: ID!
  name: String
  value: String!
}

input EnumTypeValueDeleteInput {
  enumType: EnumTypeValueEnumTypeDeleteFieldInput
}

input EnumTypeValueDisconnectInput {
  enumType: EnumTypeValueEnumTypeDisconnectFieldInput
}

input EnumTypeValueEnumTypeAggregateInput {
  AND: [EnumTypeValueEnumTypeAggregateInput!]
  OR: [EnumTypeValueEnumTypeAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: EnumTypeValueEnumTypeNodeAggregationWhereInput
}

input EnumTypeValueEnumTypeConnectFieldInput {
  connect: EnumTypeConnectInput
  where: EnumTypeConnectWhere
}

input EnumTypeValueEnumTypeConnectOrCreateFieldInput {
  onCreate: EnumTypeValueEnumTypeConnectOrCreateFieldInputOnCreate!
  where: EnumTypeConnectOrCreateWhere!
}

input EnumTypeValueEnumTypeConnectOrCreateFieldInputOnCreate {
  node: EnumTypeCreateInput!
}

type EnumTypeValueEnumTypeConnection {
  edges: [EnumTypeValueEnumTypeRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input EnumTypeValueEnumTypeConnectionSort {
  node: EnumTypeSort
}

input EnumTypeValueEnumTypeConnectionWhere {
  AND: [EnumTypeValueEnumTypeConnectionWhere!]
  OR: [EnumTypeValueEnumTypeConnectionWhere!]
  node: EnumTypeWhere
  node_NOT: EnumTypeWhere
}

input EnumTypeValueEnumTypeCreateFieldInput {
  node: EnumTypeCreateInput!
}

input EnumTypeValueEnumTypeDeleteFieldInput {
  delete: EnumTypeDeleteInput
  where: EnumTypeValueEnumTypeConnectionWhere
}

input EnumTypeValueEnumTypeDisconnectFieldInput {
  disconnect: EnumTypeDisconnectInput
  where: EnumTypeValueEnumTypeConnectionWhere
}

type EnumTypeValueEnumTypeEnumTypeAggregationSelection {
  count: Int!
  node: EnumTypeValueEnumTypeEnumTypeNodeAggregateSelection
}

type EnumTypeValueEnumTypeEnumTypeNodeAggregateSelection {
  id: IDAggregateSelection!
  name: StringAggregateSelection!
}

input EnumTypeValueEnumTypeFieldInput {
  connect: EnumTypeValueEnumTypeConnectFieldInput
  connectOrCreate: EnumTypeValueEnumTypeConnectOrCreateFieldInput
  create: EnumTypeValueEnumTypeCreateFieldInput
}

input EnumTypeValueEnumTypeNodeAggregationWhereInput {
  AND: [EnumTypeValueEnumTypeNodeAggregationWhereInput!]
  OR: [EnumTypeValueEnumTypeNodeAggregationWhereInput!]
  id_EQUAL: ID
  name_AVERAGE_EQUAL: Float
  name_AVERAGE_GT: Float
  name_AVERAGE_GTE: Float
  name_AVERAGE_LT: Float
  name_AVERAGE_LTE: Float
  name_EQUAL: String
  name_GT: Int
  name_GTE: Int
  name_LONGEST_EQUAL: Int
  name_LONGEST_GT: Int
  name_LONGEST_GTE: Int
  name_LONGEST_LT: Int
  name_LONGEST_LTE: Int
  name_LT: Int
  name_LTE: Int
  name_SHORTEST_EQUAL: Int
  name_SHORTEST_GT: Int
  name_SHORTEST_GTE: Int
  name_SHORTEST_LT: Int
  name_SHORTEST_LTE: Int
}

type EnumTypeValueEnumTypeRelationship {
  cursor: String!
  node: EnumType!
}

input EnumTypeValueEnumTypeUpdateConnectionInput {
  node: EnumTypeUpdateInput
}

input EnumTypeValueEnumTypeUpdateFieldInput {
  connect: EnumTypeValueEnumTypeConnectFieldInput
  connectOrCreate: EnumTypeValueEnumTypeConnectOrCreateFieldInput
  create: EnumTypeValueEnumTypeCreateFieldInput
  delete: EnumTypeValueEnumTypeDeleteFieldInput
  disconnect: EnumTypeValueEnumTypeDisconnectFieldInput
  update: EnumTypeValueEnumTypeUpdateConnectionInput
  where: EnumTypeValueEnumTypeConnectionWhere
}

input EnumTypeValueOptions {
  limit: Int
  offset: Int

  """
  Specify one or more EnumTypeValueSort objects to sort EnumTypeValues by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [EnumTypeValueSort]
}

input EnumTypeValueRelationInput {
  enumType: EnumTypeValueEnumTypeCreateFieldInput
}

"""
Fields to sort EnumTypeValues by. The order in which sorts are applied is not guaranteed when specifying many fields in one EnumTypeValueSort object.
"""
input EnumTypeValueSort {
  id: SortDirection
  name: SortDirection
  value: SortDirection
}

input EnumTypeValueUpdateInput {
  enumType: EnumTypeValueEnumTypeUpdateFieldInput
  id: ID
  name: String
  value: String
}

input EnumTypeValueWhere {
  AND: [EnumTypeValueWhere!]
  OR: [EnumTypeValueWhere!]
  enumType: EnumTypeWhere
  enumTypeAggregate: EnumTypeValueEnumTypeAggregateInput
  enumTypeConnection: EnumTypeValueEnumTypeConnectionWhere
  enumTypeConnection_NOT: EnumTypeValueEnumTypeConnectionWhere
  enumType_NOT: EnumTypeWhere
  id: ID
  id_CONTAINS: ID
  id_ENDS_WITH: ID
  id_IN: [ID]
  id_NOT: ID
  id_NOT_CONTAINS: ID
  id_NOT_ENDS_WITH: ID
  id_NOT_IN: [ID]
  id_NOT_STARTS_WITH: ID
  id_STARTS_WITH: ID
  name: String
  name_CONTAINS: String
  name_ENDS_WITH: String
  name_IN: [String]
  name_NOT: String
  name_NOT_CONTAINS: String
  name_NOT_ENDS_WITH: String
  name_NOT_IN: [String]
  name_NOT_STARTS_WITH: String
  name_STARTS_WITH: String
  value: String
  value_CONTAINS: String
  value_ENDS_WITH: String
  value_IN: [String]
  value_NOT: String
  value_NOT_CONTAINS: String
  value_NOT_ENDS_WITH: String
  value_NOT_IN: [String]
  value_NOT_STARTS_WITH: String
  value_STARTS_WITH: String
}

input EnumTypeWhere {
  AND: [EnumTypeWhere!]
  OR: [EnumTypeWhere!]
  allowedValues: EnumTypeValueWhere
  allowedValuesAggregate: EnumTypeAllowedValuesAggregateInput
  allowedValuesConnection: EnumTypeAllowedValuesConnectionWhere
  allowedValuesConnection_NOT: EnumTypeAllowedValuesConnectionWhere
  allowedValues_NOT: EnumTypeValueWhere
  id: ID
  id_CONTAINS: ID
  id_ENDS_WITH: ID
  id_IN: [ID]
  id_NOT: ID
  id_NOT_CONTAINS: ID
  id_NOT_ENDS_WITH: ID
  id_NOT_IN: [ID]
  id_NOT_STARTS_WITH: ID
  id_STARTS_WITH: ID
  name: String
  name_CONTAINS: String
  name_ENDS_WITH: String
  name_IN: [String]
  name_NOT: String
  name_NOT_CONTAINS: String
  name_NOT_ENDS_WITH: String
  name_NOT_IN: [String]
  name_NOT_STARTS_WITH: String
  name_STARTS_WITH: String
  owner: UserWhere
  ownerAggregate: EnumTypeOwnerAggregateInput
  ownerConnection: TypeBaseOwnerConnectionWhere
  ownerConnection_NOT: TypeBaseOwnerConnectionWhere
  owner_NOT: UserWhere
}

interface Field {
  description: String
  key: String!
  name: String
}

input FieldCreateInput {
  description: String
  key: String!
  name: String
}

input FieldSort {
  description: SortDirection
  key: SortDirection
  name: SortDirection
}

input FieldUpdateInput {
  description: String
  key: String
  name: String
}

input FieldWhere {
  AND: [FieldWhere!]
  OR: [FieldWhere!]
  description: String
  description_CONTAINS: String
  description_ENDS_WITH: String
  description_IN: [String]
  description_NOT: String
  description_NOT_CONTAINS: String
  description_NOT_ENDS_WITH: String
  description_NOT_IN: [String]
  description_NOT_STARTS_WITH: String
  description_STARTS_WITH: String
  key: String
  key_CONTAINS: String
  key_ENDS_WITH: String
  key_IN: [String]
  key_NOT: String
  key_NOT_CONTAINS: String
  key_NOT_ENDS_WITH: String
  key_NOT_IN: [String]
  key_NOT_STARTS_WITH: String
  key_STARTS_WITH: String
  name: String
  name_CONTAINS: String
  name_ENDS_WITH: String
  name_IN: [String]
  name_NOT: String
  name_NOT_CONTAINS: String
  name_NOT_ENDS_WITH: String
  name_NOT_IN: [String]
  name_NOT_STARTS_WITH: String
  name_STARTS_WITH: String
}

type Hook {
  config(options: PropOptions, where: PropWhere): Prop!
  configAggregate(where: PropWhere): HookPropConfigAggregationSelection
  configConnection(
    after: String
    first: Int
    sort: [HookConfigConnectionSort!]
    where: HookConfigConnectionWhere
  ): HookConfigConnection!
  element(options: ElementOptions, where: ElementWhere): Element!
  elementAggregate(where: ElementWhere): HookElementElementAggregationSelection
  elementConnection(
    after: String
    first: Int
    sort: [HookElementConnectionSort!]
    where: HookElementConnectionWhere
  ): HookElementConnection!
  id: ID!
  type: AtomType!
}

type HookAggregateSelection {
  count: Int!
  id: IDAggregateSelection!
}

input HookConfigAggregateInput {
  AND: [HookConfigAggregateInput!]
  OR: [HookConfigAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: HookConfigNodeAggregationWhereInput
}

input HookConfigConnectFieldInput {
  where: PropConnectWhere
}

input HookConfigConnectOrCreateFieldInput {
  onCreate: HookConfigConnectOrCreateFieldInputOnCreate!
  where: PropConnectOrCreateWhere!
}

input HookConfigConnectOrCreateFieldInputOnCreate {
  node: PropCreateInput!
}

type HookConfigConnection {
  edges: [HookConfigRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input HookConfigConnectionSort {
  node: PropSort
}

input HookConfigConnectionWhere {
  AND: [HookConfigConnectionWhere!]
  OR: [HookConfigConnectionWhere!]
  node: PropWhere
  node_NOT: PropWhere
}

input HookConfigCreateFieldInput {
  node: PropCreateInput!
}

input HookConfigDeleteFieldInput {
  where: HookConfigConnectionWhere
}

input HookConfigDisconnectFieldInput {
  where: HookConfigConnectionWhere
}

input HookConfigFieldInput {
  connect: HookConfigConnectFieldInput
  connectOrCreate: HookConfigConnectOrCreateFieldInput
  create: HookConfigCreateFieldInput
}

input HookConfigNodeAggregationWhereInput {
  AND: [HookConfigNodeAggregationWhereInput!]
  OR: [HookConfigNodeAggregationWhereInput!]
  data_AVERAGE_EQUAL: Float
  data_AVERAGE_GT: Float
  data_AVERAGE_GTE: Float
  data_AVERAGE_LT: Float
  data_AVERAGE_LTE: Float
  data_EQUAL: String
  data_GT: Int
  data_GTE: Int
  data_LONGEST_EQUAL: Int
  data_LONGEST_GT: Int
  data_LONGEST_GTE: Int
  data_LONGEST_LT: Int
  data_LONGEST_LTE: Int
  data_LT: Int
  data_LTE: Int
  data_SHORTEST_EQUAL: Int
  data_SHORTEST_GT: Int
  data_SHORTEST_GTE: Int
  data_SHORTEST_LT: Int
  data_SHORTEST_LTE: Int
  id_EQUAL: ID
}

type HookConfigRelationship {
  cursor: String!
  node: Prop!
}

input HookConfigUpdateConnectionInput {
  node: PropUpdateInput
}

input HookConfigUpdateFieldInput {
  connect: HookConfigConnectFieldInput
  connectOrCreate: HookConfigConnectOrCreateFieldInput
  create: HookConfigCreateFieldInput
  delete: HookConfigDeleteFieldInput
  disconnect: HookConfigDisconnectFieldInput
  update: HookConfigUpdateConnectionInput
  where: HookConfigConnectionWhere
}

input HookConnectInput {
  config: HookConfigConnectFieldInput
  element: HookElementConnectFieldInput
}

input HookConnectOrCreateInput {
  config: HookConfigConnectOrCreateFieldInput
  element: HookElementConnectOrCreateFieldInput
}

input HookConnectOrCreateWhere {
  node: HookUniqueWhere!
}

input HookConnectWhere {
  node: HookWhere!
}

input HookCreateInput {
  config: HookConfigFieldInput
  element: HookElementFieldInput
  type: AtomType!
}

input HookDeleteInput {
  config: HookConfigDeleteFieldInput
  element: HookElementDeleteFieldInput
}

input HookDisconnectInput {
  config: HookConfigDisconnectFieldInput
  element: HookElementDisconnectFieldInput
}

input HookElementAggregateInput {
  AND: [HookElementAggregateInput!]
  OR: [HookElementAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: HookElementNodeAggregationWhereInput
}

input HookElementConnectFieldInput {
  connect: ElementConnectInput
  where: ElementConnectWhere
}

input HookElementConnectOrCreateFieldInput {
  onCreate: HookElementConnectOrCreateFieldInputOnCreate!
  where: ElementConnectOrCreateWhere!
}

input HookElementConnectOrCreateFieldInputOnCreate {
  node: ElementCreateInput!
}

type HookElementConnection {
  edges: [HookElementRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input HookElementConnectionSort {
  node: ElementSort
}

input HookElementConnectionWhere {
  AND: [HookElementConnectionWhere!]
  OR: [HookElementConnectionWhere!]
  node: ElementWhere
  node_NOT: ElementWhere
}

input HookElementCreateFieldInput {
  node: ElementCreateInput!
}

input HookElementDeleteFieldInput {
  delete: ElementDeleteInput
  where: HookElementConnectionWhere
}

input HookElementDisconnectFieldInput {
  disconnect: ElementDisconnectInput
  where: HookElementConnectionWhere
}

type HookElementElementAggregationSelection {
  count: Int!
  node: HookElementElementNodeAggregateSelection
}

type HookElementElementNodeAggregateSelection {
  css: StringAggregateSelection!
  id: IDAggregateSelection!
  name: StringAggregateSelection!
  propTransformationJs: StringAggregateSelection!
  renderForEachPropKey: StringAggregateSelection!
  renderIfPropKey: StringAggregateSelection!
}

input HookElementFieldInput {
  connect: HookElementConnectFieldInput
  connectOrCreate: HookElementConnectOrCreateFieldInput
  create: HookElementCreateFieldInput
}

input HookElementNodeAggregationWhereInput {
  AND: [HookElementNodeAggregationWhereInput!]
  OR: [HookElementNodeAggregationWhereInput!]
  css_AVERAGE_EQUAL: Float
  css_AVERAGE_GT: Float
  css_AVERAGE_GTE: Float
  css_AVERAGE_LT: Float
  css_AVERAGE_LTE: Float
  css_EQUAL: String
  css_GT: Int
  css_GTE: Int
  css_LONGEST_EQUAL: Int
  css_LONGEST_GT: Int
  css_LONGEST_GTE: Int
  css_LONGEST_LT: Int
  css_LONGEST_LTE: Int
  css_LT: Int
  css_LTE: Int
  css_SHORTEST_EQUAL: Int
  css_SHORTEST_GT: Int
  css_SHORTEST_GTE: Int
  css_SHORTEST_LT: Int
  css_SHORTEST_LTE: Int
  id_EQUAL: ID
  name_AVERAGE_EQUAL: Float
  name_AVERAGE_GT: Float
  name_AVERAGE_GTE: Float
  name_AVERAGE_LT: Float
  name_AVERAGE_LTE: Float
  name_EQUAL: String
  name_GT: Int
  name_GTE: Int
  name_LONGEST_EQUAL: Int
  name_LONGEST_GT: Int
  name_LONGEST_GTE: Int
  name_LONGEST_LT: Int
  name_LONGEST_LTE: Int
  name_LT: Int
  name_LTE: Int
  name_SHORTEST_EQUAL: Int
  name_SHORTEST_GT: Int
  name_SHORTEST_GTE: Int
  name_SHORTEST_LT: Int
  name_SHORTEST_LTE: Int
  propTransformationJs_AVERAGE_EQUAL: Float
  propTransformationJs_AVERAGE_GT: Float
  propTransformationJs_AVERAGE_GTE: Float
  propTransformationJs_AVERAGE_LT: Float
  propTransformationJs_AVERAGE_LTE: Float
  propTransformationJs_EQUAL: String
  propTransformationJs_GT: Int
  propTransformationJs_GTE: Int
  propTransformationJs_LONGEST_EQUAL: Int
  propTransformationJs_LONGEST_GT: Int
  propTransformationJs_LONGEST_GTE: Int
  propTransformationJs_LONGEST_LT: Int
  propTransformationJs_LONGEST_LTE: Int
  propTransformationJs_LT: Int
  propTransformationJs_LTE: Int
  propTransformationJs_SHORTEST_EQUAL: Int
  propTransformationJs_SHORTEST_GT: Int
  propTransformationJs_SHORTEST_GTE: Int
  propTransformationJs_SHORTEST_LT: Int
  propTransformationJs_SHORTEST_LTE: Int
  renderForEachPropKey_AVERAGE_EQUAL: Float
  renderForEachPropKey_AVERAGE_GT: Float
  renderForEachPropKey_AVERAGE_GTE: Float
  renderForEachPropKey_AVERAGE_LT: Float
  renderForEachPropKey_AVERAGE_LTE: Float
  renderForEachPropKey_EQUAL: String
  renderForEachPropKey_GT: Int
  renderForEachPropKey_GTE: Int
  renderForEachPropKey_LONGEST_EQUAL: Int
  renderForEachPropKey_LONGEST_GT: Int
  renderForEachPropKey_LONGEST_GTE: Int
  renderForEachPropKey_LONGEST_LT: Int
  renderForEachPropKey_LONGEST_LTE: Int
  renderForEachPropKey_LT: Int
  renderForEachPropKey_LTE: Int
  renderForEachPropKey_SHORTEST_EQUAL: Int
  renderForEachPropKey_SHORTEST_GT: Int
  renderForEachPropKey_SHORTEST_GTE: Int
  renderForEachPropKey_SHORTEST_LT: Int
  renderForEachPropKey_SHORTEST_LTE: Int
  renderIfPropKey_AVERAGE_EQUAL: Float
  renderIfPropKey_AVERAGE_GT: Float
  renderIfPropKey_AVERAGE_GTE: Float
  renderIfPropKey_AVERAGE_LT: Float
  renderIfPropKey_AVERAGE_LTE: Float
  renderIfPropKey_EQUAL: String
  renderIfPropKey_GT: Int
  renderIfPropKey_GTE: Int
  renderIfPropKey_LONGEST_EQUAL: Int
  renderIfPropKey_LONGEST_GT: Int
  renderIfPropKey_LONGEST_GTE: Int
  renderIfPropKey_LONGEST_LT: Int
  renderIfPropKey_LONGEST_LTE: Int
  renderIfPropKey_LT: Int
  renderIfPropKey_LTE: Int
  renderIfPropKey_SHORTEST_EQUAL: Int
  renderIfPropKey_SHORTEST_GT: Int
  renderIfPropKey_SHORTEST_GTE: Int
  renderIfPropKey_SHORTEST_LT: Int
  renderIfPropKey_SHORTEST_LTE: Int
}

type HookElementRelationship {
  cursor: String!
  node: Element!
}

input HookElementUpdateConnectionInput {
  node: ElementUpdateInput
}

input HookElementUpdateFieldInput {
  connect: HookElementConnectFieldInput
  connectOrCreate: HookElementConnectOrCreateFieldInput
  create: HookElementCreateFieldInput
  delete: HookElementDeleteFieldInput
  disconnect: HookElementDisconnectFieldInput
  update: HookElementUpdateConnectionInput
  where: HookElementConnectionWhere
}

input HookOptions {
  limit: Int
  offset: Int

  """
  Specify one or more HookSort objects to sort Hooks by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [HookSort]
}

type HookPropConfigAggregationSelection {
  count: Int!
  node: HookPropConfigNodeAggregateSelection
}

type HookPropConfigNodeAggregateSelection {
  data: StringAggregateSelection!
  id: IDAggregateSelection!
}

input HookRelationInput {
  config: HookConfigCreateFieldInput
  element: HookElementCreateFieldInput
}

"""
Fields to sort Hooks by. The order in which sorts are applied is not guaranteed when specifying many fields in one HookSort object.
"""
input HookSort {
  id: SortDirection
  type: SortDirection
}

input HookUniqueWhere {
  id: ID
}

input HookUpdateInput {
  config: HookConfigUpdateFieldInput
  element: HookElementUpdateFieldInput
  type: AtomType
}

input HookWhere {
  AND: [HookWhere!]
  OR: [HookWhere!]
  config: PropWhere
  configAggregate: HookConfigAggregateInput
  configConnection: HookConfigConnectionWhere
  configConnection_NOT: HookConfigConnectionWhere
  config_NOT: PropWhere
  element: ElementWhere
  elementAggregate: HookElementAggregateInput
  elementConnection: HookElementConnectionWhere
  elementConnection_NOT: HookElementConnectionWhere
  element_NOT: ElementWhere
  id: ID
  id_CONTAINS: ID
  id_ENDS_WITH: ID
  id_IN: [ID]
  id_NOT: ID
  id_NOT_CONTAINS: ID
  id_NOT_ENDS_WITH: ID
  id_NOT_IN: [ID]
  id_NOT_STARTS_WITH: ID
  id_STARTS_WITH: ID
  type: AtomType
  type_IN: [AtomType]
  type_NOT: AtomType
  type_NOT_IN: [AtomType]
}

type IDAggregateSelection {
  longest: ID
  shortest: ID
}

interface IEdge {
  source: String!
  target: String!
}

input ImportAtomsInput {
  payload: [JSONObject!]
}

type ImportAtomsMutationResponse {
  atoms: [Atom!]
}

type ImportAtomsMutationResponseAggregateSelection {
  count: Int!
}

input ImportAtomsMutationResponseCreateInput {
  """
  Appears because this input type would be empty otherwise because this type is composed of just generated and/or relationship properties. See https://neo4j.com/docs/graphql-manual/current/troubleshooting/faqs/
  """
  _emptyInput: Boolean
}

input ImportAtomsMutationResponseOptions {
  limit: Int
  offset: Int
}

input ImportAtomsMutationResponseUpdateInput {
  """
  Appears because this input type would be empty otherwise because this type is composed of just generated and/or relationship properties. See https://neo4j.com/docs/graphql-manual/current/troubleshooting/faqs/
  """
  _emptyInput: Boolean
}

input ImportAtomsMutationResponseWhere {
  AND: [ImportAtomsMutationResponseWhere!]
  OR: [ImportAtomsMutationResponseWhere!]
}

type IntAggregateSelection {
  average: Float
  max: Int
  min: Int
  sum: Int
}

"""
Represents an object type with multiple fields
"""
type InterfaceType implements TypeBase {
  apiOfAtoms(options: AtomOptions, where: AtomWhere): [Atom!]
  apiOfAtomsAggregate(
    where: AtomWhere
  ): InterfaceTypeAtomApiOfAtomsAggregationSelection
  apiOfAtomsConnection(
    after: String
    first: Int
    sort: [InterfaceTypeApiOfAtomsConnectionSort!]
    where: InterfaceTypeApiOfAtomsConnectionWhere
  ): InterfaceTypeApiOfAtomsConnection!
  fields(options: QueryOptions, where: TypeBaseWhere): [TypeBase!]
  fieldsConnection(
    sort: [InterfaceTypeFieldsConnectionSort!]
    where: InterfaceTypeFieldsConnectionWhere
  ): InterfaceTypeFieldsConnection!
  graph: TypeGraph!
  id: ID!
  name: String!
  owner(options: UserOptions, where: UserWhere): User
  ownerAggregate(where: UserWhere): InterfaceTypeUserOwnerAggregationSelection
  ownerConnection(
    after: String
    first: Int
    sort: [TypeBaseOwnerConnectionSort!]
    where: TypeBaseOwnerConnectionWhere
  ): TypeBaseOwnerConnection!
}

type InterfaceTypeAggregateSelection {
  count: Int!
  id: IDAggregateSelection!
  name: StringAggregateSelection!
}

input InterfaceTypeApiOfAtomsAggregateInput {
  AND: [InterfaceTypeApiOfAtomsAggregateInput!]
  OR: [InterfaceTypeApiOfAtomsAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: InterfaceTypeApiOfAtomsNodeAggregationWhereInput
}

input InterfaceTypeApiOfAtomsConnectFieldInput {
  connect: [AtomConnectInput!]
  where: AtomConnectWhere
}

input InterfaceTypeApiOfAtomsConnectOrCreateFieldInput {
  onCreate: InterfaceTypeApiOfAtomsConnectOrCreateFieldInputOnCreate!
  where: AtomConnectOrCreateWhere!
}

input InterfaceTypeApiOfAtomsConnectOrCreateFieldInputOnCreate {
  node: AtomCreateInput!
}

type InterfaceTypeApiOfAtomsConnection {
  edges: [InterfaceTypeApiOfAtomsRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input InterfaceTypeApiOfAtomsConnectionSort {
  node: AtomSort
}

input InterfaceTypeApiOfAtomsConnectionWhere {
  AND: [InterfaceTypeApiOfAtomsConnectionWhere!]
  OR: [InterfaceTypeApiOfAtomsConnectionWhere!]
  node: AtomWhere
  node_NOT: AtomWhere
}

input InterfaceTypeApiOfAtomsCreateFieldInput {
  node: AtomCreateInput!
}

input InterfaceTypeApiOfAtomsDeleteFieldInput {
  delete: AtomDeleteInput
  where: InterfaceTypeApiOfAtomsConnectionWhere
}

input InterfaceTypeApiOfAtomsDisconnectFieldInput {
  disconnect: AtomDisconnectInput
  where: InterfaceTypeApiOfAtomsConnectionWhere
}

input InterfaceTypeApiOfAtomsFieldInput {
  connect: [InterfaceTypeApiOfAtomsConnectFieldInput!]
  connectOrCreate: [InterfaceTypeApiOfAtomsConnectOrCreateFieldInput!]
  create: [InterfaceTypeApiOfAtomsCreateFieldInput!]
}

input InterfaceTypeApiOfAtomsNodeAggregationWhereInput {
  AND: [InterfaceTypeApiOfAtomsNodeAggregationWhereInput!]
  OR: [InterfaceTypeApiOfAtomsNodeAggregationWhereInput!]
  id_EQUAL: ID
  name_AVERAGE_EQUAL: Float
  name_AVERAGE_GT: Float
  name_AVERAGE_GTE: Float
  name_AVERAGE_LT: Float
  name_AVERAGE_LTE: Float
  name_EQUAL: String
  name_GT: Int
  name_GTE: Int
  name_LONGEST_EQUAL: Int
  name_LONGEST_GT: Int
  name_LONGEST_GTE: Int
  name_LONGEST_LT: Int
  name_LONGEST_LTE: Int
  name_LT: Int
  name_LTE: Int
  name_SHORTEST_EQUAL: Int
  name_SHORTEST_GT: Int
  name_SHORTEST_GTE: Int
  name_SHORTEST_LT: Int
  name_SHORTEST_LTE: Int
}

type InterfaceTypeApiOfAtomsRelationship {
  cursor: String!
  node: Atom!
}

input InterfaceTypeApiOfAtomsUpdateConnectionInput {
  node: AtomUpdateInput
}

input InterfaceTypeApiOfAtomsUpdateFieldInput {
  connect: [InterfaceTypeApiOfAtomsConnectFieldInput!]
  connectOrCreate: [InterfaceTypeApiOfAtomsConnectOrCreateFieldInput!]
  create: [InterfaceTypeApiOfAtomsCreateFieldInput!]
  delete: [InterfaceTypeApiOfAtomsDeleteFieldInput!]
  disconnect: [InterfaceTypeApiOfAtomsDisconnectFieldInput!]
  update: InterfaceTypeApiOfAtomsUpdateConnectionInput
  where: InterfaceTypeApiOfAtomsConnectionWhere
}

type InterfaceTypeAtomApiOfAtomsAggregationSelection {
  count: Int!
  node: InterfaceTypeAtomApiOfAtomsNodeAggregateSelection
}

type InterfaceTypeAtomApiOfAtomsNodeAggregateSelection {
  id: IDAggregateSelection!
  name: StringAggregateSelection!
}

input InterfaceTypeConnectInput {
  apiOfAtoms: [InterfaceTypeApiOfAtomsConnectFieldInput!]
  fields: [InterfaceTypeFieldsConnectFieldInput!]
  owner: TypeBaseOwnerConnectFieldInput
}

input InterfaceTypeConnectOrCreateInput {
  apiOfAtoms: [InterfaceTypeApiOfAtomsConnectOrCreateFieldInput!]
  owner: TypeBaseOwnerConnectOrCreateFieldInput
}

input InterfaceTypeConnectOrCreateWhere {
  node: InterfaceTypeUniqueWhere!
}

input InterfaceTypeConnectWhere {
  node: InterfaceTypeWhere!
}

input InterfaceTypeCreateInput {
  apiOfAtoms: InterfaceTypeApiOfAtomsFieldInput
  fields: InterfaceTypeFieldsFieldInput
  name: String!
  owner: TypeBaseOwnerFieldInput
}

input InterfaceTypeDeleteInput {
  apiOfAtoms: [InterfaceTypeApiOfAtomsDeleteFieldInput!]
  fields: [InterfaceTypeFieldsDeleteFieldInput!]
  owner: TypeBaseOwnerDeleteFieldInput
}

input InterfaceTypeDisconnectInput {
  apiOfAtoms: [InterfaceTypeApiOfAtomsDisconnectFieldInput!]
  fields: [InterfaceTypeFieldsDisconnectFieldInput!]
  owner: TypeBaseOwnerDisconnectFieldInput
}

"""
Connection between an Interface Type and its fields types.
The field data is stored as relationship properties and we retreive them along with the relation itself.
"""
type InterfaceTypeEdge implements Field & IEdge {
  description: String
  key: String!
  name: String
  source: String!
  target: String!
}

input InterfaceTypeFieldsConnectFieldInput {
  connect: TypeBaseConnectInput
  edge: FieldCreateInput!
  where: TypeBaseConnectWhere
}

type InterfaceTypeFieldsConnection {
  edges: [InterfaceTypeFieldsRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input InterfaceTypeFieldsConnectionSort {
  edge: FieldSort
}

input InterfaceTypeFieldsConnectionWhere {
  AND: [InterfaceTypeFieldsConnectionWhere!]
  OR: [InterfaceTypeFieldsConnectionWhere!]
  edge: FieldWhere
  edge_NOT: FieldWhere
  node: TypeBaseWhere
  node_NOT: TypeBaseWhere
}

input InterfaceTypeFieldsCreateFieldInput {
  edge: FieldCreateInput!
  node: TypeBaseCreateInput!
}

input InterfaceTypeFieldsDeleteFieldInput {
  delete: TypeBaseDeleteInput
  where: InterfaceTypeFieldsConnectionWhere
}

input InterfaceTypeFieldsDisconnectFieldInput {
  disconnect: TypeBaseDisconnectInput
  where: InterfaceTypeFieldsConnectionWhere
}

input InterfaceTypeFieldsFieldInput {
  connect: [InterfaceTypeFieldsConnectFieldInput!]
  create: [InterfaceTypeFieldsCreateFieldInput!]
}

type InterfaceTypeFieldsRelationship implements Field {
  cursor: String!
  description: String
  key: String!
  name: String
  node: TypeBase!
}

input InterfaceTypeFieldsUpdateConnectionInput {
  edge: FieldUpdateInput
  node: TypeBaseUpdateInput
}

input InterfaceTypeFieldsUpdateFieldInput {
  connect: [InterfaceTypeFieldsConnectFieldInput!]
  create: [InterfaceTypeFieldsCreateFieldInput!]
  delete: [InterfaceTypeFieldsDeleteFieldInput!]
  disconnect: [InterfaceTypeFieldsDisconnectFieldInput!]
  update: InterfaceTypeFieldsUpdateConnectionInput
  where: InterfaceTypeFieldsConnectionWhere
}

input InterfaceTypeOptions {
  limit: Int
  offset: Int

  """
  Specify one or more InterfaceTypeSort objects to sort InterfaceTypes by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [InterfaceTypeSort]
}

input InterfaceTypeOwnerAggregateInput {
  AND: [InterfaceTypeOwnerAggregateInput!]
  OR: [InterfaceTypeOwnerAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: InterfaceTypeOwnerNodeAggregationWhereInput
}

input InterfaceTypeOwnerNodeAggregationWhereInput {
  AND: [InterfaceTypeOwnerNodeAggregationWhereInput!]
  OR: [InterfaceTypeOwnerNodeAggregationWhereInput!]
  auth0Id_AVERAGE_EQUAL: Float
  auth0Id_AVERAGE_GT: Float
  auth0Id_AVERAGE_GTE: Float
  auth0Id_AVERAGE_LT: Float
  auth0Id_AVERAGE_LTE: Float
  auth0Id_EQUAL: String
  auth0Id_GT: Int
  auth0Id_GTE: Int
  auth0Id_LONGEST_EQUAL: Int
  auth0Id_LONGEST_GT: Int
  auth0Id_LONGEST_GTE: Int
  auth0Id_LONGEST_LT: Int
  auth0Id_LONGEST_LTE: Int
  auth0Id_LT: Int
  auth0Id_LTE: Int
  auth0Id_SHORTEST_EQUAL: Int
  auth0Id_SHORTEST_GT: Int
  auth0Id_SHORTEST_GTE: Int
  auth0Id_SHORTEST_LT: Int
  auth0Id_SHORTEST_LTE: Int
  email_AVERAGE_EQUAL: Float
  email_AVERAGE_GT: Float
  email_AVERAGE_GTE: Float
  email_AVERAGE_LT: Float
  email_AVERAGE_LTE: Float
  email_EQUAL: String
  email_GT: Int
  email_GTE: Int
  email_LONGEST_EQUAL: Int
  email_LONGEST_GT: Int
  email_LONGEST_GTE: Int
  email_LONGEST_LT: Int
  email_LONGEST_LTE: Int
  email_LT: Int
  email_LTE: Int
  email_SHORTEST_EQUAL: Int
  email_SHORTEST_GT: Int
  email_SHORTEST_GTE: Int
  email_SHORTEST_LT: Int
  email_SHORTEST_LTE: Int
  id_EQUAL: ID
}

input InterfaceTypeRelationInput {
  apiOfAtoms: [InterfaceTypeApiOfAtomsCreateFieldInput!]
  fields: [InterfaceTypeFieldsCreateFieldInput!]
  owner: TypeBaseOwnerCreateFieldInput
}

"""
Fields to sort InterfaceTypes by. The order in which sorts are applied is not guaranteed when specifying many fields in one InterfaceTypeSort object.
"""
input InterfaceTypeSort {
  id: SortDirection
  name: SortDirection
}

input InterfaceTypeUniqueWhere {
  id: ID
}

input InterfaceTypeUpdateInput {
  apiOfAtoms: [InterfaceTypeApiOfAtomsUpdateFieldInput!]
  fields: [InterfaceTypeFieldsUpdateFieldInput!]
  name: String
  owner: TypeBaseOwnerUpdateFieldInput
}

type InterfaceTypeUserOwnerAggregationSelection {
  count: Int!
  node: InterfaceTypeUserOwnerNodeAggregateSelection
}

type InterfaceTypeUserOwnerNodeAggregateSelection {
  auth0Id: StringAggregateSelection!
  email: StringAggregateSelection!
  id: IDAggregateSelection!
}

input InterfaceTypeWhere {
  AND: [InterfaceTypeWhere!]
  OR: [InterfaceTypeWhere!]
  apiOfAtoms: AtomWhere
  apiOfAtomsAggregate: InterfaceTypeApiOfAtomsAggregateInput
  apiOfAtomsConnection: InterfaceTypeApiOfAtomsConnectionWhere
  apiOfAtomsConnection_NOT: InterfaceTypeApiOfAtomsConnectionWhere
  apiOfAtoms_NOT: AtomWhere
  fieldsConnection: InterfaceTypeFieldsConnectionWhere
  fieldsConnection_NOT: InterfaceTypeFieldsConnectionWhere
  id: ID
  id_CONTAINS: ID
  id_ENDS_WITH: ID
  id_IN: [ID]
  id_NOT: ID
  id_NOT_CONTAINS: ID
  id_NOT_ENDS_WITH: ID
  id_NOT_IN: [ID]
  id_NOT_STARTS_WITH: ID
  id_STARTS_WITH: ID
  name: String
  name_CONTAINS: String
  name_ENDS_WITH: String
  name_IN: [String]
  name_NOT: String
  name_NOT_CONTAINS: String
  name_NOT_ENDS_WITH: String
  name_NOT_IN: [String]
  name_NOT_STARTS_WITH: String
  name_STARTS_WITH: String
  owner: UserWhere
  ownerAggregate: InterfaceTypeOwnerAggregateInput
  ownerConnection: TypeBaseOwnerConnectionWhere
  ownerConnection_NOT: TypeBaseOwnerConnectionWhere
  owner_NOT: UserWhere
}

"""
The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

"""
Allows picking a lambda
"""
type LambdaType implements TypeBase {
  graph: TypeGraph!
  id: ID!
  name: String!
  owner(options: UserOptions, where: UserWhere): User
  ownerAggregate(where: UserWhere): LambdaTypeUserOwnerAggregationSelection
  ownerConnection(
    after: String
    first: Int
    sort: [TypeBaseOwnerConnectionSort!]
    where: TypeBaseOwnerConnectionWhere
  ): TypeBaseOwnerConnection!
}

type LambdaTypeAggregateSelection {
  count: Int!
  id: IDAggregateSelection!
  name: StringAggregateSelection!
}

input LambdaTypeConnectInput {
  owner: TypeBaseOwnerConnectFieldInput
}

input LambdaTypeConnectOrCreateInput {
  owner: TypeBaseOwnerConnectOrCreateFieldInput
}

input LambdaTypeCreateInput {
  name: String!
  owner: TypeBaseOwnerFieldInput
}

input LambdaTypeDeleteInput {
  owner: TypeBaseOwnerDeleteFieldInput
}

input LambdaTypeDisconnectInput {
  owner: TypeBaseOwnerDisconnectFieldInput
}

input LambdaTypeOptions {
  limit: Int
  offset: Int

  """
  Specify one or more LambdaTypeSort objects to sort LambdaTypes by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [LambdaTypeSort]
}

input LambdaTypeOwnerAggregateInput {
  AND: [LambdaTypeOwnerAggregateInput!]
  OR: [LambdaTypeOwnerAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: LambdaTypeOwnerNodeAggregationWhereInput
}

input LambdaTypeOwnerNodeAggregationWhereInput {
  AND: [LambdaTypeOwnerNodeAggregationWhereInput!]
  OR: [LambdaTypeOwnerNodeAggregationWhereInput!]
  auth0Id_AVERAGE_EQUAL: Float
  auth0Id_AVERAGE_GT: Float
  auth0Id_AVERAGE_GTE: Float
  auth0Id_AVERAGE_LT: Float
  auth0Id_AVERAGE_LTE: Float
  auth0Id_EQUAL: String
  auth0Id_GT: Int
  auth0Id_GTE: Int
  auth0Id_LONGEST_EQUAL: Int
  auth0Id_LONGEST_GT: Int
  auth0Id_LONGEST_GTE: Int
  auth0Id_LONGEST_LT: Int
  auth0Id_LONGEST_LTE: Int
  auth0Id_LT: Int
  auth0Id_LTE: Int
  auth0Id_SHORTEST_EQUAL: Int
  auth0Id_SHORTEST_GT: Int
  auth0Id_SHORTEST_GTE: Int
  auth0Id_SHORTEST_LT: Int
  auth0Id_SHORTEST_LTE: Int
  email_AVERAGE_EQUAL: Float
  email_AVERAGE_GT: Float
  email_AVERAGE_GTE: Float
  email_AVERAGE_LT: Float
  email_AVERAGE_LTE: Float
  email_EQUAL: String
  email_GT: Int
  email_GTE: Int
  email_LONGEST_EQUAL: Int
  email_LONGEST_GT: Int
  email_LONGEST_GTE: Int
  email_LONGEST_LT: Int
  email_LONGEST_LTE: Int
  email_LT: Int
  email_LTE: Int
  email_SHORTEST_EQUAL: Int
  email_SHORTEST_GT: Int
  email_SHORTEST_GTE: Int
  email_SHORTEST_LT: Int
  email_SHORTEST_LTE: Int
  id_EQUAL: ID
}

input LambdaTypeRelationInput {
  owner: TypeBaseOwnerCreateFieldInput
}

"""
Fields to sort LambdaTypes by. The order in which sorts are applied is not guaranteed when specifying many fields in one LambdaTypeSort object.
"""
input LambdaTypeSort {
  id: SortDirection
  name: SortDirection
}

input LambdaTypeUpdateInput {
  name: String
  owner: TypeBaseOwnerUpdateFieldInput
}

type LambdaTypeUserOwnerAggregationSelection {
  count: Int!
  node: LambdaTypeUserOwnerNodeAggregateSelection
}

type LambdaTypeUserOwnerNodeAggregateSelection {
  auth0Id: StringAggregateSelection!
  email: StringAggregateSelection!
  id: IDAggregateSelection!
}

input LambdaTypeWhere {
  AND: [LambdaTypeWhere!]
  OR: [LambdaTypeWhere!]
  id: ID
  id_CONTAINS: ID
  id_ENDS_WITH: ID
  id_IN: [ID]
  id_NOT: ID
  id_NOT_CONTAINS: ID
  id_NOT_ENDS_WITH: ID
  id_NOT_IN: [ID]
  id_NOT_STARTS_WITH: ID
  id_STARTS_WITH: ID
  name: String
  name_CONTAINS: String
  name_ENDS_WITH: String
  name_IN: [String]
  name_NOT: String
  name_NOT_CONTAINS: String
  name_NOT_ENDS_WITH: String
  name_NOT_IN: [String]
  name_NOT_STARTS_WITH: String
  name_STARTS_WITH: String
  owner: UserWhere
  ownerAggregate: LambdaTypeOwnerAggregateInput
  ownerConnection: TypeBaseOwnerConnectionWhere
  ownerConnection_NOT: TypeBaseOwnerConnectionWhere
  owner_NOT: UserWhere
}

enum MonacoLanguage {
  css
  cssInJs
  graphqlDev
  javascript
  json
  typescript
}

"""
Allows editing the value using a monaco editor
"""
type MonacoType implements TypeBase {
  graph: TypeGraph!
  id: ID!
  language: MonacoLanguage!
  name: String!
  owner(options: UserOptions, where: UserWhere): User
  ownerAggregate(where: UserWhere): MonacoTypeUserOwnerAggregationSelection
  ownerConnection(
    after: String
    first: Int
    sort: [TypeBaseOwnerConnectionSort!]
    where: TypeBaseOwnerConnectionWhere
  ): TypeBaseOwnerConnection!
}

type MonacoTypeAggregateSelection {
  count: Int!
  id: IDAggregateSelection!
  name: StringAggregateSelection!
}

input MonacoTypeConnectInput {
  owner: TypeBaseOwnerConnectFieldInput
}

input MonacoTypeConnectOrCreateInput {
  owner: TypeBaseOwnerConnectOrCreateFieldInput
}

input MonacoTypeCreateInput {
  language: MonacoLanguage!
  name: String!
  owner: TypeBaseOwnerFieldInput
}

input MonacoTypeDeleteInput {
  owner: TypeBaseOwnerDeleteFieldInput
}

input MonacoTypeDisconnectInput {
  owner: TypeBaseOwnerDisconnectFieldInput
}

input MonacoTypeOptions {
  limit: Int
  offset: Int

  """
  Specify one or more MonacoTypeSort objects to sort MonacoTypes by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [MonacoTypeSort]
}

input MonacoTypeOwnerAggregateInput {
  AND: [MonacoTypeOwnerAggregateInput!]
  OR: [MonacoTypeOwnerAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: MonacoTypeOwnerNodeAggregationWhereInput
}

input MonacoTypeOwnerNodeAggregationWhereInput {
  AND: [MonacoTypeOwnerNodeAggregationWhereInput!]
  OR: [MonacoTypeOwnerNodeAggregationWhereInput!]
  auth0Id_AVERAGE_EQUAL: Float
  auth0Id_AVERAGE_GT: Float
  auth0Id_AVERAGE_GTE: Float
  auth0Id_AVERAGE_LT: Float
  auth0Id_AVERAGE_LTE: Float
  auth0Id_EQUAL: String
  auth0Id_GT: Int
  auth0Id_GTE: Int
  auth0Id_LONGEST_EQUAL: Int
  auth0Id_LONGEST_GT: Int
  auth0Id_LONGEST_GTE: Int
  auth0Id_LONGEST_LT: Int
  auth0Id_LONGEST_LTE: Int
  auth0Id_LT: Int
  auth0Id_LTE: Int
  auth0Id_SHORTEST_EQUAL: Int
  auth0Id_SHORTEST_GT: Int
  auth0Id_SHORTEST_GTE: Int
  auth0Id_SHORTEST_LT: Int
  auth0Id_SHORTEST_LTE: Int
  email_AVERAGE_EQUAL: Float
  email_AVERAGE_GT: Float
  email_AVERAGE_GTE: Float
  email_AVERAGE_LT: Float
  email_AVERAGE_LTE: Float
  email_EQUAL: String
  email_GT: Int
  email_GTE: Int
  email_LONGEST_EQUAL: Int
  email_LONGEST_GT: Int
  email_LONGEST_GTE: Int
  email_LONGEST_LT: Int
  email_LONGEST_LTE: Int
  email_LT: Int
  email_LTE: Int
  email_SHORTEST_EQUAL: Int
  email_SHORTEST_GT: Int
  email_SHORTEST_GTE: Int
  email_SHORTEST_LT: Int
  email_SHORTEST_LTE: Int
  id_EQUAL: ID
}

input MonacoTypeRelationInput {
  owner: TypeBaseOwnerCreateFieldInput
}

"""
Fields to sort MonacoTypes by. The order in which sorts are applied is not guaranteed when specifying many fields in one MonacoTypeSort object.
"""
input MonacoTypeSort {
  id: SortDirection
  language: SortDirection
  name: SortDirection
}

input MonacoTypeUpdateInput {
  language: MonacoLanguage
  name: String
  owner: TypeBaseOwnerUpdateFieldInput
}

type MonacoTypeUserOwnerAggregationSelection {
  count: Int!
  node: MonacoTypeUserOwnerNodeAggregateSelection
}

type MonacoTypeUserOwnerNodeAggregateSelection {
  auth0Id: StringAggregateSelection!
  email: StringAggregateSelection!
  id: IDAggregateSelection!
}

input MonacoTypeWhere {
  AND: [MonacoTypeWhere!]
  OR: [MonacoTypeWhere!]
  id: ID
  id_CONTAINS: ID
  id_ENDS_WITH: ID
  id_IN: [ID]
  id_NOT: ID
  id_NOT_CONTAINS: ID
  id_NOT_ENDS_WITH: ID
  id_NOT_IN: [ID]
  id_NOT_STARTS_WITH: ID
  id_STARTS_WITH: ID
  language: MonacoLanguage
  language_IN: [MonacoLanguage]
  language_NOT: MonacoLanguage
  language_NOT_IN: [MonacoLanguage]
  name: String
  name_CONTAINS: String
  name_ENDS_WITH: String
  name_IN: [String]
  name_NOT: String
  name_NOT_CONTAINS: String
  name_NOT_ENDS_WITH: String
  name_NOT_IN: [String]
  name_NOT_STARTS_WITH: String
  name_STARTS_WITH: String
  owner: UserWhere
  ownerAggregate: MonacoTypeOwnerAggregateInput
  ownerConnection: TypeBaseOwnerConnectionWhere
  ownerConnection_NOT: TypeBaseOwnerConnectionWhere
  owner_NOT: UserWhere
}

type Mutation {
  createAppTypes(input: [AppTypeCreateInput!]!): CreateAppTypesMutationResponse!
  createApps(input: [AppCreateInput!]!): CreateAppsMutationResponse!
  createArrayTypes(
    input: [ArrayTypeCreateInput!]!
  ): CreateArrayTypesMutationResponse!
  createAtoms(input: [AtomCreateInput!]!): CreateAtomsMutationResponse!
  createCreateInfos(
    input: [CreateInfoCreateInput!]!
  ): CreateCreateInfosMutationResponse!
  createDeleteFieldResponses(
    input: [DeleteFieldResponseCreateInput!]!
  ): CreateDeleteFieldResponsesMutationResponse!
  createEdges(input: [EdgeCreateInput!]!): CreateEdgesMutationResponse!
  createElementTypes(
    input: [ElementTypeCreateInput!]!
  ): CreateElementTypesMutationResponse!
  createElements(input: [ElementCreateInput!]!): CreateElementsMutationResponse!
  createEnumTypeValues(
    input: [EnumTypeValueCreateInput!]!
  ): CreateEnumTypeValuesMutationResponse!
  createEnumTypes(
    input: [EnumTypeCreateInput!]!
  ): CreateEnumTypesMutationResponse!
  createHooks(input: [HookCreateInput!]!): CreateHooksMutationResponse!
  createImportAtomsMutationResponses(
    input: [ImportAtomsMutationResponseCreateInput!]!
  ): CreateImportAtomsMutationResponsesMutationResponse!
  createInterfaceTypes(
    input: [InterfaceTypeCreateInput!]!
  ): CreateInterfaceTypesMutationResponse!
  createLambdaTypes(
    input: [LambdaTypeCreateInput!]!
  ): CreateLambdaTypesMutationResponse!
  createMonacoTypes(
    input: [MonacoTypeCreateInput!]!
  ): CreateMonacoTypesMutationResponse!
  createPageTypes(
    input: [PageTypeCreateInput!]!
  ): CreatePageTypesMutationResponse!
  createPages(input: [PageCreateInput!]!): CreatePagesMutationResponse!
  createPrimitiveTypes(
    input: [PrimitiveTypeCreateInput!]!
  ): CreatePrimitiveTypesMutationResponse!
  createPropMapBindings(
    input: [PropMapBindingCreateInput!]!
  ): CreatePropMapBindingsMutationResponse!
  createProps(input: [PropCreateInput!]!): CreatePropsMutationResponse!
  createReactNodeTypes(
    input: [ReactNodeTypeCreateInput!]!
  ): CreateReactNodeTypesMutationResponse!
  createRenderPropsTypes(
    input: [RenderPropsTypeCreateInput!]!
  ): CreateRenderPropsTypesMutationResponse!
  createTagEdges(input: [TagEdgeCreateInput!]!): CreateTagEdgesMutationResponse!
  createTags(input: [TagCreateInput!]!): CreateTagsMutationResponse!
  createTypeReferences(
    input: [TypeReferenceCreateInput!]!
  ): CreateTypeReferencesMutationResponse!
  createUnionTypes(
    input: [UnionTypeCreateInput!]!
  ): CreateUnionTypesMutationResponse!
  deleteAppTypes(delete: AppTypeDeleteInput, where: AppTypeWhere): DeleteInfo!
  deleteApps(delete: AppDeleteInput, where: AppWhere): DeleteInfo!
  deleteArrayTypes(
    delete: ArrayTypeDeleteInput
    where: ArrayTypeWhere
  ): DeleteInfo!
  deleteAtoms(delete: AtomDeleteInput, where: AtomWhere): DeleteInfo!
  deleteCreateInfos(where: CreateInfoWhere): DeleteInfo!
  deleteDeleteFieldResponses(where: DeleteFieldResponseWhere): DeleteInfo!
  deleteEdges(where: EdgeWhere): DeleteInfo!
  deleteElementTypes(
    delete: ElementTypeDeleteInput
    where: ElementTypeWhere
  ): DeleteInfo!
  deleteElements(delete: ElementDeleteInput, where: ElementWhere): DeleteInfo!
  deleteElementsSubgraph(
    delete: ElementDeleteInput
    where: ElementWhere
  ): DeleteElementsInfo!
  deleteEnumTypeValues(
    delete: EnumTypeValueDeleteInput
    where: EnumTypeValueWhere
  ): DeleteInfo!
  deleteEnumTypes(
    delete: EnumTypeDeleteInput
    where: EnumTypeWhere
  ): DeleteInfo!
  deleteFieldEdge(input: DeleteFieldInput!): DeleteFieldResponse!
  deleteHooks(delete: HookDeleteInput, where: HookWhere): DeleteInfo!
  deleteImportAtomsMutationResponses(
    where: ImportAtomsMutationResponseWhere
  ): DeleteInfo!
  deleteInterfaceTypes(
    delete: InterfaceTypeDeleteInput
    where: InterfaceTypeWhere
  ): DeleteInfo!
  deleteLambdaTypes(
    delete: LambdaTypeDeleteInput
    where: LambdaTypeWhere
  ): DeleteInfo!
  deleteMonacoTypes(
    delete: MonacoTypeDeleteInput
    where: MonacoTypeWhere
  ): DeleteInfo!
  deletePageTypes(
    delete: PageTypeDeleteInput
    where: PageTypeWhere
  ): DeleteInfo!
  deletePages(delete: PageDeleteInput, where: PageWhere): DeleteInfo!
  deletePrimitiveTypes(
    delete: PrimitiveTypeDeleteInput
    where: PrimitiveTypeWhere
  ): DeleteInfo!
  deletePropMapBindings(
    delete: PropMapBindingDeleteInput
    where: PropMapBindingWhere
  ): DeleteInfo!
  deleteProps(where: PropWhere): DeleteInfo!
  deleteReactNodeTypes(
    delete: ReactNodeTypeDeleteInput
    where: ReactNodeTypeWhere
  ): DeleteInfo!
  deleteRenderPropsTypes(
    delete: RenderPropsTypeDeleteInput
    where: RenderPropsTypeWhere
  ): DeleteInfo!
  deleteTagEdges(where: TagEdgeWhere): DeleteInfo!
  deleteTags(delete: TagDeleteInput, where: TagWhere): DeleteInfo!
  deleteTypeReferences(where: TypeReferenceWhere): DeleteInfo!
  deleteUnionTypes(
    delete: UnionTypeDeleteInput
    where: UnionTypeWhere
  ): DeleteInfo!
  deleteUsers(delete: UserDeleteInput, where: UserWhere): DeleteInfo!
  duplicateElement(
    input: DuplicateElementInput!
  ): DuplicateElementMutationResponse!
  importAtoms(input: ImportAtomsInput!): ImportAtomsMutationResponse
  updateAppTypes(
    connect: AppTypeConnectInput
    connectOrCreate: AppTypeConnectOrCreateInput
    create: AppTypeRelationInput
    delete: AppTypeDeleteInput
    disconnect: AppTypeDisconnectInput
    update: AppTypeUpdateInput
    where: AppTypeWhere
  ): UpdateAppTypesMutationResponse!
  updateApps(
    connect: AppConnectInput
    connectOrCreate: AppConnectOrCreateInput
    create: AppRelationInput
    delete: AppDeleteInput
    disconnect: AppDisconnectInput
    update: AppUpdateInput
    where: AppWhere
  ): UpdateAppsMutationResponse!
  updateArrayTypes(
    connect: ArrayTypeConnectInput
    connectOrCreate: ArrayTypeConnectOrCreateInput
    create: ArrayTypeRelationInput
    delete: ArrayTypeDeleteInput
    disconnect: ArrayTypeDisconnectInput
    update: ArrayTypeUpdateInput
    where: ArrayTypeWhere
  ): UpdateArrayTypesMutationResponse!
  updateAtoms(
    connect: AtomConnectInput
    connectOrCreate: AtomConnectOrCreateInput
    create: AtomRelationInput
    delete: AtomDeleteInput
    disconnect: AtomDisconnectInput
    update: AtomUpdateInput
    where: AtomWhere
  ): UpdateAtomsMutationResponse!
  updateCreateInfos(
    update: CreateInfoUpdateInput
    where: CreateInfoWhere
  ): UpdateCreateInfosMutationResponse!
  updateDeleteFieldResponses(
    update: DeleteFieldResponseUpdateInput
    where: DeleteFieldResponseWhere
  ): UpdateDeleteFieldResponsesMutationResponse!
  updateEdges(
    update: EdgeUpdateInput
    where: EdgeWhere
  ): UpdateEdgesMutationResponse!
  updateElementTypes(
    connect: ElementTypeConnectInput
    connectOrCreate: ElementTypeConnectOrCreateInput
    create: ElementTypeRelationInput
    delete: ElementTypeDeleteInput
    disconnect: ElementTypeDisconnectInput
    update: ElementTypeUpdateInput
    where: ElementTypeWhere
  ): UpdateElementTypesMutationResponse!
  updateElements(
    connect: ElementConnectInput
    connectOrCreate: ElementConnectOrCreateInput
    create: ElementRelationInput
    delete: ElementDeleteInput
    disconnect: ElementDisconnectInput
    update: ElementUpdateInput
    where: ElementWhere
  ): UpdateElementsMutationResponse!
  updateEnumTypeValues(
    connect: EnumTypeValueConnectInput
    connectOrCreate: EnumTypeValueConnectOrCreateInput
    create: EnumTypeValueRelationInput
    delete: EnumTypeValueDeleteInput
    disconnect: EnumTypeValueDisconnectInput
    update: EnumTypeValueUpdateInput
    where: EnumTypeValueWhere
  ): UpdateEnumTypeValuesMutationResponse!
  updateEnumTypes(
    connect: EnumTypeConnectInput
    connectOrCreate: EnumTypeConnectOrCreateInput
    create: EnumTypeRelationInput
    delete: EnumTypeDeleteInput
    disconnect: EnumTypeDisconnectInput
    update: EnumTypeUpdateInput
    where: EnumTypeWhere
  ): UpdateEnumTypesMutationResponse!
  updateHooks(
    connect: HookConnectInput
    connectOrCreate: HookConnectOrCreateInput
    create: HookRelationInput
    delete: HookDeleteInput
    disconnect: HookDisconnectInput
    update: HookUpdateInput
    where: HookWhere
  ): UpdateHooksMutationResponse!
  updateImportAtomsMutationResponses(
    update: ImportAtomsMutationResponseUpdateInput
    where: ImportAtomsMutationResponseWhere
  ): UpdateImportAtomsMutationResponsesMutationResponse!
  updateInterfaceTypes(
    connect: InterfaceTypeConnectInput
    connectOrCreate: InterfaceTypeConnectOrCreateInput
    create: InterfaceTypeRelationInput
    delete: InterfaceTypeDeleteInput
    disconnect: InterfaceTypeDisconnectInput
    update: InterfaceTypeUpdateInput
    where: InterfaceTypeWhere
  ): UpdateInterfaceTypesMutationResponse!
  updateLambdaTypes(
    connect: LambdaTypeConnectInput
    connectOrCreate: LambdaTypeConnectOrCreateInput
    create: LambdaTypeRelationInput
    delete: LambdaTypeDeleteInput
    disconnect: LambdaTypeDisconnectInput
    update: LambdaTypeUpdateInput
    where: LambdaTypeWhere
  ): UpdateLambdaTypesMutationResponse!
  updateMonacoTypes(
    connect: MonacoTypeConnectInput
    connectOrCreate: MonacoTypeConnectOrCreateInput
    create: MonacoTypeRelationInput
    delete: MonacoTypeDeleteInput
    disconnect: MonacoTypeDisconnectInput
    update: MonacoTypeUpdateInput
    where: MonacoTypeWhere
  ): UpdateMonacoTypesMutationResponse!
  updatePageTypes(
    connect: PageTypeConnectInput
    connectOrCreate: PageTypeConnectOrCreateInput
    create: PageTypeRelationInput
    delete: PageTypeDeleteInput
    disconnect: PageTypeDisconnectInput
    update: PageTypeUpdateInput
    where: PageTypeWhere
  ): UpdatePageTypesMutationResponse!
  updatePages(
    connect: PageConnectInput
    connectOrCreate: PageConnectOrCreateInput
    create: PageRelationInput
    delete: PageDeleteInput
    disconnect: PageDisconnectInput
    update: PageUpdateInput
    where: PageWhere
  ): UpdatePagesMutationResponse!
  updatePrimitiveTypes(
    connect: PrimitiveTypeConnectInput
    connectOrCreate: PrimitiveTypeConnectOrCreateInput
    create: PrimitiveTypeRelationInput
    delete: PrimitiveTypeDeleteInput
    disconnect: PrimitiveTypeDisconnectInput
    update: PrimitiveTypeUpdateInput
    where: PrimitiveTypeWhere
  ): UpdatePrimitiveTypesMutationResponse!
  updatePropMapBindings(
    connect: PropMapBindingConnectInput
    connectOrCreate: PropMapBindingConnectOrCreateInput
    create: PropMapBindingRelationInput
    delete: PropMapBindingDeleteInput
    disconnect: PropMapBindingDisconnectInput
    update: PropMapBindingUpdateInput
    where: PropMapBindingWhere
  ): UpdatePropMapBindingsMutationResponse!
  updateProps(
    update: PropUpdateInput
    where: PropWhere
  ): UpdatePropsMutationResponse!
  updateReactNodeTypes(
    connect: ReactNodeTypeConnectInput
    connectOrCreate: ReactNodeTypeConnectOrCreateInput
    create: ReactNodeTypeRelationInput
    delete: ReactNodeTypeDeleteInput
    disconnect: ReactNodeTypeDisconnectInput
    update: ReactNodeTypeUpdateInput
    where: ReactNodeTypeWhere
  ): UpdateReactNodeTypesMutationResponse!
  updateRenderPropsTypes(
    connect: RenderPropsTypeConnectInput
    connectOrCreate: RenderPropsTypeConnectOrCreateInput
    create: RenderPropsTypeRelationInput
    delete: RenderPropsTypeDeleteInput
    disconnect: RenderPropsTypeDisconnectInput
    update: RenderPropsTypeUpdateInput
    where: RenderPropsTypeWhere
  ): UpdateRenderPropsTypesMutationResponse!
  updateTagEdges(
    update: TagEdgeUpdateInput
    where: TagEdgeWhere
  ): UpdateTagEdgesMutationResponse!
  updateTags(
    connect: TagConnectInput
    connectOrCreate: TagConnectOrCreateInput
    create: TagRelationInput
    delete: TagDeleteInput
    disconnect: TagDisconnectInput
    update: TagUpdateInput
    where: TagWhere
  ): UpdateTagsMutationResponse!
  updateTypeReferences(
    update: TypeReferenceUpdateInput
    where: TypeReferenceWhere
  ): UpdateTypeReferencesMutationResponse!
  updateUnionTypes(
    connect: UnionTypeConnectInput
    connectOrCreate: UnionTypeConnectOrCreateInput
    create: UnionTypeRelationInput
    delete: UnionTypeDeleteInput
    disconnect: UnionTypeDisconnectInput
    update: UnionTypeUpdateInput
    where: UnionTypeWhere
  ): UpdateUnionTypesMutationResponse!
  upsertFieldEdge(
    input: UpsertFieldInput!
    isCreating: Boolean!
  ): InterfaceTypeEdge!
}

type Page {
  app(options: AppOptions, where: AppWhere): App!
  appAggregate(where: AppWhere): PageAppAppAggregationSelection
  appConnection(
    after: String
    first: Int
    sort: [PageAppConnectionSort!]
    where: PageAppConnectionWhere
  ): PageAppConnection!
  id: ID!
  name: String!
  rootElement(options: ElementOptions, where: ElementWhere): Element!
  rootElementAggregate(
    where: ElementWhere
  ): PageElementRootElementAggregationSelection
  rootElementConnection(
    after: String
    first: Int
    sort: [PageRootElementConnectionSort!]
    where: PageRootElementConnectionWhere
  ): PageRootElementConnection!
}

type PageAggregateSelection {
  count: Int!
  id: IDAggregateSelection!
  name: StringAggregateSelection!
}

input PageAppAggregateInput {
  AND: [PageAppAggregateInput!]
  OR: [PageAppAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: PageAppNodeAggregationWhereInput
}

type PageAppAppAggregationSelection {
  count: Int!
  node: PageAppAppNodeAggregateSelection
}

type PageAppAppNodeAggregateSelection {
  id: IDAggregateSelection!
  name: StringAggregateSelection!
}

input PageAppConnectFieldInput {
  connect: AppConnectInput
  where: AppConnectWhere
}

input PageAppConnectOrCreateFieldInput {
  onCreate: PageAppConnectOrCreateFieldInputOnCreate!
  where: AppConnectOrCreateWhere!
}

input PageAppConnectOrCreateFieldInputOnCreate {
  node: AppCreateInput!
}

type PageAppConnection {
  edges: [PageAppRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input PageAppConnectionSort {
  node: AppSort
}

input PageAppConnectionWhere {
  AND: [PageAppConnectionWhere!]
  OR: [PageAppConnectionWhere!]
  node: AppWhere
  node_NOT: AppWhere
}

input PageAppCreateFieldInput {
  node: AppCreateInput!
}

input PageAppDeleteFieldInput {
  delete: AppDeleteInput
  where: PageAppConnectionWhere
}

input PageAppDisconnectFieldInput {
  disconnect: AppDisconnectInput
  where: PageAppConnectionWhere
}

input PageAppFieldInput {
  connect: PageAppConnectFieldInput
  connectOrCreate: PageAppConnectOrCreateFieldInput
  create: PageAppCreateFieldInput
}

input PageAppNodeAggregationWhereInput {
  AND: [PageAppNodeAggregationWhereInput!]
  OR: [PageAppNodeAggregationWhereInput!]
  id_EQUAL: ID
  name_AVERAGE_EQUAL: Float
  name_AVERAGE_GT: Float
  name_AVERAGE_GTE: Float
  name_AVERAGE_LT: Float
  name_AVERAGE_LTE: Float
  name_EQUAL: String
  name_GT: Int
  name_GTE: Int
  name_LONGEST_EQUAL: Int
  name_LONGEST_GT: Int
  name_LONGEST_GTE: Int
  name_LONGEST_LT: Int
  name_LONGEST_LTE: Int
  name_LT: Int
  name_LTE: Int
  name_SHORTEST_EQUAL: Int
  name_SHORTEST_GT: Int
  name_SHORTEST_GTE: Int
  name_SHORTEST_LT: Int
  name_SHORTEST_LTE: Int
}

type PageAppRelationship {
  cursor: String!
  node: App!
}

input PageAppUpdateConnectionInput {
  node: AppUpdateInput
}

input PageAppUpdateFieldInput {
  connect: PageAppConnectFieldInput
  connectOrCreate: PageAppConnectOrCreateFieldInput
  create: PageAppCreateFieldInput
  delete: PageAppDeleteFieldInput
  disconnect: PageAppDisconnectFieldInput
  update: PageAppUpdateConnectionInput
  where: PageAppConnectionWhere
}

input PageConnectInput {
  app: PageAppConnectFieldInput
  rootElement: PageRootElementConnectFieldInput
}

input PageConnectOrCreateInput {
  app: PageAppConnectOrCreateFieldInput
  rootElement: PageRootElementConnectOrCreateFieldInput
}

input PageConnectOrCreateWhere {
  node: PageUniqueWhere!
}

input PageConnectWhere {
  node: PageWhere!
}

input PageCreateInput {
  app: PageAppFieldInput
  name: String!
  rootElement: PageRootElementFieldInput
}

input PageDeleteInput {
  app: PageAppDeleteFieldInput
  rootElement: PageRootElementDeleteFieldInput
}

input PageDisconnectInput {
  app: PageAppDisconnectFieldInput
  rootElement: PageRootElementDisconnectFieldInput
}

type PageElementRootElementAggregationSelection {
  count: Int!
  node: PageElementRootElementNodeAggregateSelection
}

type PageElementRootElementNodeAggregateSelection {
  css: StringAggregateSelection!
  id: IDAggregateSelection!
  name: StringAggregateSelection!
  propTransformationJs: StringAggregateSelection!
  renderForEachPropKey: StringAggregateSelection!
  renderIfPropKey: StringAggregateSelection!
}

"""
Pagination information (Relay)
"""
type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

input PageOptions {
  limit: Int
  offset: Int

  """
  Specify one or more PageSort objects to sort Pages by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [PageSort]
}

input PageRelationInput {
  app: PageAppCreateFieldInput
  rootElement: PageRootElementCreateFieldInput
}

input PageRootElementAggregateInput {
  AND: [PageRootElementAggregateInput!]
  OR: [PageRootElementAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: PageRootElementNodeAggregationWhereInput
}

input PageRootElementConnectFieldInput {
  connect: ElementConnectInput
  where: ElementConnectWhere
}

input PageRootElementConnectOrCreateFieldInput {
  onCreate: PageRootElementConnectOrCreateFieldInputOnCreate!
  where: ElementConnectOrCreateWhere!
}

input PageRootElementConnectOrCreateFieldInputOnCreate {
  node: ElementCreateInput!
}

type PageRootElementConnection {
  edges: [PageRootElementRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input PageRootElementConnectionSort {
  node: ElementSort
}

input PageRootElementConnectionWhere {
  AND: [PageRootElementConnectionWhere!]
  OR: [PageRootElementConnectionWhere!]
  node: ElementWhere
  node_NOT: ElementWhere
}

input PageRootElementCreateFieldInput {
  node: ElementCreateInput!
}

input PageRootElementDeleteFieldInput {
  delete: ElementDeleteInput
  where: PageRootElementConnectionWhere
}

input PageRootElementDisconnectFieldInput {
  disconnect: ElementDisconnectInput
  where: PageRootElementConnectionWhere
}

input PageRootElementFieldInput {
  connect: PageRootElementConnectFieldInput
  connectOrCreate: PageRootElementConnectOrCreateFieldInput
  create: PageRootElementCreateFieldInput
}

input PageRootElementNodeAggregationWhereInput {
  AND: [PageRootElementNodeAggregationWhereInput!]
  OR: [PageRootElementNodeAggregationWhereInput!]
  css_AVERAGE_EQUAL: Float
  css_AVERAGE_GT: Float
  css_AVERAGE_GTE: Float
  css_AVERAGE_LT: Float
  css_AVERAGE_LTE: Float
  css_EQUAL: String
  css_GT: Int
  css_GTE: Int
  css_LONGEST_EQUAL: Int
  css_LONGEST_GT: Int
  css_LONGEST_GTE: Int
  css_LONGEST_LT: Int
  css_LONGEST_LTE: Int
  css_LT: Int
  css_LTE: Int
  css_SHORTEST_EQUAL: Int
  css_SHORTEST_GT: Int
  css_SHORTEST_GTE: Int
  css_SHORTEST_LT: Int
  css_SHORTEST_LTE: Int
  id_EQUAL: ID
  name_AVERAGE_EQUAL: Float
  name_AVERAGE_GT: Float
  name_AVERAGE_GTE: Float
  name_AVERAGE_LT: Float
  name_AVERAGE_LTE: Float
  name_EQUAL: String
  name_GT: Int
  name_GTE: Int
  name_LONGEST_EQUAL: Int
  name_LONGEST_GT: Int
  name_LONGEST_GTE: Int
  name_LONGEST_LT: Int
  name_LONGEST_LTE: Int
  name_LT: Int
  name_LTE: Int
  name_SHORTEST_EQUAL: Int
  name_SHORTEST_GT: Int
  name_SHORTEST_GTE: Int
  name_SHORTEST_LT: Int
  name_SHORTEST_LTE: Int
  propTransformationJs_AVERAGE_EQUAL: Float
  propTransformationJs_AVERAGE_GT: Float
  propTransformationJs_AVERAGE_GTE: Float
  propTransformationJs_AVERAGE_LT: Float
  propTransformationJs_AVERAGE_LTE: Float
  propTransformationJs_EQUAL: String
  propTransformationJs_GT: Int
  propTransformationJs_GTE: Int
  propTransformationJs_LONGEST_EQUAL: Int
  propTransformationJs_LONGEST_GT: Int
  propTransformationJs_LONGEST_GTE: Int
  propTransformationJs_LONGEST_LT: Int
  propTransformationJs_LONGEST_LTE: Int
  propTransformationJs_LT: Int
  propTransformationJs_LTE: Int
  propTransformationJs_SHORTEST_EQUAL: Int
  propTransformationJs_SHORTEST_GT: Int
  propTransformationJs_SHORTEST_GTE: Int
  propTransformationJs_SHORTEST_LT: Int
  propTransformationJs_SHORTEST_LTE: Int
  renderForEachPropKey_AVERAGE_EQUAL: Float
  renderForEachPropKey_AVERAGE_GT: Float
  renderForEachPropKey_AVERAGE_GTE: Float
  renderForEachPropKey_AVERAGE_LT: Float
  renderForEachPropKey_AVERAGE_LTE: Float
  renderForEachPropKey_EQUAL: String
  renderForEachPropKey_GT: Int
  renderForEachPropKey_GTE: Int
  renderForEachPropKey_LONGEST_EQUAL: Int
  renderForEachPropKey_LONGEST_GT: Int
  renderForEachPropKey_LONGEST_GTE: Int
  renderForEachPropKey_LONGEST_LT: Int
  renderForEachPropKey_LONGEST_LTE: Int
  renderForEachPropKey_LT: Int
  renderForEachPropKey_LTE: Int
  renderForEachPropKey_SHORTEST_EQUAL: Int
  renderForEachPropKey_SHORTEST_GT: Int
  renderForEachPropKey_SHORTEST_GTE: Int
  renderForEachPropKey_SHORTEST_LT: Int
  renderForEachPropKey_SHORTEST_LTE: Int
  renderIfPropKey_AVERAGE_EQUAL: Float
  renderIfPropKey_AVERAGE_GT: Float
  renderIfPropKey_AVERAGE_GTE: Float
  renderIfPropKey_AVERAGE_LT: Float
  renderIfPropKey_AVERAGE_LTE: Float
  renderIfPropKey_EQUAL: String
  renderIfPropKey_GT: Int
  renderIfPropKey_GTE: Int
  renderIfPropKey_LONGEST_EQUAL: Int
  renderIfPropKey_LONGEST_GT: Int
  renderIfPropKey_LONGEST_GTE: Int
  renderIfPropKey_LONGEST_LT: Int
  renderIfPropKey_LONGEST_LTE: Int
  renderIfPropKey_LT: Int
  renderIfPropKey_LTE: Int
  renderIfPropKey_SHORTEST_EQUAL: Int
  renderIfPropKey_SHORTEST_GT: Int
  renderIfPropKey_SHORTEST_GTE: Int
  renderIfPropKey_SHORTEST_LT: Int
  renderIfPropKey_SHORTEST_LTE: Int
}

type PageRootElementRelationship {
  cursor: String!
  node: Element!
}

input PageRootElementUpdateConnectionInput {
  node: ElementUpdateInput
}

input PageRootElementUpdateFieldInput {
  connect: PageRootElementConnectFieldInput
  connectOrCreate: PageRootElementConnectOrCreateFieldInput
  create: PageRootElementCreateFieldInput
  delete: PageRootElementDeleteFieldInput
  disconnect: PageRootElementDisconnectFieldInput
  update: PageRootElementUpdateConnectionInput
  where: PageRootElementConnectionWhere
}

"""
Fields to sort Pages by. The order in which sorts are applied is not guaranteed when specifying many fields in one PageSort object.
"""
input PageSort {
  id: SortDirection
  name: SortDirection
}

"""
Allows picking a page from the list of pages
"""
type PageType implements TypeBase {
  graph: TypeGraph!
  id: ID!
  name: String!
  owner(options: UserOptions, where: UserWhere): User
  ownerAggregate(where: UserWhere): PageTypeUserOwnerAggregationSelection
  ownerConnection(
    after: String
    first: Int
    sort: [TypeBaseOwnerConnectionSort!]
    where: TypeBaseOwnerConnectionWhere
  ): TypeBaseOwnerConnection!
}

type PageTypeAggregateSelection {
  count: Int!
  id: IDAggregateSelection!
  name: StringAggregateSelection!
}

input PageTypeConnectInput {
  owner: TypeBaseOwnerConnectFieldInput
}

input PageTypeConnectOrCreateInput {
  owner: TypeBaseOwnerConnectOrCreateFieldInput
}

input PageTypeCreateInput {
  name: String!
  owner: TypeBaseOwnerFieldInput
}

input PageTypeDeleteInput {
  owner: TypeBaseOwnerDeleteFieldInput
}

input PageTypeDisconnectInput {
  owner: TypeBaseOwnerDisconnectFieldInput
}

input PageTypeOptions {
  limit: Int
  offset: Int

  """
  Specify one or more PageTypeSort objects to sort PageTypes by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [PageTypeSort]
}

input PageTypeOwnerAggregateInput {
  AND: [PageTypeOwnerAggregateInput!]
  OR: [PageTypeOwnerAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: PageTypeOwnerNodeAggregationWhereInput
}

input PageTypeOwnerNodeAggregationWhereInput {
  AND: [PageTypeOwnerNodeAggregationWhereInput!]
  OR: [PageTypeOwnerNodeAggregationWhereInput!]
  auth0Id_AVERAGE_EQUAL: Float
  auth0Id_AVERAGE_GT: Float
  auth0Id_AVERAGE_GTE: Float
  auth0Id_AVERAGE_LT: Float
  auth0Id_AVERAGE_LTE: Float
  auth0Id_EQUAL: String
  auth0Id_GT: Int
  auth0Id_GTE: Int
  auth0Id_LONGEST_EQUAL: Int
  auth0Id_LONGEST_GT: Int
  auth0Id_LONGEST_GTE: Int
  auth0Id_LONGEST_LT: Int
  auth0Id_LONGEST_LTE: Int
  auth0Id_LT: Int
  auth0Id_LTE: Int
  auth0Id_SHORTEST_EQUAL: Int
  auth0Id_SHORTEST_GT: Int
  auth0Id_SHORTEST_GTE: Int
  auth0Id_SHORTEST_LT: Int
  auth0Id_SHORTEST_LTE: Int
  email_AVERAGE_EQUAL: Float
  email_AVERAGE_GT: Float
  email_AVERAGE_GTE: Float
  email_AVERAGE_LT: Float
  email_AVERAGE_LTE: Float
  email_EQUAL: String
  email_GT: Int
  email_GTE: Int
  email_LONGEST_EQUAL: Int
  email_LONGEST_GT: Int
  email_LONGEST_GTE: Int
  email_LONGEST_LT: Int
  email_LONGEST_LTE: Int
  email_LT: Int
  email_LTE: Int
  email_SHORTEST_EQUAL: Int
  email_SHORTEST_GT: Int
  email_SHORTEST_GTE: Int
  email_SHORTEST_LT: Int
  email_SHORTEST_LTE: Int
  id_EQUAL: ID
}

input PageTypeRelationInput {
  owner: TypeBaseOwnerCreateFieldInput
}

"""
Fields to sort PageTypes by. The order in which sorts are applied is not guaranteed when specifying many fields in one PageTypeSort object.
"""
input PageTypeSort {
  id: SortDirection
  name: SortDirection
}

input PageTypeUpdateInput {
  name: String
  owner: TypeBaseOwnerUpdateFieldInput
}

type PageTypeUserOwnerAggregationSelection {
  count: Int!
  node: PageTypeUserOwnerNodeAggregateSelection
}

type PageTypeUserOwnerNodeAggregateSelection {
  auth0Id: StringAggregateSelection!
  email: StringAggregateSelection!
  id: IDAggregateSelection!
}

input PageTypeWhere {
  AND: [PageTypeWhere!]
  OR: [PageTypeWhere!]
  id: ID
  id_CONTAINS: ID
  id_ENDS_WITH: ID
  id_IN: [ID]
  id_NOT: ID
  id_NOT_CONTAINS: ID
  id_NOT_ENDS_WITH: ID
  id_NOT_IN: [ID]
  id_NOT_STARTS_WITH: ID
  id_STARTS_WITH: ID
  name: String
  name_CONTAINS: String
  name_ENDS_WITH: String
  name_IN: [String]
  name_NOT: String
  name_NOT_CONTAINS: String
  name_NOT_ENDS_WITH: String
  name_NOT_IN: [String]
  name_NOT_STARTS_WITH: String
  name_STARTS_WITH: String
  owner: UserWhere
  ownerAggregate: PageTypeOwnerAggregateInput
  ownerConnection: TypeBaseOwnerConnectionWhere
  ownerConnection_NOT: TypeBaseOwnerConnectionWhere
  owner_NOT: UserWhere
}

input PageUniqueWhere {
  id: ID
}

input PageUpdateInput {
  app: PageAppUpdateFieldInput
  name: String
  rootElement: PageRootElementUpdateFieldInput
}

input PageWhere {
  AND: [PageWhere!]
  OR: [PageWhere!]
  app: AppWhere
  appAggregate: PageAppAggregateInput
  appConnection: PageAppConnectionWhere
  appConnection_NOT: PageAppConnectionWhere
  app_NOT: AppWhere
  id: ID
  id_CONTAINS: ID
  id_ENDS_WITH: ID
  id_IN: [ID]
  id_NOT: ID
  id_NOT_CONTAINS: ID
  id_NOT_ENDS_WITH: ID
  id_NOT_IN: [ID]
  id_NOT_STARTS_WITH: ID
  id_STARTS_WITH: ID
  name: String
  name_CONTAINS: String
  name_ENDS_WITH: String
  name_IN: [String]
  name_NOT: String
  name_NOT_CONTAINS: String
  name_NOT_ENDS_WITH: String
  name_NOT_IN: [String]
  name_NOT_STARTS_WITH: String
  name_STARTS_WITH: String
  rootElement: ElementWhere
  rootElementAggregate: PageRootElementAggregateInput
  rootElementConnection: PageRootElementConnectionWhere
  rootElementConnection_NOT: PageRootElementConnectionWhere
  rootElement_NOT: ElementWhere
}

interface ParentOfElement {
  order: Int
}

input ParentOfElementCreateInput {
  order: Int
}

input ParentOfElementSort {
  order: SortDirection
}

input ParentOfElementUpdateInput {
  order: Int
}

input ParentOfElementWhere {
  AND: [ParentOfElementWhere!]
  OR: [ParentOfElementWhere!]
  order: Int
  order_GT: Int
  order_GTE: Int
  order_IN: [Int]
  order_LT: Int
  order_LTE: Int
  order_NOT: Int
  order_NOT_IN: [Int]
}

"""
Base atomic building block of the type system. Represents primitive types - String, Integer, Float, Boolean
"""
type PrimitiveType implements TypeBase {
  graph: TypeGraph!
  id: ID!
  name: String!
  owner(options: UserOptions, where: UserWhere): User
  ownerAggregate(where: UserWhere): PrimitiveTypeUserOwnerAggregationSelection
  ownerConnection(
    after: String
    first: Int
    sort: [TypeBaseOwnerConnectionSort!]
    where: TypeBaseOwnerConnectionWhere
  ): TypeBaseOwnerConnection!
  primitiveKind: PrimitiveTypeKind!
}

type PrimitiveTypeAggregateSelection {
  count: Int!
  id: IDAggregateSelection!
  name: StringAggregateSelection!
}

input PrimitiveTypeConnectInput {
  owner: TypeBaseOwnerConnectFieldInput
}

input PrimitiveTypeConnectOrCreateInput {
  owner: TypeBaseOwnerConnectOrCreateFieldInput
}

input PrimitiveTypeCreateInput {
  name: String!
  owner: TypeBaseOwnerFieldInput
  primitiveKind: PrimitiveTypeKind!
}

input PrimitiveTypeDeleteInput {
  owner: TypeBaseOwnerDeleteFieldInput
}

input PrimitiveTypeDisconnectInput {
  owner: TypeBaseOwnerDisconnectFieldInput
}

enum PrimitiveTypeKind {
  Boolean
  Float
  Integer
  String
}

input PrimitiveTypeOptions {
  limit: Int
  offset: Int

  """
  Specify one or more PrimitiveTypeSort objects to sort PrimitiveTypes by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [PrimitiveTypeSort]
}

input PrimitiveTypeOwnerAggregateInput {
  AND: [PrimitiveTypeOwnerAggregateInput!]
  OR: [PrimitiveTypeOwnerAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: PrimitiveTypeOwnerNodeAggregationWhereInput
}

input PrimitiveTypeOwnerNodeAggregationWhereInput {
  AND: [PrimitiveTypeOwnerNodeAggregationWhereInput!]
  OR: [PrimitiveTypeOwnerNodeAggregationWhereInput!]
  auth0Id_AVERAGE_EQUAL: Float
  auth0Id_AVERAGE_GT: Float
  auth0Id_AVERAGE_GTE: Float
  auth0Id_AVERAGE_LT: Float
  auth0Id_AVERAGE_LTE: Float
  auth0Id_EQUAL: String
  auth0Id_GT: Int
  auth0Id_GTE: Int
  auth0Id_LONGEST_EQUAL: Int
  auth0Id_LONGEST_GT: Int
  auth0Id_LONGEST_GTE: Int
  auth0Id_LONGEST_LT: Int
  auth0Id_LONGEST_LTE: Int
  auth0Id_LT: Int
  auth0Id_LTE: Int
  auth0Id_SHORTEST_EQUAL: Int
  auth0Id_SHORTEST_GT: Int
  auth0Id_SHORTEST_GTE: Int
  auth0Id_SHORTEST_LT: Int
  auth0Id_SHORTEST_LTE: Int
  email_AVERAGE_EQUAL: Float
  email_AVERAGE_GT: Float
  email_AVERAGE_GTE: Float
  email_AVERAGE_LT: Float
  email_AVERAGE_LTE: Float
  email_EQUAL: String
  email_GT: Int
  email_GTE: Int
  email_LONGEST_EQUAL: Int
  email_LONGEST_GT: Int
  email_LONGEST_GTE: Int
  email_LONGEST_LT: Int
  email_LONGEST_LTE: Int
  email_LT: Int
  email_LTE: Int
  email_SHORTEST_EQUAL: Int
  email_SHORTEST_GT: Int
  email_SHORTEST_GTE: Int
  email_SHORTEST_LT: Int
  email_SHORTEST_LTE: Int
  id_EQUAL: ID
}

input PrimitiveTypeRelationInput {
  owner: TypeBaseOwnerCreateFieldInput
}

"""
Fields to sort PrimitiveTypes by. The order in which sorts are applied is not guaranteed when specifying many fields in one PrimitiveTypeSort object.
"""
input PrimitiveTypeSort {
  id: SortDirection
  name: SortDirection
  primitiveKind: SortDirection
}

input PrimitiveTypeUpdateInput {
  name: String
  owner: TypeBaseOwnerUpdateFieldInput
  primitiveKind: PrimitiveTypeKind
}

type PrimitiveTypeUserOwnerAggregationSelection {
  count: Int!
  node: PrimitiveTypeUserOwnerNodeAggregateSelection
}

type PrimitiveTypeUserOwnerNodeAggregateSelection {
  auth0Id: StringAggregateSelection!
  email: StringAggregateSelection!
  id: IDAggregateSelection!
}

input PrimitiveTypeWhere {
  AND: [PrimitiveTypeWhere!]
  OR: [PrimitiveTypeWhere!]
  id: ID
  id_CONTAINS: ID
  id_ENDS_WITH: ID
  id_IN: [ID]
  id_NOT: ID
  id_NOT_CONTAINS: ID
  id_NOT_ENDS_WITH: ID
  id_NOT_IN: [ID]
  id_NOT_STARTS_WITH: ID
  id_STARTS_WITH: ID
  name: String
  name_CONTAINS: String
  name_ENDS_WITH: String
  name_IN: [String]
  name_NOT: String
  name_NOT_CONTAINS: String
  name_NOT_ENDS_WITH: String
  name_NOT_IN: [String]
  name_NOT_STARTS_WITH: String
  name_STARTS_WITH: String
  owner: UserWhere
  ownerAggregate: PrimitiveTypeOwnerAggregateInput
  ownerConnection: TypeBaseOwnerConnectionWhere
  ownerConnection_NOT: TypeBaseOwnerConnectionWhere
  owner_NOT: UserWhere
  primitiveKind: PrimitiveTypeKind
  primitiveKind_IN: [PrimitiveTypeKind]
  primitiveKind_NOT: PrimitiveTypeKind
  primitiveKind_NOT_IN: [PrimitiveTypeKind]
}

type Prop {
  data: String!
  id: ID!
}

type PropAggregateSelection {
  count: Int!
  data: StringAggregateSelection!
  id: IDAggregateSelection!
}

input PropConnectOrCreateWhere {
  node: PropUniqueWhere!
}

input PropConnectWhere {
  node: PropWhere!
}

input PropCreateInput {
  data: String! = "{}"
}

type PropMapBinding {
  element(options: ElementOptions, where: ElementWhere): Element!
  elementAggregate(
    where: ElementWhere
  ): PropMapBindingElementElementAggregationSelection
  elementConnection(
    after: String
    first: Int
    sort: [PropMapBindingElementConnectionSort!]
    where: PropMapBindingElementConnectionWhere
  ): PropMapBindingElementConnection!
  id: ID!
  sourceKey: String!
  targetElement(options: ElementOptions, where: ElementWhere): Element
  targetElementAggregate(
    where: ElementWhere
  ): PropMapBindingElementTargetElementAggregationSelection
  targetElementConnection(
    after: String
    first: Int
    sort: [PropMapBindingTargetElementConnectionSort!]
    where: PropMapBindingTargetElementConnectionWhere
  ): PropMapBindingTargetElementConnection!
  targetKey: String!
}

type PropMapBindingAggregateSelection {
  count: Int!
  id: IDAggregateSelection!
  sourceKey: StringAggregateSelection!
  targetKey: StringAggregateSelection!
}

input PropMapBindingConnectInput {
  element: PropMapBindingElementConnectFieldInput
  targetElement: PropMapBindingTargetElementConnectFieldInput
}

input PropMapBindingConnectOrCreateInput {
  element: PropMapBindingElementConnectOrCreateFieldInput
  targetElement: PropMapBindingTargetElementConnectOrCreateFieldInput
}

input PropMapBindingConnectOrCreateWhere {
  node: PropMapBindingUniqueWhere!
}

input PropMapBindingConnectWhere {
  node: PropMapBindingWhere!
}

input PropMapBindingCreateInput {
  element: PropMapBindingElementFieldInput
  sourceKey: String!
  targetElement: PropMapBindingTargetElementFieldInput
  targetKey: String!
}

input PropMapBindingDeleteInput {
  element: PropMapBindingElementDeleteFieldInput
  targetElement: PropMapBindingTargetElementDeleteFieldInput
}

input PropMapBindingDisconnectInput {
  element: PropMapBindingElementDisconnectFieldInput
  targetElement: PropMapBindingTargetElementDisconnectFieldInput
}

input PropMapBindingElementAggregateInput {
  AND: [PropMapBindingElementAggregateInput!]
  OR: [PropMapBindingElementAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: PropMapBindingElementNodeAggregationWhereInput
}

input PropMapBindingElementConnectFieldInput {
  connect: ElementConnectInput
  where: ElementConnectWhere
}

input PropMapBindingElementConnectOrCreateFieldInput {
  onCreate: PropMapBindingElementConnectOrCreateFieldInputOnCreate!
  where: ElementConnectOrCreateWhere!
}

input PropMapBindingElementConnectOrCreateFieldInputOnCreate {
  node: ElementCreateInput!
}

type PropMapBindingElementConnection {
  edges: [PropMapBindingElementRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input PropMapBindingElementConnectionSort {
  node: ElementSort
}

input PropMapBindingElementConnectionWhere {
  AND: [PropMapBindingElementConnectionWhere!]
  OR: [PropMapBindingElementConnectionWhere!]
  node: ElementWhere
  node_NOT: ElementWhere
}

input PropMapBindingElementCreateFieldInput {
  node: ElementCreateInput!
}

input PropMapBindingElementDeleteFieldInput {
  delete: ElementDeleteInput
  where: PropMapBindingElementConnectionWhere
}

input PropMapBindingElementDisconnectFieldInput {
  disconnect: ElementDisconnectInput
  where: PropMapBindingElementConnectionWhere
}

type PropMapBindingElementElementAggregationSelection {
  count: Int!
  node: PropMapBindingElementElementNodeAggregateSelection
}

type PropMapBindingElementElementNodeAggregateSelection {
  css: StringAggregateSelection!
  id: IDAggregateSelection!
  name: StringAggregateSelection!
  propTransformationJs: StringAggregateSelection!
  renderForEachPropKey: StringAggregateSelection!
  renderIfPropKey: StringAggregateSelection!
}

input PropMapBindingElementFieldInput {
  connect: PropMapBindingElementConnectFieldInput
  connectOrCreate: PropMapBindingElementConnectOrCreateFieldInput
  create: PropMapBindingElementCreateFieldInput
}

input PropMapBindingElementNodeAggregationWhereInput {
  AND: [PropMapBindingElementNodeAggregationWhereInput!]
  OR: [PropMapBindingElementNodeAggregationWhereInput!]
  css_AVERAGE_EQUAL: Float
  css_AVERAGE_GT: Float
  css_AVERAGE_GTE: Float
  css_AVERAGE_LT: Float
  css_AVERAGE_LTE: Float
  css_EQUAL: String
  css_GT: Int
  css_GTE: Int
  css_LONGEST_EQUAL: Int
  css_LONGEST_GT: Int
  css_LONGEST_GTE: Int
  css_LONGEST_LT: Int
  css_LONGEST_LTE: Int
  css_LT: Int
  css_LTE: Int
  css_SHORTEST_EQUAL: Int
  css_SHORTEST_GT: Int
  css_SHORTEST_GTE: Int
  css_SHORTEST_LT: Int
  css_SHORTEST_LTE: Int
  id_EQUAL: ID
  name_AVERAGE_EQUAL: Float
  name_AVERAGE_GT: Float
  name_AVERAGE_GTE: Float
  name_AVERAGE_LT: Float
  name_AVERAGE_LTE: Float
  name_EQUAL: String
  name_GT: Int
  name_GTE: Int
  name_LONGEST_EQUAL: Int
  name_LONGEST_GT: Int
  name_LONGEST_GTE: Int
  name_LONGEST_LT: Int
  name_LONGEST_LTE: Int
  name_LT: Int
  name_LTE: Int
  name_SHORTEST_EQUAL: Int
  name_SHORTEST_GT: Int
  name_SHORTEST_GTE: Int
  name_SHORTEST_LT: Int
  name_SHORTEST_LTE: Int
  propTransformationJs_AVERAGE_EQUAL: Float
  propTransformationJs_AVERAGE_GT: Float
  propTransformationJs_AVERAGE_GTE: Float
  propTransformationJs_AVERAGE_LT: Float
  propTransformationJs_AVERAGE_LTE: Float
  propTransformationJs_EQUAL: String
  propTransformationJs_GT: Int
  propTransformationJs_GTE: Int
  propTransformationJs_LONGEST_EQUAL: Int
  propTransformationJs_LONGEST_GT: Int
  propTransformationJs_LONGEST_GTE: Int
  propTransformationJs_LONGEST_LT: Int
  propTransformationJs_LONGEST_LTE: Int
  propTransformationJs_LT: Int
  propTransformationJs_LTE: Int
  propTransformationJs_SHORTEST_EQUAL: Int
  propTransformationJs_SHORTEST_GT: Int
  propTransformationJs_SHORTEST_GTE: Int
  propTransformationJs_SHORTEST_LT: Int
  propTransformationJs_SHORTEST_LTE: Int
  renderForEachPropKey_AVERAGE_EQUAL: Float
  renderForEachPropKey_AVERAGE_GT: Float
  renderForEachPropKey_AVERAGE_GTE: Float
  renderForEachPropKey_AVERAGE_LT: Float
  renderForEachPropKey_AVERAGE_LTE: Float
  renderForEachPropKey_EQUAL: String
  renderForEachPropKey_GT: Int
  renderForEachPropKey_GTE: Int
  renderForEachPropKey_LONGEST_EQUAL: Int
  renderForEachPropKey_LONGEST_GT: Int
  renderForEachPropKey_LONGEST_GTE: Int
  renderForEachPropKey_LONGEST_LT: Int
  renderForEachPropKey_LONGEST_LTE: Int
  renderForEachPropKey_LT: Int
  renderForEachPropKey_LTE: Int
  renderForEachPropKey_SHORTEST_EQUAL: Int
  renderForEachPropKey_SHORTEST_GT: Int
  renderForEachPropKey_SHORTEST_GTE: Int
  renderForEachPropKey_SHORTEST_LT: Int
  renderForEachPropKey_SHORTEST_LTE: Int
  renderIfPropKey_AVERAGE_EQUAL: Float
  renderIfPropKey_AVERAGE_GT: Float
  renderIfPropKey_AVERAGE_GTE: Float
  renderIfPropKey_AVERAGE_LT: Float
  renderIfPropKey_AVERAGE_LTE: Float
  renderIfPropKey_EQUAL: String
  renderIfPropKey_GT: Int
  renderIfPropKey_GTE: Int
  renderIfPropKey_LONGEST_EQUAL: Int
  renderIfPropKey_LONGEST_GT: Int
  renderIfPropKey_LONGEST_GTE: Int
  renderIfPropKey_LONGEST_LT: Int
  renderIfPropKey_LONGEST_LTE: Int
  renderIfPropKey_LT: Int
  renderIfPropKey_LTE: Int
  renderIfPropKey_SHORTEST_EQUAL: Int
  renderIfPropKey_SHORTEST_GT: Int
  renderIfPropKey_SHORTEST_GTE: Int
  renderIfPropKey_SHORTEST_LT: Int
  renderIfPropKey_SHORTEST_LTE: Int
}

type PropMapBindingElementRelationship {
  cursor: String!
  node: Element!
}

type PropMapBindingElementTargetElementAggregationSelection {
  count: Int!
  node: PropMapBindingElementTargetElementNodeAggregateSelection
}

type PropMapBindingElementTargetElementNodeAggregateSelection {
  css: StringAggregateSelection!
  id: IDAggregateSelection!
  name: StringAggregateSelection!
  propTransformationJs: StringAggregateSelection!
  renderForEachPropKey: StringAggregateSelection!
  renderIfPropKey: StringAggregateSelection!
}

input PropMapBindingElementUpdateConnectionInput {
  node: ElementUpdateInput
}

input PropMapBindingElementUpdateFieldInput {
  connect: PropMapBindingElementConnectFieldInput
  connectOrCreate: PropMapBindingElementConnectOrCreateFieldInput
  create: PropMapBindingElementCreateFieldInput
  delete: PropMapBindingElementDeleteFieldInput
  disconnect: PropMapBindingElementDisconnectFieldInput
  update: PropMapBindingElementUpdateConnectionInput
  where: PropMapBindingElementConnectionWhere
}

input PropMapBindingOptions {
  limit: Int
  offset: Int

  """
  Specify one or more PropMapBindingSort objects to sort PropMapBindings by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [PropMapBindingSort]
}

input PropMapBindingRelationInput {
  element: PropMapBindingElementCreateFieldInput
  targetElement: PropMapBindingTargetElementCreateFieldInput
}

"""
Fields to sort PropMapBindings by. The order in which sorts are applied is not guaranteed when specifying many fields in one PropMapBindingSort object.
"""
input PropMapBindingSort {
  id: SortDirection
  sourceKey: SortDirection
  targetKey: SortDirection
}

input PropMapBindingTargetElementAggregateInput {
  AND: [PropMapBindingTargetElementAggregateInput!]
  OR: [PropMapBindingTargetElementAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: PropMapBindingTargetElementNodeAggregationWhereInput
}

input PropMapBindingTargetElementConnectFieldInput {
  connect: ElementConnectInput
  where: ElementConnectWhere
}

input PropMapBindingTargetElementConnectOrCreateFieldInput {
  onCreate: PropMapBindingTargetElementConnectOrCreateFieldInputOnCreate!
  where: ElementConnectOrCreateWhere!
}

input PropMapBindingTargetElementConnectOrCreateFieldInputOnCreate {
  node: ElementCreateInput!
}

type PropMapBindingTargetElementConnection {
  edges: [PropMapBindingTargetElementRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input PropMapBindingTargetElementConnectionSort {
  node: ElementSort
}

input PropMapBindingTargetElementConnectionWhere {
  AND: [PropMapBindingTargetElementConnectionWhere!]
  OR: [PropMapBindingTargetElementConnectionWhere!]
  node: ElementWhere
  node_NOT: ElementWhere
}

input PropMapBindingTargetElementCreateFieldInput {
  node: ElementCreateInput!
}

input PropMapBindingTargetElementDeleteFieldInput {
  delete: ElementDeleteInput
  where: PropMapBindingTargetElementConnectionWhere
}

input PropMapBindingTargetElementDisconnectFieldInput {
  disconnect: ElementDisconnectInput
  where: PropMapBindingTargetElementConnectionWhere
}

input PropMapBindingTargetElementFieldInput {
  connect: PropMapBindingTargetElementConnectFieldInput
  connectOrCreate: PropMapBindingTargetElementConnectOrCreateFieldInput
  create: PropMapBindingTargetElementCreateFieldInput
}

input PropMapBindingTargetElementNodeAggregationWhereInput {
  AND: [PropMapBindingTargetElementNodeAggregationWhereInput!]
  OR: [PropMapBindingTargetElementNodeAggregationWhereInput!]
  css_AVERAGE_EQUAL: Float
  css_AVERAGE_GT: Float
  css_AVERAGE_GTE: Float
  css_AVERAGE_LT: Float
  css_AVERAGE_LTE: Float
  css_EQUAL: String
  css_GT: Int
  css_GTE: Int
  css_LONGEST_EQUAL: Int
  css_LONGEST_GT: Int
  css_LONGEST_GTE: Int
  css_LONGEST_LT: Int
  css_LONGEST_LTE: Int
  css_LT: Int
  css_LTE: Int
  css_SHORTEST_EQUAL: Int
  css_SHORTEST_GT: Int
  css_SHORTEST_GTE: Int
  css_SHORTEST_LT: Int
  css_SHORTEST_LTE: Int
  id_EQUAL: ID
  name_AVERAGE_EQUAL: Float
  name_AVERAGE_GT: Float
  name_AVERAGE_GTE: Float
  name_AVERAGE_LT: Float
  name_AVERAGE_LTE: Float
  name_EQUAL: String
  name_GT: Int
  name_GTE: Int
  name_LONGEST_EQUAL: Int
  name_LONGEST_GT: Int
  name_LONGEST_GTE: Int
  name_LONGEST_LT: Int
  name_LONGEST_LTE: Int
  name_LT: Int
  name_LTE: Int
  name_SHORTEST_EQUAL: Int
  name_SHORTEST_GT: Int
  name_SHORTEST_GTE: Int
  name_SHORTEST_LT: Int
  name_SHORTEST_LTE: Int
  propTransformationJs_AVERAGE_EQUAL: Float
  propTransformationJs_AVERAGE_GT: Float
  propTransformationJs_AVERAGE_GTE: Float
  propTransformationJs_AVERAGE_LT: Float
  propTransformationJs_AVERAGE_LTE: Float
  propTransformationJs_EQUAL: String
  propTransformationJs_GT: Int
  propTransformationJs_GTE: Int
  propTransformationJs_LONGEST_EQUAL: Int
  propTransformationJs_LONGEST_GT: Int
  propTransformationJs_LONGEST_GTE: Int
  propTransformationJs_LONGEST_LT: Int
  propTransformationJs_LONGEST_LTE: Int
  propTransformationJs_LT: Int
  propTransformationJs_LTE: Int
  propTransformationJs_SHORTEST_EQUAL: Int
  propTransformationJs_SHORTEST_GT: Int
  propTransformationJs_SHORTEST_GTE: Int
  propTransformationJs_SHORTEST_LT: Int
  propTransformationJs_SHORTEST_LTE: Int
  renderForEachPropKey_AVERAGE_EQUAL: Float
  renderForEachPropKey_AVERAGE_GT: Float
  renderForEachPropKey_AVERAGE_GTE: Float
  renderForEachPropKey_AVERAGE_LT: Float
  renderForEachPropKey_AVERAGE_LTE: Float
  renderForEachPropKey_EQUAL: String
  renderForEachPropKey_GT: Int
  renderForEachPropKey_GTE: Int
  renderForEachPropKey_LONGEST_EQUAL: Int
  renderForEachPropKey_LONGEST_GT: Int
  renderForEachPropKey_LONGEST_GTE: Int
  renderForEachPropKey_LONGEST_LT: Int
  renderForEachPropKey_LONGEST_LTE: Int
  renderForEachPropKey_LT: Int
  renderForEachPropKey_LTE: Int
  renderForEachPropKey_SHORTEST_EQUAL: Int
  renderForEachPropKey_SHORTEST_GT: Int
  renderForEachPropKey_SHORTEST_GTE: Int
  renderForEachPropKey_SHORTEST_LT: Int
  renderForEachPropKey_SHORTEST_LTE: Int
  renderIfPropKey_AVERAGE_EQUAL: Float
  renderIfPropKey_AVERAGE_GT: Float
  renderIfPropKey_AVERAGE_GTE: Float
  renderIfPropKey_AVERAGE_LT: Float
  renderIfPropKey_AVERAGE_LTE: Float
  renderIfPropKey_EQUAL: String
  renderIfPropKey_GT: Int
  renderIfPropKey_GTE: Int
  renderIfPropKey_LONGEST_EQUAL: Int
  renderIfPropKey_LONGEST_GT: Int
  renderIfPropKey_LONGEST_GTE: Int
  renderIfPropKey_LONGEST_LT: Int
  renderIfPropKey_LONGEST_LTE: Int
  renderIfPropKey_LT: Int
  renderIfPropKey_LTE: Int
  renderIfPropKey_SHORTEST_EQUAL: Int
  renderIfPropKey_SHORTEST_GT: Int
  renderIfPropKey_SHORTEST_GTE: Int
  renderIfPropKey_SHORTEST_LT: Int
  renderIfPropKey_SHORTEST_LTE: Int
}

type PropMapBindingTargetElementRelationship {
  cursor: String!
  node: Element!
}

input PropMapBindingTargetElementUpdateConnectionInput {
  node: ElementUpdateInput
}

input PropMapBindingTargetElementUpdateFieldInput {
  connect: PropMapBindingTargetElementConnectFieldInput
  connectOrCreate: PropMapBindingTargetElementConnectOrCreateFieldInput
  create: PropMapBindingTargetElementCreateFieldInput
  delete: PropMapBindingTargetElementDeleteFieldInput
  disconnect: PropMapBindingTargetElementDisconnectFieldInput
  update: PropMapBindingTargetElementUpdateConnectionInput
  where: PropMapBindingTargetElementConnectionWhere
}

input PropMapBindingUniqueWhere {
  id: ID
}

input PropMapBindingUpdateInput {
  element: PropMapBindingElementUpdateFieldInput
  sourceKey: String
  targetElement: PropMapBindingTargetElementUpdateFieldInput
  targetKey: String
}

input PropMapBindingWhere {
  AND: [PropMapBindingWhere!]
  OR: [PropMapBindingWhere!]
  element: ElementWhere
  elementAggregate: PropMapBindingElementAggregateInput
  elementConnection: PropMapBindingElementConnectionWhere
  elementConnection_NOT: PropMapBindingElementConnectionWhere
  element_NOT: ElementWhere
  id: ID
  id_CONTAINS: ID
  id_ENDS_WITH: ID
  id_IN: [ID]
  id_NOT: ID
  id_NOT_CONTAINS: ID
  id_NOT_ENDS_WITH: ID
  id_NOT_IN: [ID]
  id_NOT_STARTS_WITH: ID
  id_STARTS_WITH: ID
  sourceKey: String
  sourceKey_CONTAINS: String
  sourceKey_ENDS_WITH: String
  sourceKey_IN: [String]
  sourceKey_NOT: String
  sourceKey_NOT_CONTAINS: String
  sourceKey_NOT_ENDS_WITH: String
  sourceKey_NOT_IN: [String]
  sourceKey_NOT_STARTS_WITH: String
  sourceKey_STARTS_WITH: String
  targetElement: ElementWhere
  targetElementAggregate: PropMapBindingTargetElementAggregateInput
  targetElementConnection: PropMapBindingTargetElementConnectionWhere
  targetElementConnection_NOT: PropMapBindingTargetElementConnectionWhere
  targetElement_NOT: ElementWhere
  targetKey: String
  targetKey_CONTAINS: String
  targetKey_ENDS_WITH: String
  targetKey_IN: [String]
  targetKey_NOT: String
  targetKey_NOT_CONTAINS: String
  targetKey_NOT_ENDS_WITH: String
  targetKey_NOT_IN: [String]
  targetKey_NOT_STARTS_WITH: String
  targetKey_STARTS_WITH: String
}

input PropOptions {
  limit: Int
  offset: Int

  """
  Specify one or more PropSort objects to sort Props by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [PropSort]
}

"""
Fields to sort Props by. The order in which sorts are applied is not guaranteed when specifying many fields in one PropSort object.
"""
input PropSort {
  data: SortDirection
  id: SortDirection
}

input PropUniqueWhere {
  id: ID
}

input PropUpdateInput {
  data: String
}

input PropWhere {
  AND: [PropWhere!]
  OR: [PropWhere!]
  data: String
  data_CONTAINS: String
  data_ENDS_WITH: String
  data_IN: [String]
  data_NOT: String
  data_NOT_CONTAINS: String
  data_NOT_ENDS_WITH: String
  data_NOT_IN: [String]
  data_NOT_STARTS_WITH: String
  data_STARTS_WITH: String
  id: ID
  id_CONTAINS: ID
  id_ENDS_WITH: ID
  id_IN: [ID]
  id_NOT: ID
  id_NOT_CONTAINS: ID
  id_NOT_ENDS_WITH: ID
  id_NOT_IN: [ID]
  id_NOT_STARTS_WITH: ID
  id_STARTS_WITH: ID
}

type Query {
  appTypes(options: AppTypeOptions, where: AppTypeWhere): [AppType!]!
  appTypesAggregate(where: AppTypeWhere): AppTypeAggregateSelection!
  appTypesCount(where: AppTypeWhere): Int!
  apps(options: AppOptions, where: AppWhere): [App!]!
  appsAggregate(where: AppWhere): AppAggregateSelection!
  appsCount(where: AppWhere): Int!
  arrayTypes(options: ArrayTypeOptions, where: ArrayTypeWhere): [ArrayType!]!
  arrayTypesAggregate(where: ArrayTypeWhere): ArrayTypeAggregateSelection!
  arrayTypesCount(where: ArrayTypeWhere): Int!
  atoms(options: AtomOptions, where: AtomWhere): [Atom!]!
  atomsAggregate(where: AtomWhere): AtomAggregateSelection!
  atomsCount(where: AtomWhere): Int!
  createInfos(
    options: CreateInfoOptions
    where: CreateInfoWhere
  ): [CreateInfo!]!
  createInfosAggregate(where: CreateInfoWhere): CreateInfoAggregateSelection!
  createInfosCount(where: CreateInfoWhere): Int!
  deleteFieldResponses(
    options: DeleteFieldResponseOptions
    where: DeleteFieldResponseWhere
  ): [DeleteFieldResponse!]!
  deleteFieldResponsesAggregate(
    where: DeleteFieldResponseWhere
  ): DeleteFieldResponseAggregateSelection!
  deleteFieldResponsesCount(where: DeleteFieldResponseWhere): Int!
  edges(options: EdgeOptions, where: EdgeWhere): [Edge!]!
  edgesAggregate(where: EdgeWhere): EdgeAggregateSelection!
  edgesCount(where: EdgeWhere): Int!
  elementGraph(input: ElementGraphInput!): ElementGraph!
  elementTypes(
    options: ElementTypeOptions
    where: ElementTypeWhere
  ): [ElementType!]!
  elementTypesAggregate(where: ElementTypeWhere): ElementTypeAggregateSelection!
  elementTypesCount(where: ElementTypeWhere): Int!
  elements(options: ElementOptions, where: ElementWhere): [Element!]!
  elementsAggregate(where: ElementWhere): ElementAggregateSelection!
  elementsCount(where: ElementWhere): Int!
  enumTypeValues(
    options: EnumTypeValueOptions
    where: EnumTypeValueWhere
  ): [EnumTypeValue!]!
  enumTypeValuesAggregate(
    where: EnumTypeValueWhere
  ): EnumTypeValueAggregateSelection!
  enumTypeValuesCount(where: EnumTypeValueWhere): Int!
  enumTypes(options: EnumTypeOptions, where: EnumTypeWhere): [EnumType!]!
  enumTypesAggregate(where: EnumTypeWhere): EnumTypeAggregateSelection!
  enumTypesCount(where: EnumTypeWhere): Int!
  getField(interfaceId: ID!, key: String!): InterfaceTypeEdge!

  """
  Returns a list of all Type and Atom entities that reference the type with the given id
  This could be different types of relationships like Atom-Api, ArrayType-itemType, InterfaceType-field, UnionType-unionTypeChild
  """
  getTypeReferences(typeId: ID!): [TypeReference!]
  hooks(options: HookOptions, where: HookWhere): [Hook!]!
  hooksAggregate(where: HookWhere): HookAggregateSelection!
  hooksCount(where: HookWhere): Int!
  importAtomsMutationResponses(
    options: ImportAtomsMutationResponseOptions
    where: ImportAtomsMutationResponseWhere
  ): [ImportAtomsMutationResponse!]!
  importAtomsMutationResponsesAggregate(
    where: ImportAtomsMutationResponseWhere
  ): ImportAtomsMutationResponseAggregateSelection!
  importAtomsMutationResponsesCount(
    where: ImportAtomsMutationResponseWhere
  ): Int!
  interfaceTypes(
    options: InterfaceTypeOptions
    where: InterfaceTypeWhere
  ): [InterfaceType!]!
  interfaceTypesAggregate(
    where: InterfaceTypeWhere
  ): InterfaceTypeAggregateSelection!
  interfaceTypesCount(where: InterfaceTypeWhere): Int!

  """
  Does a recursive check to see if the parent type (parentTypeId) contains the descendant type (descendantTypeId) at any level of nesting. Useful for checking for recursion
  """
  isTypeDescendantOf(descendantTypeId: ID!, parentTypeId: ID!): Boolean
  lambdaTypes(
    options: LambdaTypeOptions
    where: LambdaTypeWhere
  ): [LambdaType!]!
  lambdaTypesAggregate(where: LambdaTypeWhere): LambdaTypeAggregateSelection!
  lambdaTypesCount(where: LambdaTypeWhere): Int!
  monacoTypes(
    options: MonacoTypeOptions
    where: MonacoTypeWhere
  ): [MonacoType!]!
  monacoTypesAggregate(where: MonacoTypeWhere): MonacoTypeAggregateSelection!
  monacoTypesCount(where: MonacoTypeWhere): Int!
  pageTypes(options: PageTypeOptions, where: PageTypeWhere): [PageType!]!
  pageTypesAggregate(where: PageTypeWhere): PageTypeAggregateSelection!
  pageTypesCount(where: PageTypeWhere): Int!
  pages(options: PageOptions, where: PageWhere): [Page!]!
  pagesAggregate(where: PageWhere): PageAggregateSelection!
  pagesCount(where: PageWhere): Int!
  primitiveTypes(
    options: PrimitiveTypeOptions
    where: PrimitiveTypeWhere
  ): [PrimitiveType!]!
  primitiveTypesAggregate(
    where: PrimitiveTypeWhere
  ): PrimitiveTypeAggregateSelection!
  primitiveTypesCount(where: PrimitiveTypeWhere): Int!
  propMapBindings(
    options: PropMapBindingOptions
    where: PropMapBindingWhere
  ): [PropMapBinding!]!
  propMapBindingsAggregate(
    where: PropMapBindingWhere
  ): PropMapBindingAggregateSelection!
  propMapBindingsCount(where: PropMapBindingWhere): Int!
  props(options: PropOptions, where: PropWhere): [Prop!]!
  propsAggregate(where: PropWhere): PropAggregateSelection!
  propsCount(where: PropWhere): Int!
  reactNodeTypes(
    options: ReactNodeTypeOptions
    where: ReactNodeTypeWhere
  ): [ReactNodeType!]!
  reactNodeTypesAggregate(
    where: ReactNodeTypeWhere
  ): ReactNodeTypeAggregateSelection!
  reactNodeTypesCount(where: ReactNodeTypeWhere): Int!
  renderPropsTypes(
    options: RenderPropsTypeOptions
    where: RenderPropsTypeWhere
  ): [RenderPropsType!]!
  renderPropsTypesAggregate(
    where: RenderPropsTypeWhere
  ): RenderPropsTypeAggregateSelection!
  renderPropsTypesCount(where: RenderPropsTypeWhere): Int!
  tagEdges(options: TagEdgeOptions, where: TagEdgeWhere): [TagEdge!]!
  tagEdgesAggregate(where: TagEdgeWhere): TagEdgeAggregateSelection!
  tagEdgesCount(where: TagEdgeWhere): Int!
  tagGraphs: TagGraph
  tags(options: TagOptions, where: TagWhere): [Tag!]!
  tagsAggregate(where: TagWhere): TagAggregateSelection!
  tagsCount(where: TagWhere): Int!
  typeReferences(
    options: TypeReferenceOptions
    where: TypeReferenceWhere
  ): [TypeReference!]!
  typeReferencesAggregate(
    where: TypeReferenceWhere
  ): TypeReferenceAggregateSelection!
  typeReferencesCount(where: TypeReferenceWhere): Int!
  unionTypes(options: UnionTypeOptions, where: UnionTypeWhere): [UnionType!]!
  unionTypesAggregate(where: UnionTypeWhere): UnionTypeAggregateSelection!
  unionTypesCount(where: UnionTypeWhere): Int!
  users(options: UserOptions, where: UserWhere): [User!]!
  usersAggregate(where: UserWhere): UserAggregateSelection!
  usersCount(where: UserWhere): Int!
}

input QueryOptions {
  limit: Int
  offset: Int
}

"""
Allows picking a Component from the list of components.
It is passed to the rendered element as a React node: `ReactNode`
Prop values for this type have the shape of TypedValue in order to
be distinguished from other element types.
Comparison between different element types:
- RenderPropsType: Component select box, results it '(props) => ReactNode' value
- ReactNodeType: Component select box, results it 'ReactNode' value
- ElementType: Current tree element select box, results it 'ReactNod' value
"""
type ReactNodeType implements TypeBase {
  graph: TypeGraph!
  id: ID!
  name: String!
  owner(options: UserOptions, where: UserWhere): User
  ownerAggregate(where: UserWhere): ReactNodeTypeUserOwnerAggregationSelection
  ownerConnection(
    after: String
    first: Int
    sort: [TypeBaseOwnerConnectionSort!]
    where: TypeBaseOwnerConnectionWhere
  ): TypeBaseOwnerConnection!
}

type ReactNodeTypeAggregateSelection {
  count: Int!
  id: IDAggregateSelection!
  name: StringAggregateSelection!
}

input ReactNodeTypeConnectInput {
  owner: TypeBaseOwnerConnectFieldInput
}

input ReactNodeTypeConnectOrCreateInput {
  owner: TypeBaseOwnerConnectOrCreateFieldInput
}

input ReactNodeTypeCreateInput {
  name: String!
  owner: TypeBaseOwnerFieldInput
}

input ReactNodeTypeDeleteInput {
  owner: TypeBaseOwnerDeleteFieldInput
}

input ReactNodeTypeDisconnectInput {
  owner: TypeBaseOwnerDisconnectFieldInput
}

input ReactNodeTypeOptions {
  limit: Int
  offset: Int

  """
  Specify one or more ReactNodeTypeSort objects to sort ReactNodeTypes by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [ReactNodeTypeSort]
}

input ReactNodeTypeOwnerAggregateInput {
  AND: [ReactNodeTypeOwnerAggregateInput!]
  OR: [ReactNodeTypeOwnerAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: ReactNodeTypeOwnerNodeAggregationWhereInput
}

input ReactNodeTypeOwnerNodeAggregationWhereInput {
  AND: [ReactNodeTypeOwnerNodeAggregationWhereInput!]
  OR: [ReactNodeTypeOwnerNodeAggregationWhereInput!]
  auth0Id_AVERAGE_EQUAL: Float
  auth0Id_AVERAGE_GT: Float
  auth0Id_AVERAGE_GTE: Float
  auth0Id_AVERAGE_LT: Float
  auth0Id_AVERAGE_LTE: Float
  auth0Id_EQUAL: String
  auth0Id_GT: Int
  auth0Id_GTE: Int
  auth0Id_LONGEST_EQUAL: Int
  auth0Id_LONGEST_GT: Int
  auth0Id_LONGEST_GTE: Int
  auth0Id_LONGEST_LT: Int
  auth0Id_LONGEST_LTE: Int
  auth0Id_LT: Int
  auth0Id_LTE: Int
  auth0Id_SHORTEST_EQUAL: Int
  auth0Id_SHORTEST_GT: Int
  auth0Id_SHORTEST_GTE: Int
  auth0Id_SHORTEST_LT: Int
  auth0Id_SHORTEST_LTE: Int
  email_AVERAGE_EQUAL: Float
  email_AVERAGE_GT: Float
  email_AVERAGE_GTE: Float
  email_AVERAGE_LT: Float
  email_AVERAGE_LTE: Float
  email_EQUAL: String
  email_GT: Int
  email_GTE: Int
  email_LONGEST_EQUAL: Int
  email_LONGEST_GT: Int
  email_LONGEST_GTE: Int
  email_LONGEST_LT: Int
  email_LONGEST_LTE: Int
  email_LT: Int
  email_LTE: Int
  email_SHORTEST_EQUAL: Int
  email_SHORTEST_GT: Int
  email_SHORTEST_GTE: Int
  email_SHORTEST_LT: Int
  email_SHORTEST_LTE: Int
  id_EQUAL: ID
}

input ReactNodeTypeRelationInput {
  owner: TypeBaseOwnerCreateFieldInput
}

"""
Fields to sort ReactNodeTypes by. The order in which sorts are applied is not guaranteed when specifying many fields in one ReactNodeTypeSort object.
"""
input ReactNodeTypeSort {
  id: SortDirection
  name: SortDirection
}

input ReactNodeTypeUpdateInput {
  name: String
  owner: TypeBaseOwnerUpdateFieldInput
}

type ReactNodeTypeUserOwnerAggregationSelection {
  count: Int!
  node: ReactNodeTypeUserOwnerNodeAggregateSelection
}

type ReactNodeTypeUserOwnerNodeAggregateSelection {
  auth0Id: StringAggregateSelection!
  email: StringAggregateSelection!
  id: IDAggregateSelection!
}

input ReactNodeTypeWhere {
  AND: [ReactNodeTypeWhere!]
  OR: [ReactNodeTypeWhere!]
  id: ID
  id_CONTAINS: ID
  id_ENDS_WITH: ID
  id_IN: [ID]
  id_NOT: ID
  id_NOT_CONTAINS: ID
  id_NOT_ENDS_WITH: ID
  id_NOT_IN: [ID]
  id_NOT_STARTS_WITH: ID
  id_STARTS_WITH: ID
  name: String
  name_CONTAINS: String
  name_ENDS_WITH: String
  name_IN: [String]
  name_NOT: String
  name_NOT_CONTAINS: String
  name_NOT_ENDS_WITH: String
  name_NOT_IN: [String]
  name_NOT_STARTS_WITH: String
  name_STARTS_WITH: String
  owner: UserWhere
  ownerAggregate: ReactNodeTypeOwnerAggregateInput
  ownerConnection: TypeBaseOwnerConnectionWhere
  ownerConnection_NOT: TypeBaseOwnerConnectionWhere
  owner_NOT: UserWhere
}

"""
Allows picking a Component from the list of components.
It is passed to the rendered element as a function that takes props as input
and returns a React element: '(props) => ReactNode'
Prop values for this type have the shape of TypedValue in order to
be distinguished from other element types.
Comparison between different element types:
- RenderPropsType: Component select box, results it '(props) => ReactNode' value
- ReactNodeType: Component select box, results it 'ReactNode' value
- ElementType: Current tree element select box, results it 'ReactNod' value
"""
type RenderPropsType implements TypeBase {
  graph: TypeGraph!
  id: ID!
  name: String!
  owner(options: UserOptions, where: UserWhere): User
  ownerAggregate(where: UserWhere): RenderPropsTypeUserOwnerAggregationSelection
  ownerConnection(
    after: String
    first: Int
    sort: [TypeBaseOwnerConnectionSort!]
    where: TypeBaseOwnerConnectionWhere
  ): TypeBaseOwnerConnection!
}

type RenderPropsTypeAggregateSelection {
  count: Int!
  id: IDAggregateSelection!
  name: StringAggregateSelection!
}

input RenderPropsTypeConnectInput {
  owner: TypeBaseOwnerConnectFieldInput
}

input RenderPropsTypeConnectOrCreateInput {
  owner: TypeBaseOwnerConnectOrCreateFieldInput
}

input RenderPropsTypeCreateInput {
  name: String!
  owner: TypeBaseOwnerFieldInput
}

input RenderPropsTypeDeleteInput {
  owner: TypeBaseOwnerDeleteFieldInput
}

input RenderPropsTypeDisconnectInput {
  owner: TypeBaseOwnerDisconnectFieldInput
}

input RenderPropsTypeOptions {
  limit: Int
  offset: Int

  """
  Specify one or more RenderPropsTypeSort objects to sort RenderPropsTypes by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [RenderPropsTypeSort]
}

input RenderPropsTypeOwnerAggregateInput {
  AND: [RenderPropsTypeOwnerAggregateInput!]
  OR: [RenderPropsTypeOwnerAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: RenderPropsTypeOwnerNodeAggregationWhereInput
}

input RenderPropsTypeOwnerNodeAggregationWhereInput {
  AND: [RenderPropsTypeOwnerNodeAggregationWhereInput!]
  OR: [RenderPropsTypeOwnerNodeAggregationWhereInput!]
  auth0Id_AVERAGE_EQUAL: Float
  auth0Id_AVERAGE_GT: Float
  auth0Id_AVERAGE_GTE: Float
  auth0Id_AVERAGE_LT: Float
  auth0Id_AVERAGE_LTE: Float
  auth0Id_EQUAL: String
  auth0Id_GT: Int
  auth0Id_GTE: Int
  auth0Id_LONGEST_EQUAL: Int
  auth0Id_LONGEST_GT: Int
  auth0Id_LONGEST_GTE: Int
  auth0Id_LONGEST_LT: Int
  auth0Id_LONGEST_LTE: Int
  auth0Id_LT: Int
  auth0Id_LTE: Int
  auth0Id_SHORTEST_EQUAL: Int
  auth0Id_SHORTEST_GT: Int
  auth0Id_SHORTEST_GTE: Int
  auth0Id_SHORTEST_LT: Int
  auth0Id_SHORTEST_LTE: Int
  email_AVERAGE_EQUAL: Float
  email_AVERAGE_GT: Float
  email_AVERAGE_GTE: Float
  email_AVERAGE_LT: Float
  email_AVERAGE_LTE: Float
  email_EQUAL: String
  email_GT: Int
  email_GTE: Int
  email_LONGEST_EQUAL: Int
  email_LONGEST_GT: Int
  email_LONGEST_GTE: Int
  email_LONGEST_LT: Int
  email_LONGEST_LTE: Int
  email_LT: Int
  email_LTE: Int
  email_SHORTEST_EQUAL: Int
  email_SHORTEST_GT: Int
  email_SHORTEST_GTE: Int
  email_SHORTEST_LT: Int
  email_SHORTEST_LTE: Int
  id_EQUAL: ID
}

input RenderPropsTypeRelationInput {
  owner: TypeBaseOwnerCreateFieldInput
}

"""
Fields to sort RenderPropsTypes by. The order in which sorts are applied is not guaranteed when specifying many fields in one RenderPropsTypeSort object.
"""
input RenderPropsTypeSort {
  id: SortDirection
  name: SortDirection
}

input RenderPropsTypeUpdateInput {
  name: String
  owner: TypeBaseOwnerUpdateFieldInput
}

type RenderPropsTypeUserOwnerAggregationSelection {
  count: Int!
  node: RenderPropsTypeUserOwnerNodeAggregateSelection
}

type RenderPropsTypeUserOwnerNodeAggregateSelection {
  auth0Id: StringAggregateSelection!
  email: StringAggregateSelection!
  id: IDAggregateSelection!
}

input RenderPropsTypeWhere {
  AND: [RenderPropsTypeWhere!]
  OR: [RenderPropsTypeWhere!]
  id: ID
  id_CONTAINS: ID
  id_ENDS_WITH: ID
  id_IN: [ID]
  id_NOT: ID
  id_NOT_CONTAINS: ID
  id_NOT_ENDS_WITH: ID
  id_NOT_IN: [ID]
  id_NOT_STARTS_WITH: ID
  id_STARTS_WITH: ID
  name: String
  name_CONTAINS: String
  name_ENDS_WITH: String
  name_IN: [String]
  name_NOT: String
  name_NOT_CONTAINS: String
  name_NOT_ENDS_WITH: String
  name_NOT_IN: [String]
  name_NOT_STARTS_WITH: String
  name_STARTS_WITH: String
  owner: UserWhere
  ownerAggregate: RenderPropsTypeOwnerAggregateInput
  ownerConnection: TypeBaseOwnerConnectionWhere
  ownerConnection_NOT: TypeBaseOwnerConnectionWhere
  owner_NOT: UserWhere
}

enum SortDirection {
  """
  Sort by field values in ascending order.
  """
  ASC

  """
  Sort by field values in descending order.
  """
  DESC
}

type StringAggregateSelection {
  longest: String
  shortest: String
}

type Tag {
  children(options: TagOptions, where: TagWhere): [Tag!]
  childrenAggregate(where: TagWhere): TagTagChildrenAggregationSelection
  childrenConnection(
    after: String
    first: Int
    sort: [TagChildrenConnectionSort!]
    where: TagChildrenConnectionWhere
  ): TagChildrenConnection!
  id: ID!
  isRoot: Boolean
  name: String!
  parent(options: TagOptions, where: TagWhere): Tag
  parentAggregate(where: TagWhere): TagTagParentAggregationSelection
  parentConnection(
    after: String
    first: Int
    sort: [TagParentConnectionSort!]
    where: TagParentConnectionWhere
  ): TagParentConnection!
}

type TagAggregateSelection {
  count: Int!
  id: IDAggregateSelection!
  name: StringAggregateSelection!
}

input TagChildrenAggregateInput {
  AND: [TagChildrenAggregateInput!]
  OR: [TagChildrenAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: TagChildrenNodeAggregationWhereInput
}

input TagChildrenConnectFieldInput {
  connect: [TagConnectInput!]
  where: TagConnectWhere
}

input TagChildrenConnectOrCreateFieldInput {
  onCreate: TagChildrenConnectOrCreateFieldInputOnCreate!
  where: TagConnectOrCreateWhere!
}

input TagChildrenConnectOrCreateFieldInputOnCreate {
  node: TagCreateInput!
}

type TagChildrenConnection {
  edges: [TagChildrenRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input TagChildrenConnectionSort {
  node: TagSort
}

input TagChildrenConnectionWhere {
  AND: [TagChildrenConnectionWhere!]
  OR: [TagChildrenConnectionWhere!]
  node: TagWhere
  node_NOT: TagWhere
}

input TagChildrenCreateFieldInput {
  node: TagCreateInput!
}

input TagChildrenDeleteFieldInput {
  delete: TagDeleteInput
  where: TagChildrenConnectionWhere
}

input TagChildrenDisconnectFieldInput {
  disconnect: TagDisconnectInput
  where: TagChildrenConnectionWhere
}

input TagChildrenFieldInput {
  connect: [TagChildrenConnectFieldInput!]
  connectOrCreate: [TagChildrenConnectOrCreateFieldInput!]
  create: [TagChildrenCreateFieldInput!]
}

input TagChildrenNodeAggregationWhereInput {
  AND: [TagChildrenNodeAggregationWhereInput!]
  OR: [TagChildrenNodeAggregationWhereInput!]
  id_EQUAL: ID
  name_AVERAGE_EQUAL: Float
  name_AVERAGE_GT: Float
  name_AVERAGE_GTE: Float
  name_AVERAGE_LT: Float
  name_AVERAGE_LTE: Float
  name_EQUAL: String
  name_GT: Int
  name_GTE: Int
  name_LONGEST_EQUAL: Int
  name_LONGEST_GT: Int
  name_LONGEST_GTE: Int
  name_LONGEST_LT: Int
  name_LONGEST_LTE: Int
  name_LT: Int
  name_LTE: Int
  name_SHORTEST_EQUAL: Int
  name_SHORTEST_GT: Int
  name_SHORTEST_GTE: Int
  name_SHORTEST_LT: Int
  name_SHORTEST_LTE: Int
}

type TagChildrenRelationship {
  cursor: String!
  node: Tag!
}

input TagChildrenUpdateConnectionInput {
  node: TagUpdateInput
}

input TagChildrenUpdateFieldInput {
  connect: [TagChildrenConnectFieldInput!]
  connectOrCreate: [TagChildrenConnectOrCreateFieldInput!]
  create: [TagChildrenCreateFieldInput!]
  delete: [TagChildrenDeleteFieldInput!]
  disconnect: [TagChildrenDisconnectFieldInput!]
  update: TagChildrenUpdateConnectionInput
  where: TagChildrenConnectionWhere
}

input TagConnectInput {
  children: [TagChildrenConnectFieldInput!]
  parent: TagParentConnectFieldInput
}

input TagConnectOrCreateInput {
  children: [TagChildrenConnectOrCreateFieldInput!]
  parent: TagParentConnectOrCreateFieldInput
}

input TagConnectOrCreateWhere {
  node: TagUniqueWhere!
}

input TagConnectWhere {
  node: TagWhere!
}

input TagCreateInput {
  children: TagChildrenFieldInput
  isRoot: Boolean
  name: String!
  parent: TagParentFieldInput
}

input TagDeleteInput {
  children: [TagChildrenDeleteFieldInput!]
  parent: TagParentDeleteFieldInput
}

input TagDisconnectInput {
  children: [TagChildrenDisconnectFieldInput!]
  parent: TagParentDisconnectFieldInput
}

type TagEdge {
  source: ID!
  target: ID!
}

type TagEdgeAggregateSelection {
  count: Int!
  source: IDAggregateSelection!
  target: IDAggregateSelection!
}

input TagEdgeCreateInput {
  source: ID!
  target: ID!
}

input TagEdgeOptions {
  limit: Int
  offset: Int

  """
  Specify one or more TagEdgeSort objects to sort TagEdges by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [TagEdgeSort]
}

"""
Fields to sort TagEdges by. The order in which sorts are applied is not guaranteed when specifying many fields in one TagEdgeSort object.
"""
input TagEdgeSort {
  source: SortDirection
  target: SortDirection
}

input TagEdgeUpdateInput {
  source: ID
  target: ID
}

input TagEdgeWhere {
  AND: [TagEdgeWhere!]
  OR: [TagEdgeWhere!]
  source: ID
  source_CONTAINS: ID
  source_ENDS_WITH: ID
  source_IN: [ID]
  source_NOT: ID
  source_NOT_CONTAINS: ID
  source_NOT_ENDS_WITH: ID
  source_NOT_IN: [ID]
  source_NOT_STARTS_WITH: ID
  source_STARTS_WITH: ID
  target: ID
  target_CONTAINS: ID
  target_ENDS_WITH: ID
  target_IN: [ID]
  target_NOT: ID
  target_NOT_CONTAINS: ID
  target_NOT_ENDS_WITH: ID
  target_NOT_IN: [ID]
  target_NOT_STARTS_WITH: ID
  target_STARTS_WITH: ID
}

type TagGraph {
  """
  All the links connecting the descendant elements/components
  """
  edges: [TagEdge!]!

  """
  All descendant Elements or Components, at any level
  """
  vertices: [Tag!]!
}

input TagOptions {
  limit: Int
  offset: Int

  """
  Specify one or more TagSort objects to sort Tags by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [TagSort]
}

input TagParentAggregateInput {
  AND: [TagParentAggregateInput!]
  OR: [TagParentAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: TagParentNodeAggregationWhereInput
}

input TagParentConnectFieldInput {
  connect: TagConnectInput
  where: TagConnectWhere
}

input TagParentConnectOrCreateFieldInput {
  onCreate: TagParentConnectOrCreateFieldInputOnCreate!
  where: TagConnectOrCreateWhere!
}

input TagParentConnectOrCreateFieldInputOnCreate {
  node: TagCreateInput!
}

type TagParentConnection {
  edges: [TagParentRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input TagParentConnectionSort {
  node: TagSort
}

input TagParentConnectionWhere {
  AND: [TagParentConnectionWhere!]
  OR: [TagParentConnectionWhere!]
  node: TagWhere
  node_NOT: TagWhere
}

input TagParentCreateFieldInput {
  node: TagCreateInput!
}

input TagParentDeleteFieldInput {
  delete: TagDeleteInput
  where: TagParentConnectionWhere
}

input TagParentDisconnectFieldInput {
  disconnect: TagDisconnectInput
  where: TagParentConnectionWhere
}

input TagParentFieldInput {
  connect: TagParentConnectFieldInput
  connectOrCreate: TagParentConnectOrCreateFieldInput
  create: TagParentCreateFieldInput
}

input TagParentNodeAggregationWhereInput {
  AND: [TagParentNodeAggregationWhereInput!]
  OR: [TagParentNodeAggregationWhereInput!]
  id_EQUAL: ID
  name_AVERAGE_EQUAL: Float
  name_AVERAGE_GT: Float
  name_AVERAGE_GTE: Float
  name_AVERAGE_LT: Float
  name_AVERAGE_LTE: Float
  name_EQUAL: String
  name_GT: Int
  name_GTE: Int
  name_LONGEST_EQUAL: Int
  name_LONGEST_GT: Int
  name_LONGEST_GTE: Int
  name_LONGEST_LT: Int
  name_LONGEST_LTE: Int
  name_LT: Int
  name_LTE: Int
  name_SHORTEST_EQUAL: Int
  name_SHORTEST_GT: Int
  name_SHORTEST_GTE: Int
  name_SHORTEST_LT: Int
  name_SHORTEST_LTE: Int
}

type TagParentRelationship {
  cursor: String!
  node: Tag!
}

input TagParentUpdateConnectionInput {
  node: TagUpdateInput
}

input TagParentUpdateFieldInput {
  connect: TagParentConnectFieldInput
  connectOrCreate: TagParentConnectOrCreateFieldInput
  create: TagParentCreateFieldInput
  delete: TagParentDeleteFieldInput
  disconnect: TagParentDisconnectFieldInput
  update: TagParentUpdateConnectionInput
  where: TagParentConnectionWhere
}

input TagRelationInput {
  children: [TagChildrenCreateFieldInput!]
  parent: TagParentCreateFieldInput
}

"""
Fields to sort Tags by. The order in which sorts are applied is not guaranteed when specifying many fields in one TagSort object.
"""
input TagSort {
  id: SortDirection
  isRoot: SortDirection
  name: SortDirection
}

type TagTagChildrenAggregationSelection {
  count: Int!
  node: TagTagChildrenNodeAggregateSelection
}

type TagTagChildrenNodeAggregateSelection {
  id: IDAggregateSelection!
  name: StringAggregateSelection!
}

type TagTagParentAggregationSelection {
  count: Int!
  node: TagTagParentNodeAggregateSelection
}

type TagTagParentNodeAggregateSelection {
  id: IDAggregateSelection!
  name: StringAggregateSelection!
}

input TagUniqueWhere {
  id: ID
}

input TagUpdateInput {
  children: [TagChildrenUpdateFieldInput!]
  isRoot: Boolean
  name: String
  parent: TagParentUpdateFieldInput
}

input TagWhere {
  AND: [TagWhere!]
  OR: [TagWhere!]
  children: TagWhere
  childrenAggregate: TagChildrenAggregateInput
  childrenConnection: TagChildrenConnectionWhere
  childrenConnection_NOT: TagChildrenConnectionWhere
  children_NOT: TagWhere
  id: ID
  id_CONTAINS: ID
  id_ENDS_WITH: ID
  id_IN: [ID]
  id_NOT: ID
  id_NOT_CONTAINS: ID
  id_NOT_ENDS_WITH: ID
  id_NOT_IN: [ID]
  id_NOT_STARTS_WITH: ID
  id_STARTS_WITH: ID
  isRoot: Boolean
  isRoot_NOT: Boolean
  name: String
  name_CONTAINS: String
  name_ENDS_WITH: String
  name_IN: [String]
  name_NOT: String
  name_NOT_CONTAINS: String
  name_NOT_ENDS_WITH: String
  name_NOT_IN: [String]
  name_NOT_STARTS_WITH: String
  name_STARTS_WITH: String
  parent: TagWhere
  parentAggregate: TagParentAggregateInput
  parentConnection: TagParentConnectionWhere
  parentConnection_NOT: TagParentConnectionWhere
  parent_NOT: TagWhere
}

interface TypeBase {
  graph: TypeGraph!
  id: ID!
  name: String!
  owner(options: UserOptions, where: UserWhere): User
  ownerConnection(
    after: String
    first: Int
    sort: [TypeBaseOwnerConnectionSort!]
    where: TypeBaseOwnerConnectionWhere
  ): TypeBaseOwnerConnection!
}

input TypeBaseConnectInput {
  _on: TypeBaseImplementationsConnectInput
  owner: TypeBaseOwnerConnectFieldInput
}

input TypeBaseConnectWhere {
  node: TypeBaseWhere!
}

input TypeBaseCreateInput {
  AppType: AppTypeCreateInput
  ArrayType: ArrayTypeCreateInput
  ElementType: ElementTypeCreateInput
  EnumType: EnumTypeCreateInput
  InterfaceType: InterfaceTypeCreateInput
  LambdaType: LambdaTypeCreateInput
  MonacoType: MonacoTypeCreateInput
  PageType: PageTypeCreateInput
  PrimitiveType: PrimitiveTypeCreateInput
  ReactNodeType: ReactNodeTypeCreateInput
  RenderPropsType: RenderPropsTypeCreateInput
  UnionType: UnionTypeCreateInput
}

input TypeBaseDeleteInput {
  _on: TypeBaseImplementationsDeleteInput
  owner: TypeBaseOwnerDeleteFieldInput
}

input TypeBaseDisconnectInput {
  _on: TypeBaseImplementationsDisconnectInput
  owner: TypeBaseOwnerDisconnectFieldInput
}

input TypeBaseImplementationsConnectInput {
  AppType: [AppTypeConnectInput!]
  ArrayType: [ArrayTypeConnectInput!]
  ElementType: [ElementTypeConnectInput!]
  EnumType: [EnumTypeConnectInput!]
  InterfaceType: [InterfaceTypeConnectInput!]
  LambdaType: [LambdaTypeConnectInput!]
  MonacoType: [MonacoTypeConnectInput!]
  PageType: [PageTypeConnectInput!]
  PrimitiveType: [PrimitiveTypeConnectInput!]
  ReactNodeType: [ReactNodeTypeConnectInput!]
  RenderPropsType: [RenderPropsTypeConnectInput!]
  UnionType: [UnionTypeConnectInput!]
}

input TypeBaseImplementationsDeleteInput {
  AppType: [AppTypeDeleteInput!]
  ArrayType: [ArrayTypeDeleteInput!]
  ElementType: [ElementTypeDeleteInput!]
  EnumType: [EnumTypeDeleteInput!]
  InterfaceType: [InterfaceTypeDeleteInput!]
  LambdaType: [LambdaTypeDeleteInput!]
  MonacoType: [MonacoTypeDeleteInput!]
  PageType: [PageTypeDeleteInput!]
  PrimitiveType: [PrimitiveTypeDeleteInput!]
  ReactNodeType: [ReactNodeTypeDeleteInput!]
  RenderPropsType: [RenderPropsTypeDeleteInput!]
  UnionType: [UnionTypeDeleteInput!]
}

input TypeBaseImplementationsDisconnectInput {
  AppType: [AppTypeDisconnectInput!]
  ArrayType: [ArrayTypeDisconnectInput!]
  ElementType: [ElementTypeDisconnectInput!]
  EnumType: [EnumTypeDisconnectInput!]
  InterfaceType: [InterfaceTypeDisconnectInput!]
  LambdaType: [LambdaTypeDisconnectInput!]
  MonacoType: [MonacoTypeDisconnectInput!]
  PageType: [PageTypeDisconnectInput!]
  PrimitiveType: [PrimitiveTypeDisconnectInput!]
  ReactNodeType: [ReactNodeTypeDisconnectInput!]
  RenderPropsType: [RenderPropsTypeDisconnectInput!]
  UnionType: [UnionTypeDisconnectInput!]
}

input TypeBaseImplementationsUpdateInput {
  AppType: AppTypeUpdateInput
  ArrayType: ArrayTypeUpdateInput
  ElementType: ElementTypeUpdateInput
  EnumType: EnumTypeUpdateInput
  InterfaceType: InterfaceTypeUpdateInput
  LambdaType: LambdaTypeUpdateInput
  MonacoType: MonacoTypeUpdateInput
  PageType: PageTypeUpdateInput
  PrimitiveType: PrimitiveTypeUpdateInput
  ReactNodeType: ReactNodeTypeUpdateInput
  RenderPropsType: RenderPropsTypeUpdateInput
  UnionType: UnionTypeUpdateInput
}

input TypeBaseImplementationsWhere {
  AppType: AppTypeWhere
  ArrayType: ArrayTypeWhere
  ElementType: ElementTypeWhere
  EnumType: EnumTypeWhere
  InterfaceType: InterfaceTypeWhere
  LambdaType: LambdaTypeWhere
  MonacoType: MonacoTypeWhere
  PageType: PageTypeWhere
  PrimitiveType: PrimitiveTypeWhere
  ReactNodeType: ReactNodeTypeWhere
  RenderPropsType: RenderPropsTypeWhere
  UnionType: UnionTypeWhere
}

input TypeBaseOwnerAggregateInput {
  AND: [TypeBaseOwnerAggregateInput!]
  OR: [TypeBaseOwnerAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: TypeBaseOwnerNodeAggregationWhereInput
}

input TypeBaseOwnerConnectFieldInput {
  connect: UserConnectInput
  where: UserConnectWhere
}

input TypeBaseOwnerConnectOrCreateFieldInput {
  onCreate: TypeBaseOwnerConnectOrCreateFieldInputOnCreate!
  where: UserConnectOrCreateWhere!
}

input TypeBaseOwnerConnectOrCreateFieldInputOnCreate {
  node: UserCreateInput!
}

type TypeBaseOwnerConnection {
  edges: [TypeBaseOwnerRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input TypeBaseOwnerConnectionSort {
  node: UserSort
}

input TypeBaseOwnerConnectionWhere {
  AND: [TypeBaseOwnerConnectionWhere!]
  OR: [TypeBaseOwnerConnectionWhere!]
  node: UserWhere
  node_NOT: UserWhere
}

input TypeBaseOwnerCreateFieldInput {
  node: UserCreateInput!
}

input TypeBaseOwnerDeleteFieldInput {
  delete: UserDeleteInput
  where: TypeBaseOwnerConnectionWhere
}

input TypeBaseOwnerDisconnectFieldInput {
  disconnect: UserDisconnectInput
  where: TypeBaseOwnerConnectionWhere
}

input TypeBaseOwnerFieldInput {
  connect: TypeBaseOwnerConnectFieldInput
  connectOrCreate: TypeBaseOwnerConnectOrCreateFieldInput
  create: TypeBaseOwnerCreateFieldInput
}

input TypeBaseOwnerNodeAggregationWhereInput {
  AND: [TypeBaseOwnerNodeAggregationWhereInput!]
  OR: [TypeBaseOwnerNodeAggregationWhereInput!]
  auth0Id_AVERAGE_EQUAL: Float
  auth0Id_AVERAGE_GT: Float
  auth0Id_AVERAGE_GTE: Float
  auth0Id_AVERAGE_LT: Float
  auth0Id_AVERAGE_LTE: Float
  auth0Id_EQUAL: String
  auth0Id_GT: Int
  auth0Id_GTE: Int
  auth0Id_LONGEST_EQUAL: Int
  auth0Id_LONGEST_GT: Int
  auth0Id_LONGEST_GTE: Int
  auth0Id_LONGEST_LT: Int
  auth0Id_LONGEST_LTE: Int
  auth0Id_LT: Int
  auth0Id_LTE: Int
  auth0Id_SHORTEST_EQUAL: Int
  auth0Id_SHORTEST_GT: Int
  auth0Id_SHORTEST_GTE: Int
  auth0Id_SHORTEST_LT: Int
  auth0Id_SHORTEST_LTE: Int
  email_AVERAGE_EQUAL: Float
  email_AVERAGE_GT: Float
  email_AVERAGE_GTE: Float
  email_AVERAGE_LT: Float
  email_AVERAGE_LTE: Float
  email_EQUAL: String
  email_GT: Int
  email_GTE: Int
  email_LONGEST_EQUAL: Int
  email_LONGEST_GT: Int
  email_LONGEST_GTE: Int
  email_LONGEST_LT: Int
  email_LONGEST_LTE: Int
  email_LT: Int
  email_LTE: Int
  email_SHORTEST_EQUAL: Int
  email_SHORTEST_GT: Int
  email_SHORTEST_GTE: Int
  email_SHORTEST_LT: Int
  email_SHORTEST_LTE: Int
  id_EQUAL: ID
}

type TypeBaseOwnerRelationship {
  cursor: String!
  node: User!
}

input TypeBaseOwnerUpdateConnectionInput {
  node: UserUpdateInput
}

input TypeBaseOwnerUpdateFieldInput {
  connect: TypeBaseOwnerConnectFieldInput
  connectOrCreate: TypeBaseOwnerConnectOrCreateFieldInput
  create: TypeBaseOwnerCreateFieldInput
  delete: TypeBaseOwnerDeleteFieldInput
  disconnect: TypeBaseOwnerDisconnectFieldInput
  update: TypeBaseOwnerUpdateConnectionInput
  where: TypeBaseOwnerConnectionWhere
}

input TypeBaseUpdateInput {
  _on: TypeBaseImplementationsUpdateInput
  name: String
  owner: TypeBaseOwnerUpdateFieldInput
}

input TypeBaseWhere {
  _on: TypeBaseImplementationsWhere
  id: ID
  id_CONTAINS: ID
  id_ENDS_WITH: ID
  id_IN: [ID]
  id_NOT: ID
  id_NOT_CONTAINS: ID
  id_NOT_ENDS_WITH: ID
  id_NOT_IN: [ID]
  id_NOT_STARTS_WITH: ID
  id_STARTS_WITH: ID
  name: String
  name_CONTAINS: String
  name_ENDS_WITH: String
  name_IN: [String]
  name_NOT: String
  name_NOT_CONTAINS: String
  name_NOT_ENDS_WITH: String
  name_NOT_IN: [String]
  name_NOT_STARTS_WITH: String
  name_STARTS_WITH: String
  owner: UserWhere
  ownerAggregate: TypeBaseOwnerAggregateInput
  ownerConnection: TypeBaseOwnerConnectionWhere
  ownerConnection_NOT: TypeBaseOwnerConnectionWhere
  owner_NOT: UserWhere
}

"""
Connection between two types in a TypeGraph.
Can be:
Array -> ArrayItem (Edge)
Interface -> Field type - (InterfaceTypeEdge)
Union -> Union member (Edge)
"""
union TypeEdge = Edge | InterfaceTypeEdge

type TypeGraph {
  edges: [TypeEdge!]!
  vertices: [AnyType!]!
}

type TypeReference {
  """
  The type of resource - Atom, InterfaceType, etc.
  """
  label: String!

  """
  The name of the resource referencing the type
  """
  name: String!
}

type TypeReferenceAggregateSelection {
  count: Int!
  label: StringAggregateSelection!
  name: StringAggregateSelection!
}

input TypeReferenceCreateInput {
  label: String!
  name: String!
}

input TypeReferenceOptions {
  limit: Int
  offset: Int

  """
  Specify one or more TypeReferenceSort objects to sort TypeReferences by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [TypeReferenceSort]
}

"""
Fields to sort TypeReferences by. The order in which sorts are applied is not guaranteed when specifying many fields in one TypeReferenceSort object.
"""
input TypeReferenceSort {
  label: SortDirection
  name: SortDirection
}

input TypeReferenceUpdateInput {
  label: String
  name: String
}

input TypeReferenceWhere {
  AND: [TypeReferenceWhere!]
  OR: [TypeReferenceWhere!]
  label: String
  label_CONTAINS: String
  label_ENDS_WITH: String
  label_IN: [String]
  label_NOT: String
  label_NOT_CONTAINS: String
  label_NOT_ENDS_WITH: String
  label_NOT_IN: [String]
  label_NOT_STARTS_WITH: String
  label_STARTS_WITH: String
  name: String
  name_CONTAINS: String
  name_ENDS_WITH: String
  name_IN: [String]
  name_NOT: String
  name_NOT_CONTAINS: String
  name_NOT_ENDS_WITH: String
  name_NOT_IN: [String]
  name_NOT_STARTS_WITH: String
  name_STARTS_WITH: String
}

"""
Allows picking one of a set of types
"""
type UnionType implements TypeBase {
  graph: TypeGraph!
  id: ID!
  name: String!
  owner(options: UserOptions, where: UserWhere): User
  ownerAggregate(where: UserWhere): UnionTypeUserOwnerAggregationSelection
  ownerConnection(
    after: String
    first: Int
    sort: [TypeBaseOwnerConnectionSort!]
    where: TypeBaseOwnerConnectionWhere
  ): TypeBaseOwnerConnection!
  typesOfUnionType(options: QueryOptions, where: TypeBaseWhere): [TypeBase!]
  typesOfUnionTypeConnection(
    where: UnionTypeTypesOfUnionTypeConnectionWhere
  ): UnionTypeTypesOfUnionTypeConnection!
}

type UnionTypeAggregateSelection {
  count: Int!
  id: IDAggregateSelection!
  name: StringAggregateSelection!
}

input UnionTypeConnectInput {
  owner: TypeBaseOwnerConnectFieldInput
  typesOfUnionType: [UnionTypeTypesOfUnionTypeConnectFieldInput!]
}

input UnionTypeConnectOrCreateInput {
  owner: TypeBaseOwnerConnectOrCreateFieldInput
}

input UnionTypeCreateInput {
  name: String!
  owner: TypeBaseOwnerFieldInput
  typesOfUnionType: UnionTypeTypesOfUnionTypeFieldInput
}

input UnionTypeDeleteInput {
  owner: TypeBaseOwnerDeleteFieldInput
  typesOfUnionType: [UnionTypeTypesOfUnionTypeDeleteFieldInput!]
}

input UnionTypeDisconnectInput {
  owner: TypeBaseOwnerDisconnectFieldInput
  typesOfUnionType: [UnionTypeTypesOfUnionTypeDisconnectFieldInput!]
}

input UnionTypeOptions {
  limit: Int
  offset: Int

  """
  Specify one or more UnionTypeSort objects to sort UnionTypes by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [UnionTypeSort]
}

input UnionTypeOwnerAggregateInput {
  AND: [UnionTypeOwnerAggregateInput!]
  OR: [UnionTypeOwnerAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: UnionTypeOwnerNodeAggregationWhereInput
}

input UnionTypeOwnerNodeAggregationWhereInput {
  AND: [UnionTypeOwnerNodeAggregationWhereInput!]
  OR: [UnionTypeOwnerNodeAggregationWhereInput!]
  auth0Id_AVERAGE_EQUAL: Float
  auth0Id_AVERAGE_GT: Float
  auth0Id_AVERAGE_GTE: Float
  auth0Id_AVERAGE_LT: Float
  auth0Id_AVERAGE_LTE: Float
  auth0Id_EQUAL: String
  auth0Id_GT: Int
  auth0Id_GTE: Int
  auth0Id_LONGEST_EQUAL: Int
  auth0Id_LONGEST_GT: Int
  auth0Id_LONGEST_GTE: Int
  auth0Id_LONGEST_LT: Int
  auth0Id_LONGEST_LTE: Int
  auth0Id_LT: Int
  auth0Id_LTE: Int
  auth0Id_SHORTEST_EQUAL: Int
  auth0Id_SHORTEST_GT: Int
  auth0Id_SHORTEST_GTE: Int
  auth0Id_SHORTEST_LT: Int
  auth0Id_SHORTEST_LTE: Int
  email_AVERAGE_EQUAL: Float
  email_AVERAGE_GT: Float
  email_AVERAGE_GTE: Float
  email_AVERAGE_LT: Float
  email_AVERAGE_LTE: Float
  email_EQUAL: String
  email_GT: Int
  email_GTE: Int
  email_LONGEST_EQUAL: Int
  email_LONGEST_GT: Int
  email_LONGEST_GTE: Int
  email_LONGEST_LT: Int
  email_LONGEST_LTE: Int
  email_LT: Int
  email_LTE: Int
  email_SHORTEST_EQUAL: Int
  email_SHORTEST_GT: Int
  email_SHORTEST_GTE: Int
  email_SHORTEST_LT: Int
  email_SHORTEST_LTE: Int
  id_EQUAL: ID
}

input UnionTypeRelationInput {
  owner: TypeBaseOwnerCreateFieldInput
  typesOfUnionType: [UnionTypeTypesOfUnionTypeCreateFieldInput!]
}

"""
Fields to sort UnionTypes by. The order in which sorts are applied is not guaranteed when specifying many fields in one UnionTypeSort object.
"""
input UnionTypeSort {
  id: SortDirection
  name: SortDirection
}

input UnionTypeTypesOfUnionTypeConnectFieldInput {
  connect: TypeBaseConnectInput
  where: TypeBaseConnectWhere
}

type UnionTypeTypesOfUnionTypeConnection {
  edges: [UnionTypeTypesOfUnionTypeRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input UnionTypeTypesOfUnionTypeConnectionWhere {
  AND: [UnionTypeTypesOfUnionTypeConnectionWhere!]
  OR: [UnionTypeTypesOfUnionTypeConnectionWhere!]
  node: TypeBaseWhere
  node_NOT: TypeBaseWhere
}

input UnionTypeTypesOfUnionTypeCreateFieldInput {
  node: TypeBaseCreateInput!
}

input UnionTypeTypesOfUnionTypeDeleteFieldInput {
  delete: TypeBaseDeleteInput
  where: UnionTypeTypesOfUnionTypeConnectionWhere
}

input UnionTypeTypesOfUnionTypeDisconnectFieldInput {
  disconnect: TypeBaseDisconnectInput
  where: UnionTypeTypesOfUnionTypeConnectionWhere
}

input UnionTypeTypesOfUnionTypeFieldInput {
  connect: [UnionTypeTypesOfUnionTypeConnectFieldInput!]
  create: [UnionTypeTypesOfUnionTypeCreateFieldInput!]
}

type UnionTypeTypesOfUnionTypeRelationship {
  cursor: String!
  node: TypeBase!
}

input UnionTypeTypesOfUnionTypeUpdateConnectionInput {
  node: TypeBaseUpdateInput
}

input UnionTypeTypesOfUnionTypeUpdateFieldInput {
  connect: [UnionTypeTypesOfUnionTypeConnectFieldInput!]
  create: [UnionTypeTypesOfUnionTypeCreateFieldInput!]
  delete: [UnionTypeTypesOfUnionTypeDeleteFieldInput!]
  disconnect: [UnionTypeTypesOfUnionTypeDisconnectFieldInput!]
  update: UnionTypeTypesOfUnionTypeUpdateConnectionInput
  where: UnionTypeTypesOfUnionTypeConnectionWhere
}

input UnionTypeUpdateInput {
  name: String
  owner: TypeBaseOwnerUpdateFieldInput
  typesOfUnionType: [UnionTypeTypesOfUnionTypeUpdateFieldInput!]
}

type UnionTypeUserOwnerAggregationSelection {
  count: Int!
  node: UnionTypeUserOwnerNodeAggregateSelection
}

type UnionTypeUserOwnerNodeAggregateSelection {
  auth0Id: StringAggregateSelection!
  email: StringAggregateSelection!
  id: IDAggregateSelection!
}

input UnionTypeWhere {
  AND: [UnionTypeWhere!]
  OR: [UnionTypeWhere!]
  id: ID
  id_CONTAINS: ID
  id_ENDS_WITH: ID
  id_IN: [ID]
  id_NOT: ID
  id_NOT_CONTAINS: ID
  id_NOT_ENDS_WITH: ID
  id_NOT_IN: [ID]
  id_NOT_STARTS_WITH: ID
  id_STARTS_WITH: ID
  name: String
  name_CONTAINS: String
  name_ENDS_WITH: String
  name_IN: [String]
  name_NOT: String
  name_NOT_CONTAINS: String
  name_NOT_ENDS_WITH: String
  name_NOT_IN: [String]
  name_NOT_STARTS_WITH: String
  name_STARTS_WITH: String
  owner: UserWhere
  ownerAggregate: UnionTypeOwnerAggregateInput
  ownerConnection: TypeBaseOwnerConnectionWhere
  ownerConnection_NOT: TypeBaseOwnerConnectionWhere
  owner_NOT: UserWhere
  typesOfUnionTypeConnection: UnionTypeTypesOfUnionTypeConnectionWhere
  typesOfUnionTypeConnection_NOT: UnionTypeTypesOfUnionTypeConnectionWhere
}

type UpdateAppTypesMutationResponse {
  appTypes: [AppType!]!
  info: UpdateInfo!
}

type UpdateAppsMutationResponse {
  apps: [App!]!
  info: UpdateInfo!
}

type UpdateArrayTypesMutationResponse {
  arrayTypes: [ArrayType!]!
  info: UpdateInfo!
}

type UpdateAtomsMutationResponse {
  atoms: [Atom!]!
  info: UpdateInfo!
}

type UpdateCreateInfosMutationResponse {
  createInfos: [CreateInfo!]!
  info: UpdateInfo!
}

type UpdateDeleteFieldResponsesMutationResponse {
  deleteFieldResponses: [DeleteFieldResponse!]!
  info: UpdateInfo!
}

type UpdateEdgesMutationResponse {
  edges: [Edge!]!
  info: UpdateInfo!
}

type UpdateElementTypesMutationResponse {
  elementTypes: [ElementType!]!
  info: UpdateInfo!
}

type UpdateElementsMutationResponse {
  elements: [Element!]!
  info: UpdateInfo!
}

type UpdateEnumTypeValuesMutationResponse {
  enumTypeValues: [EnumTypeValue!]!
  info: UpdateInfo!
}

type UpdateEnumTypesMutationResponse {
  enumTypes: [EnumType!]!
  info: UpdateInfo!
}

type UpdateHooksMutationResponse {
  hooks: [Hook!]!
  info: UpdateInfo!
}

type UpdateImportAtomsMutationResponsesMutationResponse {
  importAtomsMutationResponses: [ImportAtomsMutationResponse!]!
  info: UpdateInfo!
}

type UpdateInfo {
  bookmark: String
  nodesCreated: Int!
  nodesDeleted: Int!
  relationshipsCreated: Int!
  relationshipsDeleted: Int!
}

type UpdateInterfaceTypesMutationResponse {
  info: UpdateInfo!
  interfaceTypes: [InterfaceType!]!
}

type UpdateLambdaTypesMutationResponse {
  info: UpdateInfo!
  lambdaTypes: [LambdaType!]!
}

type UpdateMonacoTypesMutationResponse {
  info: UpdateInfo!
  monacoTypes: [MonacoType!]!
}

type UpdatePageTypesMutationResponse {
  info: UpdateInfo!
  pageTypes: [PageType!]!
}

type UpdatePagesMutationResponse {
  info: UpdateInfo!
  pages: [Page!]!
}

type UpdatePrimitiveTypesMutationResponse {
  info: UpdateInfo!
  primitiveTypes: [PrimitiveType!]!
}

type UpdatePropMapBindingsMutationResponse {
  info: UpdateInfo!
  propMapBindings: [PropMapBinding!]!
}

type UpdatePropsMutationResponse {
  info: UpdateInfo!
  props: [Prop!]!
}

type UpdateReactNodeTypesMutationResponse {
  info: UpdateInfo!
  reactNodeTypes: [ReactNodeType!]!
}

type UpdateRenderPropsTypesMutationResponse {
  info: UpdateInfo!
  renderPropsTypes: [RenderPropsType!]!
}

type UpdateTagEdgesMutationResponse {
  info: UpdateInfo!
  tagEdges: [TagEdge!]!
}

type UpdateTagsMutationResponse {
  info: UpdateInfo!
  tags: [Tag!]!
}

type UpdateTypeReferencesMutationResponse {
  info: UpdateInfo!
  typeReferences: [TypeReference!]!
}

type UpdateUnionTypesMutationResponse {
  info: UpdateInfo!
  unionTypes: [UnionType!]!
}

input UpsertFieldInput {
  description: String
  interfaceTypeId: ID!
  key: String!
  name: String
  targetTypeId: ID!
}

type User {
  apps(options: AppOptions, where: AppWhere): [App]
  appsAggregate(where: AppWhere): UserAppAppsAggregationSelection
  appsConnection(
    after: String
    first: Int
    sort: [UserAppsConnectionSort!]
    where: UserAppsConnectionWhere
  ): UserAppsConnection!
  auth0Id: String!
  email: String!
  id: ID!
}

type UserAggregateSelection {
  auth0Id: StringAggregateSelection!
  count: Int!
  email: StringAggregateSelection!
  id: IDAggregateSelection!
}

type UserAppAppsAggregationSelection {
  count: Int!
  node: UserAppAppsNodeAggregateSelection
}

type UserAppAppsNodeAggregateSelection {
  id: IDAggregateSelection!
  name: StringAggregateSelection!
}

input UserAppsAggregateInput {
  AND: [UserAppsAggregateInput!]
  OR: [UserAppsAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: UserAppsNodeAggregationWhereInput
}

input UserAppsConnectFieldInput {
  connect: [AppConnectInput!]
  where: AppConnectWhere
}

input UserAppsConnectOrCreateFieldInput {
  onCreate: UserAppsConnectOrCreateFieldInputOnCreate!
  where: AppConnectOrCreateWhere!
}

input UserAppsConnectOrCreateFieldInputOnCreate {
  node: AppCreateInput!
}

type UserAppsConnection {
  edges: [UserAppsRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input UserAppsConnectionSort {
  node: AppSort
}

input UserAppsConnectionWhere {
  AND: [UserAppsConnectionWhere!]
  OR: [UserAppsConnectionWhere!]
  node: AppWhere
  node_NOT: AppWhere
}

input UserAppsCreateFieldInput {
  node: AppCreateInput!
}

input UserAppsDeleteFieldInput {
  delete: AppDeleteInput
  where: UserAppsConnectionWhere
}

input UserAppsDisconnectFieldInput {
  disconnect: AppDisconnectInput
  where: UserAppsConnectionWhere
}

input UserAppsFieldInput {
  connect: [UserAppsConnectFieldInput!]
  connectOrCreate: [UserAppsConnectOrCreateFieldInput!]
  create: [UserAppsCreateFieldInput!]
}

input UserAppsNodeAggregationWhereInput {
  AND: [UserAppsNodeAggregationWhereInput!]
  OR: [UserAppsNodeAggregationWhereInput!]
  id_EQUAL: ID
  name_AVERAGE_EQUAL: Float
  name_AVERAGE_GT: Float
  name_AVERAGE_GTE: Float
  name_AVERAGE_LT: Float
  name_AVERAGE_LTE: Float
  name_EQUAL: String
  name_GT: Int
  name_GTE: Int
  name_LONGEST_EQUAL: Int
  name_LONGEST_GT: Int
  name_LONGEST_GTE: Int
  name_LONGEST_LT: Int
  name_LONGEST_LTE: Int
  name_LT: Int
  name_LTE: Int
  name_SHORTEST_EQUAL: Int
  name_SHORTEST_GT: Int
  name_SHORTEST_GTE: Int
  name_SHORTEST_LT: Int
  name_SHORTEST_LTE: Int
}

type UserAppsRelationship {
  cursor: String!
  node: App!
}

input UserAppsUpdateConnectionInput {
  node: AppUpdateInput
}

input UserAppsUpdateFieldInput {
  connect: [UserAppsConnectFieldInput!]
  connectOrCreate: [UserAppsConnectOrCreateFieldInput!]
  create: [UserAppsCreateFieldInput!]
  delete: [UserAppsDeleteFieldInput!]
  disconnect: [UserAppsDisconnectFieldInput!]
  update: UserAppsUpdateConnectionInput
  where: UserAppsConnectionWhere
}

input UserConnectInput {
  apps: [UserAppsConnectFieldInput!]
}

input UserConnectOrCreateWhere {
  node: UserUniqueWhere!
}

input UserConnectWhere {
  node: UserWhere!
}

input UserCreateInput {
  apps: UserAppsFieldInput
  auth0Id: String!
  email: String!
}

input UserDeleteInput {
  apps: [UserAppsDeleteFieldInput!]
}

input UserDisconnectInput {
  apps: [UserAppsDisconnectFieldInput!]
}

input UserOptions {
  limit: Int
  offset: Int

  """
  Specify one or more UserSort objects to sort Users by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [UserSort]
}

"""
Fields to sort Users by. The order in which sorts are applied is not guaranteed when specifying many fields in one UserSort object.
"""
input UserSort {
  auth0Id: SortDirection
  email: SortDirection
  id: SortDirection
}

input UserUniqueWhere {
  id: ID
}

input UserUpdateInput {
  apps: [UserAppsUpdateFieldInput!]
  auth0Id: String
  email: String
}

input UserWhere {
  AND: [UserWhere!]
  OR: [UserWhere!]
  apps: AppWhere
  appsAggregate: UserAppsAggregateInput
  appsConnection: UserAppsConnectionWhere
  appsConnection_NOT: UserAppsConnectionWhere
  apps_NOT: AppWhere
  auth0Id: String
  auth0Id_CONTAINS: String
  auth0Id_ENDS_WITH: String
  auth0Id_IN: [String]
  auth0Id_NOT: String
  auth0Id_NOT_CONTAINS: String
  auth0Id_NOT_ENDS_WITH: String
  auth0Id_NOT_IN: [String]
  auth0Id_NOT_STARTS_WITH: String
  auth0Id_STARTS_WITH: String
  email: String
  email_CONTAINS: String
  email_ENDS_WITH: String
  email_IN: [String]
  email_NOT: String
  email_NOT_CONTAINS: String
  email_NOT_ENDS_WITH: String
  email_NOT_IN: [String]
  email_NOT_STARTS_WITH: String
  email_STARTS_WITH: String
  id: ID
  id_CONTAINS: ID
  id_ENDS_WITH: ID
  id_IN: [ID]
  id_NOT: ID
  id_NOT_CONTAINS: ID
  id_NOT_ENDS_WITH: ID
  id_NOT_IN: [ID]
  id_NOT_STARTS_WITH: ID
  id_STARTS_WITH: ID
}
