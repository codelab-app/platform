type App {
  id: ID!
  name: String!
  owner(options: UserOptions, where: UserWhere): [User]
  ownerAggregate(where: UserWhere): AppUserOwnerAggregationSelection
  ownerConnection(
    after: String
    first: Int
    sort: [AppOwnerConnectionSort!]
    where: AppOwnerConnectionWhere
  ): AppOwnerConnection!
  pages(options: PageOptions, where: PageWhere): [Page]
  pagesAggregate(where: PageWhere): AppPagePagesAggregationSelection
  pagesConnection(
    after: String
    first: Int
    sort: [AppPagesConnectionSort!]
    where: AppPagesConnectionWhere
  ): AppPagesConnection!
}

type AppAggregateSelection {
  count: Int!
  id: IDAggregateSelection!
  name: StringAggregateSelection!
}

input AppConnectInput {
  owner: [AppOwnerConnectFieldInput!]
  pages: [AppPagesConnectFieldInput!]
}

input AppConnectOrCreateInput {
  owner: [AppOwnerConnectOrCreateFieldInput!]
  pages: [AppPagesConnectOrCreateFieldInput!]
}

input AppConnectOrCreateWhere {
  node: AppUniqueWhere!
}

input AppConnectWhere {
  node: AppWhere!
}

input AppCreateInput {
  name: String!
  owner: AppOwnerFieldInput
  pages: AppPagesFieldInput
}

input AppDeleteInput {
  owner: [AppOwnerDeleteFieldInput!]
  pages: [AppPagesDeleteFieldInput!]
}

input AppDisconnectInput {
  owner: [AppOwnerDisconnectFieldInput!]
  pages: [AppPagesDisconnectFieldInput!]
}

input AppOptions {
  limit: Int
  offset: Int

  """
  Specify one or more AppSort objects to sort Apps by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [AppSort]
}

input AppOwnerAggregateInput {
  AND: [AppOwnerAggregateInput!]
  OR: [AppOwnerAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: AppOwnerNodeAggregationWhereInput
}

input AppOwnerConnectFieldInput {
  connect: [UserConnectInput!]
  where: UserConnectWhere
}

input AppOwnerConnectOrCreateFieldInput {
  onCreate: AppOwnerConnectOrCreateFieldInputOnCreate!
  where: UserConnectOrCreateWhere!
}

input AppOwnerConnectOrCreateFieldInputOnCreate {
  node: UserCreateInput!
}

type AppOwnerConnection {
  edges: [AppOwnerRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input AppOwnerConnectionSort {
  node: UserSort
}

input AppOwnerConnectionWhere {
  AND: [AppOwnerConnectionWhere!]
  OR: [AppOwnerConnectionWhere!]
  node: UserWhere
  node_NOT: UserWhere
}

input AppOwnerCreateFieldInput {
  node: UserCreateInput!
}

input AppOwnerDeleteFieldInput {
  delete: UserDeleteInput
  where: AppOwnerConnectionWhere
}

input AppOwnerDisconnectFieldInput {
  disconnect: UserDisconnectInput
  where: AppOwnerConnectionWhere
}

input AppOwnerFieldInput {
  connect: [AppOwnerConnectFieldInput!]
  connectOrCreate: [AppOwnerConnectOrCreateFieldInput!]
  create: [AppOwnerCreateFieldInput!]
}

input AppOwnerNodeAggregationWhereInput {
  AND: [AppOwnerNodeAggregationWhereInput!]
  OR: [AppOwnerNodeAggregationWhereInput!]
  auth0Id_AVERAGE_EQUAL: Float
  auth0Id_AVERAGE_GT: Float
  auth0Id_AVERAGE_GTE: Float
  auth0Id_AVERAGE_LT: Float
  auth0Id_AVERAGE_LTE: Float
  auth0Id_EQUAL: String
  auth0Id_GT: Int
  auth0Id_GTE: Int
  auth0Id_LONGEST_EQUAL: Int
  auth0Id_LONGEST_GT: Int
  auth0Id_LONGEST_GTE: Int
  auth0Id_LONGEST_LT: Int
  auth0Id_LONGEST_LTE: Int
  auth0Id_LT: Int
  auth0Id_LTE: Int
  auth0Id_SHORTEST_EQUAL: Int
  auth0Id_SHORTEST_GT: Int
  auth0Id_SHORTEST_GTE: Int
  auth0Id_SHORTEST_LT: Int
  auth0Id_SHORTEST_LTE: Int
  email_AVERAGE_EQUAL: Float
  email_AVERAGE_GT: Float
  email_AVERAGE_GTE: Float
  email_AVERAGE_LT: Float
  email_AVERAGE_LTE: Float
  email_EQUAL: String
  email_GT: Int
  email_GTE: Int
  email_LONGEST_EQUAL: Int
  email_LONGEST_GT: Int
  email_LONGEST_GTE: Int
  email_LONGEST_LT: Int
  email_LONGEST_LTE: Int
  email_LT: Int
  email_LTE: Int
  email_SHORTEST_EQUAL: Int
  email_SHORTEST_GT: Int
  email_SHORTEST_GTE: Int
  email_SHORTEST_LT: Int
  email_SHORTEST_LTE: Int
  id_EQUAL: ID
}

type AppOwnerRelationship {
  cursor: String!
  node: User!
}

input AppOwnerUpdateConnectionInput {
  node: UserUpdateInput
}

input AppOwnerUpdateFieldInput {
  connect: [AppOwnerConnectFieldInput!]
  connectOrCreate: [AppOwnerConnectOrCreateFieldInput!]
  create: [AppOwnerCreateFieldInput!]
  delete: [AppOwnerDeleteFieldInput!]
  disconnect: [AppOwnerDisconnectFieldInput!]
  update: AppOwnerUpdateConnectionInput
  where: AppOwnerConnectionWhere
}

type AppPagePagesAggregationSelection {
  count: Int!
  node: AppPagePagesNodeAggregateSelection
}

type AppPagePagesNodeAggregateSelection {
  id: IDAggregateSelection!
  name: StringAggregateSelection!
}

input AppPagesAggregateInput {
  AND: [AppPagesAggregateInput!]
  OR: [AppPagesAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: AppPagesNodeAggregationWhereInput
}

input AppPagesConnectFieldInput {
  connect: [PageConnectInput!]
  where: PageConnectWhere
}

input AppPagesConnectOrCreateFieldInput {
  onCreate: AppPagesConnectOrCreateFieldInputOnCreate!
  where: PageConnectOrCreateWhere!
}

input AppPagesConnectOrCreateFieldInputOnCreate {
  node: PageCreateInput!
}

type AppPagesConnection {
  edges: [AppPagesRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input AppPagesConnectionSort {
  node: PageSort
}

input AppPagesConnectionWhere {
  AND: [AppPagesConnectionWhere!]
  OR: [AppPagesConnectionWhere!]
  node: PageWhere
  node_NOT: PageWhere
}

input AppPagesCreateFieldInput {
  node: PageCreateInput!
}

input AppPagesDeleteFieldInput {
  delete: PageDeleteInput
  where: AppPagesConnectionWhere
}

input AppPagesDisconnectFieldInput {
  disconnect: PageDisconnectInput
  where: AppPagesConnectionWhere
}

input AppPagesFieldInput {
  connect: [AppPagesConnectFieldInput!]
  connectOrCreate: [AppPagesConnectOrCreateFieldInput!]
  create: [AppPagesCreateFieldInput!]
}

input AppPagesNodeAggregationWhereInput {
  AND: [AppPagesNodeAggregationWhereInput!]
  OR: [AppPagesNodeAggregationWhereInput!]
  id_EQUAL: ID
  name_AVERAGE_EQUAL: Float
  name_AVERAGE_GT: Float
  name_AVERAGE_GTE: Float
  name_AVERAGE_LT: Float
  name_AVERAGE_LTE: Float
  name_EQUAL: String
  name_GT: Int
  name_GTE: Int
  name_LONGEST_EQUAL: Int
  name_LONGEST_GT: Int
  name_LONGEST_GTE: Int
  name_LONGEST_LT: Int
  name_LONGEST_LTE: Int
  name_LT: Int
  name_LTE: Int
  name_SHORTEST_EQUAL: Int
  name_SHORTEST_GT: Int
  name_SHORTEST_GTE: Int
  name_SHORTEST_LT: Int
  name_SHORTEST_LTE: Int
}

type AppPagesRelationship {
  cursor: String!
  node: Page!
}

input AppPagesUpdateConnectionInput {
  node: PageUpdateInput
}

input AppPagesUpdateFieldInput {
  connect: [AppPagesConnectFieldInput!]
  connectOrCreate: [AppPagesConnectOrCreateFieldInput!]
  create: [AppPagesCreateFieldInput!]
  delete: [AppPagesDeleteFieldInput!]
  disconnect: [AppPagesDisconnectFieldInput!]
  update: AppPagesUpdateConnectionInput
  where: AppPagesConnectionWhere
}

input AppRelationInput {
  owner: [AppOwnerCreateFieldInput!]
  pages: [AppPagesCreateFieldInput!]
}

"""
Fields to sort Apps by. The order in which sorts are applied is not guaranteed when specifying many fields in one AppSort object.
"""
input AppSort {
  id: SortDirection
  name: SortDirection
}

input AppUniqueWhere {
  id: ID
}

input AppUpdateInput {
  name: String
  owner: [AppOwnerUpdateFieldInput!]
  pages: [AppPagesUpdateFieldInput!]
}

type AppUserOwnerAggregationSelection {
  count: Int!
  node: AppUserOwnerNodeAggregateSelection
}

type AppUserOwnerNodeAggregateSelection {
  auth0Id: StringAggregateSelection!
  email: StringAggregateSelection!
  id: IDAggregateSelection!
}

input AppWhere {
  AND: [AppWhere!]
  OR: [AppWhere!]
  id: ID
  id_CONTAINS: ID
  id_ENDS_WITH: ID
  id_IN: [ID]
  id_NOT: ID
  id_NOT_CONTAINS: ID
  id_NOT_ENDS_WITH: ID
  id_NOT_IN: [ID]
  id_NOT_STARTS_WITH: ID
  id_STARTS_WITH: ID
  name: String
  name_CONTAINS: String
  name_ENDS_WITH: String
  name_IN: [String]
  name_NOT: String
  name_NOT_CONTAINS: String
  name_NOT_ENDS_WITH: String
  name_NOT_IN: [String]
  name_NOT_STARTS_WITH: String
  name_STARTS_WITH: String
  owner: UserWhere
  ownerAggregate: AppOwnerAggregateInput
  ownerConnection: AppOwnerConnectionWhere
  ownerConnection_NOT: AppOwnerConnectionWhere
  owner_NOT: UserWhere
  pages: PageWhere
  pagesAggregate: AppPagesAggregateInput
  pagesConnection: AppPagesConnectionWhere
  pagesConnection_NOT: AppPagesConnectionWhere
  pages_NOT: PageWhere
}

type Atom {
  id: ID!
  name: String!
  type: AtomType!
}

type AtomAggregateSelection {
  count: Int!
  id: IDAggregateSelection!
  name: StringAggregateSelection!
}

input AtomCreateInput {
  name: String!
  type: AtomType!
}

input AtomOptions {
  limit: Int
  offset: Int

  """
  Specify one or more AtomSort objects to sort Atoms by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [AtomSort]
}

"""
Fields to sort Atoms by. The order in which sorts are applied is not guaranteed when specifying many fields in one AtomSort object.
"""
input AtomSort {
  id: SortDirection
  name: SortDirection
  type: SortDirection
}

enum AtomType {
  AntDesignAffix
  AntDesignAlert
  AntDesignAnchor
  AntDesignAnchorLink
  AntDesignAutoComplete
  AntDesignAvatar
  AntDesignBackTop
  AntDesignBadge
  AntDesignBreadcrumb
  AntDesignBreadcrumbItem
  AntDesignButton
  AntDesignCalendar
  AntDesignCard
  AntDesignCardGrid
  AntDesignCardMeta
  AntDesignCarousel
  AntDesignCascader
  AntDesignCheckbox
  AntDesignCollapse
  AntDesignCollapsePanel
  AntDesignComment
  AntDesignConfigProvider
  AntDesignDatePicker
  AntDesignDescriptions
  AntDesignDescriptionsItem
  AntDesignDivider
  AntDesignDrawer
  AntDesignDropdown
  AntDesignEmpty
  AntDesignForm
  AntDesignFormItem
  AntDesignFormItemHook
  AntDesignFormList
  AntDesignGridCol
  AntDesignGridRow
  AntDesignIcon
  AntDesignImage
  AntDesignInput
  AntDesignInputNumber
  AntDesignLayout
  AntDesignLayoutContent
  AntDesignLayoutFooter
  AntDesignLayoutHeader
  AntDesignLayoutSider
  AntDesignList
  AntDesignListItem
  AntDesignListItemMeta
  AntDesignMapper
  AntDesignMentions
  AntDesignMentionsOption
  AntDesignMenu
  AntDesignMenuItem
  AntDesignMenuItemGroup
  AntDesignMenuSubMenu
  AntDesignModal
  AntDesignPageContainer
  AntDesignPageHeader
  AntDesignPagination
  AntDesignPopconfirm
  AntDesignPopover
  AntDesignProgress
  AntDesignProvider
  AntDesignRadio
  AntDesignRadioGroup
  AntDesignRate
  AntDesignRenderComponent
  AntDesignRenderContainer
  AntDesignResult
  AntDesignRglContainer
  AntDesignRglItem
  AntDesignRglResponsiveContainer
  AntDesignSelect
  AntDesignSelectOption
  AntDesignSkeleton
  AntDesignSlider
  AntDesignSpace
  AntDesignSpin
  AntDesignStatistic
  AntDesignSteps
  AntDesignStepsStep
  AntDesignSwitch
  AntDesignTable
  AntDesignTabs
  AntDesignTabsTabPane
  AntDesignTag
  AntDesignTimePicker
  AntDesignTimeline
  AntDesignTimelineItem
  AntDesignTooltip
  AntDesignTransfer
  AntDesignTree
  AntDesignTreeNode
  AntDesignTreeSelect
  AntDesignTypography
  AntDesignTypographyParagraph
  AntDesignTypographyText
  AntDesignTypographyTitle
  AntDesignUpload
  HookGraphqlMutation
  HookGraphqlQuery
  HookQueryConfig
  HookQueryLambda
  HookQueryPage
  HookQueryPages
  HookRecoilState
  HookRouter
  HtmlA
  HtmlArea
  HtmlAside
  HtmlAudio
  HtmlBase
  HtmlBr
  HtmlButton
  HtmlCanvas
  HtmlCode
  HtmlDList
  HtmlData
  HtmlDatalist
  HtmlDetails
  HtmlDialog
  HtmlDiv
  HtmlEm
  HtmlEmbed
  HtmlFieldset
  HtmlFont
  HtmlFooter
  HtmlForm
  HtmlFrame
  HtmlFrameset
  HtmlH1
  HtmlH2
  HtmlH3
  HtmlH4
  HtmlH5
  HtmlH6
  HtmlHead
  HtmlHeader
  HtmlHr
  HtmlI
  HtmlIframe
  HtmlImage
  HtmlInput
  HtmlLabel
  HtmlLegend
  HtmlLi
  HtmlLink
  HtmlMain
  HtmlMap
  HtmlMeta
  HtmlMeter
  HtmlNav
  HtmlOList
  HtmlObject
  HtmlOptgroup
  HtmlOption
  HtmlOutput
  HtmlP
  HtmlParam
  HtmlPicture
  HtmlPre
  HtmlProgress
  HtmlQuote
  HtmlS
  HtmlSection
  HtmlSelect
  HtmlSmall
  HtmlSource
  HtmlSpan
  HtmlStrong
  HtmlStyle
  HtmlSub
  HtmlSup
  HtmlTable
  HtmlTableCaption
  HtmlTableCell
  HtmlTableCol
  HtmlTableRow
  HtmlTemplate
  HtmlTextarea
  HtmlTime
  HtmlTitle
  HtmlTrack
  HtmlUList
  HtmlVideo
  MuiAccordion
  MuiAccordionActions
  MuiAccordionDetails
  MuiAccordionSummary
  MuiAlert
  MuiAlertTitle
  MuiAppBar
  MuiAutocomplete
  MuiAvatar
  MuiAvatarGroup
  MuiBackdrop
  MuiBackdropUnstyled
  MuiBadge
  MuiBadgeUnstyled
  MuiBottomNavigation
  MuiBottomNavigationAction
  MuiBox
  MuiBreadcrumbs
  MuiButton
  MuiButtonBase
  MuiButtonGroup
  MuiButtonUnstyled
  MuiCalendarPicker
  MuiCalendarPickerSkeleton
  MuiCard
  MuiCardActionArea
  MuiCardActions
  MuiCardContent
  MuiCardHeader
  MuiCardMedia
  MuiCheckbox
  MuiChip
  MuiCircularProgress
  MuiClickAwayListener
  MuiClockPicker
  MuiCollapse
  MuiContainer
  MuiCssBaseline
  MuiDataGrid
  MuiDatePicker
  MuiDateRangePicker
  MuiDateRangePickerDay
  MuiDateTimePicker
  MuiDesktopDatePicker
  MuiDesktopDateRangePicker
  MuiDesktopDateTimePicker
  MuiDesktopTimePicker
  MuiDialog
  MuiDialogActions
  MuiDialogContent
  MuiDialogContentText
  MuiDialogTitle
  MuiDivider
  MuiDrawer
  MuiFab
  MuiFade
  MuiFilledInput
  MuiFormControl
  MuiFormControlLabel
  MuiFormControlUnstyled
  MuiFormGroup
  MuiFormHelperText
  MuiFormLabel
  MuiGlobalStyles
  MuiGrid
  MuiGridColDef
  MuiGrow
  MuiHidden
  MuiIcon
  MuiIconButton
  MuiImageList
  MuiImageListItem
  MuiImageListItemBar
  MuiInput
  MuiInputAdornment
  MuiInputBase
  MuiInputLabel
  MuiLinearProgress
  MuiLink
  MuiList
  MuiListItem
  MuiListItemAvatar
  MuiListItemButton
  MuiListItemIcon
  MuiListItemSecondaryAction
  MuiListItemText
  MuiListSubheader
  MuiLoadingButton
  MuiMasonry
  MuiMasonryItem
  MuiMenu
  MuiMenuItem
  MuiMenuList
  MuiMobileDatePicker
  MuiMobileDateRangePicker
  MuiMobileDateTimePicker
  MuiMobileStepper
  MuiMobileTimePicker
  MuiModal
  MuiModalUnstyled
  MuiMonthPicker
  MuiNativeSelect
  MuiNoSsr
  MuiOutlinedInput
  MuiPagination
  MuiPaginationItem
  MuiPaper
  MuiPickersDay
  MuiPopover
  MuiPopper
  MuiPortal
  MuiRadio
  MuiRadioGroup
  MuiRating
  MuiScopedCssBaseline
  MuiSelect
  MuiSkeleton
  MuiSlide
  MuiSlider
  MuiSliderUnstyled
  MuiSnackbar
  MuiSnackbarContent
  MuiSpeedDial
  MuiSpeedDialAction
  MuiSpeedDialIcon
  MuiStack
  MuiStaticDatePicker
  MuiStaticDateRangePicker
  MuiStaticDateTimePicker
  MuiStaticTimePicker
  MuiStep
  MuiStepButton
  MuiStepConnector
  MuiStepContent
  MuiStepIcon
  MuiStepLabel
  MuiStepper
  MuiSvgIcon
  MuiSwipeableDrawer
  MuiSwitch
  MuiSwitchUnstyled
  MuiTab
  MuiTabContext
  MuiTabList
  MuiTabPanel
  MuiTabScrollButton
  MuiTable
  MuiTableBody
  MuiTableCell
  MuiTableContainer
  MuiTableFooter
  MuiTableHead
  MuiTablePagination
  MuiTableRow
  MuiTableSortLabel
  MuiTabs
  MuiTextField
  MuiTextareaAutosize
  MuiTimePicker
  MuiTimeline
  MuiTimelineConnector
  MuiTimelineContent
  MuiTimelineDot
  MuiTimelineItem
  MuiTimelineOppositeContent
  MuiTimelineSeparator
  MuiToggleButton
  MuiToggleButtonGroup
  MuiToolbar
  MuiTooltip
  MuiTreeItem
  MuiTreeView
  MuiTypography
  MuiUnstableTrapFocus
  MuiYearPicker
  MuiZoom
  Query
  ReactFragment
  State
  Text
  TextList
}

input AtomUpdateInput {
  name: String
  type: AtomType
}

input AtomWhere {
  AND: [AtomWhere!]
  OR: [AtomWhere!]
  id: ID
  id_CONTAINS: ID
  id_ENDS_WITH: ID
  id_IN: [ID]
  id_NOT: ID
  id_NOT_CONTAINS: ID
  id_NOT_ENDS_WITH: ID
  id_NOT_IN: [ID]
  id_NOT_STARTS_WITH: ID
  id_STARTS_WITH: ID
  name: String
  name_CONTAINS: String
  name_ENDS_WITH: String
  name_IN: [String]
  name_NOT: String
  name_NOT_CONTAINS: String
  name_NOT_ENDS_WITH: String
  name_NOT_IN: [String]
  name_NOT_STARTS_WITH: String
  name_STARTS_WITH: String
  type: AtomType
  type_IN: [AtomType]
  type_NOT: AtomType
  type_NOT_IN: [AtomType]
}

type CreateAppsMutationResponse {
  apps: [App!]!
  info: CreateInfo!
}

type CreateAtomsMutationResponse {
  atoms: [Atom!]!
  info: CreateInfo!
}

type CreateCreateInfosMutationResponse {
  createInfos: [CreateInfo!]!
  info: CreateInfo!
}

type CreateElementsMutationResponse {
  elements: [Element!]!
  info: CreateInfo!
}

type CreateImportAtomsMutationResponsesMutationResponse {
  importAtomsMutationResponses: [ImportAtomsMutationResponse!]!
  info: CreateInfo!
}

type CreateInfo {
  bookmark: String
  nodesCreated: Int!
  relationshipsCreated: Int!
}

type CreateInfoAggregateSelection {
  bookmark: StringAggregateSelection!
  count: Int!
  nodesCreated: IntAggregateSelection!
  relationshipsCreated: IntAggregateSelection!
}

input CreateInfoCreateInput {
  bookmark: String
  nodesCreated: Int!
  relationshipsCreated: Int!
}

input CreateInfoOptions {
  limit: Int
  offset: Int

  """
  Specify one or more CreateInfoSort objects to sort CreateInfos by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [CreateInfoSort]
}

"""
Fields to sort CreateInfos by. The order in which sorts are applied is not guaranteed when specifying many fields in one CreateInfoSort object.
"""
input CreateInfoSort {
  bookmark: SortDirection
  nodesCreated: SortDirection
  relationshipsCreated: SortDirection
}

input CreateInfoUpdateInput {
  bookmark: String
  nodesCreated: Int
  relationshipsCreated: Int
}

input CreateInfoWhere {
  AND: [CreateInfoWhere!]
  OR: [CreateInfoWhere!]
  bookmark: String
  bookmark_CONTAINS: String
  bookmark_ENDS_WITH: String
  bookmark_IN: [String]
  bookmark_NOT: String
  bookmark_NOT_CONTAINS: String
  bookmark_NOT_ENDS_WITH: String
  bookmark_NOT_IN: [String]
  bookmark_NOT_STARTS_WITH: String
  bookmark_STARTS_WITH: String
  nodesCreated: Int
  nodesCreated_GT: Int
  nodesCreated_GTE: Int
  nodesCreated_IN: [Int]
  nodesCreated_LT: Int
  nodesCreated_LTE: Int
  nodesCreated_NOT: Int
  nodesCreated_NOT_IN: [Int]
  relationshipsCreated: Int
  relationshipsCreated_GT: Int
  relationshipsCreated_GTE: Int
  relationshipsCreated_IN: [Int]
  relationshipsCreated_LT: Int
  relationshipsCreated_LTE: Int
  relationshipsCreated_NOT: Int
  relationshipsCreated_NOT_IN: [Int]
}

type CreatePagesMutationResponse {
  info: CreateInfo!
  pages: [Page!]!
}

type CreateTagEdgesMutationResponse {
  info: CreateInfo!
  tagEdges: [TagEdge!]!
}

type CreateTagGraphsMutationResponse {
  info: CreateInfo!
  tagGraphs: [TagGraph!]!
}

type CreateTagsMutationResponse {
  info: CreateInfo!
  tags: [Tag!]!
}

"""
A date and time, represented as an ISO-8601 string
"""
scalar DateTime

type DateTimeAggregateSelection {
  max: DateTime
  min: DateTime
}

type DeleteInfo {
  bookmark: String
  nodesDeleted: Int!
  relationshipsDeleted: Int!
}

type Element {
  children(options: ElementOptions, where: ElementWhere): [Element!]
  childrenAggregate(
    where: ElementWhere
  ): ElementElementChildrenAggregationSelection
  childrenConnection(
    after: String
    first: Int
    sort: [ElementChildrenConnectionSort!]
    where: ElementChildrenConnectionWhere
  ): ElementChildrenConnection!
  createdAt: DateTime!
  graph: IElementGraph!
  id: ID!
  name: String!
  ownerId: String!
  parent(options: ElementOptions, where: ElementWhere): Element
  parentAggregate(where: ElementWhere): ElementElementParentAggregationSelection
  parentConnection(
    after: String
    first: Int
    sort: [ElementParentConnectionSort!]
    where: ElementParentConnectionWhere
  ): ElementParentConnection!
  updatedAt: DateTime
}

type ElementAggregateSelection {
  count: Int!
  createdAt: DateTimeAggregateSelection!
  id: IDAggregateSelection!
  name: StringAggregateSelection!
  ownerId: StringAggregateSelection!
  updatedAt: DateTimeAggregateSelection!
}

input ElementChildrenAggregateInput {
  AND: [ElementChildrenAggregateInput!]
  OR: [ElementChildrenAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: ElementChildrenNodeAggregationWhereInput
}

input ElementChildrenConnectFieldInput {
  connect: [ElementConnectInput!]
  where: ElementConnectWhere
}

input ElementChildrenConnectOrCreateFieldInput {
  onCreate: ElementChildrenConnectOrCreateFieldInputOnCreate!
  where: ElementConnectOrCreateWhere!
}

input ElementChildrenConnectOrCreateFieldInputOnCreate {
  node: ElementCreateInput!
}

type ElementChildrenConnection {
  edges: [ElementChildrenRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input ElementChildrenConnectionSort {
  node: ElementSort
}

input ElementChildrenConnectionWhere {
  AND: [ElementChildrenConnectionWhere!]
  OR: [ElementChildrenConnectionWhere!]
  node: ElementWhere
  node_NOT: ElementWhere
}

input ElementChildrenCreateFieldInput {
  node: ElementCreateInput!
}

input ElementChildrenDeleteFieldInput {
  delete: ElementDeleteInput
  where: ElementChildrenConnectionWhere
}

input ElementChildrenDisconnectFieldInput {
  disconnect: ElementDisconnectInput
  where: ElementChildrenConnectionWhere
}

input ElementChildrenFieldInput {
  connect: [ElementChildrenConnectFieldInput!]
  connectOrCreate: [ElementChildrenConnectOrCreateFieldInput!]
  create: [ElementChildrenCreateFieldInput!]
}

input ElementChildrenNodeAggregationWhereInput {
  AND: [ElementChildrenNodeAggregationWhereInput!]
  OR: [ElementChildrenNodeAggregationWhereInput!]
  createdAt_EQUAL: DateTime
  createdAt_GT: DateTime
  createdAt_GTE: DateTime
  createdAt_LT: DateTime
  createdAt_LTE: DateTime
  createdAt_MAX_EQUAL: DateTime
  createdAt_MAX_GT: DateTime
  createdAt_MAX_GTE: DateTime
  createdAt_MAX_LT: DateTime
  createdAt_MAX_LTE: DateTime
  createdAt_MIN_EQUAL: DateTime
  createdAt_MIN_GT: DateTime
  createdAt_MIN_GTE: DateTime
  createdAt_MIN_LT: DateTime
  createdAt_MIN_LTE: DateTime
  id_EQUAL: ID
  name_AVERAGE_EQUAL: Float
  name_AVERAGE_GT: Float
  name_AVERAGE_GTE: Float
  name_AVERAGE_LT: Float
  name_AVERAGE_LTE: Float
  name_EQUAL: String
  name_GT: Int
  name_GTE: Int
  name_LONGEST_EQUAL: Int
  name_LONGEST_GT: Int
  name_LONGEST_GTE: Int
  name_LONGEST_LT: Int
  name_LONGEST_LTE: Int
  name_LT: Int
  name_LTE: Int
  name_SHORTEST_EQUAL: Int
  name_SHORTEST_GT: Int
  name_SHORTEST_GTE: Int
  name_SHORTEST_LT: Int
  name_SHORTEST_LTE: Int
  ownerId_AVERAGE_EQUAL: Float
  ownerId_AVERAGE_GT: Float
  ownerId_AVERAGE_GTE: Float
  ownerId_AVERAGE_LT: Float
  ownerId_AVERAGE_LTE: Float
  ownerId_EQUAL: String
  ownerId_GT: Int
  ownerId_GTE: Int
  ownerId_LONGEST_EQUAL: Int
  ownerId_LONGEST_GT: Int
  ownerId_LONGEST_GTE: Int
  ownerId_LONGEST_LT: Int
  ownerId_LONGEST_LTE: Int
  ownerId_LT: Int
  ownerId_LTE: Int
  ownerId_SHORTEST_EQUAL: Int
  ownerId_SHORTEST_GT: Int
  ownerId_SHORTEST_GTE: Int
  ownerId_SHORTEST_LT: Int
  ownerId_SHORTEST_LTE: Int
  updatedAt_EQUAL: DateTime
  updatedAt_GT: DateTime
  updatedAt_GTE: DateTime
  updatedAt_LT: DateTime
  updatedAt_LTE: DateTime
  updatedAt_MAX_EQUAL: DateTime
  updatedAt_MAX_GT: DateTime
  updatedAt_MAX_GTE: DateTime
  updatedAt_MAX_LT: DateTime
  updatedAt_MAX_LTE: DateTime
  updatedAt_MIN_EQUAL: DateTime
  updatedAt_MIN_GT: DateTime
  updatedAt_MIN_GTE: DateTime
  updatedAt_MIN_LT: DateTime
  updatedAt_MIN_LTE: DateTime
}

type ElementChildrenRelationship {
  cursor: String!
  node: Element!
}

input ElementChildrenUpdateConnectionInput {
  node: ElementUpdateInput
}

input ElementChildrenUpdateFieldInput {
  connect: [ElementChildrenConnectFieldInput!]
  connectOrCreate: [ElementChildrenConnectOrCreateFieldInput!]
  create: [ElementChildrenCreateFieldInput!]
  delete: [ElementChildrenDeleteFieldInput!]
  disconnect: [ElementChildrenDisconnectFieldInput!]
  update: ElementChildrenUpdateConnectionInput
  where: ElementChildrenConnectionWhere
}

input ElementConnectInput {
  children: [ElementChildrenConnectFieldInput!]
  parent: ElementParentConnectFieldInput
}

input ElementConnectOrCreateInput {
  children: [ElementChildrenConnectOrCreateFieldInput!]
  parent: ElementParentConnectOrCreateFieldInput
}

input ElementConnectOrCreateWhere {
  node: ElementUniqueWhere!
}

input ElementConnectWhere {
  node: ElementWhere!
}

input ElementCreateInput {
  children: ElementChildrenFieldInput
  name: String!
  ownerId: String!
  parent: ElementParentFieldInput
}

input ElementDeleteInput {
  children: [ElementChildrenDeleteFieldInput!]
  parent: ElementParentDeleteFieldInput
}

input ElementDisconnectInput {
  children: [ElementChildrenDisconnectFieldInput!]
  parent: ElementParentDisconnectFieldInput
}

type ElementElementChildrenAggregationSelection {
  count: Int!
  node: ElementElementChildrenNodeAggregateSelection
}

type ElementElementChildrenNodeAggregateSelection {
  createdAt: DateTimeAggregateSelection!
  id: IDAggregateSelection!
  name: StringAggregateSelection!
  ownerId: StringAggregateSelection!
  updatedAt: DateTimeAggregateSelection!
}

type ElementElementParentAggregationSelection {
  count: Int!
  node: ElementElementParentNodeAggregateSelection
}

type ElementElementParentNodeAggregateSelection {
  createdAt: DateTimeAggregateSelection!
  id: IDAggregateSelection!
  name: StringAggregateSelection!
  ownerId: StringAggregateSelection!
  updatedAt: DateTimeAggregateSelection!
}

input ElementOptions {
  limit: Int
  offset: Int

  """
  Specify one or more ElementSort objects to sort Elements by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [ElementSort]
}

input ElementParentAggregateInput {
  AND: [ElementParentAggregateInput!]
  OR: [ElementParentAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: ElementParentNodeAggregationWhereInput
}

input ElementParentConnectFieldInput {
  connect: ElementConnectInput
  where: ElementConnectWhere
}

input ElementParentConnectOrCreateFieldInput {
  onCreate: ElementParentConnectOrCreateFieldInputOnCreate!
  where: ElementConnectOrCreateWhere!
}

input ElementParentConnectOrCreateFieldInputOnCreate {
  node: ElementCreateInput!
}

type ElementParentConnection {
  edges: [ElementParentRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input ElementParentConnectionSort {
  node: ElementSort
}

input ElementParentConnectionWhere {
  AND: [ElementParentConnectionWhere!]
  OR: [ElementParentConnectionWhere!]
  node: ElementWhere
  node_NOT: ElementWhere
}

input ElementParentCreateFieldInput {
  node: ElementCreateInput!
}

input ElementParentDeleteFieldInput {
  delete: ElementDeleteInput
  where: ElementParentConnectionWhere
}

input ElementParentDisconnectFieldInput {
  disconnect: ElementDisconnectInput
  where: ElementParentConnectionWhere
}

input ElementParentFieldInput {
  connect: ElementParentConnectFieldInput
  connectOrCreate: ElementParentConnectOrCreateFieldInput
  create: ElementParentCreateFieldInput
}

input ElementParentNodeAggregationWhereInput {
  AND: [ElementParentNodeAggregationWhereInput!]
  OR: [ElementParentNodeAggregationWhereInput!]
  createdAt_EQUAL: DateTime
  createdAt_GT: DateTime
  createdAt_GTE: DateTime
  createdAt_LT: DateTime
  createdAt_LTE: DateTime
  createdAt_MAX_EQUAL: DateTime
  createdAt_MAX_GT: DateTime
  createdAt_MAX_GTE: DateTime
  createdAt_MAX_LT: DateTime
  createdAt_MAX_LTE: DateTime
  createdAt_MIN_EQUAL: DateTime
  createdAt_MIN_GT: DateTime
  createdAt_MIN_GTE: DateTime
  createdAt_MIN_LT: DateTime
  createdAt_MIN_LTE: DateTime
  id_EQUAL: ID
  name_AVERAGE_EQUAL: Float
  name_AVERAGE_GT: Float
  name_AVERAGE_GTE: Float
  name_AVERAGE_LT: Float
  name_AVERAGE_LTE: Float
  name_EQUAL: String
  name_GT: Int
  name_GTE: Int
  name_LONGEST_EQUAL: Int
  name_LONGEST_GT: Int
  name_LONGEST_GTE: Int
  name_LONGEST_LT: Int
  name_LONGEST_LTE: Int
  name_LT: Int
  name_LTE: Int
  name_SHORTEST_EQUAL: Int
  name_SHORTEST_GT: Int
  name_SHORTEST_GTE: Int
  name_SHORTEST_LT: Int
  name_SHORTEST_LTE: Int
  ownerId_AVERAGE_EQUAL: Float
  ownerId_AVERAGE_GT: Float
  ownerId_AVERAGE_GTE: Float
  ownerId_AVERAGE_LT: Float
  ownerId_AVERAGE_LTE: Float
  ownerId_EQUAL: String
  ownerId_GT: Int
  ownerId_GTE: Int
  ownerId_LONGEST_EQUAL: Int
  ownerId_LONGEST_GT: Int
  ownerId_LONGEST_GTE: Int
  ownerId_LONGEST_LT: Int
  ownerId_LONGEST_LTE: Int
  ownerId_LT: Int
  ownerId_LTE: Int
  ownerId_SHORTEST_EQUAL: Int
  ownerId_SHORTEST_GT: Int
  ownerId_SHORTEST_GTE: Int
  ownerId_SHORTEST_LT: Int
  ownerId_SHORTEST_LTE: Int
  updatedAt_EQUAL: DateTime
  updatedAt_GT: DateTime
  updatedAt_GTE: DateTime
  updatedAt_LT: DateTime
  updatedAt_LTE: DateTime
  updatedAt_MAX_EQUAL: DateTime
  updatedAt_MAX_GT: DateTime
  updatedAt_MAX_GTE: DateTime
  updatedAt_MAX_LT: DateTime
  updatedAt_MAX_LTE: DateTime
  updatedAt_MIN_EQUAL: DateTime
  updatedAt_MIN_GT: DateTime
  updatedAt_MIN_GTE: DateTime
  updatedAt_MIN_LT: DateTime
  updatedAt_MIN_LTE: DateTime
}

type ElementParentRelationship {
  cursor: String!
  node: Element!
}

input ElementParentUpdateConnectionInput {
  node: ElementUpdateInput
}

input ElementParentUpdateFieldInput {
  connect: ElementParentConnectFieldInput
  connectOrCreate: ElementParentConnectOrCreateFieldInput
  create: ElementParentCreateFieldInput
  delete: ElementParentDeleteFieldInput
  disconnect: ElementParentDisconnectFieldInput
  update: ElementParentUpdateConnectionInput
  where: ElementParentConnectionWhere
}

input ElementRelationInput {
  children: [ElementChildrenCreateFieldInput!]
  parent: ElementParentCreateFieldInput
}

"""
Fields to sort Elements by. The order in which sorts are applied is not guaranteed when specifying many fields in one ElementSort object.
"""
input ElementSort {
  createdAt: SortDirection
  id: SortDirection
  name: SortDirection
  ownerId: SortDirection
  updatedAt: SortDirection
}

input ElementUniqueWhere {
  id: ID
}

input ElementUpdateInput {
  children: [ElementChildrenUpdateFieldInput!]
  name: String
  ownerId: String
  parent: ElementParentUpdateFieldInput
}

input ElementWhere {
  AND: [ElementWhere!]
  OR: [ElementWhere!]
  children: ElementWhere
  childrenAggregate: ElementChildrenAggregateInput
  childrenConnection: ElementChildrenConnectionWhere
  childrenConnection_NOT: ElementChildrenConnectionWhere
  children_NOT: ElementWhere
  createdAt: DateTime
  createdAt_GT: DateTime
  createdAt_GTE: DateTime
  createdAt_IN: [DateTime]
  createdAt_LT: DateTime
  createdAt_LTE: DateTime
  createdAt_NOT: DateTime
  createdAt_NOT_IN: [DateTime]
  id: ID
  id_CONTAINS: ID
  id_ENDS_WITH: ID
  id_IN: [ID]
  id_NOT: ID
  id_NOT_CONTAINS: ID
  id_NOT_ENDS_WITH: ID
  id_NOT_IN: [ID]
  id_NOT_STARTS_WITH: ID
  id_STARTS_WITH: ID
  name: String
  name_CONTAINS: String
  name_ENDS_WITH: String
  name_IN: [String]
  name_NOT: String
  name_NOT_CONTAINS: String
  name_NOT_ENDS_WITH: String
  name_NOT_IN: [String]
  name_NOT_STARTS_WITH: String
  name_STARTS_WITH: String
  ownerId: String
  ownerId_CONTAINS: String
  ownerId_ENDS_WITH: String
  ownerId_IN: [String]
  ownerId_NOT: String
  ownerId_NOT_CONTAINS: String
  ownerId_NOT_ENDS_WITH: String
  ownerId_NOT_IN: [String]
  ownerId_NOT_STARTS_WITH: String
  ownerId_STARTS_WITH: String
  parent: ElementWhere
  parentAggregate: ElementParentAggregateInput
  parentConnection: ElementParentConnectionWhere
  parentConnection_NOT: ElementParentConnectionWhere
  parent_NOT: ElementWhere
  updatedAt: DateTime
  updatedAt_GT: DateTime
  updatedAt_GTE: DateTime
  updatedAt_IN: [DateTime]
  updatedAt_LT: DateTime
  updatedAt_LTE: DateTime
  updatedAt_NOT: DateTime
  updatedAt_NOT_IN: [DateTime]
}

type IDAggregateSelection {
  longest: ID
  shortest: ID
}

interface IElementGraph {
  root: Element
  vertices: [Element!]
}

interface IGraph {
  edges: [TagEdge!]!
  vertices: [TagVertex!]!
}

input ImportAtomsInput {
  payload: JSONObject!
}

type ImportAtomsMutationResponse {
  atoms: [Atom!]
}

type ImportAtomsMutationResponseAggregateSelection {
  count: Int!
}

input ImportAtomsMutationResponseCreateInput {
  """
  Appears because this input type would be empty otherwise because this type is composed of just generated and/or relationship properties. See https://neo4j.com/docs/graphql-manual/current/troubleshooting/faqs/
  """
  _emptyInput: Boolean
}

input ImportAtomsMutationResponseOptions {
  limit: Int
  offset: Int
}

input ImportAtomsMutationResponseUpdateInput {
  """
  Appears because this input type would be empty otherwise because this type is composed of just generated and/or relationship properties. See https://neo4j.com/docs/graphql-manual/current/troubleshooting/faqs/
  """
  _emptyInput: Boolean
}

input ImportAtomsMutationResponseWhere {
  AND: [ImportAtomsMutationResponseWhere!]
  OR: [ImportAtomsMutationResponseWhere!]
}

type IntAggregateSelection {
  average: Float
  max: Int
  min: Int
  sum: Int
}

"""
The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

type Mutation {
  createApps(input: [AppCreateInput!]!): CreateAppsMutationResponse!
  createAtoms(input: [AtomCreateInput!]!): CreateAtomsMutationResponse!
  createCreateInfos(
    input: [CreateInfoCreateInput!]!
  ): CreateCreateInfosMutationResponse!
  createElements(input: [ElementCreateInput!]!): CreateElementsMutationResponse!
  createImportAtomsMutationResponses(
    input: [ImportAtomsMutationResponseCreateInput!]!
  ): CreateImportAtomsMutationResponsesMutationResponse!
  createPages(input: [PageCreateInput!]!): CreatePagesMutationResponse!
  createTagEdges(input: [TagEdgeCreateInput!]!): CreateTagEdgesMutationResponse!
  createTagGraphs(
    input: [TagGraphCreateInput!]!
  ): CreateTagGraphsMutationResponse!
  createTags(input: [TagCreateInput!]!): CreateTagsMutationResponse!
  deleteApps(delete: AppDeleteInput, where: AppWhere): DeleteInfo!
  deleteAtoms(where: AtomWhere): DeleteInfo!
  deleteCreateInfos(where: CreateInfoWhere): DeleteInfo!
  deleteElements(delete: ElementDeleteInput, where: ElementWhere): DeleteInfo!
  deleteImportAtomsMutationResponses(
    where: ImportAtomsMutationResponseWhere
  ): DeleteInfo!
  deletePages(delete: PageDeleteInput, where: PageWhere): DeleteInfo!
  deleteTagEdges(where: TagEdgeWhere): DeleteInfo!
  deleteTagGraphs(where: TagGraphWhere): DeleteInfo!
  deleteTags(delete: TagDeleteInput, where: TagWhere): DeleteInfo!
  deleteUsers(delete: UserDeleteInput, where: UserWhere): DeleteInfo!
  importAtoms(input: ImportAtomsInput!): ImportAtomsMutationResponse
  updateApps(
    connect: AppConnectInput
    connectOrCreate: AppConnectOrCreateInput
    create: AppRelationInput
    delete: AppDeleteInput
    disconnect: AppDisconnectInput
    update: AppUpdateInput
    where: AppWhere
  ): UpdateAppsMutationResponse!
  updateAtoms(
    update: AtomUpdateInput
    where: AtomWhere
  ): UpdateAtomsMutationResponse!
  updateCreateInfos(
    update: CreateInfoUpdateInput
    where: CreateInfoWhere
  ): UpdateCreateInfosMutationResponse!
  updateElements(
    connect: ElementConnectInput
    connectOrCreate: ElementConnectOrCreateInput
    create: ElementRelationInput
    delete: ElementDeleteInput
    disconnect: ElementDisconnectInput
    update: ElementUpdateInput
    where: ElementWhere
  ): UpdateElementsMutationResponse!
  updateImportAtomsMutationResponses(
    update: ImportAtomsMutationResponseUpdateInput
    where: ImportAtomsMutationResponseWhere
  ): UpdateImportAtomsMutationResponsesMutationResponse!
  updatePages(
    connect: PageConnectInput
    connectOrCreate: PageConnectOrCreateInput
    create: PageRelationInput
    delete: PageDeleteInput
    disconnect: PageDisconnectInput
    update: PageUpdateInput
    where: PageWhere
  ): UpdatePagesMutationResponse!
  updateTagEdges(
    update: TagEdgeUpdateInput
    where: TagEdgeWhere
  ): UpdateTagEdgesMutationResponse!
  updateTagGraphs(
    update: TagGraphUpdateInput
    where: TagGraphWhere
  ): UpdateTagGraphsMutationResponse!
  updateTags(
    connect: TagConnectInput
    connectOrCreate: TagConnectOrCreateInput
    create: TagRelationInput
    delete: TagDeleteInput
    disconnect: TagDisconnectInput
    update: TagUpdateInput
    where: TagWhere
  ): UpdateTagsMutationResponse!
}

type Page {
  app(options: AppOptions, where: AppWhere): App
  appAggregate(where: AppWhere): PageAppAppAggregationSelection
  appConnection(
    after: String
    first: Int
    sort: [PageAppConnectionSort!]
    where: PageAppConnectionWhere
  ): PageAppConnection!
  id: ID!
  name: String!
  rootElement(options: ElementOptions, where: ElementWhere): Element
  rootElementAggregate(
    where: ElementWhere
  ): PageElementRootElementAggregationSelection
  rootElementConnection(
    after: String
    first: Int
    sort: [PageRootElementConnectionSort!]
    where: PageRootElementConnectionWhere
  ): PageRootElementConnection!
}

type PageAggregateSelection {
  count: Int!
  id: IDAggregateSelection!
  name: StringAggregateSelection!
}

input PageAppAggregateInput {
  AND: [PageAppAggregateInput!]
  OR: [PageAppAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: PageAppNodeAggregationWhereInput
}

type PageAppAppAggregationSelection {
  count: Int!
  node: PageAppAppNodeAggregateSelection
}

type PageAppAppNodeAggregateSelection {
  id: IDAggregateSelection!
  name: StringAggregateSelection!
}

input PageAppConnectFieldInput {
  connect: AppConnectInput
  where: AppConnectWhere
}

input PageAppConnectOrCreateFieldInput {
  onCreate: PageAppConnectOrCreateFieldInputOnCreate!
  where: AppConnectOrCreateWhere!
}

input PageAppConnectOrCreateFieldInputOnCreate {
  node: AppCreateInput!
}

type PageAppConnection {
  edges: [PageAppRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input PageAppConnectionSort {
  node: AppSort
}

input PageAppConnectionWhere {
  AND: [PageAppConnectionWhere!]
  OR: [PageAppConnectionWhere!]
  node: AppWhere
  node_NOT: AppWhere
}

input PageAppCreateFieldInput {
  node: AppCreateInput!
}

input PageAppDeleteFieldInput {
  delete: AppDeleteInput
  where: PageAppConnectionWhere
}

input PageAppDisconnectFieldInput {
  disconnect: AppDisconnectInput
  where: PageAppConnectionWhere
}

input PageAppFieldInput {
  connect: PageAppConnectFieldInput
  connectOrCreate: PageAppConnectOrCreateFieldInput
  create: PageAppCreateFieldInput
}

input PageAppNodeAggregationWhereInput {
  AND: [PageAppNodeAggregationWhereInput!]
  OR: [PageAppNodeAggregationWhereInput!]
  id_EQUAL: ID
  name_AVERAGE_EQUAL: Float
  name_AVERAGE_GT: Float
  name_AVERAGE_GTE: Float
  name_AVERAGE_LT: Float
  name_AVERAGE_LTE: Float
  name_EQUAL: String
  name_GT: Int
  name_GTE: Int
  name_LONGEST_EQUAL: Int
  name_LONGEST_GT: Int
  name_LONGEST_GTE: Int
  name_LONGEST_LT: Int
  name_LONGEST_LTE: Int
  name_LT: Int
  name_LTE: Int
  name_SHORTEST_EQUAL: Int
  name_SHORTEST_GT: Int
  name_SHORTEST_GTE: Int
  name_SHORTEST_LT: Int
  name_SHORTEST_LTE: Int
}

type PageAppRelationship {
  cursor: String!
  node: App!
}

input PageAppUpdateConnectionInput {
  node: AppUpdateInput
}

input PageAppUpdateFieldInput {
  connect: PageAppConnectFieldInput
  connectOrCreate: PageAppConnectOrCreateFieldInput
  create: PageAppCreateFieldInput
  delete: PageAppDeleteFieldInput
  disconnect: PageAppDisconnectFieldInput
  update: PageAppUpdateConnectionInput
  where: PageAppConnectionWhere
}

input PageConnectInput {
  app: PageAppConnectFieldInput
  rootElement: PageRootElementConnectFieldInput
}

input PageConnectOrCreateInput {
  app: PageAppConnectOrCreateFieldInput
  rootElement: PageRootElementConnectOrCreateFieldInput
}

input PageConnectOrCreateWhere {
  node: PageUniqueWhere!
}

input PageConnectWhere {
  node: PageWhere!
}

input PageCreateInput {
  app: PageAppFieldInput
  name: String!
  rootElement: PageRootElementFieldInput
}

input PageDeleteInput {
  app: PageAppDeleteFieldInput
  rootElement: PageRootElementDeleteFieldInput
}

input PageDisconnectInput {
  app: PageAppDisconnectFieldInput
  rootElement: PageRootElementDisconnectFieldInput
}

type PageElementRootElementAggregationSelection {
  count: Int!
  node: PageElementRootElementNodeAggregateSelection
}

type PageElementRootElementNodeAggregateSelection {
  createdAt: DateTimeAggregateSelection!
  id: IDAggregateSelection!
  name: StringAggregateSelection!
  ownerId: StringAggregateSelection!
  updatedAt: DateTimeAggregateSelection!
}

"""
Pagination information (Relay)
"""
type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

input PageOptions {
  limit: Int
  offset: Int

  """
  Specify one or more PageSort objects to sort Pages by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [PageSort]
}

input PageRelationInput {
  app: PageAppCreateFieldInput
  rootElement: PageRootElementCreateFieldInput
}

input PageRootElementAggregateInput {
  AND: [PageRootElementAggregateInput!]
  OR: [PageRootElementAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: PageRootElementNodeAggregationWhereInput
}

input PageRootElementConnectFieldInput {
  connect: ElementConnectInput
  where: ElementConnectWhere
}

input PageRootElementConnectOrCreateFieldInput {
  onCreate: PageRootElementConnectOrCreateFieldInputOnCreate!
  where: ElementConnectOrCreateWhere!
}

input PageRootElementConnectOrCreateFieldInputOnCreate {
  node: ElementCreateInput!
}

type PageRootElementConnection {
  edges: [PageRootElementRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input PageRootElementConnectionSort {
  node: ElementSort
}

input PageRootElementConnectionWhere {
  AND: [PageRootElementConnectionWhere!]
  OR: [PageRootElementConnectionWhere!]
  node: ElementWhere
  node_NOT: ElementWhere
}

input PageRootElementCreateFieldInput {
  node: ElementCreateInput!
}

input PageRootElementDeleteFieldInput {
  delete: ElementDeleteInput
  where: PageRootElementConnectionWhere
}

input PageRootElementDisconnectFieldInput {
  disconnect: ElementDisconnectInput
  where: PageRootElementConnectionWhere
}

input PageRootElementFieldInput {
  connect: PageRootElementConnectFieldInput
  connectOrCreate: PageRootElementConnectOrCreateFieldInput
  create: PageRootElementCreateFieldInput
}

input PageRootElementNodeAggregationWhereInput {
  AND: [PageRootElementNodeAggregationWhereInput!]
  OR: [PageRootElementNodeAggregationWhereInput!]
  createdAt_EQUAL: DateTime
  createdAt_GT: DateTime
  createdAt_GTE: DateTime
  createdAt_LT: DateTime
  createdAt_LTE: DateTime
  createdAt_MAX_EQUAL: DateTime
  createdAt_MAX_GT: DateTime
  createdAt_MAX_GTE: DateTime
  createdAt_MAX_LT: DateTime
  createdAt_MAX_LTE: DateTime
  createdAt_MIN_EQUAL: DateTime
  createdAt_MIN_GT: DateTime
  createdAt_MIN_GTE: DateTime
  createdAt_MIN_LT: DateTime
  createdAt_MIN_LTE: DateTime
  id_EQUAL: ID
  name_AVERAGE_EQUAL: Float
  name_AVERAGE_GT: Float
  name_AVERAGE_GTE: Float
  name_AVERAGE_LT: Float
  name_AVERAGE_LTE: Float
  name_EQUAL: String
  name_GT: Int
  name_GTE: Int
  name_LONGEST_EQUAL: Int
  name_LONGEST_GT: Int
  name_LONGEST_GTE: Int
  name_LONGEST_LT: Int
  name_LONGEST_LTE: Int
  name_LT: Int
  name_LTE: Int
  name_SHORTEST_EQUAL: Int
  name_SHORTEST_GT: Int
  name_SHORTEST_GTE: Int
  name_SHORTEST_LT: Int
  name_SHORTEST_LTE: Int
  ownerId_AVERAGE_EQUAL: Float
  ownerId_AVERAGE_GT: Float
  ownerId_AVERAGE_GTE: Float
  ownerId_AVERAGE_LT: Float
  ownerId_AVERAGE_LTE: Float
  ownerId_EQUAL: String
  ownerId_GT: Int
  ownerId_GTE: Int
  ownerId_LONGEST_EQUAL: Int
  ownerId_LONGEST_GT: Int
  ownerId_LONGEST_GTE: Int
  ownerId_LONGEST_LT: Int
  ownerId_LONGEST_LTE: Int
  ownerId_LT: Int
  ownerId_LTE: Int
  ownerId_SHORTEST_EQUAL: Int
  ownerId_SHORTEST_GT: Int
  ownerId_SHORTEST_GTE: Int
  ownerId_SHORTEST_LT: Int
  ownerId_SHORTEST_LTE: Int
  updatedAt_EQUAL: DateTime
  updatedAt_GT: DateTime
  updatedAt_GTE: DateTime
  updatedAt_LT: DateTime
  updatedAt_LTE: DateTime
  updatedAt_MAX_EQUAL: DateTime
  updatedAt_MAX_GT: DateTime
  updatedAt_MAX_GTE: DateTime
  updatedAt_MAX_LT: DateTime
  updatedAt_MAX_LTE: DateTime
  updatedAt_MIN_EQUAL: DateTime
  updatedAt_MIN_GT: DateTime
  updatedAt_MIN_GTE: DateTime
  updatedAt_MIN_LT: DateTime
  updatedAt_MIN_LTE: DateTime
}

type PageRootElementRelationship {
  cursor: String!
  node: Element!
}

input PageRootElementUpdateConnectionInput {
  node: ElementUpdateInput
}

input PageRootElementUpdateFieldInput {
  connect: PageRootElementConnectFieldInput
  connectOrCreate: PageRootElementConnectOrCreateFieldInput
  create: PageRootElementCreateFieldInput
  delete: PageRootElementDeleteFieldInput
  disconnect: PageRootElementDisconnectFieldInput
  update: PageRootElementUpdateConnectionInput
  where: PageRootElementConnectionWhere
}

"""
Fields to sort Pages by. The order in which sorts are applied is not guaranteed when specifying many fields in one PageSort object.
"""
input PageSort {
  id: SortDirection
  name: SortDirection
}

input PageUniqueWhere {
  id: ID
}

input PageUpdateInput {
  app: PageAppUpdateFieldInput
  name: String
  rootElement: PageRootElementUpdateFieldInput
}

input PageWhere {
  AND: [PageWhere!]
  OR: [PageWhere!]
  app: AppWhere
  appAggregate: PageAppAggregateInput
  appConnection: PageAppConnectionWhere
  appConnection_NOT: PageAppConnectionWhere
  app_NOT: AppWhere
  id: ID
  id_CONTAINS: ID
  id_ENDS_WITH: ID
  id_IN: [ID]
  id_NOT: ID
  id_NOT_CONTAINS: ID
  id_NOT_ENDS_WITH: ID
  id_NOT_IN: [ID]
  id_NOT_STARTS_WITH: ID
  id_STARTS_WITH: ID
  name: String
  name_CONTAINS: String
  name_ENDS_WITH: String
  name_IN: [String]
  name_NOT: String
  name_NOT_CONTAINS: String
  name_NOT_ENDS_WITH: String
  name_NOT_IN: [String]
  name_NOT_STARTS_WITH: String
  name_STARTS_WITH: String
  rootElement: ElementWhere
  rootElementAggregate: PageRootElementAggregateInput
  rootElementConnection: PageRootElementConnectionWhere
  rootElementConnection_NOT: PageRootElementConnectionWhere
  rootElement_NOT: ElementWhere
}

type Query {
  apps(options: AppOptions, where: AppWhere): [App!]!
  appsAggregate(where: AppWhere): AppAggregateSelection!
  appsCount(where: AppWhere): Int!
  atoms(options: AtomOptions, where: AtomWhere): [Atom!]!
  atomsAggregate(where: AtomWhere): AtomAggregateSelection!
  atomsCount(where: AtomWhere): Int!
  createInfos(
    options: CreateInfoOptions
    where: CreateInfoWhere
  ): [CreateInfo!]!
  createInfosAggregate(where: CreateInfoWhere): CreateInfoAggregateSelection!
  createInfosCount(where: CreateInfoWhere): Int!
  elements(options: ElementOptions, where: ElementWhere): [Element!]!
  elementsAggregate(where: ElementWhere): ElementAggregateSelection!
  elementsCount(where: ElementWhere): Int!
  importAtomsMutationResponses(
    options: ImportAtomsMutationResponseOptions
    where: ImportAtomsMutationResponseWhere
  ): [ImportAtomsMutationResponse!]!
  importAtomsMutationResponsesAggregate(
    where: ImportAtomsMutationResponseWhere
  ): ImportAtomsMutationResponseAggregateSelection!
  importAtomsMutationResponsesCount(
    where: ImportAtomsMutationResponseWhere
  ): Int!
  pages(options: PageOptions, where: PageWhere): [Page!]!
  pagesAggregate(where: PageWhere): PageAggregateSelection!
  pagesCount(where: PageWhere): Int!
  tagEdges(options: TagEdgeOptions, where: TagEdgeWhere): [TagEdge!]!
  tagEdgesAggregate(where: TagEdgeWhere): TagEdgeAggregateSelection!
  tagEdgesCount(where: TagEdgeWhere): Int!
  tagGraphs: TagGraph
  tagGraphsAggregate(where: TagGraphWhere): TagGraphAggregateSelection!
  tagGraphsCount(where: TagGraphWhere): Int!
  tags(options: TagOptions, where: TagWhere): [Tag!]!
  tagsAggregate(where: TagWhere): TagAggregateSelection!
  tagsCount(where: TagWhere): Int!
  users(options: UserOptions, where: UserWhere): [User!]!
  usersAggregate(where: UserWhere): UserAggregateSelection!
  usersCount(where: UserWhere): Int!
}

enum SortDirection {
  """
  Sort by field values in ascending order.
  """
  ASC

  """
  Sort by field values in descending order.
  """
  DESC
}

type StringAggregateSelection {
  longest: String
  shortest: String
}

type Tag {
  children(options: TagOptions, where: TagWhere): [Tag]
  childrenAggregate(where: TagWhere): TagTagChildrenAggregationSelection
  childrenConnection(
    after: String
    first: Int
    sort: [TagChildrenConnectionSort!]
    where: TagChildrenConnectionWhere
  ): TagChildrenConnection!
  id: ID!
  isRoot: Boolean
  name: String!
  parent(options: TagOptions, where: TagWhere): Tag
  parentAggregate(where: TagWhere): TagTagParentAggregationSelection
  parentConnection(
    after: String
    first: Int
    sort: [TagParentConnectionSort!]
    where: TagParentConnectionWhere
  ): TagParentConnection!
}

type TagAggregateSelection {
  count: Int!
  id: IDAggregateSelection!
  name: StringAggregateSelection!
}

input TagChildrenAggregateInput {
  AND: [TagChildrenAggregateInput!]
  OR: [TagChildrenAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: TagChildrenNodeAggregationWhereInput
}

input TagChildrenConnectFieldInput {
  connect: [TagConnectInput!]
  where: TagConnectWhere
}

input TagChildrenConnectOrCreateFieldInput {
  onCreate: TagChildrenConnectOrCreateFieldInputOnCreate!
  where: TagConnectOrCreateWhere!
}

input TagChildrenConnectOrCreateFieldInputOnCreate {
  node: TagCreateInput!
}

type TagChildrenConnection {
  edges: [TagChildrenRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input TagChildrenConnectionSort {
  node: TagSort
}

input TagChildrenConnectionWhere {
  AND: [TagChildrenConnectionWhere!]
  OR: [TagChildrenConnectionWhere!]
  node: TagWhere
  node_NOT: TagWhere
}

input TagChildrenCreateFieldInput {
  node: TagCreateInput!
}

input TagChildrenDeleteFieldInput {
  delete: TagDeleteInput
  where: TagChildrenConnectionWhere
}

input TagChildrenDisconnectFieldInput {
  disconnect: TagDisconnectInput
  where: TagChildrenConnectionWhere
}

input TagChildrenFieldInput {
  connect: [TagChildrenConnectFieldInput!]
  connectOrCreate: [TagChildrenConnectOrCreateFieldInput!]
  create: [TagChildrenCreateFieldInput!]
}

input TagChildrenNodeAggregationWhereInput {
  AND: [TagChildrenNodeAggregationWhereInput!]
  OR: [TagChildrenNodeAggregationWhereInput!]
  id_EQUAL: ID
  name_AVERAGE_EQUAL: Float
  name_AVERAGE_GT: Float
  name_AVERAGE_GTE: Float
  name_AVERAGE_LT: Float
  name_AVERAGE_LTE: Float
  name_EQUAL: String
  name_GT: Int
  name_GTE: Int
  name_LONGEST_EQUAL: Int
  name_LONGEST_GT: Int
  name_LONGEST_GTE: Int
  name_LONGEST_LT: Int
  name_LONGEST_LTE: Int
  name_LT: Int
  name_LTE: Int
  name_SHORTEST_EQUAL: Int
  name_SHORTEST_GT: Int
  name_SHORTEST_GTE: Int
  name_SHORTEST_LT: Int
  name_SHORTEST_LTE: Int
}

type TagChildrenRelationship {
  cursor: String!
  node: Tag!
}

input TagChildrenUpdateConnectionInput {
  node: TagUpdateInput
}

input TagChildrenUpdateFieldInput {
  connect: [TagChildrenConnectFieldInput!]
  connectOrCreate: [TagChildrenConnectOrCreateFieldInput!]
  create: [TagChildrenCreateFieldInput!]
  delete: [TagChildrenDeleteFieldInput!]
  disconnect: [TagChildrenDisconnectFieldInput!]
  update: TagChildrenUpdateConnectionInput
  where: TagChildrenConnectionWhere
}

input TagConnectInput {
  children: [TagChildrenConnectFieldInput!]
  parent: TagParentConnectFieldInput
}

input TagConnectOrCreateInput {
  children: [TagChildrenConnectOrCreateFieldInput!]
  parent: TagParentConnectOrCreateFieldInput
}

input TagConnectOrCreateWhere {
  node: TagUniqueWhere!
}

input TagConnectWhere {
  node: TagWhere!
}

input TagCreateInput {
  children: TagChildrenFieldInput
  isRoot: Boolean
  name: String!
  parent: TagParentFieldInput
}

input TagDeleteInput {
  children: [TagChildrenDeleteFieldInput!]
  parent: TagParentDeleteFieldInput
}

input TagDisconnectInput {
  children: [TagChildrenDisconnectFieldInput!]
  parent: TagParentDisconnectFieldInput
}

type TagEdge {
  source: ID!
  target: ID!
}

type TagEdgeAggregateSelection {
  count: Int!
  source: IDAggregateSelection!
  target: IDAggregateSelection!
}

input TagEdgeCreateInput {
  source: ID!
  target: ID!
}

input TagEdgeOptions {
  limit: Int
  offset: Int

  """
  Specify one or more TagEdgeSort objects to sort TagEdges by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [TagEdgeSort]
}

"""
Fields to sort TagEdges by. The order in which sorts are applied is not guaranteed when specifying many fields in one TagEdgeSort object.
"""
input TagEdgeSort {
  source: SortDirection
  target: SortDirection
}

input TagEdgeUpdateInput {
  source: ID
  target: ID
}

input TagEdgeWhere {
  AND: [TagEdgeWhere!]
  OR: [TagEdgeWhere!]
  source: ID
  source_CONTAINS: ID
  source_ENDS_WITH: ID
  source_IN: [ID]
  source_NOT: ID
  source_NOT_CONTAINS: ID
  source_NOT_ENDS_WITH: ID
  source_NOT_IN: [ID]
  source_NOT_STARTS_WITH: ID
  source_STARTS_WITH: ID
  target: ID
  target_CONTAINS: ID
  target_ENDS_WITH: ID
  target_IN: [ID]
  target_NOT: ID
  target_NOT_CONTAINS: ID
  target_NOT_ENDS_WITH: ID
  target_NOT_IN: [ID]
  target_NOT_STARTS_WITH: ID
  target_STARTS_WITH: ID
}

type TagGraph implements IGraph {
  """
  All the links connecting the descendant elements/components
  """
  edges: [TagEdge!]!

  """
  All descendant Elements or Components, at any level
  """
  vertices: [Tag!]!
}

type TagGraphAggregateSelection {
  count: Int!
}

input TagGraphCreateInput {
  """
  Appears because this input type would be empty otherwise because this type is composed of just generated and/or relationship properties. See https://neo4j.com/docs/graphql-manual/current/troubleshooting/faqs/
  """
  _emptyInput: Boolean
}

input TagGraphUpdateInput {
  """
  Appears because this input type would be empty otherwise because this type is composed of just generated and/or relationship properties. See https://neo4j.com/docs/graphql-manual/current/troubleshooting/faqs/
  """
  _emptyInput: Boolean
}

input TagGraphWhere {
  AND: [TagGraphWhere!]
  OR: [TagGraphWhere!]
}

input TagOptions {
  limit: Int
  offset: Int

  """
  Specify one or more TagSort objects to sort Tags by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [TagSort]
}

input TagParentAggregateInput {
  AND: [TagParentAggregateInput!]
  OR: [TagParentAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: TagParentNodeAggregationWhereInput
}

input TagParentConnectFieldInput {
  connect: TagConnectInput
  where: TagConnectWhere
}

input TagParentConnectOrCreateFieldInput {
  onCreate: TagParentConnectOrCreateFieldInputOnCreate!
  where: TagConnectOrCreateWhere!
}

input TagParentConnectOrCreateFieldInputOnCreate {
  node: TagCreateInput!
}

type TagParentConnection {
  edges: [TagParentRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input TagParentConnectionSort {
  node: TagSort
}

input TagParentConnectionWhere {
  AND: [TagParentConnectionWhere!]
  OR: [TagParentConnectionWhere!]
  node: TagWhere
  node_NOT: TagWhere
}

input TagParentCreateFieldInput {
  node: TagCreateInput!
}

input TagParentDeleteFieldInput {
  delete: TagDeleteInput
  where: TagParentConnectionWhere
}

input TagParentDisconnectFieldInput {
  disconnect: TagDisconnectInput
  where: TagParentConnectionWhere
}

input TagParentFieldInput {
  connect: TagParentConnectFieldInput
  connectOrCreate: TagParentConnectOrCreateFieldInput
  create: TagParentCreateFieldInput
}

input TagParentNodeAggregationWhereInput {
  AND: [TagParentNodeAggregationWhereInput!]
  OR: [TagParentNodeAggregationWhereInput!]
  id_EQUAL: ID
  name_AVERAGE_EQUAL: Float
  name_AVERAGE_GT: Float
  name_AVERAGE_GTE: Float
  name_AVERAGE_LT: Float
  name_AVERAGE_LTE: Float
  name_EQUAL: String
  name_GT: Int
  name_GTE: Int
  name_LONGEST_EQUAL: Int
  name_LONGEST_GT: Int
  name_LONGEST_GTE: Int
  name_LONGEST_LT: Int
  name_LONGEST_LTE: Int
  name_LT: Int
  name_LTE: Int
  name_SHORTEST_EQUAL: Int
  name_SHORTEST_GT: Int
  name_SHORTEST_GTE: Int
  name_SHORTEST_LT: Int
  name_SHORTEST_LTE: Int
}

type TagParentRelationship {
  cursor: String!
  node: Tag!
}

input TagParentUpdateConnectionInput {
  node: TagUpdateInput
}

input TagParentUpdateFieldInput {
  connect: TagParentConnectFieldInput
  connectOrCreate: TagParentConnectOrCreateFieldInput
  create: TagParentCreateFieldInput
  delete: TagParentDeleteFieldInput
  disconnect: TagParentDisconnectFieldInput
  update: TagParentUpdateConnectionInput
  where: TagParentConnectionWhere
}

input TagRelationInput {
  children: [TagChildrenCreateFieldInput!]
  parent: TagParentCreateFieldInput
}

"""
Fields to sort Tags by. The order in which sorts are applied is not guaranteed when specifying many fields in one TagSort object.
"""
input TagSort {
  id: SortDirection
  isRoot: SortDirection
  name: SortDirection
}

type TagTagChildrenAggregationSelection {
  count: Int!
  node: TagTagChildrenNodeAggregateSelection
}

type TagTagChildrenNodeAggregateSelection {
  id: IDAggregateSelection!
  name: StringAggregateSelection!
}

type TagTagParentAggregationSelection {
  count: Int!
  node: TagTagParentNodeAggregateSelection
}

type TagTagParentNodeAggregateSelection {
  id: IDAggregateSelection!
  name: StringAggregateSelection!
}

input TagUniqueWhere {
  id: ID
}

input TagUpdateInput {
  children: [TagChildrenUpdateFieldInput!]
  isRoot: Boolean
  name: String
  parent: TagParentUpdateFieldInput
}

union TagVertex = Tag

input TagWhere {
  AND: [TagWhere!]
  OR: [TagWhere!]
  children: TagWhere
  childrenAggregate: TagChildrenAggregateInput
  childrenConnection: TagChildrenConnectionWhere
  childrenConnection_NOT: TagChildrenConnectionWhere
  children_NOT: TagWhere
  id: ID
  id_CONTAINS: ID
  id_ENDS_WITH: ID
  id_IN: [ID]
  id_NOT: ID
  id_NOT_CONTAINS: ID
  id_NOT_ENDS_WITH: ID
  id_NOT_IN: [ID]
  id_NOT_STARTS_WITH: ID
  id_STARTS_WITH: ID
  isRoot: Boolean
  isRoot_NOT: Boolean
  name: String
  name_CONTAINS: String
  name_ENDS_WITH: String
  name_IN: [String]
  name_NOT: String
  name_NOT_CONTAINS: String
  name_NOT_ENDS_WITH: String
  name_NOT_IN: [String]
  name_NOT_STARTS_WITH: String
  name_STARTS_WITH: String
  parent: TagWhere
  parentAggregate: TagParentAggregateInput
  parentConnection: TagParentConnectionWhere
  parentConnection_NOT: TagParentConnectionWhere
  parent_NOT: TagWhere
}

type UpdateAppsMutationResponse {
  apps: [App!]!
  info: UpdateInfo!
}

type UpdateAtomsMutationResponse {
  atoms: [Atom!]!
  info: UpdateInfo!
}

type UpdateCreateInfosMutationResponse {
  createInfos: [CreateInfo!]!
  info: UpdateInfo!
}

type UpdateElementsMutationResponse {
  elements: [Element!]!
  info: UpdateInfo!
}

type UpdateImportAtomsMutationResponsesMutationResponse {
  importAtomsMutationResponses: [ImportAtomsMutationResponse!]!
  info: UpdateInfo!
}

type UpdateInfo {
  bookmark: String
  nodesCreated: Int!
  nodesDeleted: Int!
  relationshipsCreated: Int!
  relationshipsDeleted: Int!
}

type UpdatePagesMutationResponse {
  info: UpdateInfo!
  pages: [Page!]!
}

type UpdateTagEdgesMutationResponse {
  info: UpdateInfo!
  tagEdges: [TagEdge!]!
}

type UpdateTagGraphsMutationResponse {
  info: UpdateInfo!
  tagGraphs: [TagGraph!]!
}

type UpdateTagsMutationResponse {
  info: UpdateInfo!
  tags: [Tag!]!
}

type User {
  apps(options: AppOptions, where: AppWhere): [App]
  appsAggregate(where: AppWhere): UserAppAppsAggregationSelection
  appsConnection(
    after: String
    first: Int
    sort: [UserAppsConnectionSort!]
    where: UserAppsConnectionWhere
  ): UserAppsConnection!
  auth0Id: String!
  email: String!
  id: ID!
}

type UserAggregateSelection {
  auth0Id: StringAggregateSelection!
  count: Int!
  email: StringAggregateSelection!
  id: IDAggregateSelection!
}

type UserAppAppsAggregationSelection {
  count: Int!
  node: UserAppAppsNodeAggregateSelection
}

type UserAppAppsNodeAggregateSelection {
  id: IDAggregateSelection!
  name: StringAggregateSelection!
}

input UserAppsAggregateInput {
  AND: [UserAppsAggregateInput!]
  OR: [UserAppsAggregateInput!]
  count: Int
  count_GT: Int
  count_GTE: Int
  count_LT: Int
  count_LTE: Int
  node: UserAppsNodeAggregationWhereInput
}

input UserAppsConnectFieldInput {
  connect: [AppConnectInput!]
  where: AppConnectWhere
}

input UserAppsConnectOrCreateFieldInput {
  onCreate: UserAppsConnectOrCreateFieldInputOnCreate!
  where: AppConnectOrCreateWhere!
}

input UserAppsConnectOrCreateFieldInputOnCreate {
  node: AppCreateInput!
}

type UserAppsConnection {
  edges: [UserAppsRelationship!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input UserAppsConnectionSort {
  node: AppSort
}

input UserAppsConnectionWhere {
  AND: [UserAppsConnectionWhere!]
  OR: [UserAppsConnectionWhere!]
  node: AppWhere
  node_NOT: AppWhere
}

input UserAppsCreateFieldInput {
  node: AppCreateInput!
}

input UserAppsDeleteFieldInput {
  delete: AppDeleteInput
  where: UserAppsConnectionWhere
}

input UserAppsDisconnectFieldInput {
  disconnect: AppDisconnectInput
  where: UserAppsConnectionWhere
}

input UserAppsFieldInput {
  connect: [UserAppsConnectFieldInput!]
  connectOrCreate: [UserAppsConnectOrCreateFieldInput!]
  create: [UserAppsCreateFieldInput!]
}

input UserAppsNodeAggregationWhereInput {
  AND: [UserAppsNodeAggregationWhereInput!]
  OR: [UserAppsNodeAggregationWhereInput!]
  id_EQUAL: ID
  name_AVERAGE_EQUAL: Float
  name_AVERAGE_GT: Float
  name_AVERAGE_GTE: Float
  name_AVERAGE_LT: Float
  name_AVERAGE_LTE: Float
  name_EQUAL: String
  name_GT: Int
  name_GTE: Int
  name_LONGEST_EQUAL: Int
  name_LONGEST_GT: Int
  name_LONGEST_GTE: Int
  name_LONGEST_LT: Int
  name_LONGEST_LTE: Int
  name_LT: Int
  name_LTE: Int
  name_SHORTEST_EQUAL: Int
  name_SHORTEST_GT: Int
  name_SHORTEST_GTE: Int
  name_SHORTEST_LT: Int
  name_SHORTEST_LTE: Int
}

type UserAppsRelationship {
  cursor: String!
  node: App!
}

input UserAppsUpdateConnectionInput {
  node: AppUpdateInput
}

input UserAppsUpdateFieldInput {
  connect: [UserAppsConnectFieldInput!]
  connectOrCreate: [UserAppsConnectOrCreateFieldInput!]
  create: [UserAppsCreateFieldInput!]
  delete: [UserAppsDeleteFieldInput!]
  disconnect: [UserAppsDisconnectFieldInput!]
  update: UserAppsUpdateConnectionInput
  where: UserAppsConnectionWhere
}

input UserConnectInput {
  apps: [UserAppsConnectFieldInput!]
}

input UserConnectOrCreateWhere {
  node: UserUniqueWhere!
}

input UserConnectWhere {
  node: UserWhere!
}

input UserCreateInput {
  apps: UserAppsFieldInput
  auth0Id: String!
  email: String!
}

input UserDeleteInput {
  apps: [UserAppsDeleteFieldInput!]
}

input UserDisconnectInput {
  apps: [UserAppsDisconnectFieldInput!]
}

input UserOptions {
  limit: Int
  offset: Int

  """
  Specify one or more UserSort objects to sort Users by. The sorts will be applied in the order in which they are arranged in the array.
  """
  sort: [UserSort]
}

"""
Fields to sort Users by. The order in which sorts are applied is not guaranteed when specifying many fields in one UserSort object.
"""
input UserSort {
  auth0Id: SortDirection
  email: SortDirection
  id: SortDirection
}

input UserUniqueWhere {
  id: ID
}

input UserUpdateInput {
  apps: [UserAppsUpdateFieldInput!]
  auth0Id: String
  email: String
}

input UserWhere {
  AND: [UserWhere!]
  OR: [UserWhere!]
  apps: AppWhere
  appsAggregate: UserAppsAggregateInput
  appsConnection: UserAppsConnectionWhere
  appsConnection_NOT: UserAppsConnectionWhere
  apps_NOT: AppWhere
  auth0Id: String
  auth0Id_CONTAINS: String
  auth0Id_ENDS_WITH: String
  auth0Id_IN: [String]
  auth0Id_NOT: String
  auth0Id_NOT_CONTAINS: String
  auth0Id_NOT_ENDS_WITH: String
  auth0Id_NOT_IN: [String]
  auth0Id_NOT_STARTS_WITH: String
  auth0Id_STARTS_WITH: String
  email: String
  email_CONTAINS: String
  email_ENDS_WITH: String
  email_IN: [String]
  email_NOT: String
  email_NOT_CONTAINS: String
  email_NOT_ENDS_WITH: String
  email_NOT_IN: [String]
  email_NOT_STARTS_WITH: String
  email_STARTS_WITH: String
  id: ID
  id_CONTAINS: ID
  id_ENDS_WITH: ID
  id_IN: [ID]
  id_NOT: ID
  id_NOT_CONTAINS: ID
  id_NOT_ENDS_WITH: ID
  id_NOT_IN: [ID]
  id_NOT_STARTS_WITH: ID
  id_STARTS_WITH: ID
}
