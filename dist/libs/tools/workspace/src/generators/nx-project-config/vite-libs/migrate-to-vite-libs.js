"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.migrateToViteLibs = void 0;
const devkit_1 = require("@nx/devkit");
const path_1 = require("path");
/**
 * Updates the package.json for a Vite library project.
 * GENERATED BY CURSOR
 */
const _updatePackageJsonForVite = (tree, projectConfig) => {
    const packageJsonPath = (0, devkit_1.joinPathFragments)(projectConfig.root, 'package.json');
    if (!tree.exists(packageJsonPath)) {
        console.warn(`Package.json not found at ${packageJsonPath}, skipping update.`);
        return;
    }
    const packageJson = (0, devkit_1.readJson)(tree, packageJsonPath);
    // Add or update the required fields
    packageJson.type = 'module';
    delete packageJson.main;
    delete packageJson.module;
    delete packageJson.types;
    // Write the updated package.json back to the file
    (0, devkit_1.writeJson)(tree, packageJsonPath, packageJson);
    console.log(`Updated package.json at: ${packageJsonPath}`);
    // Return package name for potential use
    return packageJson.name;
};
/**
 * Removes the compilerOptions.module property from tsconfig.lib.json if it exists.
 * GENERATED BY CURSOR
 */
const _updateTsConfigForVite = (tree, projectConfig) => {
    const tsconfigPath = (0, devkit_1.joinPathFragments)(projectConfig.root, 'tsconfig.lib.json');
    if (!tree.exists(tsconfigPath)) {
        console.warn(`Tsconfig.lib.json not found at ${tsconfigPath}, skipping update.`);
        return;
    }
    const tsconfigJson = (0, devkit_1.readJson)(tree, tsconfigPath);
    if (tsconfigJson.compilerOptions?.module) {
        delete tsconfigJson.compilerOptions.module;
        (0, devkit_1.writeJson)(tree, tsconfigPath, tsconfigJson);
        console.log(`Removed compilerOptions.module from: ${tsconfigPath}`);
    }
    else {
        console.log(`compilerOptions.module not found or already removed in: ${tsconfigPath}`);
    }
};
const migrateToViteLibs = async (tree, projectConfig) => {
    console.log('Migrating to Vite libs:', projectConfig.name);
    // Update package.json and get package name
    const packageName = _updatePackageJsonForVite(tree, projectConfig);
    // Update tsconfig.lib.json
    _updateTsConfigForVite(tree, projectConfig);
    // If package.json didn't exist or name couldn't be read, we might need to handle it
    if (!packageName) {
        console.error(`Could not retrieve package name for ${projectConfig.name}. Aborting Vite config generation.`);
        return;
    }
    const substitutions = {
        // Calculate cacheDir relative to workspace root
        cacheDir: (0, devkit_1.joinPathFragments)((0, devkit_1.offsetFromRoot)(projectConfig.root), 'node_modules/.vite', projectConfig.root),
        libName: packageName,
        // Replaces __tmpl__ portion of file
        tmpl: '',
        tsconfigPath: 'tsconfig.lib.json',
    };
    // Path to the template files directory
    const templateDir = (0, path_1.join)(__dirname, 'files');
    // Target directory (project root)
    const targetDir = projectConfig.root;
    (0, devkit_1.generateFiles)(tree, templateDir, targetDir, substitutions);
    console.log(`Generated Vite config in: ${targetDir}`);
};
exports.migrateToViteLibs = migrateToViteLibs;
//# sourceMappingURL=migrate-to-vite-libs.js.map